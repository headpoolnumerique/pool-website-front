"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_p5-wrapper_next_dist_next_js"],{

/***/ "./node_modules/@p5-wrapper/next/dist/next.js":
/*!****************************************************!*\
  !*** ./node_modules/@p5-wrapper/next/dist/next.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NextReactP5Wrapper: () => (/* binding */ Tr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nfunction dr(p) {\n  return p && p.__esModule && Object.prototype.hasOwnProperty.call(p, \"default\") ? p.default : p;\n}\nvar le = { exports: {} }, B = {};\nB._ = B._interop_require_default = pr;\nfunction pr(p) {\n  return p && p.__esModule ? p : { default: p };\n}\nvar se = { exports: {} }, V = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Fe;\nfunction vr() {\n  if (Fe)\n    return V;\n  Fe = 1;\n  var p = react__WEBPACK_IMPORTED_MODULE_0__, E = Symbol.for(\"react.element\"), T = Symbol.for(\"react.fragment\"), C = Object.prototype.hasOwnProperty, j = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, D = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function x(P, b, k) {\n    var l, v = {}, g = null, d = null;\n    k !== void 0 && (g = \"\" + k), b.key !== void 0 && (g = \"\" + b.key), b.ref !== void 0 && (d = b.ref);\n    for (l in b)\n      C.call(b, l) && !D.hasOwnProperty(l) && (v[l] = b[l]);\n    if (P && P.defaultProps)\n      for (l in b = P.defaultProps, b)\n        v[l] === void 0 && (v[l] = b[l]);\n    return { $$typeof: E, type: P, key: g, ref: d, props: v, _owner: j.current };\n  }\n  return V.Fragment = T, V.jsx = x, V.jsxs = x, V;\n}\nvar U = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Le;\nfunction _r() {\n  return Le || (Le = 1,  true && function() {\n    var p = react__WEBPACK_IMPORTED_MODULE_0__, E = Symbol.for(\"react.element\"), T = Symbol.for(\"react.portal\"), C = Symbol.for(\"react.fragment\"), j = Symbol.for(\"react.strict_mode\"), D = Symbol.for(\"react.profiler\"), x = Symbol.for(\"react.provider\"), P = Symbol.for(\"react.context\"), b = Symbol.for(\"react.forward_ref\"), k = Symbol.for(\"react.suspense\"), l = Symbol.for(\"react.suspense_list\"), v = Symbol.for(\"react.memo\"), g = Symbol.for(\"react.lazy\"), d = Symbol.for(\"react.offscreen\"), s = Symbol.iterator, _ = \"@@iterator\";\n    function o(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = s && e[s] || e[_];\n      return typeof r == \"function\" ? r : null;\n    }\n    var f = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function m(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        W(\"error\", e, t);\n      }\n    }\n    function W(e, r, t) {\n      {\n        var n = f.ReactDebugCurrentFrame, u = n.getStackAddendum();\n        u !== \"\" && (r += \"%s\", t = t.concat([u]));\n        var c = t.map(function(i) {\n          return String(i);\n        });\n        c.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, c);\n      }\n    }\n    var M = !1, R = !1, L = !1, O = !1, $e = !1, fe;\n    fe = Symbol.for(\"react.module.reference\");\n    function We(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === C || e === D || $e || e === j || e === k || e === l || O || e === d || M || R || L || typeof e == \"object\" && e !== null && (e.$$typeof === g || e.$$typeof === v || e.$$typeof === x || e.$$typeof === P || e.$$typeof === b || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === fe || e.getModuleId !== void 0));\n    }\n    function Me(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var u = r.displayName || r.name || \"\";\n      return u !== \"\" ? t + \"(\" + u + \")\" : t;\n    }\n    function ce(e) {\n      return e.displayName || \"Context\";\n    }\n    function A(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && m(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case C:\n          return \"Fragment\";\n        case T:\n          return \"Portal\";\n        case D:\n          return \"Profiler\";\n        case j:\n          return \"StrictMode\";\n        case k:\n          return \"Suspense\";\n        case l:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case P:\n            var r = e;\n            return ce(r) + \".Consumer\";\n          case x:\n            var t = e;\n            return ce(t._context) + \".Provider\";\n          case b:\n            return Me(e, e.render, \"ForwardRef\");\n          case v:\n            var n = e.displayName || null;\n            return n !== null ? n : A(e.type) || \"Memo\";\n          case g: {\n            var u = e, c = u._payload, i = u._init;\n            try {\n              return A(i(c));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var I = Object.assign, q = 0, de, pe, ve, _e, me, he, be;\n    function ye() {\n    }\n    ye.__reactDisabledLog = !0;\n    function qe() {\n      {\n        if (q === 0) {\n          de = console.log, pe = console.info, ve = console.warn, _e = console.error, me = console.group, he = console.groupCollapsed, be = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: ye,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        q++;\n      }\n    }\n    function Ye() {\n      {\n        if (q--, q === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: I({}, e, {\n              value: de\n            }),\n            info: I({}, e, {\n              value: pe\n            }),\n            warn: I({}, e, {\n              value: ve\n            }),\n            error: I({}, e, {\n              value: _e\n            }),\n            group: I({}, e, {\n              value: me\n            }),\n            groupCollapsed: I({}, e, {\n              value: he\n            }),\n            groupEnd: I({}, e, {\n              value: be\n            })\n          });\n        }\n        q < 0 && m(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Z = f.ReactCurrentDispatcher, Q;\n    function G(e, r, t) {\n      {\n        if (Q === void 0)\n          try {\n            throw Error();\n          } catch (u) {\n            var n = u.stack.trim().match(/\\n( *(at )?)/);\n            Q = n && n[1] || \"\";\n          }\n        return `\n` + Q + e;\n      }\n    }\n    var ee = !1, J;\n    {\n      var Ve = typeof WeakMap == \"function\" ? WeakMap : Map;\n      J = new Ve();\n    }\n    function ge(e, r) {\n      if (!e || ee)\n        return \"\";\n      {\n        var t = J.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      ee = !0;\n      var u = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var c;\n      c = Z.current, Z.current = null, qe();\n      try {\n        if (r) {\n          var i = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(i.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(i, []);\n            } catch (F) {\n              n = F;\n            }\n            Reflect.construct(e, [], i);\n          } else {\n            try {\n              i.call();\n            } catch (F) {\n              n = F;\n            }\n            e.call(i.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (F) {\n            n = F;\n          }\n          e();\n        }\n      } catch (F) {\n        if (F && n && typeof F.stack == \"string\") {\n          for (var a = F.stack.split(`\n`), w = n.stack.split(`\n`), h = a.length - 1, y = w.length - 1; h >= 1 && y >= 0 && a[h] !== w[y]; )\n            y--;\n          for (; h >= 1 && y >= 0; h--, y--)\n            if (a[h] !== w[y]) {\n              if (h !== 1 || y !== 1)\n                do\n                  if (h--, y--, y < 0 || a[h] !== w[y]) {\n                    var S = `\n` + a[h].replace(\" at new \", \" at \");\n                    return e.displayName && S.includes(\"<anonymous>\") && (S = S.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && J.set(e, S), S;\n                  }\n                while (h >= 1 && y >= 0);\n              break;\n            }\n        }\n      } finally {\n        ee = !1, Z.current = c, Ye(), Error.prepareStackTrace = u;\n      }\n      var $ = e ? e.displayName || e.name : \"\", Ae = $ ? G($) : \"\";\n      return typeof e == \"function\" && J.set(e, Ae), Ae;\n    }\n    function Ue(e, r, t) {\n      return ge(e, !1);\n    }\n    function Be(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function z(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return ge(e, Be(e));\n      if (typeof e == \"string\")\n        return G(e);\n      switch (e) {\n        case k:\n          return G(\"Suspense\");\n        case l:\n          return G(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case b:\n            return Ue(e.render);\n          case v:\n            return z(e.type, r, t);\n          case g: {\n            var n = e, u = n._payload, c = n._init;\n            try {\n              return z(c(u), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var H = Object.prototype.hasOwnProperty, Re = {}, Ee = f.ReactDebugCurrentFrame;\n    function K(e) {\n      if (e) {\n        var r = e._owner, t = z(e.type, e._source, r ? r.type : null);\n        Ee.setExtraStackFrame(t);\n      } else\n        Ee.setExtraStackFrame(null);\n    }\n    function Ge(e, r, t, n, u) {\n      {\n        var c = Function.call.bind(H);\n        for (var i in e)\n          if (c(e, i)) {\n            var a = void 0;\n            try {\n              if (typeof e[i] != \"function\") {\n                var w = Error((n || \"React class\") + \": \" + t + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[i] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw w.name = \"Invariant Violation\", w;\n              }\n              a = e[i](r, i, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (h) {\n              a = h;\n            }\n            a && !(a instanceof Error) && (K(u), m(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, i, typeof a), K(null)), a instanceof Error && !(a.message in Re) && (Re[a.message] = !0, K(u), m(\"Failed %s type: %s\", t, a.message), K(null));\n          }\n      }\n    }\n    var Je = Array.isArray;\n    function re(e) {\n      return Je(e);\n    }\n    function ze(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function He(e) {\n      try {\n        return we(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function we(e) {\n      return \"\" + e;\n    }\n    function Te(e) {\n      if (He(e))\n        return m(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", ze(e)), we(e);\n    }\n    var Y = f.ReactCurrentOwner, Ke = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ce, Pe, te;\n    te = {};\n    function Xe(e) {\n      if (H.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ze(e) {\n      if (H.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function Qe(e, r) {\n      if (typeof e.ref == \"string\" && Y.current && r && Y.current.stateNode !== r) {\n        var t = A(Y.current.type);\n        te[t] || (m('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A(Y.current.type), e.ref), te[t] = !0);\n      }\n    }\n    function er(e, r) {\n      {\n        var t = function() {\n          Ce || (Ce = !0, m(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function rr(e, r) {\n      {\n        var t = function() {\n          Pe || (Pe = !0, m(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var tr = function(e, r, t, n, u, c, i) {\n      var a = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: E,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: i,\n        // Record the component responsible for creating this element.\n        _owner: c\n      };\n      return a._store = {}, Object.defineProperty(a._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(a, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(a, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: u\n      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;\n    };\n    function nr(e, r, t, n, u) {\n      {\n        var c, i = {}, a = null, w = null;\n        t !== void 0 && (Te(t), a = \"\" + t), Ze(r) && (Te(r.key), a = \"\" + r.key), Xe(r) && (w = r.ref, Qe(r, u));\n        for (c in r)\n          H.call(r, c) && !Ke.hasOwnProperty(c) && (i[c] = r[c]);\n        if (e && e.defaultProps) {\n          var h = e.defaultProps;\n          for (c in h)\n            i[c] === void 0 && (i[c] = h[c]);\n        }\n        if (a || w) {\n          var y = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          a && er(i, y), w && rr(i, y);\n        }\n        return tr(e, a, w, u, n, Y.current, i);\n      }\n    }\n    var ne = f.ReactCurrentOwner, Oe = f.ReactDebugCurrentFrame;\n    function N(e) {\n      if (e) {\n        var r = e._owner, t = z(e.type, e._source, r ? r.type : null);\n        Oe.setExtraStackFrame(t);\n      } else\n        Oe.setExtraStackFrame(null);\n    }\n    var ae;\n    ae = !1;\n    function oe(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === E;\n    }\n    function Se() {\n      {\n        if (ne.current) {\n          var e = A(ne.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function ar(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var je = {};\n    function or(e) {\n      {\n        var r = Se();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function xe(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = or(r);\n        if (je[t])\n          return;\n        je[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== ne.current && (n = \" It was passed a child from \" + A(e._owner.type) + \".\"), N(e), m('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), N(null);\n      }\n    }\n    function ke(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (re(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            oe(n) && xe(n, r);\n          }\n        else if (oe(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var u = o(e);\n          if (typeof u == \"function\" && u !== e.entries)\n            for (var c = u.call(e), i; !(i = c.next()).done; )\n              oe(i.value) && xe(i.value, r);\n        }\n      }\n    }\n    function ir(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === b || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === v))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = A(r);\n          Ge(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !ae) {\n          ae = !0;\n          var u = A(r);\n          m(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", u || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && m(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ur(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            N(e), m(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), N(null);\n            break;\n          }\n        }\n        e.ref !== null && (N(e), m(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), N(null));\n      }\n    }\n    function De(e, r, t, n, u, c) {\n      {\n        var i = We(e);\n        if (!i) {\n          var a = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (a += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var w = ar(u);\n          w ? a += w : a += Se();\n          var h;\n          e === null ? h = \"null\" : re(e) ? h = \"array\" : e !== void 0 && e.$$typeof === E ? (h = \"<\" + (A(e.type) || \"Unknown\") + \" />\", a = \" Did you accidentally export a JSX literal instead of a component?\") : h = typeof e, m(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", h, a);\n        }\n        var y = nr(e, r, t, u, c);\n        if (y == null)\n          return y;\n        if (i) {\n          var S = r.children;\n          if (S !== void 0)\n            if (n)\n              if (re(S)) {\n                for (var $ = 0; $ < S.length; $++)\n                  ke(S[$], e);\n                Object.freeze && Object.freeze(S);\n              } else\n                m(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ke(S, e);\n        }\n        return e === C ? ur(y) : ir(y), y;\n      }\n    }\n    function lr(e, r, t) {\n      return De(e, r, t, !0);\n    }\n    function sr(e, r, t) {\n      return De(e, r, t, !1);\n    }\n    var fr = sr, cr = lr;\n    U.Fragment = C, U.jsx = fr, U.jsxs = cr;\n  }()), U;\n}\n false ? 0 : se.exports = _r();\nvar mr = se.exports;\nfunction hr(p) {\n  throw new Error('Could not dynamically require \"' + p + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar ie = {}, ue = {}, Ie;\nfunction br() {\n  return Ie || (Ie = 1, function(p) {\n    \"use client\";\n    Object.defineProperty(p, \"__esModule\", {\n      value: !0\n    }), Object.defineProperty(p, \"LoadableContext\", {\n      enumerable: !0,\n      get: function() {\n        return C;\n      }\n    });\n    const C = (/* @__PURE__ */ B._(react__WEBPACK_IMPORTED_MODULE_0__)).default.createContext(null);\n     true && (C.displayName = \"LoadableContext\");\n  }(ue)), ue;\n}\nvar Ne;\nfunction yr() {\n  return Ne || (Ne = 1, function(p) {\n    Object.defineProperty(p, \"__esModule\", {\n      value: !0\n    }), Object.defineProperty(p, \"default\", {\n      enumerable: !0,\n      get: function() {\n        return d;\n      }\n    });\n    const T = /* @__PURE__ */ B._(react__WEBPACK_IMPORTED_MODULE_0__), C = br();\n    function j(s) {\n      return s && s.default ? s.default : s;\n    }\n    const D = [], x = [];\n    let P = !1;\n    function b(s) {\n      let _ = s(), o = {\n        loading: !0,\n        loaded: null,\n        error: null\n      };\n      return o.promise = _.then((f) => (o.loading = !1, o.loaded = f, f)).catch((f) => {\n        throw o.loading = !1, o.error = f, f;\n      }), o;\n    }\n    function k(s, _) {\n      let o = Object.assign({\n        loader: null,\n        loading: null,\n        delay: 200,\n        timeout: null,\n        webpack: null,\n        modules: null\n      }, _), f = null;\n      function m() {\n        if (!f) {\n          const R = new l(s, o);\n          f = {\n            getCurrentValue: R.getCurrentValue.bind(R),\n            subscribe: R.subscribe.bind(R),\n            retry: R.retry.bind(R),\n            promise: R.promise.bind(R)\n          };\n        }\n        return f.promise();\n      }\n      if (typeof window > \"u\" && D.push(m), !P && typeof window < \"u\") {\n        const R = o.webpack && typeof hr.resolveWeak == \"function\" ? o.webpack() : o.modules;\n        R && x.push((L) => {\n          for (const O of R)\n            if (L.includes(O))\n              return m();\n        });\n      }\n      function W() {\n        m();\n        const R = T.default.useContext(C.LoadableContext);\n        R && Array.isArray(o.modules) && o.modules.forEach((L) => {\n          R(L);\n        });\n      }\n      function M(R, L) {\n        W();\n        const O = T.default.useSyncExternalStore(f.subscribe, f.getCurrentValue, f.getCurrentValue);\n        return T.default.useImperativeHandle(L, () => ({\n          retry: f.retry\n        }), []), T.default.useMemo(() => O.loading || O.error ? /* @__PURE__ */ T.default.createElement(o.loading, {\n          isLoading: O.loading,\n          pastDelay: O.pastDelay,\n          timedOut: O.timedOut,\n          error: O.error,\n          retry: f.retry\n        }) : O.loaded ? /* @__PURE__ */ T.default.createElement(j(O.loaded), R) : null, [\n          R,\n          O\n        ]);\n      }\n      return M.preload = () => m(), M.displayName = \"LoadableComponent\", /* @__PURE__ */ T.default.forwardRef(M);\n    }\n    class l {\n      promise() {\n        return this._res.promise;\n      }\n      retry() {\n        this._clearTimeouts(), this._res = this._loadFn(this._opts.loader), this._state = {\n          pastDelay: !1,\n          timedOut: !1\n        };\n        const { _res: _, _opts: o } = this;\n        _.loading && (typeof o.delay == \"number\" && (o.delay === 0 ? this._state.pastDelay = !0 : this._delay = setTimeout(() => {\n          this._update({\n            pastDelay: !0\n          });\n        }, o.delay)), typeof o.timeout == \"number\" && (this._timeout = setTimeout(() => {\n          this._update({\n            timedOut: !0\n          });\n        }, o.timeout))), this._res.promise.then(() => {\n          this._update({}), this._clearTimeouts();\n        }).catch((f) => {\n          this._update({}), this._clearTimeouts();\n        }), this._update({});\n      }\n      _update(_) {\n        this._state = {\n          ...this._state,\n          error: this._res.error,\n          loaded: this._res.loaded,\n          loading: this._res.loading,\n          ..._\n        }, this._callbacks.forEach((o) => o());\n      }\n      _clearTimeouts() {\n        clearTimeout(this._delay), clearTimeout(this._timeout);\n      }\n      getCurrentValue() {\n        return this._state;\n      }\n      subscribe(_) {\n        return this._callbacks.add(_), () => {\n          this._callbacks.delete(_);\n        };\n      }\n      constructor(_, o) {\n        this._loadFn = _, this._opts = o, this._callbacks = /* @__PURE__ */ new Set(), this._delay = null, this._timeout = null, this.retry();\n      }\n    }\n    function v(s) {\n      return k(b, s);\n    }\n    function g(s, _) {\n      let o = [];\n      for (; s.length; ) {\n        let f = s.pop();\n        o.push(f(_));\n      }\n      return Promise.all(o).then(() => {\n        if (s.length)\n          return g(s, _);\n      });\n    }\n    v.preloadAll = () => new Promise((s, _) => {\n      g(D).then(s, _);\n    }), v.preloadReady = (s) => (s === void 0 && (s = []), new Promise((_) => {\n      const o = () => (P = !0, _());\n      g(x, s).then(o, o);\n    })), typeof window < \"u\" && (window.__NEXT_PRELOADREADY = v.preloadReady);\n    const d = v;\n  }(ie)), ie;\n}\n(function(p, E) {\n  Object.defineProperty(E, \"__esModule\", {\n    value: !0\n  });\n  function T(l, v) {\n    for (var g in v)\n      Object.defineProperty(l, g, {\n        enumerable: !0,\n        get: v[g]\n      });\n  }\n  T(E, {\n    noSSR: function() {\n      return b;\n    },\n    default: function() {\n      return k;\n    }\n  });\n  const C = B, j = mr, D = /* @__PURE__ */ C._(yr()), x = typeof window > \"u\";\n  function P(l) {\n    return {\n      default: (l == null ? void 0 : l.default) || l\n    };\n  }\n  function b(l, v) {\n    if (delete v.webpack, delete v.modules, !x)\n      return l(v);\n    const g = v.loading;\n    return () => /* @__PURE__ */ (0, j.jsx)(g, {\n      error: null,\n      isLoading: !0,\n      pastDelay: !1,\n      timedOut: !1\n    });\n  }\n  function k(l, v) {\n    let g = D.default, d = {\n      // A loading component is not required, so we default it\n      loading: (o) => {\n        let { error: f, isLoading: m, pastDelay: W } = o;\n        if (!W)\n          return null;\n        if (true) {\n          if (m)\n            return null;\n          if (f)\n            return /* @__PURE__ */ (0, j.jsxs)(\"p\", {\n              children: [\n                f.message,\n                /* @__PURE__ */ (0, j.jsx)(\"br\", {}),\n                f.stack\n              ]\n            });\n        }\n        return null;\n      }\n    };\n    l instanceof Promise ? d.loader = () => l : typeof l == \"function\" ? d.loader = l : typeof l == \"object\" && (d = {\n      ...d,\n      ...l\n    }), d = {\n      ...d,\n      ...v\n    };\n    const s = d.loader, _ = () => s != null ? s().then(P) : Promise.resolve(P(() => null));\n    return d.loadableGenerated && (d = {\n      ...d,\n      ...d.loadableGenerated\n    }, delete d.loadableGenerated), typeof d.ssr == \"boolean\" && !d.ssr ? (delete d.webpack, delete d.modules, b(g, d)) : g({\n      ...d,\n      loader: _\n    });\n  }\n  (typeof E.default == \"function\" || typeof E.default == \"object\" && E.default !== null) && typeof E.default.__esModule > \"u\" && (Object.defineProperty(E.default, \"__esModule\", { value: !0 }), Object.assign(E.default, E), p.exports = E.default);\n})(le, le.exports);\nvar gr = le.exports, Rr = gr;\nconst Er = /* @__PURE__ */ dr(Rr), Tr = Er(\n  async () => (await __webpack_require__.e(/*! import() */ \"node_modules_p5-wrapper_react_dist_component_react_js\").then(__webpack_require__.bind(__webpack_require__, /*! @p5-wrapper/react */ \"./node_modules/@p5-wrapper/react/dist/component/react.js\"))).ReactP5Wrapper,\n  { ssr: !1 }\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHA1LXdyYXBwZXIvbmV4dC9kaXN0L25leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQUMsNExBQTRMO0FBQ3ZNO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0QsWUFBWSxrQ0FBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBcUMsR0FBRyxDQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyxrQ0FBQztBQUNwQyxJQUFJLEtBQXFDO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDLGtDQUFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCx5QkFBeUI7QUFDekIsU0FBUztBQUNULHlCQUF5QjtBQUN6QixTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUxBQW1MLFdBQVc7QUFDOUwsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxQkFBcUIsdU9BQTJCO0FBQ2hELElBQUk7QUFDSjtBQUdFIiwic291cmNlcyI6WyIvVXNlcnMvY3lydXNraGFsYXRiYXJpL0RvY3VtZW50cy8yIC0gV09SSy8wMi4gUE9PTCBOVU0vUE9PTCBXRUJTSVRFL3Bvb2wtd2Vic2l0ZS9mcm9udC1lbmQvbm9kZV9tb2R1bGVzL0BwNS13cmFwcGVyL25leHQvZGlzdC9uZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBYIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gZHIocCkge1xuICByZXR1cm4gcCAmJiBwLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsIFwiZGVmYXVsdFwiKSA/IHAuZGVmYXVsdCA6IHA7XG59XG52YXIgbGUgPSB7IGV4cG9ydHM6IHt9IH0sIEIgPSB7fTtcbkIuXyA9IEIuX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcHI7XG5mdW5jdGlvbiBwcihwKSB7XG4gIHJldHVybiBwICYmIHAuX19lc01vZHVsZSA/IHAgOiB7IGRlZmF1bHQ6IHAgfTtcbn1cbnZhciBzZSA9IHsgZXhwb3J0czoge30gfSwgViA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIEZlO1xuZnVuY3Rpb24gdnIoKSB7XG4gIGlmIChGZSlcbiAgICByZXR1cm4gVjtcbiAgRmUgPSAxO1xuICB2YXIgcCA9IFgsIEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgVCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgQyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGogPSBwLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBEID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24geChQLCBiLCBrKSB7XG4gICAgdmFyIGwsIHYgPSB7fSwgZyA9IG51bGwsIGQgPSBudWxsO1xuICAgIGsgIT09IHZvaWQgMCAmJiAoZyA9IFwiXCIgKyBrKSwgYi5rZXkgIT09IHZvaWQgMCAmJiAoZyA9IFwiXCIgKyBiLmtleSksIGIucmVmICE9PSB2b2lkIDAgJiYgKGQgPSBiLnJlZik7XG4gICAgZm9yIChsIGluIGIpXG4gICAgICBDLmNhbGwoYiwgbCkgJiYgIUQuaGFzT3duUHJvcGVydHkobCkgJiYgKHZbbF0gPSBiW2xdKTtcbiAgICBpZiAoUCAmJiBQLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAobCBpbiBiID0gUC5kZWZhdWx0UHJvcHMsIGIpXG4gICAgICAgIHZbbF0gPT09IHZvaWQgMCAmJiAodltsXSA9IGJbbF0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBFLCB0eXBlOiBQLCBrZXk6IGcsIHJlZjogZCwgcHJvcHM6IHYsIF9vd25lcjogai5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIFYuRnJhZ21lbnQgPSBULCBWLmpzeCA9IHgsIFYuanN4cyA9IHgsIFY7XG59XG52YXIgVSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIExlO1xuZnVuY3Rpb24gX3IoKSB7XG4gIHJldHVybiBMZSB8fCAoTGUgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSBYLCBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIFQgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBDID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBqID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBEID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCB4ID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBQID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGsgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgdiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBzID0gU3ltYm9sLml0ZXJhdG9yLCBfID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICBpZiAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciByID0gcyAmJiBlW3NdIHx8IGVbX107XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgfVxuICAgIHZhciBmID0gcC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBtKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkociA+IDEgPyByIC0gMSA6IDApLCBuID0gMTsgbiA8IHI7IG4rKylcbiAgICAgICAgICB0W24gLSAxXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgVyhcImVycm9yXCIsIGUsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSBmLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIHUgPSBuLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgdSAhPT0gXCJcIiAmJiAociArPSBcIiVzXCIsIHQgPSB0LmNvbmNhdChbdV0pKTtcbiAgICAgICAgdmFyIGMgPSB0Lm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGMudW5zaGlmdChcIldhcm5pbmc6IFwiICsgciksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbZV0sIGNvbnNvbGUsIGMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgTSA9ICExLCBSID0gITEsIEwgPSAhMSwgTyA9ICExLCAkZSA9ICExLCBmZTtcbiAgICBmZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIFdlKGUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSBDIHx8IGUgPT09IEQgfHwgJGUgfHwgZSA9PT0gaiB8fCBlID09PSBrIHx8IGUgPT09IGwgfHwgTyB8fCBlID09PSBkIHx8IE0gfHwgUiB8fCBMIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gZyB8fCBlLiQkdHlwZW9mID09PSB2IHx8IGUuJCR0eXBlb2YgPT09IHggfHwgZS4kJHR5cGVvZiA9PT0gUCB8fCBlLiQkdHlwZW9mID09PSBiIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIGUuJCR0eXBlb2YgPT09IGZlIHx8IGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNZShlLCByLCB0KSB7XG4gICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgdSA9IHIuZGlzcGxheU5hbWUgfHwgci5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gdSAhPT0gXCJcIiA/IHQgKyBcIihcIiArIHUgKyBcIilcIiA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlKGUpIHtcbiAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKGUpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlLnRhZyA9PSBcIm51bWJlclwiICYmIG0oXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBUOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIEQ6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBqOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBrOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFA6XG4gICAgICAgICAgICB2YXIgciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gY2UocikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgeDpcbiAgICAgICAgICAgIHZhciB0ID0gZTtcbiAgICAgICAgICAgIHJldHVybiBjZSh0Ll9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgcmV0dXJuIE1lKGUsIGUucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSB2OlxuICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbiAhPT0gbnVsbCA/IG4gOiBBKGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBnOiB7XG4gICAgICAgICAgICB2YXIgdSA9IGUsIGMgPSB1Ll9wYXlsb2FkLCBpID0gdS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBBKGkoYykpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBJID0gT2JqZWN0LmFzc2lnbiwgcSA9IDAsIGRlLCBwZSwgdmUsIF9lLCBtZSwgaGUsIGJlO1xuICAgIGZ1bmN0aW9uIHllKCkge1xuICAgIH1cbiAgICB5ZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBxZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHEgPT09IDApIHtcbiAgICAgICAgICBkZSA9IGNvbnNvbGUubG9nLCBwZSA9IGNvbnNvbGUuaW5mbywgdmUgPSBjb25zb2xlLndhcm4sIF9lID0gY29uc29sZS5lcnJvciwgbWUgPSBjb25zb2xlLmdyb3VwLCBoZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIGJlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiB5ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogZSxcbiAgICAgICAgICAgIGxvZzogZSxcbiAgICAgICAgICAgIHdhcm46IGUsXG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIGdyb3VwOiBlLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGUsXG4gICAgICAgICAgICBncm91cEVuZDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHErKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChxLS0sIHEgPT09IDApIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBJKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBkZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBJKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBJKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogSSh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogX2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IEkoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBJKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBoZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogSSh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogYmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcSA8IDAgJiYgbShcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBaID0gZi5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBRO1xuICAgIGZ1bmN0aW9uIEcoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICBpZiAoUSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICAgIHZhciBuID0gdS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIFEgPSBuICYmIG5bMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgUSArIGU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlZSA9ICExLCBKO1xuICAgIHtcbiAgICAgIHZhciBWZSA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBKID0gbmV3IFZlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlKGUsIHIpIHtcbiAgICAgIGlmICghZSB8fCBlZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gSi5nZXQoZSk7XG4gICAgICAgIGlmICh0ICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICB2YXIgbjtcbiAgICAgIGVlID0gITA7XG4gICAgICB2YXIgdSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgYztcbiAgICAgIGMgPSBaLmN1cnJlbnQsIFouY3VycmVudCA9IG51bGwsIHFlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHZhciBpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChpLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgICAgIG4gPSBGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEYpIHtcbiAgICAgICAgICAgICAgbiA9IEY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNhbGwoaS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgICBuID0gRjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgIGlmIChGICYmIG4gJiYgdHlwZW9mIEYuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBGLnN0YWNrLnNwbGl0KGBcbmApLCB3ID0gbi5zdGFjay5zcGxpdChgXG5gKSwgaCA9IGEubGVuZ3RoIC0gMSwgeSA9IHcubGVuZ3RoIC0gMTsgaCA+PSAxICYmIHkgPj0gMCAmJiBhW2hdICE9PSB3W3ldOyApXG4gICAgICAgICAgICB5LS07XG4gICAgICAgICAgZm9yICg7IGggPj0gMSAmJiB5ID49IDA7IGgtLSwgeS0tKVxuICAgICAgICAgICAgaWYgKGFbaF0gIT09IHdbeV0pIHtcbiAgICAgICAgICAgICAgaWYgKGggIT09IDEgfHwgeSAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKGgtLSwgeS0tLCB5IDwgMCB8fCBhW2hdICE9PSB3W3ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTID0gYFxuYCArIGFbaF0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgUy5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChTID0gUy5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgSi5zZXQoZSwgUyksIFM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGggPj0gMSAmJiB5ID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZWUgPSAhMSwgWi5jdXJyZW50ID0gYywgWWUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1O1xuICAgICAgfVxuICAgICAgdmFyICQgPSBlID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgOiBcIlwiLCBBZSA9ICQgPyBHKCQpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgSi5zZXQoZSwgQWUpLCBBZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWUoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIGdlKGUsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmUoZSkge1xuICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShyICYmIHIuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHooZSwgciwgdCkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZ2UoZSwgQmUoZSkpO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBHKGUpO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgazpcbiAgICAgICAgICByZXR1cm4gRyhcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgcmV0dXJuIEcoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgcmV0dXJuIFVlKGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIHY6XG4gICAgICAgICAgICByZXR1cm4geihlLnR5cGUsIHIsIHQpO1xuICAgICAgICAgIGNhc2UgZzoge1xuICAgICAgICAgICAgdmFyIG4gPSBlLCB1ID0gbi5fcGF5bG9hZCwgYyA9IG4uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geihjKHUpLCByLCB0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBIID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgUmUgPSB7fSwgRWUgPSBmLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gSyhlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0geihlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBFZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgRWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHZShlLCByLCB0LCBuLCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjID0gRnVuY3Rpb24uY2FsbC5iaW5kKEgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIGUpXG4gICAgICAgICAgaWYgKGMoZSwgaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlW2ldICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gRXJyb3IoKG4gfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIHQgKyBcIiB0eXBlIGBcIiArIGkgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbaV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IHcubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCB3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEgPSBlW2ldKHIsIGksIG4sIHQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICAgIGEgPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSAmJiAhKGEgaW5zdGFuY2VvZiBFcnJvcikgJiYgKEsodSksIG0oXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG4gfHwgXCJSZWFjdCBjbGFzc1wiLCB0LCBpLCB0eXBlb2YgYSksIEsobnVsbCkpLCBhIGluc3RhbmNlb2YgRXJyb3IgJiYgIShhLm1lc3NhZ2UgaW4gUmUpICYmIChSZVthLm1lc3NhZ2VdID0gITAsIEsodSksIG0oXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgdCwgYS5tZXNzYWdlKSwgSyhudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSmUgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIHJlKGUpIHtcbiAgICAgIHJldHVybiBKZShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gemUoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgdCA9IHIgJiYgZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IGUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSGUoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHdlKGUpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdlKGUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGUoZSkge1xuICAgICAgaWYgKEhlKGUpKVxuICAgICAgICByZXR1cm4gbShcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCB6ZShlKSksIHdlKGUpO1xuICAgIH1cbiAgICB2YXIgWSA9IGYuUmVhY3RDdXJyZW50T3duZXIsIEtlID0ge1xuICAgICAga2V5OiAhMCxcbiAgICAgIHJlZjogITAsXG4gICAgICBfX3NlbGY6ICEwLFxuICAgICAgX19zb3VyY2U6ICEwXG4gICAgfSwgQ2UsIFBlLCB0ZTtcbiAgICB0ZSA9IHt9O1xuICAgIGZ1bmN0aW9uIFhlKGUpIHtcbiAgICAgIGlmIChILmNhbGwoZSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gWmUoZSkge1xuICAgICAgaWYgKEguY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRZShlLCByKSB7XG4gICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgWS5jdXJyZW50ICYmIHIgJiYgWS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gcikge1xuICAgICAgICB2YXIgdCA9IEEoWS5jdXJyZW50LnR5cGUpO1xuICAgICAgICB0ZVt0XSB8fCAobSgnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIEEoWS5jdXJyZW50LnR5cGUpLCBlLnJlZiksIHRlW3RdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcihlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgQ2UgfHwgKENlID0gITAsIG0oXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnIoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFBlIHx8IChQZSA9ICEwLCBtKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ciA9IGZ1bmN0aW9uKGUsIHIsIHQsIG4sIHUsIGMsIGkpIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IEUsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAga2V5OiByLFxuICAgICAgICByZWY6IHQsXG4gICAgICAgIHByb3BzOiBpLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IGNcbiAgICAgIH07XG4gICAgICByZXR1cm4gYS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IG5cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IHVcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKGEucHJvcHMpLCBPYmplY3QuZnJlZXplKGEpKSwgYTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5yKGUsIHIsIHQsIG4sIHUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGMsIGkgPSB7fSwgYSA9IG51bGwsIHcgPSBudWxsO1xuICAgICAgICB0ICE9PSB2b2lkIDAgJiYgKFRlKHQpLCBhID0gXCJcIiArIHQpLCBaZShyKSAmJiAoVGUoci5rZXkpLCBhID0gXCJcIiArIHIua2V5KSwgWGUocikgJiYgKHcgPSByLnJlZiwgUWUociwgdSkpO1xuICAgICAgICBmb3IgKGMgaW4gcilcbiAgICAgICAgICBILmNhbGwociwgYykgJiYgIUtlLmhhc093blByb3BlcnR5KGMpICYmIChpW2NdID0gcltjXSk7XG4gICAgICAgIGlmIChlICYmIGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIGggPSBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKGMgaW4gaClcbiAgICAgICAgICAgIGlbY10gPT09IHZvaWQgMCAmJiAoaVtjXSA9IGhbY10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIHx8IHcpIHtcbiAgICAgICAgICB2YXIgeSA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IFwiVW5rbm93blwiIDogZTtcbiAgICAgICAgICBhICYmIGVyKGksIHkpLCB3ICYmIHJyKGksIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cihlLCBhLCB3LCB1LCBuLCBZLmN1cnJlbnQsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmUgPSBmLlJlYWN0Q3VycmVudE93bmVyLCBPZSA9IGYuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBOKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSB6KGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIE9lLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBPZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBhZTtcbiAgICBhZSA9ICExO1xuICAgIGZ1bmN0aW9uIG9lKGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgZS4kJHR5cGVvZiA9PT0gRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2UoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZS5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIGUgPSBBKG5lLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgZSArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXIoZSkge1xuICAgICAge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCB0ID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgdCArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgamUgPSB7fTtcbiAgICBmdW5jdGlvbiBvcihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gU2UoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIHQgJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyB0ICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24geGUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciB0ID0gb3Iocik7XG4gICAgICAgIGlmIChqZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGplW3RdID0gITA7XG4gICAgICAgIHZhciBuID0gXCJcIjtcbiAgICAgICAgZSAmJiBlLl9vd25lciAmJiBlLl9vd25lciAhPT0gbmUuY3VycmVudCAmJiAobiA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgQShlLl9vd25lci50eXBlKSArIFwiLlwiKSwgTihlKSwgbSgnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgdCwgbiksIE4obnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocmUoZSkpXG4gICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVbdF07XG4gICAgICAgICAgICBvZShuKSAmJiB4ZShuLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9lKGUpKVxuICAgICAgICAgIGUuX3N0b3JlICYmIChlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgdSA9IG8oZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiAmJiB1ICE9PSBlLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gdS5jYWxsKGUpLCBpOyAhKGkgPSBjLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBvZShpLnZhbHVlKSAmJiB4ZShpLnZhbHVlLCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gZS50eXBlO1xuICAgICAgICBpZiAociA9PSBudWxsIHx8IHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaWYgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgKHIuJCR0eXBlb2YgPT09IGIgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgci4kJHR5cGVvZiA9PT0gdikpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciBuID0gQShyKTtcbiAgICAgICAgICBHZSh0LCBlLnByb3BzLCBcInByb3BcIiwgbiwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoci5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhYWUpIHtcbiAgICAgICAgICBhZSA9ICEwO1xuICAgICAgICAgIHZhciB1ID0gQShyKTtcbiAgICAgICAgICBtKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIHUgfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiByLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIXIuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIG0oXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXIoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gT2JqZWN0LmtleXMoZS5wcm9wcyksIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIHZhciBuID0gclt0XTtcbiAgICAgICAgICBpZiAobiAhPT0gXCJjaGlsZHJlblwiICYmIG4gIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIE4oZSksIG0oXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCBuKSwgTihudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlLnJlZiAhPT0gbnVsbCAmJiAoTihlKSwgbShcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBOKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRGUoZSwgciwgdCwgbiwgdSwgYykge1xuICAgICAge1xuICAgICAgICB2YXIgaSA9IFdlKGUpO1xuICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICB2YXIgYSA9IFwiXCI7XG4gICAgICAgICAgKGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID09PSAwKSAmJiAoYSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciB3ID0gYXIodSk7XG4gICAgICAgICAgdyA/IGEgKz0gdyA6IGEgKz0gU2UoKTtcbiAgICAgICAgICB2YXIgaDtcbiAgICAgICAgICBlID09PSBudWxsID8gaCA9IFwibnVsbFwiIDogcmUoZSkgPyBoID0gXCJhcnJheVwiIDogZSAhPT0gdm9pZCAwICYmIGUuJCR0eXBlb2YgPT09IEUgPyAoaCA9IFwiPFwiICsgKEEoZS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBhID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBoID0gdHlwZW9mIGUsIG0oXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgaCwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBucihlLCByLCB0LCB1LCBjKTtcbiAgICAgICAgaWYgKHkgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICB2YXIgUyA9IHIuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKFMgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICBpZiAocmUoUykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAkID0gMDsgJCA8IFMubGVuZ3RoOyAkKyspXG4gICAgICAgICAgICAgICAgICBrZShTWyRdLCBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoUyk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIG0oXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBrZShTLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA9PT0gQyA/IHVyKHkpIDogaXIoeSksIHk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBEZShlLCByLCB0LCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBEZShlLCByLCB0LCAhMSk7XG4gICAgfVxuICAgIHZhciBmciA9IHNyLCBjciA9IGxyO1xuICAgIFUuRnJhZ21lbnQgPSBDLCBVLmpzeCA9IGZyLCBVLmpzeHMgPSBjcjtcbiAgfSgpKSwgVTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHNlLmV4cG9ydHMgPSB2cigpIDogc2UuZXhwb3J0cyA9IF9yKCk7XG52YXIgbXIgPSBzZS5leHBvcnRzO1xuZnVuY3Rpb24gaHIocCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHAgKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO1xufVxudmFyIGllID0ge30sIHVlID0ge30sIEllO1xuZnVuY3Rpb24gYnIoKSB7XG4gIHJldHVybiBJZSB8fCAoSWUgPSAxLCBmdW5jdGlvbihwKSB7XG4gICAgXCJ1c2UgY2xpZW50XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogITBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwiTG9hZGFibGVDb250ZXh0XCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgQyA9ICgvKiBAX19QVVJFX18gKi8gQi5fKFgpKS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChDLmRpc3BsYXlOYW1lID0gXCJMb2FkYWJsZUNvbnRleHRcIik7XG4gIH0odWUpKSwgdWU7XG59XG52YXIgTmU7XG5mdW5jdGlvbiB5cigpIHtcbiAgcmV0dXJuIE5lIHx8IChOZSA9IDEsIGZ1bmN0aW9uKHApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiAhMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJkZWZhdWx0XCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgVCA9IC8qIEBfX1BVUkVfXyAqLyBCLl8oWCksIEMgPSBicigpO1xuICAgIGZ1bmN0aW9uIGoocykge1xuICAgICAgcmV0dXJuIHMgJiYgcy5kZWZhdWx0ID8gcy5kZWZhdWx0IDogcztcbiAgICB9XG4gICAgY29uc3QgRCA9IFtdLCB4ID0gW107XG4gICAgbGV0IFAgPSAhMTtcbiAgICBmdW5jdGlvbiBiKHMpIHtcbiAgICAgIGxldCBfID0gcygpLCBvID0ge1xuICAgICAgICBsb2FkaW5nOiAhMCxcbiAgICAgICAgbG9hZGVkOiBudWxsLFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiBvLnByb21pc2UgPSBfLnRoZW4oKGYpID0+IChvLmxvYWRpbmcgPSAhMSwgby5sb2FkZWQgPSBmLCBmKSkuY2F0Y2goKGYpID0+IHtcbiAgICAgICAgdGhyb3cgby5sb2FkaW5nID0gITEsIG8uZXJyb3IgPSBmLCBmO1xuICAgICAgfSksIG87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsocywgXykge1xuICAgICAgbGV0IG8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBkZWxheTogMjAwLFxuICAgICAgICB0aW1lb3V0OiBudWxsLFxuICAgICAgICB3ZWJwYWNrOiBudWxsLFxuICAgICAgICBtb2R1bGVzOiBudWxsXG4gICAgICB9LCBfKSwgZiA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICBjb25zdCBSID0gbmV3IGwocywgbyk7XG4gICAgICAgICAgZiA9IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRWYWx1ZTogUi5nZXRDdXJyZW50VmFsdWUuYmluZChSKSxcbiAgICAgICAgICAgIHN1YnNjcmliZTogUi5zdWJzY3JpYmUuYmluZChSKSxcbiAgICAgICAgICAgIHJldHJ5OiBSLnJldHJ5LmJpbmQoUiksXG4gICAgICAgICAgICBwcm9taXNlOiBSLnByb21pc2UuYmluZChSKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYucHJvbWlzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIiAmJiBELnB1c2gobSksICFQICYmIHR5cGVvZiB3aW5kb3cgPCBcInVcIikge1xuICAgICAgICBjb25zdCBSID0gby53ZWJwYWNrICYmIHR5cGVvZiBoci5yZXNvbHZlV2VhayA9PSBcImZ1bmN0aW9uXCIgPyBvLndlYnBhY2soKSA6IG8ubW9kdWxlcztcbiAgICAgICAgUiAmJiB4LnB1c2goKEwpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IE8gb2YgUilcbiAgICAgICAgICAgIGlmIChMLmluY2x1ZGVzKE8pKVxuICAgICAgICAgICAgICByZXR1cm4gbSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICAgIG0oKTtcbiAgICAgICAgY29uc3QgUiA9IFQuZGVmYXVsdC51c2VDb250ZXh0KEMuTG9hZGFibGVDb250ZXh0KTtcbiAgICAgICAgUiAmJiBBcnJheS5pc0FycmF5KG8ubW9kdWxlcykgJiYgby5tb2R1bGVzLmZvckVhY2goKEwpID0+IHtcbiAgICAgICAgICBSKEwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE0oUiwgTCkge1xuICAgICAgICBXKCk7XG4gICAgICAgIGNvbnN0IE8gPSBULmRlZmF1bHQudXNlU3luY0V4dGVybmFsU3RvcmUoZi5zdWJzY3JpYmUsIGYuZ2V0Q3VycmVudFZhbHVlLCBmLmdldEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBULmRlZmF1bHQudXNlSW1wZXJhdGl2ZUhhbmRsZShMLCAoKSA9PiAoe1xuICAgICAgICAgIHJldHJ5OiBmLnJldHJ5XG4gICAgICAgIH0pLCBbXSksIFQuZGVmYXVsdC51c2VNZW1vKCgpID0+IE8ubG9hZGluZyB8fCBPLmVycm9yID8gLyogQF9fUFVSRV9fICovIFQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KG8ubG9hZGluZywge1xuICAgICAgICAgIGlzTG9hZGluZzogTy5sb2FkaW5nLFxuICAgICAgICAgIHBhc3REZWxheTogTy5wYXN0RGVsYXksXG4gICAgICAgICAgdGltZWRPdXQ6IE8udGltZWRPdXQsXG4gICAgICAgICAgZXJyb3I6IE8uZXJyb3IsXG4gICAgICAgICAgcmV0cnk6IGYucmV0cnlcbiAgICAgICAgfSkgOiBPLmxvYWRlZCA/IC8qIEBfX1BVUkVfXyAqLyBULmRlZmF1bHQuY3JlYXRlRWxlbWVudChqKE8ubG9hZGVkKSwgUikgOiBudWxsLCBbXG4gICAgICAgICAgUixcbiAgICAgICAgICBPXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE0ucHJlbG9hZCA9ICgpID0+IG0oKSwgTS5kaXNwbGF5TmFtZSA9IFwiTG9hZGFibGVDb21wb25lbnRcIiwgLyogQF9fUFVSRV9fICovIFQuZGVmYXVsdC5mb3J3YXJkUmVmKE0pO1xuICAgIH1cbiAgICBjbGFzcyBsIHtcbiAgICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXMucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHJldHJ5KCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXRzKCksIHRoaXMuX3JlcyA9IHRoaXMuX2xvYWRGbih0aGlzLl9vcHRzLmxvYWRlciksIHRoaXMuX3N0YXRlID0ge1xuICAgICAgICAgIHBhc3REZWxheTogITEsXG4gICAgICAgICAgdGltZWRPdXQ6ICExXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgX3JlczogXywgX29wdHM6IG8gfSA9IHRoaXM7XG4gICAgICAgIF8ubG9hZGluZyAmJiAodHlwZW9mIG8uZGVsYXkgPT0gXCJudW1iZXJcIiAmJiAoby5kZWxheSA9PT0gMCA/IHRoaXMuX3N0YXRlLnBhc3REZWxheSA9ICEwIDogdGhpcy5fZGVsYXkgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGUoe1xuICAgICAgICAgICAgcGFzdERlbGF5OiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBvLmRlbGF5KSksIHR5cGVvZiBvLnRpbWVvdXQgPT0gXCJudW1iZXJcIiAmJiAodGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZSh7XG4gICAgICAgICAgICB0aW1lZE91dDogITBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgby50aW1lb3V0KSkpLCB0aGlzLl9yZXMucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGUoe30pLCB0aGlzLl9jbGVhclRpbWVvdXRzKCk7XG4gICAgICAgIH0pLmNhdGNoKChmKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKHt9KSwgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgICAgICB9KSwgdGhpcy5fdXBkYXRlKHt9KTtcbiAgICAgIH1cbiAgICAgIF91cGRhdGUoXykge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgICAgICAuLi50aGlzLl9zdGF0ZSxcbiAgICAgICAgICBlcnJvcjogdGhpcy5fcmVzLmVycm9yLFxuICAgICAgICAgIGxvYWRlZDogdGhpcy5fcmVzLmxvYWRlZCxcbiAgICAgICAgICBsb2FkaW5nOiB0aGlzLl9yZXMubG9hZGluZyxcbiAgICAgICAgICAuLi5fXG4gICAgICAgIH0sIHRoaXMuX2NhbGxiYWNrcy5mb3JFYWNoKChvKSA9PiBvKCkpO1xuICAgICAgfVxuICAgICAgX2NsZWFyVGltZW91dHMoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZWxheSksIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGdldEN1cnJlbnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlKF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5hZGQoXyksICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGVsZXRlKF8pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3RydWN0b3IoXywgbykge1xuICAgICAgICB0aGlzLl9sb2FkRm4gPSBfLCB0aGlzLl9vcHRzID0gbywgdGhpcy5fY2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGhpcy5fZGVsYXkgPSBudWxsLCB0aGlzLl90aW1lb3V0ID0gbnVsbCwgdGhpcy5yZXRyeSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2KHMpIHtcbiAgICAgIHJldHVybiBrKGIsIHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnKHMsIF8pIHtcbiAgICAgIGxldCBvID0gW107XG4gICAgICBmb3IgKDsgcy5sZW5ndGg7ICkge1xuICAgICAgICBsZXQgZiA9IHMucG9wKCk7XG4gICAgICAgIG8ucHVzaChmKF8pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChvKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHMubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBnKHMsIF8pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHYucHJlbG9hZEFsbCA9ICgpID0+IG5ldyBQcm9taXNlKChzLCBfKSA9PiB7XG4gICAgICBnKEQpLnRoZW4ocywgXyk7XG4gICAgfSksIHYucHJlbG9hZFJlYWR5ID0gKHMpID0+IChzID09PSB2b2lkIDAgJiYgKHMgPSBbXSksIG5ldyBQcm9taXNlKChfKSA9PiB7XG4gICAgICBjb25zdCBvID0gKCkgPT4gKFAgPSAhMCwgXygpKTtcbiAgICAgIGcoeCwgcykudGhlbihvLCBvKTtcbiAgICB9KSksIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkgPSB2LnByZWxvYWRSZWFkeSk7XG4gICAgY29uc3QgZCA9IHY7XG4gIH0oaWUpKSwgaWU7XG59XG4oZnVuY3Rpb24ocCwgRSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogITBcbiAgfSk7XG4gIGZ1bmN0aW9uIFQobCwgdikge1xuICAgIGZvciAodmFyIGcgaW4gdilcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLCBnLCB7XG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBnZXQ6IHZbZ11cbiAgICAgIH0pO1xuICB9XG4gIFQoRSwge1xuICAgIG5vU1NSOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaztcbiAgICB9XG4gIH0pO1xuICBjb25zdCBDID0gQiwgaiA9IG1yLCBEID0gLyogQF9fUFVSRV9fICovIEMuXyh5cigpKSwgeCA9IHR5cGVvZiB3aW5kb3cgPiBcInVcIjtcbiAgZnVuY3Rpb24gUChsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHQ6IChsID09IG51bGwgPyB2b2lkIDAgOiBsLmRlZmF1bHQpIHx8IGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGIobCwgdikge1xuICAgIGlmIChkZWxldGUgdi53ZWJwYWNrLCBkZWxldGUgdi5tb2R1bGVzLCAheClcbiAgICAgIHJldHVybiBsKHYpO1xuICAgIGNvbnN0IGcgPSB2LmxvYWRpbmc7XG4gICAgcmV0dXJuICgpID0+IC8qIEBfX1BVUkVfXyAqLyAoMCwgai5qc3gpKGcsIHtcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgaXNMb2FkaW5nOiAhMCxcbiAgICAgIHBhc3REZWxheTogITEsXG4gICAgICB0aW1lZE91dDogITFcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBrKGwsIHYpIHtcbiAgICBsZXQgZyA9IEQuZGVmYXVsdCwgZCA9IHtcbiAgICAgIC8vIEEgbG9hZGluZyBjb21wb25lbnQgaXMgbm90IHJlcXVpcmVkLCBzbyB3ZSBkZWZhdWx0IGl0XG4gICAgICBsb2FkaW5nOiAobykgPT4ge1xuICAgICAgICBsZXQgeyBlcnJvcjogZiwgaXNMb2FkaW5nOiBtLCBwYXN0RGVsYXk6IFcgfSA9IG87XG4gICAgICAgIGlmICghVylcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGlmIChtKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBqLmpzeHMpKFwicFwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgZi5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgai5qc3gpKFwiYnJcIiwge30pLFxuICAgICAgICAgICAgICAgIGYuc3RhY2tcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBsIGluc3RhbmNlb2YgUHJvbWlzZSA/IGQubG9hZGVyID0gKCkgPT4gbCA6IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGQubG9hZGVyID0gbCA6IHR5cGVvZiBsID09IFwib2JqZWN0XCIgJiYgKGQgPSB7XG4gICAgICAuLi5kLFxuICAgICAgLi4ubFxuICAgIH0pLCBkID0ge1xuICAgICAgLi4uZCxcbiAgICAgIC4uLnZcbiAgICB9O1xuICAgIGNvbnN0IHMgPSBkLmxvYWRlciwgXyA9ICgpID0+IHMgIT0gbnVsbCA/IHMoKS50aGVuKFApIDogUHJvbWlzZS5yZXNvbHZlKFAoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiBkLmxvYWRhYmxlR2VuZXJhdGVkICYmIChkID0ge1xuICAgICAgLi4uZCxcbiAgICAgIC4uLmQubG9hZGFibGVHZW5lcmF0ZWRcbiAgICB9LCBkZWxldGUgZC5sb2FkYWJsZUdlbmVyYXRlZCksIHR5cGVvZiBkLnNzciA9PSBcImJvb2xlYW5cIiAmJiAhZC5zc3IgPyAoZGVsZXRlIGQud2VicGFjaywgZGVsZXRlIGQubW9kdWxlcywgYihnLCBkKSkgOiBnKHtcbiAgICAgIC4uLmQsXG4gICAgICBsb2FkZXI6IF9cbiAgICB9KTtcbiAgfVxuICAodHlwZW9mIEUuZGVmYXVsdCA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIEUuZGVmYXVsdCA9PSBcIm9iamVjdFwiICYmIEUuZGVmYXVsdCAhPT0gbnVsbCkgJiYgdHlwZW9mIEUuZGVmYXVsdC5fX2VzTW9kdWxlID4gXCJ1XCIgJiYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFLmRlZmF1bHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgT2JqZWN0LmFzc2lnbihFLmRlZmF1bHQsIEUpLCBwLmV4cG9ydHMgPSBFLmRlZmF1bHQpO1xufSkobGUsIGxlLmV4cG9ydHMpO1xudmFyIGdyID0gbGUuZXhwb3J0cywgUnIgPSBncjtcbmNvbnN0IEVyID0gLyogQF9fUFVSRV9fICovIGRyKFJyKSwgVHIgPSBFcihcbiAgYXN5bmMgKCkgPT4gKGF3YWl0IGltcG9ydChcIkBwNS13cmFwcGVyL3JlYWN0XCIpKS5SZWFjdFA1V3JhcHBlcixcbiAgeyBzc3I6ICExIH1cbik7XG5leHBvcnQge1xuICBUciBhcyBOZXh0UmVhY3RQNVdyYXBwZXJcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@p5-wrapper/next/dist/next.js\n"));

/***/ })

}]);