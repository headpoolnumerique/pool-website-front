"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_p5-wrapper_react_dist_component_react_js"],{

/***/ "./node_modules/@p5-wrapper/react/dist/component/react.js":
/*!****************************************************************!*\
  !*** ./node_modules/@p5-wrapper/react/dist/component/react.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P5WrapperClassName: () => (/* binding */ Zn),\n/* harmony export */   ReactP5Wrapper: () => (/* binding */ ro)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nconst Hn = { Date: !0, RegExp: !0, String: !0, Number: !0 };\nfunction xn(yt, Et, Vt = { cyclesFix: !0 }, t = []) {\n  var y, u;\n  let H = [];\n  const C = Array.isArray(yt);\n  for (const h in yt) {\n    const g = yt[h], f = C ? +h : h;\n    if (!(h in Et)) {\n      H.push({\n        type: \"REMOVE\",\n        path: [f],\n        oldValue: yt[h]\n      });\n      continue;\n    }\n    const r = Et[h], s = typeof g == \"object\" && typeof r == \"object\" && Array.isArray(g) === Array.isArray(r);\n    if (g && r && s && !Hn[(u = (y = Object.getPrototypeOf(g)) == null ? void 0 : y.constructor) == null ? void 0 : u.name] && (!Vt.cyclesFix || !t.includes(g))) {\n      const o = xn(g, r, Vt, Vt.cyclesFix ? t.concat([g]) : []);\n      H.push.apply(H, o.map((i) => (i.path.unshift(f), i)));\n    } else\n      g !== r && // treat NaN values as equivalent\n      !(Number.isNaN(g) && Number.isNaN(r)) && !(s && (isNaN(g) ? g + \"\" == r + \"\" : +g == +r)) && H.push({\n        path: [f],\n        type: \"CHANGE\",\n        value: r,\n        oldValue: g\n      });\n  }\n  const m = Array.isArray(Et);\n  for (const h in Et)\n    h in yt || H.push({\n      type: \"CREATE\",\n      path: [m ? +h : h],\n      value: Et[h]\n    });\n  return H;\n}\nfunction Wn(yt, Et) {\n  return xn(yt, Et).length === 0;\n}\nvar _r = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction qn(yt) {\n  return yt && yt.__esModule && Object.prototype.hasOwnProperty.call(yt, \"default\") ? yt.default : yt;\n}\nvar Pr = { exports: {} }, pr = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar vn;\nfunction Xn() {\n  if (vn)\n    return pr;\n  vn = 1;\n  var yt = react__WEBPACK_IMPORTED_MODULE_0__, Et = Symbol.for(\"react.element\"), Vt = Symbol.for(\"react.fragment\"), t = Object.prototype.hasOwnProperty, H = yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, C = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function m(y, u, h) {\n    var g, f = {}, r = null, s = null;\n    h !== void 0 && (r = \"\" + h), u.key !== void 0 && (r = \"\" + u.key), u.ref !== void 0 && (s = u.ref);\n    for (g in u)\n      t.call(u, g) && !C.hasOwnProperty(g) && (f[g] = u[g]);\n    if (y && y.defaultProps)\n      for (g in u = y.defaultProps, u)\n        f[g] === void 0 && (f[g] = u[g]);\n    return { $$typeof: Et, type: y, key: r, ref: s, props: f, _owner: H.current };\n  }\n  return pr.Fragment = Vt, pr.jsx = m, pr.jsxs = m, pr;\n}\nvar mr = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar bn;\nfunction Yn() {\n  return bn || (bn = 1,  true && function() {\n    var yt = react__WEBPACK_IMPORTED_MODULE_0__, Et = Symbol.for(\"react.element\"), Vt = Symbol.for(\"react.portal\"), t = Symbol.for(\"react.fragment\"), H = Symbol.for(\"react.strict_mode\"), C = Symbol.for(\"react.profiler\"), m = Symbol.for(\"react.provider\"), y = Symbol.for(\"react.context\"), u = Symbol.for(\"react.forward_ref\"), h = Symbol.for(\"react.suspense\"), g = Symbol.for(\"react.suspense_list\"), f = Symbol.for(\"react.memo\"), r = Symbol.for(\"react.lazy\"), s = Symbol.for(\"react.offscreen\"), o = Symbol.iterator, i = \"@@iterator\";\n    function l(me) {\n      if (me === null || typeof me != \"object\")\n        return null;\n      var Ue = o && me[o] || me[i];\n      return typeof Ue == \"function\" ? Ue : null;\n    }\n    var n = yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function a(me) {\n      {\n        for (var Ue = arguments.length, Ye = new Array(Ue > 1 ? Ue - 1 : 0), it = 1; it < Ue; it++)\n          Ye[it - 1] = arguments[it];\n        c(\"error\", me, Ye);\n      }\n    }\n    function c(me, Ue, Ye) {\n      {\n        var it = n.ReactDebugCurrentFrame, ft = it.getStackAddendum();\n        ft !== \"\" && (Ue += \"%s\", Ye = Ye.concat([ft]));\n        var pt = Ye.map(function(ie) {\n          return String(ie);\n        });\n        pt.unshift(\"Warning: \" + Ue), Function.prototype.apply.call(console[me], console, pt);\n      }\n    }\n    var p = !1, j = !1, T = !1, _ = !1, S = !1, E;\n    E = Symbol.for(\"react.module.reference\");\n    function A(me) {\n      return !!(typeof me == \"string\" || typeof me == \"function\" || me === t || me === C || S || me === H || me === h || me === g || _ || me === s || p || j || T || typeof me == \"object\" && me !== null && (me.$$typeof === r || me.$$typeof === f || me.$$typeof === m || me.$$typeof === y || me.$$typeof === u || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      me.$$typeof === E || me.getModuleId !== void 0));\n    }\n    function x(me, Ue, Ye) {\n      var it = me.displayName;\n      if (it)\n        return it;\n      var ft = Ue.displayName || Ue.name || \"\";\n      return ft !== \"\" ? Ye + \"(\" + ft + \")\" : Ye;\n    }\n    function P(me) {\n      return me.displayName || \"Context\";\n    }\n    function M(me) {\n      if (me == null)\n        return null;\n      if (typeof me.tag == \"number\" && a(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof me == \"function\")\n        return me.displayName || me.name || null;\n      if (typeof me == \"string\")\n        return me;\n      switch (me) {\n        case t:\n          return \"Fragment\";\n        case Vt:\n          return \"Portal\";\n        case C:\n          return \"Profiler\";\n        case H:\n          return \"StrictMode\";\n        case h:\n          return \"Suspense\";\n        case g:\n          return \"SuspenseList\";\n      }\n      if (typeof me == \"object\")\n        switch (me.$$typeof) {\n          case y:\n            var Ue = me;\n            return P(Ue) + \".Consumer\";\n          case m:\n            var Ye = me;\n            return P(Ye._context) + \".Provider\";\n          case u:\n            return x(me, me.render, \"ForwardRef\");\n          case f:\n            var it = me.displayName || null;\n            return it !== null ? it : M(me.type) || \"Memo\";\n          case r: {\n            var ft = me, pt = ft._payload, ie = ft._init;\n            try {\n              return M(ie(pt));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var R = Object.assign, L = 0, F, V, G, U, W, X, ne;\n    function b() {\n    }\n    b.__reactDisabledLog = !0;\n    function O() {\n      {\n        if (L === 0) {\n          F = console.log, V = console.info, G = console.warn, U = console.error, W = console.group, X = console.groupCollapsed, ne = console.groupEnd;\n          var me = {\n            configurable: !0,\n            enumerable: !0,\n            value: b,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: me,\n            log: me,\n            warn: me,\n            error: me,\n            group: me,\n            groupCollapsed: me,\n            groupEnd: me\n          });\n        }\n        L++;\n      }\n    }\n    function D() {\n      {\n        if (L--, L === 0) {\n          var me = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: R({}, me, {\n              value: F\n            }),\n            info: R({}, me, {\n              value: V\n            }),\n            warn: R({}, me, {\n              value: G\n            }),\n            error: R({}, me, {\n              value: U\n            }),\n            group: R({}, me, {\n              value: W\n            }),\n            groupCollapsed: R({}, me, {\n              value: X\n            }),\n            groupEnd: R({}, me, {\n              value: ne\n            })\n          });\n        }\n        L < 0 && a(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var B = n.ReactCurrentDispatcher, Y;\n    function J(me, Ue, Ye) {\n      {\n        if (Y === void 0)\n          try {\n            throw Error();\n          } catch (ft) {\n            var it = ft.stack.trim().match(/\\n( *(at )?)/);\n            Y = it && it[1] || \"\";\n          }\n        return `\n` + Y + me;\n      }\n    }\n    var te = !1, ce;\n    {\n      var re = typeof WeakMap == \"function\" ? WeakMap : Map;\n      ce = new re();\n    }\n    function ue(me, Ue) {\n      if (!me || te)\n        return \"\";\n      {\n        var Ye = ce.get(me);\n        if (Ye !== void 0)\n          return Ye;\n      }\n      var it;\n      te = !0;\n      var ft = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var pt;\n      pt = B.current, B.current = null, O();\n      try {\n        if (Ue) {\n          var ie = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(ie.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(ie, []);\n            } catch (ut) {\n              it = ut;\n            }\n            Reflect.construct(me, [], ie);\n          } else {\n            try {\n              ie.call();\n            } catch (ut) {\n              it = ut;\n            }\n            me.call(ie.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (ut) {\n            it = ut;\n          }\n          me();\n        }\n      } catch (ut) {\n        if (ut && it && typeof ut.stack == \"string\") {\n          for (var Oe = ut.stack.split(`\n`), Ge = it.stack.split(`\n`), Le = Oe.length - 1, rt = Ge.length - 1; Le >= 1 && rt >= 0 && Oe[Le] !== Ge[rt]; )\n            rt--;\n          for (; Le >= 1 && rt >= 0; Le--, rt--)\n            if (Oe[Le] !== Ge[rt]) {\n              if (Le !== 1 || rt !== 1)\n                do\n                  if (Le--, rt--, rt < 0 || Oe[Le] !== Ge[rt]) {\n                    var Pe = `\n` + Oe[Le].replace(\" at new \", \" at \");\n                    return me.displayName && Pe.includes(\"<anonymous>\") && (Pe = Pe.replace(\"<anonymous>\", me.displayName)), typeof me == \"function\" && ce.set(me, Pe), Pe;\n                  }\n                while (Le >= 1 && rt >= 0);\n              break;\n            }\n        }\n      } finally {\n        te = !1, B.current = pt, D(), Error.prepareStackTrace = ft;\n      }\n      var ct = me ? me.displayName || me.name : \"\", qe = ct ? J(ct) : \"\";\n      return typeof me == \"function\" && ce.set(me, qe), qe;\n    }\n    function le(me, Ue, Ye) {\n      return ue(me, !1);\n    }\n    function K(me) {\n      var Ue = me.prototype;\n      return !!(Ue && Ue.isReactComponent);\n    }\n    function ae(me, Ue, Ye) {\n      if (me == null)\n        return \"\";\n      if (typeof me == \"function\")\n        return ue(me, K(me));\n      if (typeof me == \"string\")\n        return J(me);\n      switch (me) {\n        case h:\n          return J(\"Suspense\");\n        case g:\n          return J(\"SuspenseList\");\n      }\n      if (typeof me == \"object\")\n        switch (me.$$typeof) {\n          case u:\n            return le(me.render);\n          case f:\n            return ae(me.type, Ue, Ye);\n          case r: {\n            var it = me, ft = it._payload, pt = it._init;\n            try {\n              return ae(pt(ft), Ue, Ye);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var he = Object.prototype.hasOwnProperty, _e = {}, fe = n.ReactDebugCurrentFrame;\n    function ge(me) {\n      if (me) {\n        var Ue = me._owner, Ye = ae(me.type, me._source, Ue ? Ue.type : null);\n        fe.setExtraStackFrame(Ye);\n      } else\n        fe.setExtraStackFrame(null);\n    }\n    function xe(me, Ue, Ye, it, ft) {\n      {\n        var pt = Function.call.bind(he);\n        for (var ie in me)\n          if (pt(me, ie)) {\n            var Oe = void 0;\n            try {\n              if (typeof me[ie] != \"function\") {\n                var Ge = Error((it || \"React class\") + \": \" + Ye + \" type `\" + ie + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof me[ie] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw Ge.name = \"Invariant Violation\", Ge;\n              }\n              Oe = me[ie](Ue, ie, it, Ye, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (Le) {\n              Oe = Le;\n            }\n            Oe && !(Oe instanceof Error) && (ge(ft), a(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", it || \"React class\", Ye, ie, typeof Oe), ge(null)), Oe instanceof Error && !(Oe.message in _e) && (_e[Oe.message] = !0, ge(ft), a(\"Failed %s type: %s\", Ye, Oe.message), ge(null));\n          }\n      }\n    }\n    var De = Array.isArray;\n    function Me(me) {\n      return De(me);\n    }\n    function Qe(me) {\n      {\n        var Ue = typeof Symbol == \"function\" && Symbol.toStringTag, Ye = Ue && me[Symbol.toStringTag] || me.constructor.name || \"Object\";\n        return Ye;\n      }\n    }\n    function ze(me) {\n      try {\n        return Ve(me), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Ve(me) {\n      return \"\" + me;\n    }\n    function Xe(me) {\n      if (ze(me))\n        return a(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Qe(me)), Ve(me);\n    }\n    var He = n.ReactCurrentOwner, ve = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Re, we, Z;\n    Z = {};\n    function $(me) {\n      if (he.call(me, \"ref\")) {\n        var Ue = Object.getOwnPropertyDescriptor(me, \"ref\").get;\n        if (Ue && Ue.isReactWarning)\n          return !1;\n      }\n      return me.ref !== void 0;\n    }\n    function q(me) {\n      if (he.call(me, \"key\")) {\n        var Ue = Object.getOwnPropertyDescriptor(me, \"key\").get;\n        if (Ue && Ue.isReactWarning)\n          return !1;\n      }\n      return me.key !== void 0;\n    }\n    function ee(me, Ue) {\n      if (typeof me.ref == \"string\" && He.current && Ue && He.current.stateNode !== Ue) {\n        var Ye = M(He.current.type);\n        Z[Ye] || (a('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(He.current.type), me.ref), Z[Ye] = !0);\n      }\n    }\n    function pe(me, Ue) {\n      {\n        var Ye = function() {\n          Re || (Re = !0, a(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", Ue));\n        };\n        Ye.isReactWarning = !0, Object.defineProperty(me, \"key\", {\n          get: Ye,\n          configurable: !0\n        });\n      }\n    }\n    function je(me, Ue) {\n      {\n        var Ye = function() {\n          we || (we = !0, a(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", Ue));\n        };\n        Ye.isReactWarning = !0, Object.defineProperty(me, \"ref\", {\n          get: Ye,\n          configurable: !0\n        });\n      }\n    }\n    var Ce = function(me, Ue, Ye, it, ft, pt, ie) {\n      var Oe = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: Et,\n        // Built-in properties that belong on the element\n        type: me,\n        key: Ue,\n        ref: Ye,\n        props: ie,\n        // Record the component responsible for creating this element.\n        _owner: pt\n      };\n      return Oe._store = {}, Object.defineProperty(Oe._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(Oe, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: it\n      }), Object.defineProperty(Oe, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: ft\n      }), Object.freeze && (Object.freeze(Oe.props), Object.freeze(Oe)), Oe;\n    };\n    function Fe(me, Ue, Ye, it, ft) {\n      {\n        var pt, ie = {}, Oe = null, Ge = null;\n        Ye !== void 0 && (Xe(Ye), Oe = \"\" + Ye), q(Ue) && (Xe(Ue.key), Oe = \"\" + Ue.key), $(Ue) && (Ge = Ue.ref, ee(Ue, ft));\n        for (pt in Ue)\n          he.call(Ue, pt) && !ve.hasOwnProperty(pt) && (ie[pt] = Ue[pt]);\n        if (me && me.defaultProps) {\n          var Le = me.defaultProps;\n          for (pt in Le)\n            ie[pt] === void 0 && (ie[pt] = Le[pt]);\n        }\n        if (Oe || Ge) {\n          var rt = typeof me == \"function\" ? me.displayName || me.name || \"Unknown\" : me;\n          Oe && pe(ie, rt), Ge && je(ie, rt);\n        }\n        return Ce(me, Oe, Ge, ft, it, He.current, ie);\n      }\n    }\n    var Ne = n.ReactCurrentOwner, Be = n.ReactDebugCurrentFrame;\n    function We(me) {\n      if (me) {\n        var Ue = me._owner, Ye = ae(me.type, me._source, Ue ? Ue.type : null);\n        Be.setExtraStackFrame(Ye);\n      } else\n        Be.setExtraStackFrame(null);\n    }\n    var st;\n    st = !1;\n    function nt(me) {\n      return typeof me == \"object\" && me !== null && me.$$typeof === Et;\n    }\n    function Ke() {\n      {\n        if (Ne.current) {\n          var me = M(Ne.current.type);\n          if (me)\n            return `\n\nCheck the render method of \\`` + me + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function at(me) {\n      return \"\";\n    }\n    var ot = {};\n    function bt(me) {\n      {\n        var Ue = Ke();\n        if (!Ue) {\n          var Ye = typeof me == \"string\" ? me : me.displayName || me.name;\n          Ye && (Ue = `\n\nCheck the top-level render call using <` + Ye + \">.\");\n        }\n        return Ue;\n      }\n    }\n    function It(me, Ue) {\n      {\n        if (!me._store || me._store.validated || me.key != null)\n          return;\n        me._store.validated = !0;\n        var Ye = bt(Ue);\n        if (ot[Ye])\n          return;\n        ot[Ye] = !0;\n        var it = \"\";\n        me && me._owner && me._owner !== Ne.current && (it = \" It was passed a child from \" + M(me._owner.type) + \".\"), We(me), a('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ye, it), We(null);\n      }\n    }\n    function Mt(me, Ue) {\n      {\n        if (typeof me != \"object\")\n          return;\n        if (Me(me))\n          for (var Ye = 0; Ye < me.length; Ye++) {\n            var it = me[Ye];\n            nt(it) && It(it, Ue);\n          }\n        else if (nt(me))\n          me._store && (me._store.validated = !0);\n        else if (me) {\n          var ft = l(me);\n          if (typeof ft == \"function\" && ft !== me.entries)\n            for (var pt = ft.call(me), ie; !(ie = pt.next()).done; )\n              nt(ie.value) && It(ie.value, Ue);\n        }\n      }\n    }\n    function mt(me) {\n      {\n        var Ue = me.type;\n        if (Ue == null || typeof Ue == \"string\")\n          return;\n        var Ye;\n        if (typeof Ue == \"function\")\n          Ye = Ue.propTypes;\n        else if (typeof Ue == \"object\" && (Ue.$$typeof === u || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        Ue.$$typeof === f))\n          Ye = Ue.propTypes;\n        else\n          return;\n        if (Ye) {\n          var it = M(Ue);\n          xe(Ye, me.props, \"prop\", it, me);\n        } else if (Ue.PropTypes !== void 0 && !st) {\n          st = !0;\n          var ft = M(Ue);\n          a(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", ft || \"Unknown\");\n        }\n        typeof Ue.getDefaultProps == \"function\" && !Ue.getDefaultProps.isReactClassApproved && a(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function jt(me) {\n      {\n        for (var Ue = Object.keys(me.props), Ye = 0; Ye < Ue.length; Ye++) {\n          var it = Ue[Ye];\n          if (it !== \"children\" && it !== \"key\") {\n            We(me), a(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", it), We(null);\n            break;\n          }\n        }\n        me.ref !== null && (We(me), a(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), We(null));\n      }\n    }\n    function ht(me, Ue, Ye, it, ft, pt) {\n      {\n        var ie = A(me);\n        if (!ie) {\n          var Oe = \"\";\n          (me === void 0 || typeof me == \"object\" && me !== null && Object.keys(me).length === 0) && (Oe += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var Ge = at();\n          Ge ? Oe += Ge : Oe += Ke();\n          var Le;\n          me === null ? Le = \"null\" : Me(me) ? Le = \"array\" : me !== void 0 && me.$$typeof === Et ? (Le = \"<\" + (M(me.type) || \"Unknown\") + \" />\", Oe = \" Did you accidentally export a JSX literal instead of a component?\") : Le = typeof me, a(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", Le, Oe);\n        }\n        var rt = Fe(me, Ue, Ye, ft, pt);\n        if (rt == null)\n          return rt;\n        if (ie) {\n          var Pe = Ue.children;\n          if (Pe !== void 0)\n            if (it)\n              if (Me(Pe)) {\n                for (var ct = 0; ct < Pe.length; ct++)\n                  Mt(Pe[ct], me);\n                Object.freeze && Object.freeze(Pe);\n              } else\n                a(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Mt(Pe, me);\n        }\n        return me === t ? jt(rt) : mt(rt), rt;\n      }\n    }\n    function Dt(me, Ue, Ye) {\n      return ht(me, Ue, Ye, !0);\n    }\n    function Pt(me, Ue, Ye) {\n      return ht(me, Ue, Ye, !1);\n    }\n    var gt = Pt, Ft = Dt;\n    mr.Fragment = t, mr.jsx = gt, mr.jsxs = Ft;\n  }()), mr;\n}\n false ? 0 : Pr.exports = Yn();\nvar wr = Pr.exports;\nconst Zn = \"react-p5-wrapper\";\nfunction xr(yt) {\n  throw new Error('Could not dynamically require \"' + yt + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar wn = { exports: {} };\n/*! p5.js v1.9.4 May 21, 2024 */\n(function(yt, Et) {\n  (function(Vt) {\n    yt.exports = Vt();\n  })(function() {\n    var Vt;\n    return function t(H, C, m) {\n      function y(g, f) {\n        if (!C[g]) {\n          if (!H[g]) {\n            var r = typeof xr == \"function\" && xr;\n            if (!f && r)\n              return r(g, !0);\n            if (u)\n              return u(g, !0);\n            throw (f = new Error(\"Cannot find module '\" + g + \"'\")).code = \"MODULE_NOT_FOUND\", f;\n          }\n          r = C[g] = { exports: {} }, H[g][0].call(r.exports, function(s) {\n            return y(H[g][1][s] || s);\n          }, r, r.exports, t, H, C, m);\n        }\n        return C[g].exports;\n      }\n      for (var u = typeof xr == \"function\" && xr, h = 0; h < m.length; h++)\n        y(m[h]);\n      return y;\n    }({ 1: [function(t, H, C) {\n      C.byteLength = function(i) {\n        var i = r(i), o = i[0], i = i[1];\n        return 3 * (o + i) / 4 - i;\n      }, C.toByteArray = function(s) {\n        var o, i, n = r(s), l = n[0], n = n[1], a = new u(function(j, T) {\n          return 3 * (j + T) / 4 - T;\n        }(l, n)), c = 0, p = 0 < n ? l - 4 : l;\n        for (i = 0; i < p; i += 4)\n          o = y[s.charCodeAt(i)] << 18 | y[s.charCodeAt(i + 1)] << 12 | y[s.charCodeAt(i + 2)] << 6 | y[s.charCodeAt(i + 3)], a[c++] = o >> 16 & 255, a[c++] = o >> 8 & 255, a[c++] = 255 & o;\n        return n === 2 && (o = y[s.charCodeAt(i)] << 2 | y[s.charCodeAt(i + 1)] >> 4, a[c++] = 255 & o), n === 1 && (o = y[s.charCodeAt(i)] << 10 | y[s.charCodeAt(i + 1)] << 4 | y[s.charCodeAt(i + 2)] >> 2, a[c++] = o >> 8 & 255, a[c++] = 255 & o), a;\n      }, C.fromByteArray = function(s) {\n        for (var o, i = s.length, l = i % 3, n = [], a = 0, c = i - l; a < c; a += 16383)\n          n.push(function(p, j, T) {\n            for (var _, S = [], E = j; E < T; E += 3)\n              _ = (p[E] << 16 & 16711680) + (p[E + 1] << 8 & 65280) + (255 & p[E + 2]), S.push(function(A) {\n                return m[A >> 18 & 63] + m[A >> 12 & 63] + m[A >> 6 & 63] + m[63 & A];\n              }(_));\n            return S.join(\"\");\n          }(s, a, c < a + 16383 ? c : a + 16383));\n        return l == 1 ? (o = s[i - 1], n.push(m[o >> 2] + m[o << 4 & 63] + \"==\")) : l == 2 && (o = (s[i - 2] << 8) + s[i - 1], n.push(m[o >> 10] + m[o >> 4 & 63] + m[o << 2 & 63] + \"=\")), n.join(\"\");\n      };\n      for (var m = [], y = [], u = typeof Uint8Array < \"u\" ? Uint8Array : Array, h = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", g = 0, f = h.length; g < f; ++g)\n        m[g] = h[g], y[h.charCodeAt(g)] = g;\n      function r(s) {\n        var o = s.length;\n        if (0 < o % 4)\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        return s = s.indexOf(\"=\"), o = (s = s === -1 ? o : s) === o ? 0 : 4 - s % 4, [s, o];\n      }\n      y[45] = 62, y[95] = 63;\n    }, {}], 2: [function(t, H, C) {\n    }, {}], 3: [function(t, H, C) {\n    }, {}], 4: [function(t, H, C) {\n      (function(r) {\n        var y = t(\"base64-js\"), u = t(\"ieee754\"), h = typeof Symbol == \"function\" && typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null, g = (C.Buffer = r, C.SlowBuffer = function(b) {\n          return +b != b && (b = 0), r.alloc(+b);\n        }, C.INSPECT_MAX_BYTES = 50, 2147483647);\n        function f(b) {\n          if (g < b)\n            throw new RangeError('The value \"' + b + '\" is invalid for option \"size\"');\n          return b = new Uint8Array(b), Object.setPrototypeOf(b, r.prototype), b;\n        }\n        function r(b, O, D) {\n          if (typeof b != \"number\")\n            return s(b, O, D);\n          if (typeof O == \"string\")\n            throw new TypeError('The \"string\" argument must be of type string. Received type number');\n          return i(b);\n        }\n        function s(b, O, D) {\n          if (typeof b == \"string\") {\n            var B = b, Y = O;\n            if (r.isEncoding(Y = typeof Y == \"string\" && Y !== \"\" ? Y : \"utf8\"))\n              return J = 0 | a(B, Y), te = f(J), te = (B = te.write(B, Y)) !== J ? te.slice(0, B) : te;\n            throw new TypeError(\"Unknown encoding: \" + Y);\n          }\n          if (ArrayBuffer.isView(b))\n            return l(b);\n          if (b != null) {\n            if (W(b, ArrayBuffer) || b && W(b.buffer, ArrayBuffer)) {\n              var J = b, B = O, te = D;\n              if (B < 0 || J.byteLength < B)\n                throw new RangeError('\"offset\" is outside of buffer bounds');\n              if (J.byteLength < B + (te || 0))\n                throw new RangeError('\"length\" is outside of buffer bounds');\n              return J = B === void 0 && te === void 0 ? new Uint8Array(J) : te === void 0 ? new Uint8Array(J, B) : new Uint8Array(J, B, te), Object.setPrototypeOf(J, r.prototype), J;\n            }\n            if (typeof b == \"number\")\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            if (Y = b.valueOf && b.valueOf(), Y != null && Y !== b)\n              return r.from(Y, O, D);\n            var ce = function(re) {\n              {\n                var ue, le;\n                if (r.isBuffer(re))\n                  return ue = 0 | n(re.length), (le = f(ue)).length !== 0 && re.copy(le, 0, 0, ue), le;\n              }\n              if (re.length !== void 0)\n                return typeof re.length != \"number\" || X(re.length) ? f(0) : l(re);\n              if (re.type === \"Buffer\" && Array.isArray(re.data))\n                return l(re.data);\n            }(b);\n            if (ce)\n              return ce;\n            if (typeof Symbol < \"u\" && Symbol.toPrimitive != null && typeof b[Symbol.toPrimitive] == \"function\")\n              return r.from(b[Symbol.toPrimitive](\"string\"), O, D);\n          }\n          throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof b);\n        }\n        function o(b) {\n          if (typeof b != \"number\")\n            throw new TypeError('\"size\" argument must be of type number');\n          if (b < 0)\n            throw new RangeError('The value \"' + b + '\" is invalid for option \"size\"');\n        }\n        function i(b) {\n          return o(b), f(b < 0 ? 0 : 0 | n(b));\n        }\n        function l(b) {\n          for (var O = b.length < 0 ? 0 : 0 | n(b.length), D = f(O), B = 0; B < O; B += 1)\n            D[B] = 255 & b[B];\n          return D;\n        }\n        function n(b) {\n          if (g <= b)\n            throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + g.toString(16) + \" bytes\");\n          return 0 | b;\n        }\n        function a(b, O) {\n          if (r.isBuffer(b))\n            return b.length;\n          if (ArrayBuffer.isView(b) || W(b, ArrayBuffer))\n            return b.byteLength;\n          if (typeof b != \"string\")\n            throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof b);\n          var D = b.length, B = 2 < arguments.length && arguments[2] === !0;\n          if (!B && D === 0)\n            return 0;\n          for (var Y = !1; ; )\n            switch (O) {\n              case \"ascii\":\n              case \"latin1\":\n              case \"binary\":\n                return D;\n              case \"utf8\":\n              case \"utf-8\":\n                return V(b).length;\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return 2 * D;\n              case \"hex\":\n                return D >>> 1;\n              case \"base64\":\n                return G(b).length;\n              default:\n                if (Y)\n                  return B ? -1 : V(b).length;\n                O = (\"\" + O).toLowerCase(), Y = !0;\n            }\n        }\n        function c(b, O, D) {\n          var B, Y = !1;\n          if ((O = O === void 0 || O < 0 ? 0 : O) > this.length || (D = D === void 0 || D > this.length ? this.length : D) <= 0 || (D >>>= 0) <= (O >>>= 0))\n            return \"\";\n          for (b = b || \"utf8\"; ; )\n            switch (b) {\n              case \"hex\":\n                var J = this, fe = O, te = D, le = J.length;\n                (!te || te < 0 || le < te) && (te = le);\n                for (var ce = \"\", re = fe = !fe || fe < 0 ? 0 : fe; re < te; ++re)\n                  ce += ne[J[re]];\n                return ce;\n              case \"utf8\":\n              case \"utf-8\":\n                return E(this, O, D);\n              case \"ascii\":\n                var ue = this, le = O, K = D, ae = \"\";\n                K = Math.min(ue.length, K);\n                for (var he = le; he < K; ++he)\n                  ae += String.fromCharCode(127 & ue[he]);\n                return ae;\n              case \"latin1\":\n              case \"binary\":\n                var _e = this, fe = O, ge = D, xe = \"\";\n                ge = Math.min(_e.length, ge);\n                for (var De = fe; De < ge; ++De)\n                  xe += String.fromCharCode(_e[De]);\n                return xe;\n              case \"base64\":\n                return Me = this, B = D, (Qe = O) === 0 && B === Me.length ? y.fromByteArray(Me) : y.fromByteArray(Me.slice(Qe, B));\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                for (var Me = O, Qe = D, ze = this.slice(Me, Qe), Ve = \"\", Xe = 0; Xe < ze.length; Xe += 2)\n                  Ve += String.fromCharCode(ze[Xe] + 256 * ze[Xe + 1]);\n                return Ve;\n              default:\n                if (Y)\n                  throw new TypeError(\"Unknown encoding: \" + b);\n                b = (b + \"\").toLowerCase(), Y = !0;\n            }\n        }\n        function p(b, O, D) {\n          var B = b[O];\n          b[O] = b[D], b[D] = B;\n        }\n        function j(b, O, D, B, Y) {\n          if (b.length === 0)\n            return -1;\n          if (typeof D == \"string\" ? (B = D, D = 0) : 2147483647 < D ? D = 2147483647 : D < -2147483648 && (D = -2147483648), (D = (D = X(D = +D) ? Y ? 0 : b.length - 1 : D) < 0 ? b.length + D : D) >= b.length) {\n            if (Y)\n              return -1;\n            D = b.length - 1;\n          } else if (D < 0) {\n            if (!Y)\n              return -1;\n            D = 0;\n          }\n          if (typeof O == \"string\" && (O = r.from(O, B)), r.isBuffer(O))\n            return O.length === 0 ? -1 : T(b, O, D, B, Y);\n          if (typeof O == \"number\")\n            return O &= 255, typeof Uint8Array.prototype.indexOf == \"function\" ? (Y ? Uint8Array.prototype.indexOf : Uint8Array.prototype.lastIndexOf).call(b, O, D) : T(b, [O], D, B, Y);\n          throw new TypeError(\"val must be string, number or Buffer\");\n        }\n        function T(b, O, D, B, Y) {\n          var J = 1, te = b.length, ce = O.length;\n          if (B !== void 0 && ((B = String(B).toLowerCase()) === \"ucs2\" || B === \"ucs-2\" || B === \"utf16le\" || B === \"utf-16le\")) {\n            if (b.length < 2 || O.length < 2)\n              return -1;\n            te /= J = 2, ce /= 2, D /= 2;\n          }\n          function re(he, _e) {\n            return J === 1 ? he[_e] : he.readUInt16BE(_e * J);\n          }\n          if (Y)\n            for (var ue = -1, le = D; le < te; le++)\n              if (re(b, le) === re(O, ue === -1 ? 0 : le - ue)) {\n                if (le - (ue = ue === -1 ? le : ue) + 1 === ce)\n                  return ue * J;\n              } else\n                ue !== -1 && (le -= le - ue), ue = -1;\n          else\n            for (le = D = te < D + ce ? te - ce : D; 0 <= le; le--) {\n              for (var K = !0, ae = 0; ae < ce; ae++)\n                if (re(b, le + ae) !== re(O, ae)) {\n                  K = !1;\n                  break;\n                }\n              if (K)\n                return le;\n            }\n          return -1;\n        }\n        function _(b, O, D, B) {\n          return U(function(Y) {\n            for (var J = [], te = 0; te < Y.length; ++te)\n              J.push(255 & Y.charCodeAt(te));\n            return J;\n          }(O), b, D, B);\n        }\n        function S(b, O, D, B) {\n          return U(function(Y, J) {\n            for (var te, ce, re = [], ue = 0; ue < Y.length && !((J -= 2) < 0); ++ue)\n              ce = Y.charCodeAt(ue), te = ce >> 8, ce = ce % 256, re.push(ce), re.push(te);\n            return re;\n          }(O, b.length - D), b, D, B);\n        }\n        function E(b, O, D) {\n          D = Math.min(b.length, D);\n          for (var B = [], Y = O; Y < D; ) {\n            var J, te, ce, re, ue = b[Y], le = null, K = 239 < ue ? 4 : 223 < ue ? 3 : 191 < ue ? 2 : 1;\n            if (Y + K <= D)\n              switch (K) {\n                case 1:\n                  ue < 128 && (le = ue);\n                  break;\n                case 2:\n                  (192 & (J = b[Y + 1])) == 128 && 127 < (re = (31 & ue) << 6 | 63 & J) && (le = re);\n                  break;\n                case 3:\n                  J = b[Y + 1], te = b[Y + 2], (192 & J) == 128 && (192 & te) == 128 && 2047 < (re = (15 & ue) << 12 | (63 & J) << 6 | 63 & te) && (re < 55296 || 57343 < re) && (le = re);\n                  break;\n                case 4:\n                  J = b[Y + 1], te = b[Y + 2], ce = b[Y + 3], (192 & J) == 128 && (192 & te) == 128 && (192 & ce) == 128 && 65535 < (re = (15 & ue) << 18 | (63 & J) << 12 | (63 & te) << 6 | 63 & ce) && re < 1114112 && (le = re);\n              }\n            le === null ? (le = 65533, K = 1) : 65535 < le && (le -= 65536, B.push(le >>> 10 & 1023 | 55296), le = 56320 | 1023 & le), B.push(le), Y += K;\n          }\n          var ae = B, he = ae.length;\n          if (he <= A)\n            return String.fromCharCode.apply(String, ae);\n          for (var _e = \"\", fe = 0; fe < he; )\n            _e += String.fromCharCode.apply(String, ae.slice(fe, fe += A));\n          return _e;\n        }\n        C.kMaxLength = g, (r.TYPED_ARRAY_SUPPORT = function() {\n          try {\n            var b = new Uint8Array(1), O = { foo: function() {\n              return 42;\n            } };\n            return Object.setPrototypeOf(O, Uint8Array.prototype), Object.setPrototypeOf(b, O), b.foo() === 42;\n          } catch {\n            return !1;\n          }\n        }()) || typeof console > \"u\" || typeof console.error != \"function\" || console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"), Object.defineProperty(r.prototype, \"parent\", { enumerable: !0, get: function() {\n          if (r.isBuffer(this))\n            return this.buffer;\n        } }), Object.defineProperty(r.prototype, \"offset\", { enumerable: !0, get: function() {\n          if (r.isBuffer(this))\n            return this.byteOffset;\n        } }), typeof Symbol < \"u\" && Symbol.species != null && r[Symbol.species] === r && Object.defineProperty(r, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), r.poolSize = 8192, r.from = s, Object.setPrototypeOf(r.prototype, Uint8Array.prototype), Object.setPrototypeOf(r, Uint8Array), r.alloc = function(b, O, D) {\n          return O = O, D = D, o(b = b), !(b <= 0) && O !== void 0 ? typeof D == \"string\" ? f(b).fill(O, D) : f(b).fill(O) : f(b);\n        }, r.allocUnsafe = i, r.allocUnsafeSlow = i, r.isBuffer = function(b) {\n          return b != null && b._isBuffer === !0 && b !== r.prototype;\n        }, r.compare = function(b, O) {\n          if (W(b, Uint8Array) && (b = r.from(b, b.offset, b.byteLength)), W(O, Uint8Array) && (O = r.from(O, O.offset, O.byteLength)), !r.isBuffer(b) || !r.isBuffer(O))\n            throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n          if (b === O)\n            return 0;\n          for (var D = b.length, B = O.length, Y = 0, J = Math.min(D, B); Y < J; ++Y)\n            if (b[Y] !== O[Y]) {\n              D = b[Y], B = O[Y];\n              break;\n            }\n          return D < B ? -1 : B < D ? 1 : 0;\n        }, r.isEncoding = function(b) {\n          switch (String(b).toLowerCase()) {\n            case \"hex\":\n            case \"utf8\":\n            case \"utf-8\":\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n            case \"base64\":\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return !0;\n            default:\n              return !1;\n          }\n        }, r.concat = function(b, O) {\n          if (!Array.isArray(b))\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          if (b.length === 0)\n            return r.alloc(0);\n          if (O === void 0)\n            for (Y = O = 0; Y < b.length; ++Y)\n              O += b[Y].length;\n          for (var D = r.allocUnsafe(O), B = 0, Y = 0; Y < b.length; ++Y) {\n            var J = b[Y];\n            if (W(J, Uint8Array) && (J = r.from(J)), !r.isBuffer(J))\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            J.copy(D, B), B += J.length;\n          }\n          return D;\n        }, r.byteLength = a, r.prototype._isBuffer = !0, r.prototype.swap16 = function() {\n          var b = this.length;\n          if (b % 2 != 0)\n            throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n          for (var O = 0; O < b; O += 2)\n            p(this, O, O + 1);\n          return this;\n        }, r.prototype.swap32 = function() {\n          var b = this.length;\n          if (b % 4 != 0)\n            throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n          for (var O = 0; O < b; O += 4)\n            p(this, O, O + 3), p(this, O + 1, O + 2);\n          return this;\n        }, r.prototype.swap64 = function() {\n          var b = this.length;\n          if (b % 8 != 0)\n            throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n          for (var O = 0; O < b; O += 8)\n            p(this, O, O + 7), p(this, O + 1, O + 6), p(this, O + 2, O + 5), p(this, O + 3, O + 4);\n          return this;\n        }, r.prototype.toLocaleString = r.prototype.toString = function() {\n          var b = this.length;\n          return b === 0 ? \"\" : arguments.length === 0 ? E(this, 0, b) : c.apply(this, arguments);\n        }, r.prototype.equals = function(b) {\n          if (r.isBuffer(b))\n            return this === b || r.compare(this, b) === 0;\n          throw new TypeError(\"Argument must be a Buffer\");\n        }, r.prototype.inspect = function() {\n          var O = \"\", b = C.INSPECT_MAX_BYTES, O = this.toString(\"hex\", 0, b).replace(/(.{2})/g, \"$1 \").trim();\n          return this.length > b && (O += \" ... \"), \"<Buffer \" + O + \">\";\n        }, h && (r.prototype[h] = r.prototype.inspect), r.prototype.compare = function(b, O, D, B, Y) {\n          if (W(b, Uint8Array) && (b = r.from(b, b.offset, b.byteLength)), !r.isBuffer(b))\n            throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof b);\n          if (D === void 0 && (D = b ? b.length : 0), B === void 0 && (B = 0), Y === void 0 && (Y = this.length), (O = O === void 0 ? 0 : O) < 0 || D > b.length || B < 0 || Y > this.length)\n            throw new RangeError(\"out of range index\");\n          if (Y <= B && D <= O)\n            return 0;\n          if (Y <= B)\n            return -1;\n          if (D <= O)\n            return 1;\n          if (this === b)\n            return 0;\n          for (var J = (Y >>>= 0) - (B >>>= 0), te = (D >>>= 0) - (O >>>= 0), ce = Math.min(J, te), re = this.slice(B, Y), ue = b.slice(O, D), le = 0; le < ce; ++le)\n            if (re[le] !== ue[le]) {\n              J = re[le], te = ue[le];\n              break;\n            }\n          return J < te ? -1 : te < J ? 1 : 0;\n        }, r.prototype.includes = function(b, O, D) {\n          return this.indexOf(b, O, D) !== -1;\n        }, r.prototype.indexOf = function(b, O, D) {\n          return j(this, b, O, D, !0);\n        }, r.prototype.lastIndexOf = function(b, O, D) {\n          return j(this, b, O, D, !1);\n        }, r.prototype.write = function(b, O, D, B) {\n          if (O === void 0)\n            B = \"utf8\", D = this.length, O = 0;\n          else if (D === void 0 && typeof O == \"string\")\n            B = O, D = this.length, O = 0;\n          else {\n            if (!isFinite(O))\n              throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n            O >>>= 0, isFinite(D) ? (D >>>= 0, B === void 0 && (B = \"utf8\")) : (B = D, D = void 0);\n          }\n          var Y = this.length - O;\n          if ((D === void 0 || Y < D) && (D = Y), 0 < b.length && (D < 0 || O < 0) || O > this.length)\n            throw new RangeError(\"Attempt to write outside buffer bounds\");\n          B = B || \"utf8\";\n          for (var J, te, ce, re = !1; ; )\n            switch (B) {\n              case \"hex\":\n                var ue = this, le = b, K = O, ae = D, he = (K = Number(K) || 0, ue.length - K);\n                (!ae || he < (ae = Number(ae))) && (ae = he), (he = le.length) / 2 < ae && (ae = he / 2);\n                for (var _e = 0; _e < ae; ++_e) {\n                  var fe = parseInt(le.substr(2 * _e, 2), 16);\n                  if (X(fe))\n                    return _e;\n                  ue[K + _e] = fe;\n                }\n                return _e;\n              case \"utf8\":\n              case \"utf-8\":\n                return he = O, ce = D, U(V(b, (te = this).length - he), te, he, ce);\n              case \"ascii\":\n                return _(this, b, O, D);\n              case \"latin1\":\n              case \"binary\":\n                return _(this, b, O, D);\n              case \"base64\":\n                return te = this, ce = O, J = D, U(G(b), te, ce, J);\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return S(this, b, O, D);\n              default:\n                if (re)\n                  throw new TypeError(\"Unknown encoding: \" + B);\n                B = (\"\" + B).toLowerCase(), re = !0;\n            }\n        }, r.prototype.toJSON = function() {\n          return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) };\n        };\n        var A = 4096;\n        function x(b, O, D) {\n          if (b % 1 != 0 || b < 0)\n            throw new RangeError(\"offset is not uint\");\n          if (D < b + O)\n            throw new RangeError(\"Trying to access beyond buffer length\");\n        }\n        function P(b, O, D, B, Y, J) {\n          if (!r.isBuffer(b))\n            throw new TypeError('\"buffer\" argument must be a Buffer instance');\n          if (Y < O || O < J)\n            throw new RangeError('\"value\" argument is out of bounds');\n          if (D + B > b.length)\n            throw new RangeError(\"Index out of range\");\n        }\n        function M(b, O, D, B) {\n          if (D + B > b.length)\n            throw new RangeError(\"Index out of range\");\n          if (D < 0)\n            throw new RangeError(\"Index out of range\");\n        }\n        function R(b, O, D, B, Y) {\n          return O = +O, D >>>= 0, Y || M(b, 0, D, 4), u.write(b, O, D, B, 23, 4), D + 4;\n        }\n        function L(b, O, D, B, Y) {\n          return O = +O, D >>>= 0, Y || M(b, 0, D, 8), u.write(b, O, D, B, 52, 8), D + 8;\n        }\n        r.prototype.slice = function(b, O) {\n          var D = this.length, D = ((b = ~~b) < 0 ? (b += D) < 0 && (b = 0) : D < b && (b = D), (O = O === void 0 ? D : ~~O) < 0 ? (O += D) < 0 && (O = 0) : D < O && (O = D), O < b && (O = b), this.subarray(b, O));\n          return Object.setPrototypeOf(D, r.prototype), D;\n        }, r.prototype.readUIntLE = function(b, O, D) {\n          b >>>= 0, O >>>= 0, D || x(b, O, this.length);\n          for (var B = this[b], Y = 1, J = 0; ++J < O && (Y *= 256); )\n            B += this[b + J] * Y;\n          return B;\n        }, r.prototype.readUIntBE = function(b, O, D) {\n          b >>>= 0, O >>>= 0, D || x(b, O, this.length);\n          for (var B = this[b + --O], Y = 1; 0 < O && (Y *= 256); )\n            B += this[b + --O] * Y;\n          return B;\n        }, r.prototype.readUInt8 = function(b, O) {\n          return b >>>= 0, O || x(b, 1, this.length), this[b];\n        }, r.prototype.readUInt16LE = function(b, O) {\n          return b >>>= 0, O || x(b, 2, this.length), this[b] | this[b + 1] << 8;\n        }, r.prototype.readUInt16BE = function(b, O) {\n          return b >>>= 0, O || x(b, 2, this.length), this[b] << 8 | this[b + 1];\n        }, r.prototype.readUInt32LE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), (this[b] | this[b + 1] << 8 | this[b + 2] << 16) + 16777216 * this[b + 3];\n        }, r.prototype.readUInt32BE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), 16777216 * this[b] + (this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3]);\n        }, r.prototype.readIntLE = function(b, O, D) {\n          b >>>= 0, O >>>= 0, D || x(b, O, this.length);\n          for (var B = this[b], Y = 1, J = 0; ++J < O && (Y *= 256); )\n            B += this[b + J] * Y;\n          return (Y *= 128) <= B && (B -= Math.pow(2, 8 * O)), B;\n        }, r.prototype.readIntBE = function(b, O, D) {\n          b >>>= 0, O >>>= 0, D || x(b, O, this.length);\n          for (var B = O, Y = 1, J = this[b + --B]; 0 < B && (Y *= 256); )\n            J += this[b + --B] * Y;\n          return (Y *= 128) <= J && (J -= Math.pow(2, 8 * O)), J;\n        }, r.prototype.readInt8 = function(b, O) {\n          return b >>>= 0, O || x(b, 1, this.length), 128 & this[b] ? -1 * (255 - this[b] + 1) : this[b];\n        }, r.prototype.readInt16LE = function(b, O) {\n          return b >>>= 0, O || x(b, 2, this.length), O = this[b] | this[b + 1] << 8, 32768 & O ? 4294901760 | O : O;\n        }, r.prototype.readInt16BE = function(b, O) {\n          return b >>>= 0, O || x(b, 2, this.length), O = this[b + 1] | this[b] << 8, 32768 & O ? 4294901760 | O : O;\n        }, r.prototype.readInt32LE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), this[b] | this[b + 1] << 8 | this[b + 2] << 16 | this[b + 3] << 24;\n        }, r.prototype.readInt32BE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), this[b] << 24 | this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3];\n        }, r.prototype.readFloatLE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), u.read(this, b, !0, 23, 4);\n        }, r.prototype.readFloatBE = function(b, O) {\n          return b >>>= 0, O || x(b, 4, this.length), u.read(this, b, !1, 23, 4);\n        }, r.prototype.readDoubleLE = function(b, O) {\n          return b >>>= 0, O || x(b, 8, this.length), u.read(this, b, !0, 52, 8);\n        }, r.prototype.readDoubleBE = function(b, O) {\n          return b >>>= 0, O || x(b, 8, this.length), u.read(this, b, !1, 52, 8);\n        }, r.prototype.writeUIntLE = function(b, O, D, B) {\n          b = +b, O >>>= 0, D >>>= 0, B || P(this, b, O, D, Math.pow(2, 8 * D) - 1, 0);\n          var Y = 1, J = 0;\n          for (this[O] = 255 & b; ++J < D && (Y *= 256); )\n            this[O + J] = b / Y & 255;\n          return O + D;\n        }, r.prototype.writeUIntBE = function(b, O, D, B) {\n          b = +b, O >>>= 0, D >>>= 0, B || P(this, b, O, D, Math.pow(2, 8 * D) - 1, 0);\n          var Y = D - 1, J = 1;\n          for (this[O + Y] = 255 & b; 0 <= --Y && (J *= 256); )\n            this[O + Y] = b / J & 255;\n          return O + D;\n        }, r.prototype.writeUInt8 = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 1, 255, 0), this[O] = 255 & b, O + 1;\n        }, r.prototype.writeUInt16LE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 2, 65535, 0), this[O] = 255 & b, this[O + 1] = b >>> 8, O + 2;\n        }, r.prototype.writeUInt16BE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 2, 65535, 0), this[O] = b >>> 8, this[O + 1] = 255 & b, O + 2;\n        }, r.prototype.writeUInt32LE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 4, 4294967295, 0), this[O + 3] = b >>> 24, this[O + 2] = b >>> 16, this[O + 1] = b >>> 8, this[O] = 255 & b, O + 4;\n        }, r.prototype.writeUInt32BE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 4, 4294967295, 0), this[O] = b >>> 24, this[O + 1] = b >>> 16, this[O + 2] = b >>> 8, this[O + 3] = 255 & b, O + 4;\n        }, r.prototype.writeIntLE = function(b, O, D, B) {\n          b = +b, O >>>= 0, B || P(this, b, O, D, (B = Math.pow(2, 8 * D - 1)) - 1, -B);\n          var Y = 0, J = 1, te = 0;\n          for (this[O] = 255 & b; ++Y < D && (J *= 256); )\n            b < 0 && te === 0 && this[O + Y - 1] !== 0 && (te = 1), this[O + Y] = (b / J >> 0) - te & 255;\n          return O + D;\n        }, r.prototype.writeIntBE = function(b, O, D, B) {\n          b = +b, O >>>= 0, B || P(this, b, O, D, (B = Math.pow(2, 8 * D - 1)) - 1, -B);\n          var Y = D - 1, J = 1, te = 0;\n          for (this[O + Y] = 255 & b; 0 <= --Y && (J *= 256); )\n            b < 0 && te === 0 && this[O + Y + 1] !== 0 && (te = 1), this[O + Y] = (b / J >> 0) - te & 255;\n          return O + D;\n        }, r.prototype.writeInt8 = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 1, 127, -128), this[O] = 255 & (b = b < 0 ? 255 + b + 1 : b), O + 1;\n        }, r.prototype.writeInt16LE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 2, 32767, -32768), this[O] = 255 & b, this[O + 1] = b >>> 8, O + 2;\n        }, r.prototype.writeInt16BE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 2, 32767, -32768), this[O] = b >>> 8, this[O + 1] = 255 & b, O + 2;\n        }, r.prototype.writeInt32LE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 4, 2147483647, -2147483648), this[O] = 255 & b, this[O + 1] = b >>> 8, this[O + 2] = b >>> 16, this[O + 3] = b >>> 24, O + 4;\n        }, r.prototype.writeInt32BE = function(b, O, D) {\n          return b = +b, O >>>= 0, D || P(this, b, O, 4, 2147483647, -2147483648), this[O] = (b = b < 0 ? 4294967295 + b + 1 : b) >>> 24, this[O + 1] = b >>> 16, this[O + 2] = b >>> 8, this[O + 3] = 255 & b, O + 4;\n        }, r.prototype.writeFloatLE = function(b, O, D) {\n          return R(this, b, O, !0, D);\n        }, r.prototype.writeFloatBE = function(b, O, D) {\n          return R(this, b, O, !1, D);\n        }, r.prototype.writeDoubleLE = function(b, O, D) {\n          return L(this, b, O, !0, D);\n        }, r.prototype.writeDoubleBE = function(b, O, D) {\n          return L(this, b, O, !1, D);\n        }, r.prototype.copy = function(b, O, D, B) {\n          if (!r.isBuffer(b))\n            throw new TypeError(\"argument should be a Buffer\");\n          if (D = D || 0, B || B === 0 || (B = this.length), O >= b.length && (O = b.length), (B = 0 < B && B < D ? D : B) === D || b.length === 0 || this.length === 0)\n            return 0;\n          if ((O = O || 0) < 0)\n            throw new RangeError(\"targetStart out of bounds\");\n          if (D < 0 || D >= this.length)\n            throw new RangeError(\"Index out of range\");\n          if (B < 0)\n            throw new RangeError(\"sourceEnd out of bounds\");\n          B > this.length && (B = this.length);\n          var Y = (B = b.length - O < B - D ? b.length - O + D : B) - D;\n          if (this === b && typeof Uint8Array.prototype.copyWithin == \"function\")\n            this.copyWithin(O, D, B);\n          else if (this === b && D < O && O < B)\n            for (var J = Y - 1; 0 <= J; --J)\n              b[J + O] = this[J + D];\n          else\n            Uint8Array.prototype.set.call(b, this.subarray(D, B), O);\n          return Y;\n        }, r.prototype.fill = function(b, O, D, B) {\n          if (typeof b == \"string\") {\n            if (typeof O == \"string\" ? (B = O, O = 0, D = this.length) : typeof D == \"string\" && (B = D, D = this.length), B !== void 0 && typeof B != \"string\")\n              throw new TypeError(\"encoding must be a string\");\n            if (typeof B == \"string\" && !r.isEncoding(B))\n              throw new TypeError(\"Unknown encoding: \" + B);\n            var Y;\n            b.length === 1 && (Y = b.charCodeAt(0), (B === \"utf8\" && Y < 128 || B === \"latin1\") && (b = Y));\n          } else\n            typeof b == \"number\" ? b &= 255 : typeof b == \"boolean\" && (b = Number(b));\n          if (O < 0 || this.length < O || this.length < D)\n            throw new RangeError(\"Out of range index\");\n          var J;\n          if (!(D <= O))\n            if (O >>>= 0, D = D === void 0 ? this.length : D >>> 0, typeof (b = b || 0) == \"number\")\n              for (J = O; J < D; ++J)\n                this[J] = b;\n            else {\n              var te = r.isBuffer(b) ? b : r.from(b, B), ce = te.length;\n              if (ce === 0)\n                throw new TypeError('The value \"' + b + '\" is invalid for argument \"value\"');\n              for (J = 0; J < D - O; ++J)\n                this[J + O] = te[J % ce];\n            }\n          return this;\n        };\n        var F = /[^+/0-9A-Za-z-_]/g;\n        function V(b, O) {\n          O = O || 1 / 0;\n          for (var D, B = b.length, Y = null, J = [], te = 0; te < B; ++te) {\n            if (55295 < (D = b.charCodeAt(te)) && D < 57344) {\n              if (!Y) {\n                if (56319 < D) {\n                  -1 < (O -= 3) && J.push(239, 191, 189);\n                  continue;\n                }\n                if (te + 1 === B) {\n                  -1 < (O -= 3) && J.push(239, 191, 189);\n                  continue;\n                }\n                Y = D;\n                continue;\n              }\n              if (D < 56320) {\n                -1 < (O -= 3) && J.push(239, 191, 189), Y = D;\n                continue;\n              }\n              D = 65536 + (Y - 55296 << 10 | D - 56320);\n            } else\n              Y && -1 < (O -= 3) && J.push(239, 191, 189);\n            if (Y = null, D < 128) {\n              if (--O < 0)\n                break;\n              J.push(D);\n            } else if (D < 2048) {\n              if ((O -= 2) < 0)\n                break;\n              J.push(D >> 6 | 192, 63 & D | 128);\n            } else if (D < 65536) {\n              if ((O -= 3) < 0)\n                break;\n              J.push(D >> 12 | 224, D >> 6 & 63 | 128, 63 & D | 128);\n            } else {\n              if (!(D < 1114112))\n                throw new Error(\"Invalid code point\");\n              if ((O -= 4) < 0)\n                break;\n              J.push(D >> 18 | 240, D >> 12 & 63 | 128, D >> 6 & 63 | 128, 63 & D | 128);\n            }\n          }\n          return J;\n        }\n        function G(b) {\n          return y.toByteArray(function(O) {\n            if ((O = (O = O.split(\"=\")[0]).trim().replace(F, \"\")).length < 2)\n              return \"\";\n            for (; O.length % 4 != 0; )\n              O += \"=\";\n            return O;\n          }(b));\n        }\n        function U(b, O, D, B) {\n          for (var Y = 0; Y < B && !(Y + D >= O.length || Y >= b.length); ++Y)\n            O[Y + D] = b[Y];\n          return Y;\n        }\n        function W(b, O) {\n          return b instanceof O || b != null && b.constructor != null && b.constructor.name != null && b.constructor.name === O.name;\n        }\n        function X(b) {\n          return b != b;\n        }\n        var ne = function() {\n          for (var b = \"0123456789abcdef\", O = new Array(256), D = 0; D < 16; ++D)\n            for (var B = 16 * D, Y = 0; Y < 16; ++Y)\n              O[B + Y] = b[D] + b[Y];\n          return O;\n        }();\n      }).call(this, t(\"buffer\").Buffer);\n    }, { \"base64-js\": 1, buffer: 4, ieee754: 251 }], 5: [function(t, H, C) {\n      H.exports = function(m) {\n        if (typeof m != \"function\")\n          throw TypeError(String(m) + \" is not a function\");\n        return m;\n      };\n    }, {}], 6: [function(t, H, C) {\n      var m = t(\"../internals/is-object\");\n      H.exports = function(y) {\n        if (m(y) || y === null)\n          return y;\n        throw TypeError(\"Can't set \" + String(y) + \" as a prototype\");\n      };\n    }, { \"../internals/is-object\": 75 }], 7: [function(u, H, C) {\n      var m = u(\"../internals/well-known-symbol\"), y = u(\"../internals/object-create\"), u = u(\"../internals/object-define-property\"), h = m(\"unscopables\"), g = Array.prototype;\n      g[h] == null && u.f(g, h, { configurable: !0, value: y(null) }), H.exports = function(f) {\n        g[h][f] = !0;\n      };\n    }, { \"../internals/object-create\": 91, \"../internals/object-define-property\": 93, \"../internals/well-known-symbol\": 149 }], 8: [function(t, H, C) {\n      var m = t(\"../internals/string-multibyte\").charAt;\n      H.exports = function(y, u, h) {\n        return u + (h ? m(y, u).length : 1);\n      };\n    }, { \"../internals/string-multibyte\": 124 }], 9: [function(t, H, C) {\n      H.exports = function(m, y, u) {\n        if (m instanceof y)\n          return m;\n        throw TypeError(\"Incorrect \" + (u ? u + \" \" : \"\") + \"invocation\");\n      };\n    }, {}], 10: [function(t, H, C) {\n      var m = t(\"../internals/is-object\");\n      H.exports = function(y) {\n        if (m(y))\n          return y;\n        throw TypeError(String(y) + \" is not an object\");\n      };\n    }, { \"../internals/is-object\": 75 }], 11: [function(t, H, C) {\n      H.exports = typeof ArrayBuffer < \"u\" && typeof DataView < \"u\";\n    }, {}], 12: [function(M, H, C) {\n      function m(L) {\n        return f(L) && r(R, s(L));\n      }\n      var y, u = M(\"../internals/array-buffer-native\"), h = M(\"../internals/descriptors\"), g = M(\"../internals/global\"), f = M(\"../internals/is-object\"), r = M(\"../internals/has\"), s = M(\"../internals/classof\"), o = M(\"../internals/create-non-enumerable-property\"), i = M(\"../internals/redefine\"), l = M(\"../internals/object-define-property\").f, n = M(\"../internals/object-get-prototype-of\"), a = M(\"../internals/object-set-prototype-of\"), A = M(\"../internals/well-known-symbol\"), M = M(\"../internals/uid\"), c = g.Int8Array, p = c && c.prototype, j = g.Uint8ClampedArray, j = j && j.prototype, T = c && n(c), _ = p && n(p), S = Object.prototype, E = S.isPrototypeOf, A = A(\"toStringTag\"), x = M(\"TYPED_ARRAY_TAG\"), P = u && !!a && s(g.opera) !== \"Opera\", M = !1, R = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 };\n      for (y in R)\n        g[y] || (P = !1);\n      if ((!P || typeof T != \"function\" || T === Function.prototype) && (T = function() {\n        throw TypeError(\"Incorrect invocation\");\n      }, P))\n        for (y in R)\n          g[y] && a(g[y], T);\n      if ((!P || !_ || _ === S) && (_ = T.prototype, P))\n        for (y in R)\n          g[y] && a(g[y].prototype, _);\n      if (P && n(j) !== _ && a(j, _), h && !r(_, A))\n        for (y in M = !0, l(_, A, { get: function() {\n          return f(this) ? this[x] : void 0;\n        } }), R)\n          g[y] && o(g[y], x, y);\n      H.exports = { NATIVE_ARRAY_BUFFER_VIEWS: P, TYPED_ARRAY_TAG: M && x, aTypedArray: function(L) {\n        if (m(L))\n          return L;\n        throw TypeError(\"Target is not a typed array\");\n      }, aTypedArrayConstructor: function(L) {\n        if (a) {\n          if (E.call(T, L))\n            return L;\n        } else\n          for (var F in R)\n            if (r(R, y) && (F = g[F], F && (L === F || E.call(F, L))))\n              return L;\n        throw TypeError(\"Target is not a typed array constructor\");\n      }, exportTypedArrayMethod: function(L, F, V) {\n        if (h) {\n          if (V)\n            for (var G in R)\n              G = g[G], G && r(G.prototype, L) && delete G.prototype[L];\n          _[L] && !V || i(_, L, !V && P && p[L] || F);\n        }\n      }, exportTypedArrayStaticMethod: function(L, F, V) {\n        var G, U;\n        if (h) {\n          if (a) {\n            if (V)\n              for (G in R)\n                (U = g[G]) && r(U, L) && delete U[L];\n            if (T[L] && !V)\n              return;\n            try {\n              return i(T, L, !V && P && c[L] || F);\n            } catch {\n            }\n          }\n          for (G in R)\n            !(U = g[G]) || U[L] && !V || i(U, L, F);\n        }\n      }, isView: function(L) {\n        return L = s(L), L === \"DataView\" || r(R, L);\n      }, isTypedArray: m, TypedArray: T, TypedArrayPrototype: _ };\n    }, { \"../internals/array-buffer-native\": 11, \"../internals/classof\": 29, \"../internals/create-non-enumerable-property\": 38, \"../internals/descriptors\": 43, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/is-object\": 75, \"../internals/object-define-property\": 93, \"../internals/object-get-prototype-of\": 98, \"../internals/object-set-prototype-of\": 102, \"../internals/redefine\": 109, \"../internals/uid\": 146, \"../internals/well-known-symbol\": 149 }], 13: [function(D, H, C) {\n      function m(K) {\n        return [255 & K];\n      }\n      function y(K) {\n        return [255 & K, K >> 8 & 255];\n      }\n      function u(K) {\n        return [255 & K, K >> 8 & 255, K >> 16 & 255, K >> 24 & 255];\n      }\n      function h(K) {\n        return K[3] << 24 | K[2] << 16 | K[1] << 8 | K[0];\n      }\n      function g(K) {\n        return J(K, 23, 4);\n      }\n      function f(K) {\n        return J(K, 52, 8);\n      }\n      function r(K, ae) {\n        M(K[W], ae, { get: function() {\n          return F(this)[ae];\n        } });\n      }\n      function s(xe, ae, ge, _e) {\n        if (ge = S(ge), xe = F(xe), ge + ae > xe.byteLength)\n          throw Y(X);\n        var fe = F(xe.buffer).bytes, ge = ge + xe.byteOffset, xe = fe.slice(ge, ge + ae);\n        return _e ? xe : xe.reverse();\n      }\n      function o(K, ae, he, _e, fe, ge) {\n        if (he = S(he), K = F(K), he + ae > K.byteLength)\n          throw Y(X);\n        for (var xe = F(K.buffer).bytes, De = he + K.byteOffset, Me = _e(+fe), Qe = 0; Qe < ae; Qe++)\n          xe[De + Qe] = Me[ge ? Qe : ae - Qe - 1];\n      }\n      var i = D(\"../internals/global\"), l = D(\"../internals/descriptors\"), n = D(\"../internals/array-buffer-native\"), a = D(\"../internals/create-non-enumerable-property\"), c = D(\"../internals/redefine-all\"), p = D(\"../internals/fails\"), j = D(\"../internals/an-instance\"), T = D(\"../internals/to-integer\"), _ = D(\"../internals/to-length\"), S = D(\"../internals/to-index\"), E = D(\"../internals/ieee754\"), A = D(\"../internals/object-get-prototype-of\"), x = D(\"../internals/object-set-prototype-of\"), P = D(\"../internals/object-get-own-property-names\").f, M = D(\"../internals/object-define-property\").f, R = D(\"../internals/array-fill\"), L = D(\"../internals/set-to-string-tag\"), D = D(\"../internals/internal-state\"), F = D.get, V = D.set, G = \"ArrayBuffer\", U = \"DataView\", W = \"prototype\", X = \"Wrong index\", ne = i[G], b = ne, O = i[U], D = O && O[W], B = Object.prototype, Y = i.RangeError, J = E.pack, te = E.unpack;\n      if (n) {\n        if (!p(function() {\n          ne(1);\n        }) || !p(function() {\n          new ne(-1);\n        }) || p(function() {\n          return new ne(), new ne(1.5), new ne(NaN), ne.name != G;\n        })) {\n          for (var ce, i = (b = function(he) {\n            return j(this, b), new ne(S(he));\n          })[W] = ne[W], re = P(ne), ue = 0; re.length > ue; )\n            (ce = re[ue++]) in b || a(b, ce, ne[ce]);\n          i.constructor = b;\n        }\n        x && A(D) !== B && x(D, B);\n        var E = new O(new b(2)), le = D.setInt8;\n        E.setInt8(0, 2147483648), E.setInt8(1, 2147483649), !E.getInt8(0) && E.getInt8(1) || c(D, { setInt8: function(ae, he) {\n          le.call(this, ae, he << 24 >> 24);\n        }, setUint8: function(ae, he) {\n          le.call(this, ae, he << 24 >> 24);\n        } }, { unsafe: !0 });\n      } else\n        b = function(K) {\n          j(this, b, G), K = S(K), V(this, { bytes: R.call(new Array(K), 0), byteLength: K }), l || (this.byteLength = K);\n        }, O = function(K, fe, he) {\n          j(this, O, U), j(K, b, U);\n          var _e = F(K).byteLength, fe = T(fe);\n          if (fe < 0 || _e < fe)\n            throw Y(\"Wrong offset\");\n          if (_e < fe + (he = he === void 0 ? _e - fe : _(he)))\n            throw Y(\"Wrong length\");\n          V(this, { buffer: K, byteLength: he, byteOffset: fe }), l || (this.buffer = K, this.byteLength = he, this.byteOffset = fe);\n        }, l && (r(b, \"byteLength\"), r(O, \"buffer\"), r(O, \"byteLength\"), r(O, \"byteOffset\")), c(O[W], { getInt8: function(K) {\n          return s(this, 1, K)[0] << 24 >> 24;\n        }, getUint8: function(K) {\n          return s(this, 1, K)[0];\n        }, getInt16: function(K) {\n          return K = s(this, 2, K, 1 < arguments.length ? arguments[1] : void 0), (K[1] << 8 | K[0]) << 16 >> 16;\n        }, getUint16: function(K) {\n          return K = s(this, 2, K, 1 < arguments.length ? arguments[1] : void 0), K[1] << 8 | K[0];\n        }, getInt32: function(K) {\n          return h(s(this, 4, K, 1 < arguments.length ? arguments[1] : void 0));\n        }, getUint32: function(K) {\n          return h(s(this, 4, K, 1 < arguments.length ? arguments[1] : void 0)) >>> 0;\n        }, getFloat32: function(K) {\n          return te(s(this, 4, K, 1 < arguments.length ? arguments[1] : void 0), 23);\n        }, getFloat64: function(K) {\n          return te(s(this, 8, K, 1 < arguments.length ? arguments[1] : void 0), 52);\n        }, setInt8: function(K, ae) {\n          o(this, 1, K, m, ae);\n        }, setUint8: function(K, ae) {\n          o(this, 1, K, m, ae);\n        }, setInt16: function(K, ae) {\n          o(this, 2, K, y, ae, 2 < arguments.length ? arguments[2] : void 0);\n        }, setUint16: function(K, ae) {\n          o(this, 2, K, y, ae, 2 < arguments.length ? arguments[2] : void 0);\n        }, setInt32: function(K, ae) {\n          o(this, 4, K, u, ae, 2 < arguments.length ? arguments[2] : void 0);\n        }, setUint32: function(K, ae) {\n          o(this, 4, K, u, ae, 2 < arguments.length ? arguments[2] : void 0);\n        }, setFloat32: function(K, ae) {\n          o(this, 4, K, g, ae, 2 < arguments.length ? arguments[2] : void 0);\n        }, setFloat64: function(K, ae) {\n          o(this, 8, K, f, ae, 2 < arguments.length ? arguments[2] : void 0);\n        } });\n      L(b, G), L(O, U), H.exports = { ArrayBuffer: b, DataView: O };\n    }, { \"../internals/an-instance\": 9, \"../internals/array-buffer-native\": 11, \"../internals/array-fill\": 15, \"../internals/create-non-enumerable-property\": 38, \"../internals/descriptors\": 43, \"../internals/fails\": 51, \"../internals/global\": 60, \"../internals/ieee754\": 66, \"../internals/internal-state\": 71, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-names\": 96, \"../internals/object-get-prototype-of\": 98, \"../internals/object-set-prototype-of\": 102, \"../internals/redefine-all\": 108, \"../internals/set-to-string-tag\": 118, \"../internals/to-index\": 134, \"../internals/to-integer\": 136, \"../internals/to-length\": 137 }], 14: [function(t, H, C) {\n      var m = t(\"../internals/to-object\"), y = t(\"../internals/to-absolute-index\"), u = t(\"../internals/to-length\"), h = Math.min;\n      H.exports = [].copyWithin || function(l, f) {\n        var r = m(this), s = u(r.length), o = y(l, s), i = y(f, s), l = 2 < arguments.length ? arguments[2] : void 0, n = h((l === void 0 ? s : y(l, s)) - i, s - o), a = 1;\n        for (i < o && o < i + n && (a = -1, i += n - 1, o += n - 1); 0 < n--; )\n          i in r ? r[o] = r[i] : delete r[o], o += a, i += a;\n        return r;\n      };\n    }, { \"../internals/to-absolute-index\": 133, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 15: [function(t, H, C) {\n      var m = t(\"../internals/to-object\"), y = t(\"../internals/to-absolute-index\"), u = t(\"../internals/to-length\");\n      H.exports = function(h) {\n        for (var g = m(this), f = u(g.length), s = arguments.length, r = y(1 < s ? arguments[1] : void 0, f), s = 2 < s ? arguments[2] : void 0, o = s === void 0 ? f : y(s, f); r < o; )\n          g[r++] = h;\n        return g;\n      };\n    }, { \"../internals/to-absolute-index\": 133, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 16: [function(u, H, C) {\n      var m = u(\"../internals/array-iteration\").forEach, y = u(\"../internals/array-method-is-strict\"), u = u(\"../internals/array-method-uses-to-length\"), y = y(\"forEach\"), u = u(\"forEach\");\n      H.exports = y && u ? [].forEach : function(h) {\n        return m(this, h, 1 < arguments.length ? arguments[1] : void 0);\n      };\n    }, { \"../internals/array-iteration\": 19, \"../internals/array-method-is-strict\": 22, \"../internals/array-method-uses-to-length\": 23 }], 17: [function(t, H, C) {\n      var m = t(\"../internals/function-bind-context\"), y = t(\"../internals/to-object\"), u = t(\"../internals/call-with-safe-iteration-closing\"), h = t(\"../internals/is-array-iterator-method\"), g = t(\"../internals/to-length\"), f = t(\"../internals/create-property\"), r = t(\"../internals/get-iterator-method\");\n      H.exports = function(j) {\n        var o, i, l, n, a, c, p = y(j), j = typeof this == \"function\" ? this : Array, T = arguments.length, _ = 1 < T ? arguments[1] : void 0, S = _ !== void 0, E = r(p), A = 0;\n        if (S && (_ = m(_, 2 < T ? arguments[2] : void 0, 2)), E == null || j == Array && h(E))\n          for (i = new j(o = g(p.length)); A < o; A++)\n            c = S ? _(p[A], A) : p[A], f(i, A, c);\n        else\n          for (a = (n = E.call(p)).next, i = new j(); !(l = a.call(n)).done; A++)\n            c = S ? u(n, _, [l.value, A], !0) : l.value, f(i, A, c);\n        return i.length = A, i;\n      };\n    }, { \"../internals/call-with-safe-iteration-closing\": 26, \"../internals/create-property\": 40, \"../internals/function-bind-context\": 55, \"../internals/get-iterator-method\": 58, \"../internals/is-array-iterator-method\": 72, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 18: [function(t, H, C) {\n      function m(g) {\n        return function(f, r, s) {\n          var o, i = y(f), l = u(i.length), n = h(s, l);\n          if (g && r != r) {\n            for (; n < l; )\n              if ((o = i[n++]) != o)\n                return !0;\n          } else\n            for (; n < l; n++)\n              if ((g || n in i) && i[n] === r)\n                return g || n || 0;\n          return !g && -1;\n        };\n      }\n      var y = t(\"../internals/to-indexed-object\"), u = t(\"../internals/to-length\"), h = t(\"../internals/to-absolute-index\");\n      H.exports = { includes: m(!0), indexOf: m(!1) };\n    }, { \"../internals/to-absolute-index\": 133, \"../internals/to-indexed-object\": 135, \"../internals/to-length\": 137 }], 19: [function(t, H, C) {\n      function m(s) {\n        var o = s == 1, i = s == 2, l = s == 3, n = s == 4, a = s == 6, c = s == 5 || a;\n        return function(p, j, T, _) {\n          for (var S, E, A = h(p), x = u(A), P = y(j, T, 3), M = g(x.length), R = 0, j = _ || f, L = o ? j(p, M) : i ? j(p, 0) : void 0; R < M; R++)\n            if ((c || R in x) && (E = P(S = x[R], R, A), s)) {\n              if (o)\n                L[R] = E;\n              else if (E)\n                switch (s) {\n                  case 3:\n                    return !0;\n                  case 5:\n                    return S;\n                  case 6:\n                    return R;\n                  case 2:\n                    r.call(L, S);\n                }\n              else if (n)\n                return !1;\n            }\n          return a ? -1 : l || n ? n : L;\n        };\n      }\n      var y = t(\"../internals/function-bind-context\"), u = t(\"../internals/indexed-object\"), h = t(\"../internals/to-object\"), g = t(\"../internals/to-length\"), f = t(\"../internals/array-species-create\"), r = [].push;\n      H.exports = { forEach: m(0), map: m(1), filter: m(2), some: m(3), every: m(4), find: m(5), findIndex: m(6) };\n    }, { \"../internals/array-species-create\": 25, \"../internals/function-bind-context\": 55, \"../internals/indexed-object\": 67, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 20: [function(s, H, C) {\n      var m = s(\"../internals/to-indexed-object\"), y = s(\"../internals/to-integer\"), u = s(\"../internals/to-length\"), r = s(\"../internals/array-method-is-strict\"), s = s(\"../internals/array-method-uses-to-length\"), h = Math.min, g = [].lastIndexOf, f = !!g && 1 / [1].lastIndexOf(1, -0) < 0, r = r(\"lastIndexOf\"), s = s(\"indexOf\", { ACCESSORS: !0, 1: 0 });\n      H.exports = f || !r || !s ? function(o) {\n        if (f)\n          return g.apply(this, arguments) || 0;\n        var i = m(this), l = u(i.length), n = l - 1;\n        for ((n = 1 < arguments.length ? h(n, y(arguments[1])) : n) < 0 && (n = l + n); 0 <= n; n--)\n          if (n in i && i[n] === o)\n            return n || 0;\n        return -1;\n      } : g;\n    }, { \"../internals/array-method-is-strict\": 22, \"../internals/array-method-uses-to-length\": 23, \"../internals/to-indexed-object\": 135, \"../internals/to-integer\": 136, \"../internals/to-length\": 137 }], 21: [function(t, H, C) {\n      var m = t(\"../internals/fails\"), y = t(\"../internals/well-known-symbol\"), u = t(\"../internals/engine-v8-version\"), h = y(\"species\");\n      H.exports = function(g) {\n        return 51 <= u || !m(function() {\n          var f = [];\n          return (f.constructor = {})[h] = function() {\n            return { foo: 1 };\n          }, f[g](Boolean).foo !== 1;\n        });\n      };\n    }, { \"../internals/engine-v8-version\": 48, \"../internals/fails\": 51, \"../internals/well-known-symbol\": 149 }], 22: [function(t, H, C) {\n      var m = t(\"../internals/fails\");\n      H.exports = function(y, u) {\n        var h = [][y];\n        return !!h && m(function() {\n          h.call(null, u || function() {\n            throw 1;\n          }, 1);\n        });\n      };\n    }, { \"../internals/fails\": 51 }], 23: [function(t, H, C) {\n      function m(r) {\n        throw r;\n      }\n      var y = t(\"../internals/descriptors\"), u = t(\"../internals/fails\"), h = t(\"../internals/has\"), g = Object.defineProperty, f = {};\n      H.exports = function(r, s) {\n        var o, i, l, n;\n        return h(f, r) ? f[r] : (o = [][r], i = !!h(s = s || {}, \"ACCESSORS\") && s.ACCESSORS, l = h(s, 0) ? s[0] : m, n = h(s, 1) ? s[1] : void 0, f[r] = !!o && !u(function() {\n          if (i && !y)\n            return !0;\n          var a = { length: -1 };\n          i ? g(a, 1, { enumerable: !0, get: m }) : a[1] = 1, o.call(a, l, n);\n        }));\n      };\n    }, { \"../internals/descriptors\": 43, \"../internals/fails\": 51, \"../internals/has\": 61 }], 24: [function(t, H, C) {\n      function m(f) {\n        return function(r, s, o, i) {\n          y(s);\n          var l = u(r), n = h(l), a = g(l.length), c = f ? a - 1 : 0, p = f ? -1 : 1;\n          if (o < 2)\n            for (; ; ) {\n              if (c in n) {\n                i = n[c], c += p;\n                break;\n              }\n              if (c += p, f ? c < 0 : a <= c)\n                throw TypeError(\"Reduce of empty array with no initial value\");\n            }\n          for (; f ? 0 <= c : c < a; c += p)\n            c in n && (i = s(i, n[c], c, l));\n          return i;\n        };\n      }\n      var y = t(\"../internals/a-function\"), u = t(\"../internals/to-object\"), h = t(\"../internals/indexed-object\"), g = t(\"../internals/to-length\");\n      H.exports = { left: m(!1), right: m(!0) };\n    }, { \"../internals/a-function\": 5, \"../internals/indexed-object\": 67, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 25: [function(t, H, C) {\n      var m = t(\"../internals/is-object\"), y = t(\"../internals/is-array\"), u = t(\"../internals/well-known-symbol\")(\"species\");\n      H.exports = function(h, g) {\n        var f;\n        return new ((f = y(h) && (typeof (f = h.constructor) == \"function\" && (f === Array || y(f.prototype)) || m(f) && (f = f[u]) === null) ? void 0 : f) === void 0 ? Array : f)(g === 0 ? 0 : g);\n      };\n    }, { \"../internals/is-array\": 73, \"../internals/is-object\": 75, \"../internals/well-known-symbol\": 149 }], 26: [function(t, H, C) {\n      var m = t(\"../internals/an-object\");\n      H.exports = function(y, u, h, g) {\n        try {\n          return g ? u(m(h)[0], h[1]) : u(h);\n        } catch (f) {\n          throw g = y.return, g !== void 0 && m(g.call(y)), f;\n        }\n      };\n    }, { \"../internals/an-object\": 10 }], 27: [function(t, H, C) {\n      var m = t(\"../internals/well-known-symbol\")(\"iterator\"), y = !1;\n      try {\n        var u = 0, h = { next: function() {\n          return { done: !!u++ };\n        }, return: function() {\n          y = !0;\n        } };\n        h[m] = function() {\n          return this;\n        }, Array.from(h, function() {\n          throw 2;\n        });\n      } catch {\n      }\n      H.exports = function(g, f) {\n        if (!f && !y)\n          return !1;\n        var r = !1;\n        try {\n          var s = {};\n          s[m] = function() {\n            return { next: function() {\n              return { done: r = !0 };\n            } };\n          }, g(s);\n        } catch {\n        }\n        return r;\n      };\n    }, { \"../internals/well-known-symbol\": 149 }], 28: [function(t, H, C) {\n      var m = {}.toString;\n      H.exports = function(y) {\n        return m.call(y).slice(8, -1);\n      };\n    }, {}], 29: [function(t, H, C) {\n      var m = t(\"../internals/to-string-tag-support\"), y = t(\"../internals/classof-raw\"), u = t(\"../internals/well-known-symbol\")(\"toStringTag\"), h = y(/* @__PURE__ */ function() {\n        return arguments;\n      }()) == \"Arguments\";\n      H.exports = m ? y : function(g) {\n        var f;\n        return g === void 0 ? \"Undefined\" : g === null ? \"Null\" : typeof (f = function(r, s) {\n          try {\n            return r[s];\n          } catch {\n          }\n        }(g = Object(g), u)) == \"string\" ? f : h ? y(g) : (f = y(g)) == \"Object\" && typeof g.callee == \"function\" ? \"Arguments\" : f;\n      };\n    }, { \"../internals/classof-raw\": 28, \"../internals/to-string-tag-support\": 142, \"../internals/well-known-symbol\": 149 }], 30: [function(l, H, C) {\n      var m = l(\"../internals/object-define-property\").f, y = l(\"../internals/object-create\"), u = l(\"../internals/redefine-all\"), h = l(\"../internals/function-bind-context\"), g = l(\"../internals/an-instance\"), f = l(\"../internals/iterate\"), r = l(\"../internals/define-iterator\"), s = l(\"../internals/set-species\"), o = l(\"../internals/descriptors\"), i = l(\"../internals/internal-metadata\").fastKey, l = l(\"../internals/internal-state\"), n = l.set, a = l.getterFor;\n      H.exports = { getConstructor: function(c, p, j, T) {\n        function _(x, P, M) {\n          var R, L = A(x), F = S(x, P);\n          return F ? F.value = M : (L.last = F = { index: R = i(P, !0), key: P, value: M, previous: P = L.last, next: void 0, removed: !1 }, L.first || (L.first = F), P && (P.next = F), o ? L.size++ : x.size++, R !== \"F\" && (L.index[R] = F)), x;\n        }\n        function S(R, P) {\n          var M, R = A(R), L = i(P);\n          if (L !== \"F\")\n            return R.index[L];\n          for (M = R.first; M; M = M.next)\n            if (M.key == P)\n              return M;\n        }\n        var E = c(function(x, P) {\n          g(x, E, p), n(x, { type: p, index: y(null), first: void 0, last: void 0, size: 0 }), o || (x.size = 0), P != null && f(P, x[T], x, j);\n        }), A = a(p);\n        return u(E.prototype, { clear: function() {\n          for (var x = A(this), P = x.index, M = x.first; M; )\n            M.removed = !0, M.previous && (M.previous = M.previous.next = void 0), delete P[M.index], M = M.next;\n          x.first = x.last = void 0, o ? x.size = 0 : this.size = 0;\n        }, delete: function(L) {\n          var P, M, R = A(this), L = S(this, L);\n          return L && (P = L.next, M = L.previous, delete R.index[L.index], L.removed = !0, M && (M.next = P), P && (P.previous = M), R.first == L && (R.first = P), R.last == L && (R.last = M), o ? R.size-- : this.size--), !!L;\n        }, forEach: function(x) {\n          for (var P, M = A(this), R = h(x, 1 < arguments.length ? arguments[1] : void 0, 3); P = P ? P.next : M.first; )\n            for (R(P.value, P.key, this); P && P.removed; )\n              P = P.previous;\n        }, has: function(x) {\n          return !!S(this, x);\n        } }), u(E.prototype, j ? { get: function(x) {\n          return x = S(this, x), x && x.value;\n        }, set: function(x, P) {\n          return _(this, x === 0 ? 0 : x, P);\n        } } : { add: function(x) {\n          return _(this, x = x === 0 ? 0 : x, x);\n        } }), o && m(E.prototype, \"size\", { get: function() {\n          return A(this).size;\n        } }), E;\n      }, setStrong: function(c, p, j) {\n        var T = p + \" Iterator\", _ = a(p), S = a(T);\n        r(c, p, function(E, A) {\n          n(this, { type: T, target: E, state: _(E), kind: A, last: void 0 });\n        }, function() {\n          for (var E = S(this), A = E.kind, x = E.last; x && x.removed; )\n            x = x.previous;\n          return E.target && (E.last = x = x ? x.next : E.state.first) ? A == \"keys\" ? { value: x.key, done: !1 } : A == \"values\" ? { value: x.value, done: !1 } : { value: [x.key, x.value], done: !1 } : { value: E.target = void 0, done: !0 };\n        }, j ? \"entries\" : \"values\", !j, !0), s(p);\n      } };\n    }, { \"../internals/an-instance\": 9, \"../internals/define-iterator\": 41, \"../internals/descriptors\": 43, \"../internals/function-bind-context\": 55, \"../internals/internal-metadata\": 70, \"../internals/internal-state\": 71, \"../internals/iterate\": 78, \"../internals/object-create\": 91, \"../internals/object-define-property\": 93, \"../internals/redefine-all\": 108, \"../internals/set-species\": 117 }], 31: [function(n, H, C) {\n      function m(_) {\n        return _.frozen || (_.frozen = new y());\n      }\n      function y() {\n        this.entries = [];\n      }\n      function u(_, S) {\n        return p(_.entries, function(E) {\n          return E[0] === S;\n        });\n      }\n      var h = n(\"../internals/redefine-all\"), g = n(\"../internals/internal-metadata\").getWeakData, f = n(\"../internals/an-object\"), r = n(\"../internals/is-object\"), s = n(\"../internals/an-instance\"), o = n(\"../internals/iterate\"), i = n(\"../internals/array-iteration\"), l = n(\"../internals/has\"), n = n(\"../internals/internal-state\"), a = n.set, c = n.getterFor, p = i.find, j = i.findIndex, T = 0;\n      y.prototype = { get: function(_) {\n        if (_ = u(this, _), _)\n          return _[1];\n      }, has: function(_) {\n        return !!u(this, _);\n      }, set: function(_, S) {\n        var E = u(this, _);\n        E ? E[1] = S : this.entries.push([_, S]);\n      }, delete: function(_) {\n        var S = j(this.entries, function(E) {\n          return E[0] === _;\n        });\n        return ~S && this.entries.splice(S, 1), !!~S;\n      } }, H.exports = { getConstructor: function(_, S, E, A) {\n        function x(R, L, F) {\n          var V = M(R), G = g(f(L), !0);\n          return G === !0 ? m(V).set(L, F) : G[V.id] = F, R;\n        }\n        var P = _(function(R, L) {\n          s(R, P, S), a(R, { type: S, id: T++, frozen: void 0 }), L != null && o(L, R[A], R, E);\n        }), M = c(S);\n        return h(P.prototype, { delete: function(R) {\n          var L, F = M(this);\n          return !!r(R) && ((L = g(R)) === !0 ? m(F).delete(R) : L && l(L, F.id) && delete L[F.id]);\n        }, has: function(R) {\n          var L, F = M(this);\n          return !!r(R) && ((L = g(R)) === !0 ? m(F).has(R) : L && l(L, F.id));\n        } }), h(P.prototype, E ? { get: function(R) {\n          var L, F = M(this);\n          if (r(R))\n            return (L = g(R)) === !0 ? m(F).get(R) : L ? L[F.id] : void 0;\n        }, set: function(R, L) {\n          return x(this, R, L);\n        } } : { add: function(R) {\n          return x(this, R, !0);\n        } }), P;\n      } };\n    }, { \"../internals/an-instance\": 9, \"../internals/an-object\": 10, \"../internals/array-iteration\": 19, \"../internals/has\": 61, \"../internals/internal-metadata\": 70, \"../internals/internal-state\": 71, \"../internals/is-object\": 75, \"../internals/iterate\": 78, \"../internals/redefine-all\": 108 }], 32: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/global\"), u = t(\"../internals/is-forced\"), h = t(\"../internals/redefine\"), g = t(\"../internals/internal-metadata\"), f = t(\"../internals/iterate\"), r = t(\"../internals/an-instance\"), s = t(\"../internals/is-object\"), o = t(\"../internals/fails\"), i = t(\"../internals/check-correctness-of-iteration\"), l = t(\"../internals/set-to-string-tag\"), n = t(\"../internals/inherit-if-required\");\n      H.exports = function(a, c, p) {\n        function j(G) {\n          var U = L[G];\n          h(L, G, G == \"add\" ? function(W) {\n            return U.call(this, W === 0 ? 0 : W), this;\n          } : G == \"delete\" ? function(W) {\n            return !(P && !s(W)) && U.call(this, W === 0 ? 0 : W);\n          } : G == \"get\" ? function(W) {\n            return P && !s(W) ? void 0 : U.call(this, W === 0 ? 0 : W);\n          } : G == \"has\" ? function(W) {\n            return !(P && !s(W)) && U.call(this, W === 0 ? 0 : W);\n          } : function(W, X) {\n            return U.call(this, W === 0 ? 0 : W, X), this;\n          });\n        }\n        var T, _, S, E, A, x = a.indexOf(\"Map\") !== -1, P = a.indexOf(\"Weak\") !== -1, M = x ? \"set\" : \"add\", R = y[a], L = R && R.prototype, F = R, V = {};\n        return u(a, typeof R != \"function\" || !(P || L.forEach && !o(function() {\n          new R().entries().next();\n        }))) ? (F = p.getConstructor(c, a, x, M), g.REQUIRED = !0) : u(a, !0) && (_ = (T = new F())[M](P ? {} : -0, 1) != T, S = o(function() {\n          T.has(1);\n        }), E = i(function(G) {\n          new R(G);\n        }), A = !P && o(function() {\n          for (var G = new R(), U = 5; U--; )\n            G[M](U, U);\n          return !G.has(-0);\n        }), E || (((F = c(function(G, U) {\n          return r(G, F, a), G = n(new R(), G, F), U != null && f(U, G[M], G, x), G;\n        })).prototype = L).constructor = F), (S || A) && (j(\"delete\"), j(\"has\"), x && j(\"get\")), (A || _) && j(M), P && L.clear && delete L.clear), V[a] = F, m({ global: !0, forced: F != R }, V), l(F, a), P || p.setStrong(F, a, x), F;\n      };\n    }, { \"../internals/an-instance\": 9, \"../internals/check-correctness-of-iteration\": 27, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/global\": 60, \"../internals/inherit-if-required\": 68, \"../internals/internal-metadata\": 70, \"../internals/is-forced\": 74, \"../internals/is-object\": 75, \"../internals/iterate\": 78, \"../internals/redefine\": 109, \"../internals/set-to-string-tag\": 118 }], 33: [function(t, H, C) {\n      var m = t(\"../internals/has\"), y = t(\"../internals/own-keys\"), u = t(\"../internals/object-get-own-property-descriptor\"), h = t(\"../internals/object-define-property\");\n      H.exports = function(g, f) {\n        for (var r = y(f), s = h.f, o = u.f, i = 0; i < r.length; i++) {\n          var l = r[i];\n          m(g, l) || s(g, l, o(f, l));\n        }\n      };\n    }, { \"../internals/has\": 61, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/own-keys\": 104 }], 34: [function(t, H, C) {\n      var m = t(\"../internals/well-known-symbol\")(\"match\");\n      H.exports = function(y) {\n        var u = /./;\n        try {\n          \"/./\"[y](u);\n        } catch {\n          try {\n            return u[m] = !1, \"/./\"[y](u);\n          } catch {\n          }\n        }\n        return !1;\n      };\n    }, { \"../internals/well-known-symbol\": 149 }], 35: [function(t, H, C) {\n      t = t(\"../internals/fails\"), H.exports = !t(function() {\n        function m() {\n        }\n        return m.prototype.constructor = null, Object.getPrototypeOf(new m()) !== m.prototype;\n      });\n    }, { \"../internals/fails\": 51 }], 36: [function(t, H, C) {\n      var m = t(\"../internals/require-object-coercible\"), y = /\"/g;\n      H.exports = function(r, h, g, f) {\n        var r = String(m(r)), s = \"<\" + h;\n        return g !== \"\" && (s += \" \" + g + '=\"' + String(f).replace(y, \"&quot;\") + '\"'), s + \">\" + r + \"</\" + h + \">\";\n      };\n    }, { \"../internals/require-object-coercible\": 114 }], 37: [function(t, H, C) {\n      function m() {\n        return this;\n      }\n      var y = t(\"../internals/iterators-core\").IteratorPrototype, u = t(\"../internals/object-create\"), h = t(\"../internals/create-property-descriptor\"), g = t(\"../internals/set-to-string-tag\"), f = t(\"../internals/iterators\");\n      H.exports = function(r, s, o) {\n        return s += \" Iterator\", r.prototype = u(y, { next: h(1, o) }), g(r, s, !1, !0), f[s] = m, r;\n      };\n    }, { \"../internals/create-property-descriptor\": 39, \"../internals/iterators\": 80, \"../internals/iterators-core\": 79, \"../internals/object-create\": 91, \"../internals/set-to-string-tag\": 118 }], 38: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/object-define-property\"), u = t(\"../internals/create-property-descriptor\");\n      H.exports = m ? function(h, g, f) {\n        return y.f(h, g, u(1, f));\n      } : function(h, g, f) {\n        return h[g] = f, h;\n      };\n    }, { \"../internals/create-property-descriptor\": 39, \"../internals/descriptors\": 43, \"../internals/object-define-property\": 93 }], 39: [function(t, H, C) {\n      H.exports = function(m, y) {\n        return { enumerable: !(1 & m), configurable: !(2 & m), writable: !(4 & m), value: y };\n      };\n    }, {}], 40: [function(t, H, C) {\n      var m = t(\"../internals/to-primitive\"), y = t(\"../internals/object-define-property\"), u = t(\"../internals/create-property-descriptor\");\n      H.exports = function(h, g, f) {\n        g = m(g), g in h ? y.f(h, g, u(0, f)) : h[g] = f;\n      };\n    }, { \"../internals/create-property-descriptor\": 39, \"../internals/object-define-property\": 93, \"../internals/to-primitive\": 141 }], 41: [function(n, H, C) {\n      function m() {\n        return this;\n      }\n      var y = n(\"../internals/export\"), u = n(\"../internals/create-iterator-constructor\"), h = n(\"../internals/object-get-prototype-of\"), g = n(\"../internals/object-set-prototype-of\"), f = n(\"../internals/set-to-string-tag\"), r = n(\"../internals/create-non-enumerable-property\"), s = n(\"../internals/redefine\"), o = n(\"../internals/well-known-symbol\"), i = n(\"../internals/is-pure\"), l = n(\"../internals/iterators\"), n = n(\"../internals/iterators-core\"), a = n.IteratorPrototype, c = n.BUGGY_SAFARI_ITERATORS, p = o(\"iterator\"), j = \"values\", T = \"entries\";\n      H.exports = function(_, S, E, V, x, P, M) {\n        u(E, S, V);\n        function R(b) {\n          if (b === x && X)\n            return X;\n          if (!c && b in U)\n            return U[b];\n          switch (b) {\n            case \"keys\":\n            case j:\n            case T:\n              return function() {\n                return new E(this, b);\n              };\n          }\n          return function() {\n            return new E(this);\n          };\n        }\n        var L, F, V = S + \" Iterator\", G = !1, U = _.prototype, W = U[p] || U[\"@@iterator\"] || x && U[x], X = !c && W || R(x), ne = S == \"Array\" && U.entries || W;\n        if (ne && (ne = h(ne.call(new _())), a !== Object.prototype && ne.next && (i || h(ne) === a || (g ? g(ne, a) : typeof ne[p] != \"function\" && r(ne, p, m)), f(ne, V, !0, !0), i && (l[V] = m))), x == j && W && W.name !== j && (G = !0, X = function() {\n          return W.call(this);\n        }), i && !M || U[p] === X || r(U, p, X), l[S] = X, x)\n          if (L = { values: R(j), keys: P ? X : R(\"keys\"), entries: R(T) }, M)\n            for (F in L)\n              !c && !G && F in U || s(U, F, L[F]);\n          else\n            y({ target: S, proto: !0, forced: c || G }, L);\n        return L;\n      };\n    }, { \"../internals/create-iterator-constructor\": 37, \"../internals/create-non-enumerable-property\": 38, \"../internals/export\": 50, \"../internals/is-pure\": 76, \"../internals/iterators\": 80, \"../internals/iterators-core\": 79, \"../internals/object-get-prototype-of\": 98, \"../internals/object-set-prototype-of\": 102, \"../internals/redefine\": 109, \"../internals/set-to-string-tag\": 118, \"../internals/well-known-symbol\": 149 }], 42: [function(t, H, C) {\n      var m = t(\"../internals/path\"), y = t(\"../internals/has\"), u = t(\"../internals/well-known-symbol-wrapped\"), h = t(\"../internals/object-define-property\").f;\n      H.exports = function(g) {\n        var f = m.Symbol || (m.Symbol = {});\n        y(f, g) || h(f, g, { value: u.f(g) });\n      };\n    }, { \"../internals/has\": 61, \"../internals/object-define-property\": 93, \"../internals/path\": 105, \"../internals/well-known-symbol-wrapped\": 148 }], 43: [function(t, H, C) {\n      t = t(\"../internals/fails\"), H.exports = !t(function() {\n        return Object.defineProperty({}, 1, { get: function() {\n          return 7;\n        } })[1] != 7;\n      });\n    }, { \"../internals/fails\": 51 }], 44: [function(y, H, C) {\n      var m = y(\"../internals/global\"), y = y(\"../internals/is-object\"), u = m.document, h = y(u) && y(u.createElement);\n      H.exports = function(g) {\n        return h ? u.createElement(g) : {};\n      };\n    }, { \"../internals/global\": 60, \"../internals/is-object\": 75 }], 45: [function(t, H, C) {\n      H.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };\n    }, {}], 46: [function(t, H, C) {\n      t = t(\"../internals/engine-user-agent\"), H.exports = /(iphone|ipod|ipad).*applewebkit/i.test(t);\n    }, { \"../internals/engine-user-agent\": 47 }], 47: [function(t, H, C) {\n      t = t(\"../internals/get-built-in\"), H.exports = t(\"navigator\", \"userAgent\") || \"\";\n    }, { \"../internals/get-built-in\": 57 }], 48: [function(u, H, C) {\n      var m, y, h = u(\"../internals/global\"), u = u(\"../internals/engine-user-agent\"), h = h.process, h = h && h.versions, h = h && h.v8;\n      h ? y = (m = h.split(\".\"))[0] + m[1] : u && (!(m = u.match(/Edge\\/(\\d+)/)) || 74 <= m[1]) && (m = u.match(/Chrome\\/(\\d+)/)) && (y = m[1]), H.exports = y && +y;\n    }, { \"../internals/engine-user-agent\": 47, \"../internals/global\": 60 }], 49: [function(t, H, C) {\n      H.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n    }, {}], 50: [function(t, H, C) {\n      var m = t(\"../internals/global\"), y = t(\"../internals/object-get-own-property-descriptor\").f, u = t(\"../internals/create-non-enumerable-property\"), h = t(\"../internals/redefine\"), g = t(\"../internals/set-global\"), f = t(\"../internals/copy-constructor-properties\"), r = t(\"../internals/is-forced\");\n      H.exports = function(s, o) {\n        var i, l, n, a = s.target, c = s.global, p = s.stat, j = c ? m : p ? m[a] || g(a, {}) : (m[a] || {}).prototype;\n        if (j)\n          for (i in o) {\n            if (l = o[i], n = s.noTargetGet ? (n = y(j, i)) && n.value : j[i], !r(c ? i : a + (p ? \".\" : \"#\") + i, s.forced) && n !== void 0) {\n              if (typeof l == typeof n)\n                continue;\n              f(l, n);\n            }\n            (s.sham || n && n.sham) && u(l, \"sham\", !0), h(j, i, l, s);\n          }\n      };\n    }, { \"../internals/copy-constructor-properties\": 33, \"../internals/create-non-enumerable-property\": 38, \"../internals/global\": 60, \"../internals/is-forced\": 74, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/redefine\": 109, \"../internals/set-global\": 116 }], 51: [function(t, H, C) {\n      H.exports = function(m) {\n        try {\n          return !!m();\n        } catch {\n          return !0;\n        }\n      };\n    }, {}], 52: [function(o, H, C) {\n      o(\"../modules/es.regexp.exec\");\n      var m = o(\"../internals/redefine\"), y = o(\"../internals/fails\"), u = o(\"../internals/well-known-symbol\"), h = o(\"../internals/regexp-exec\"), g = o(\"../internals/create-non-enumerable-property\"), f = u(\"species\"), r = !y(function() {\n        var n = /./;\n        return n.exec = function() {\n          var a = [];\n          return a.groups = { a: \"7\" }, a;\n        }, \"\".replace(n, \"$<a>\") !== \"7\";\n      }), s = \"a\".replace(/./, \"$0\") === \"$0\", o = u(\"replace\"), i = !!/./[o] && /./[o](\"a\", \"$0\") === \"\", l = !y(function() {\n        var a = /(?:)/, n = a.exec, a = (a.exec = function() {\n          return n.apply(this, arguments);\n        }, \"ab\".split(a));\n        return a.length !== 2 || a[0] !== \"a\" || a[1] !== \"b\";\n      });\n      H.exports = function(n, a, c, p) {\n        var j, T, _ = u(n), S = !y(function() {\n          var A = {};\n          return A[_] = function() {\n            return 7;\n          }, \"\"[n](A) != 7;\n        }), E = S && !y(function() {\n          var A = !1, x = /a/;\n          return n === \"split\" && ((x = { constructor: {} }).constructor[f] = function() {\n            return x;\n          }, x.flags = \"\", x[_] = /./[_]), x.exec = function() {\n            return A = !0, null;\n          }, x[_](\"\"), !A;\n        });\n        S && E && (n !== \"replace\" || r && s && !i) && (n !== \"split\" || l) || (j = /./[_], c = (E = c(_, \"\"[n], function(A, x, P, M, R) {\n          return x.exec === h ? S && !R ? { done: !0, value: j.call(x, P, M) } : { done: !0, value: A.call(P, x, M) } : { done: !1 };\n        }, { REPLACE_KEEPS_$0: s, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: i }))[0], T = E[1], m(String.prototype, n, c), m(RegExp.prototype, _, a == 2 ? function(A, x) {\n          return T.call(A, this, x);\n        } : function(A) {\n          return T.call(A, this);\n        })), p && g(RegExp.prototype[_], \"sham\", !0);\n      };\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/fails\": 51, \"../internals/redefine\": 109, \"../internals/regexp-exec\": 111, \"../internals/well-known-symbol\": 149, \"../modules/es.regexp.exec\": 192 }], 53: [function(t, H, C) {\n      function m(g, f, r, s, o, i, l, n) {\n        for (var a, c = o, p = 0, j = !!l && h(l, n, 3); p < s; ) {\n          if (p in r) {\n            if (a = j ? j(r[p], p, f) : r[p], 0 < i && y(a))\n              c = m(g, f, a, u(a.length), c, i - 1) - 1;\n            else {\n              if (9007199254740991 <= c)\n                throw TypeError(\"Exceed the acceptable array length\");\n              g[c] = a;\n            }\n            c++;\n          }\n          p++;\n        }\n        return c;\n      }\n      var y = t(\"../internals/is-array\"), u = t(\"../internals/to-length\"), h = t(\"../internals/function-bind-context\");\n      H.exports = m;\n    }, { \"../internals/function-bind-context\": 55, \"../internals/is-array\": 73, \"../internals/to-length\": 137 }], 54: [function(t, H, C) {\n      t = t(\"../internals/fails\"), H.exports = !t(function() {\n        return Object.isExtensible(Object.preventExtensions({}));\n      });\n    }, { \"../internals/fails\": 51 }], 55: [function(t, H, C) {\n      var m = t(\"../internals/a-function\");\n      H.exports = function(y, u, h) {\n        if (m(y), u === void 0)\n          return y;\n        switch (h) {\n          case 0:\n            return function() {\n              return y.call(u);\n            };\n          case 1:\n            return function(g) {\n              return y.call(u, g);\n            };\n          case 2:\n            return function(g, f) {\n              return y.call(u, g, f);\n            };\n          case 3:\n            return function(g, f, r) {\n              return y.call(u, g, f, r);\n            };\n        }\n        return function() {\n          return y.apply(u, arguments);\n        };\n      };\n    }, { \"../internals/a-function\": 5 }], 56: [function(t, H, C) {\n      var m = t(\"../internals/a-function\"), y = t(\"../internals/is-object\"), u = [].slice, h = {};\n      H.exports = Function.bind || function(g) {\n        var f = m(this), r = u.call(arguments, 1), s = function() {\n          var o = r.concat(u.call(arguments));\n          if (this instanceof s) {\n            var i = f, l = o.length, n = o;\n            if (!(l in h)) {\n              for (var a = [], c = 0; c < l; c++)\n                a[c] = \"a[\" + c + \"]\";\n              h[l] = Function(\"C,a\", \"return new C(\" + a.join(\",\") + \")\");\n            }\n            return h[l](i, n);\n          }\n          return f.apply(g, o);\n        };\n        return y(f.prototype) && (s.prototype = f.prototype), s;\n      };\n    }, { \"../internals/a-function\": 5, \"../internals/is-object\": 75 }], 57: [function(t, H, C) {\n      function m(h) {\n        return typeof h == \"function\" ? h : void 0;\n      }\n      var y = t(\"../internals/path\"), u = t(\"../internals/global\");\n      H.exports = function(h, g) {\n        return arguments.length < 2 ? m(y[h]) || m(u[h]) : y[h] && y[h][g] || u[h] && u[h][g];\n      };\n    }, { \"../internals/global\": 60, \"../internals/path\": 105 }], 58: [function(t, H, C) {\n      var m = t(\"../internals/classof\"), y = t(\"../internals/iterators\"), u = t(\"../internals/well-known-symbol\")(\"iterator\");\n      H.exports = function(h) {\n        if (h != null)\n          return h[u] || h[\"@@iterator\"] || y[m(h)];\n      };\n    }, { \"../internals/classof\": 29, \"../internals/iterators\": 80, \"../internals/well-known-symbol\": 149 }], 59: [function(t, H, C) {\n      var m = t(\"../internals/an-object\"), y = t(\"../internals/get-iterator-method\");\n      H.exports = function(u) {\n        var h = y(u);\n        if (typeof h != \"function\")\n          throw TypeError(String(u) + \" is not iterable\");\n        return m(h.call(u));\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/get-iterator-method\": 58 }], 60: [function(t, H, C) {\n      (function(m) {\n        function y(u) {\n          return u && u.Math == Math && u;\n        }\n        H.exports = y(typeof globalThis == \"object\" && globalThis) || y(typeof window == \"object\" && window) || y(typeof self == \"object\" && self) || y(typeof m == \"object\" && m) || Function(\"return this\")();\n      }).call(this, typeof _r < \"u\" ? _r : typeof self < \"u\" ? self : typeof window < \"u\" ? window : {});\n    }, {}], 61: [function(t, H, C) {\n      var m = {}.hasOwnProperty;\n      H.exports = function(y, u) {\n        return m.call(y, u);\n      };\n    }, {}], 62: [function(t, H, C) {\n      H.exports = {};\n    }, {}], 63: [function(t, H, C) {\n      var m = t(\"../internals/global\");\n      H.exports = function(y, u) {\n        var h = m.console;\n        h && h.error && (arguments.length === 1 ? h.error(y) : h.error(y, u));\n      };\n    }, { \"../internals/global\": 60 }], 64: [function(t, H, C) {\n      t = t(\"../internals/get-built-in\"), H.exports = t(\"document\", \"documentElement\");\n    }, { \"../internals/get-built-in\": 57 }], 65: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/fails\"), u = t(\"../internals/document-create-element\");\n      H.exports = !m && !y(function() {\n        return Object.defineProperty(u(\"div\"), \"a\", { get: function() {\n          return 7;\n        } }).a != 7;\n      });\n    }, { \"../internals/descriptors\": 43, \"../internals/document-create-element\": 44, \"../internals/fails\": 51 }], 66: [function(t, H, C) {\n      var m = Math.abs, y = Math.pow, u = Math.floor, h = Math.log, g = Math.LN2;\n      H.exports = { pack: function(f, r, c) {\n        var o, i, l, n = new Array(c), a = 8 * c - r - 1, c = (1 << a) - 1, p = c >> 1, j = r === 23 ? y(2, -24) - y(2, -77) : 0, T = f < 0 || f === 0 && 1 / f < 0 ? 1 : 0, _ = 0;\n        for ((f = m(f)) != f || f === 1 / 0 ? (i = f != f ? 1 : 0, o = c) : (o = u(h(f) / g), f * (l = y(2, -o)) < 1 && (o--, l *= 2), 2 <= (f += 1 <= o + p ? j / l : j * y(2, 1 - p)) * l && (o++, l /= 2), c <= o + p ? (i = 0, o = c) : 1 <= o + p ? (i = (f * l - 1) * y(2, r), o += p) : (i = f * y(2, p - 1) * y(2, r), o = 0)); 8 <= r; n[_++] = 255 & i, i /= 256, r -= 8)\n          ;\n        for (o = o << r | i, a += r; 0 < a; n[_++] = 255 & o, o /= 256, a -= 8)\n          ;\n        return n[--_] |= 128 * T, n;\n      }, unpack: function(f, r) {\n        var s, o = f.length, c = 8 * o - r - 1, i = (1 << c) - 1, l = i >> 1, n = c - 7, a = o - 1, c = f[a--], p = 127 & c;\n        for (c >>= 7; 0 < n; p = 256 * p + f[a], a--, n -= 8)\n          ;\n        for (s = p & (1 << -n) - 1, p >>= -n, n += r; 0 < n; s = 256 * s + f[a], a--, n -= 8)\n          ;\n        if (p === 0)\n          p = 1 - l;\n        else {\n          if (p === i)\n            return s ? NaN : c ? -1 / 0 : 1 / 0;\n          s += y(2, r), p -= l;\n        }\n        return (c ? -1 : 1) * s * y(2, p - r);\n      } };\n    }, {}], 67: [function(t, H, C) {\n      var m = t(\"../internals/fails\"), y = t(\"../internals/classof-raw\"), u = \"\".split;\n      H.exports = m(function() {\n        return !Object(\"z\").propertyIsEnumerable(0);\n      }) ? function(h) {\n        return y(h) == \"String\" ? u.call(h, \"\") : Object(h);\n      } : Object;\n    }, { \"../internals/classof-raw\": 28, \"../internals/fails\": 51 }], 68: [function(t, H, C) {\n      var m = t(\"../internals/is-object\"), y = t(\"../internals/object-set-prototype-of\");\n      H.exports = function(u, h, g) {\n        return y && typeof (h = h.constructor) == \"function\" && h !== g && m(h = h.prototype) && h !== g.prototype && y(u, h), u;\n      };\n    }, { \"../internals/is-object\": 75, \"../internals/object-set-prototype-of\": 102 }], 69: [function(m, H, C) {\n      var m = m(\"../internals/shared-store\"), y = Function.toString;\n      typeof m.inspectSource != \"function\" && (m.inspectSource = function(u) {\n        return y.call(u);\n      }), H.exports = m.inspectSource;\n    }, { \"../internals/shared-store\": 120 }], 70: [function(t, H, C) {\n      function m(n) {\n        g(n, s, { value: { objectID: \"O\" + ++o, weakData: {} } });\n      }\n      var y = t(\"../internals/hidden-keys\"), u = t(\"../internals/is-object\"), h = t(\"../internals/has\"), g = t(\"../internals/object-define-property\").f, f = t(\"../internals/uid\"), r = t(\"../internals/freezing\"), s = f(\"meta\"), o = 0, i = Object.isExtensible || function() {\n        return !0;\n      }, l = H.exports = { REQUIRED: !1, fastKey: function(n, a) {\n        if (!u(n))\n          return typeof n == \"symbol\" ? n : (typeof n == \"string\" ? \"S\" : \"P\") + n;\n        if (!h(n, s)) {\n          if (!i(n))\n            return \"F\";\n          if (!a)\n            return \"E\";\n          m(n);\n        }\n        return n[s].objectID;\n      }, getWeakData: function(n, a) {\n        if (!h(n, s)) {\n          if (!i(n))\n            return !0;\n          if (!a)\n            return !1;\n          m(n);\n        }\n        return n[s].weakData;\n      }, onFreeze: function(n) {\n        return r && l.REQUIRED && i(n) && !h(n, s) && m(n), n;\n      } };\n      y[s] = !0;\n    }, { \"../internals/freezing\": 54, \"../internals/has\": 61, \"../internals/hidden-keys\": 62, \"../internals/is-object\": 75, \"../internals/object-define-property\": 93, \"../internals/uid\": 146 }], 71: [function(c, H, C) {\n      var m, y, u, h, g, f, r, s, o = c(\"../internals/native-weak-map\"), p = c(\"../internals/global\"), i = c(\"../internals/is-object\"), l = c(\"../internals/create-non-enumerable-property\"), n = c(\"../internals/has\"), a = c(\"../internals/shared-key\"), c = c(\"../internals/hidden-keys\"), p = p.WeakMap;\n      r = o ? (m = new p(), y = m.get, u = m.has, h = m.set, g = function(j, T) {\n        return h.call(m, j, T), T;\n      }, f = function(j) {\n        return y.call(m, j) || {};\n      }, function(j) {\n        return u.call(m, j);\n      }) : (c[s = a(\"state\")] = !0, g = function(j, T) {\n        return l(j, s, T), T;\n      }, f = function(j) {\n        return n(j, s) ? j[s] : {};\n      }, function(j) {\n        return n(j, s);\n      }), H.exports = { set: g, get: f, has: r, enforce: function(j) {\n        return r(j) ? f(j) : g(j, {});\n      }, getterFor: function(j) {\n        return function(T) {\n          if (i(T) && (T = f(T)).type === j)\n            return T;\n          throw TypeError(\"Incompatible receiver, \" + j + \" required\");\n        };\n      } };\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/hidden-keys\": 62, \"../internals/is-object\": 75, \"../internals/native-weak-map\": 86, \"../internals/shared-key\": 119 }], 72: [function(t, H, C) {\n      var m = t(\"../internals/well-known-symbol\"), y = t(\"../internals/iterators\"), u = m(\"iterator\"), h = Array.prototype;\n      H.exports = function(g) {\n        return g !== void 0 && (y.Array === g || h[u] === g);\n      };\n    }, { \"../internals/iterators\": 80, \"../internals/well-known-symbol\": 149 }], 73: [function(t, H, C) {\n      var m = t(\"../internals/classof-raw\");\n      H.exports = Array.isArray || function(y) {\n        return m(y) == \"Array\";\n      };\n    }, { \"../internals/classof-raw\": 28 }], 74: [function(t, H, C) {\n      function m(s, o) {\n        return (s = g[h(s)]) == r || s != f && (typeof o == \"function\" ? y(o) : !!o);\n      }\n      var y = t(\"../internals/fails\"), u = /#|\\.prototype\\./, h = m.normalize = function(s) {\n        return String(s).replace(u, \".\").toLowerCase();\n      }, g = m.data = {}, f = m.NATIVE = \"N\", r = m.POLYFILL = \"P\";\n      H.exports = m;\n    }, { \"../internals/fails\": 51 }], 75: [function(t, H, C) {\n      H.exports = function(m) {\n        return typeof m == \"object\" ? m !== null : typeof m == \"function\";\n      };\n    }, {}], 76: [function(t, H, C) {\n      H.exports = !1;\n    }, {}], 77: [function(t, H, C) {\n      var m = t(\"../internals/is-object\"), y = t(\"../internals/classof-raw\"), u = t(\"../internals/well-known-symbol\")(\"match\");\n      H.exports = function(h) {\n        var g;\n        return m(h) && ((g = h[u]) !== void 0 ? !!g : y(h) == \"RegExp\");\n      };\n    }, { \"../internals/classof-raw\": 28, \"../internals/is-object\": 75, \"../internals/well-known-symbol\": 149 }], 78: [function(t, H, C) {\n      function m(s, o) {\n        this.stopped = s, this.result = o;\n      }\n      var y = t(\"../internals/an-object\"), u = t(\"../internals/is-array-iterator-method\"), h = t(\"../internals/to-length\"), g = t(\"../internals/function-bind-context\"), f = t(\"../internals/get-iterator-method\"), r = t(\"../internals/call-with-safe-iteration-closing\");\n      (H.exports = function(s, o, i, l, n) {\n        var a, c, p, j, T, _, S = g(o, i, l ? 2 : 1);\n        if (n)\n          a = s;\n        else {\n          if (typeof (o = f(s)) != \"function\")\n            throw TypeError(\"Target is not iterable\");\n          if (u(o)) {\n            for (c = 0, p = h(s.length); c < p; c++)\n              if ((j = l ? S(y(_ = s[c])[0], _[1]) : S(s[c])) && j instanceof m)\n                return j;\n            return new m(!1);\n          }\n          a = o.call(s);\n        }\n        for (T = a.next; !(_ = T.call(a)).done; )\n          if (typeof (j = r(a, S, _.value, l)) == \"object\" && j && j instanceof m)\n            return j;\n        return new m(!1);\n      }).stop = function(s) {\n        return new m(!0, s);\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/call-with-safe-iteration-closing\": 26, \"../internals/function-bind-context\": 55, \"../internals/get-iterator-method\": 58, \"../internals/is-array-iterator-method\": 72, \"../internals/to-length\": 137 }], 79: [function(f, H, C) {\n      var m, y, u = f(\"../internals/object-get-prototype-of\"), h = f(\"../internals/create-non-enumerable-property\"), g = f(\"../internals/has\"), r = f(\"../internals/well-known-symbol\"), f = f(\"../internals/is-pure\"), r = r(\"iterator\"), s = !1;\n      [].keys && (\"next\" in (y = [].keys()) ? (u = u(u(y))) !== Object.prototype && (m = u) : s = !0), m == null && (m = {}), f || g(m, r) || h(m, r, function() {\n        return this;\n      }), H.exports = { IteratorPrototype: m, BUGGY_SAFARI_ITERATORS: s };\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/has\": 61, \"../internals/is-pure\": 76, \"../internals/object-get-prototype-of\": 98, \"../internals/well-known-symbol\": 149 }], 80: [function(t, H, C) {\n      H.exports = {};\n    }, {}], 81: [function(t, H, C) {\n      H.exports = Math.sign || function(m) {\n        return (m = +m) == 0 || m != m ? m : m < 0 ? -1 : 1;\n      };\n    }, {}], 82: [function(l, H, C) {\n      var m, y, u, h, g, f, r, s, o = l(\"../internals/global\"), T = l(\"../internals/object-get-own-property-descriptor\").f, j = l(\"../internals/classof-raw\"), i = l(\"../internals/task\").set, l = l(\"../internals/engine-is-ios\"), n = o.MutationObserver || o.WebKitMutationObserver, a = o.process, c = o.Promise, p = j(a) == \"process\", j = T(o, \"queueMicrotask\"), T = j && j.value;\n      T || (m = function() {\n        var _, S;\n        for (p && (_ = a.domain) && _.exit(); y; ) {\n          S = y.fn, y = y.next;\n          try {\n            S();\n          } catch (E) {\n            throw y ? h() : u = void 0, E;\n          }\n        }\n        u = void 0, _ && _.enter();\n      }, h = p ? function() {\n        a.nextTick(m);\n      } : n && !l ? (g = !0, f = document.createTextNode(\"\"), new n(m).observe(f, { characterData: !0 }), function() {\n        f.data = g = !g;\n      }) : c && c.resolve ? (r = c.resolve(void 0), s = r.then, function() {\n        s.call(r, m);\n      }) : function() {\n        i.call(o, m);\n      }), H.exports = T || function(_) {\n        _ = { fn: _, next: void 0 }, u && (u.next = _), y || (y = _, h()), u = _;\n      };\n    }, { \"../internals/classof-raw\": 28, \"../internals/engine-is-ios\": 46, \"../internals/global\": 60, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/task\": 131 }], 83: [function(t, H, C) {\n      t = t(\"../internals/global\"), H.exports = t.Promise;\n    }, { \"../internals/global\": 60 }], 84: [function(t, H, C) {\n      t = t(\"../internals/fails\"), H.exports = !!Object.getOwnPropertySymbols && !t(function() {\n        return !String(Symbol());\n      });\n    }, { \"../internals/fails\": 51 }], 85: [function(t, H, C) {\n      var m = t(\"../internals/fails\"), y = t(\"../internals/well-known-symbol\"), u = t(\"../internals/is-pure\"), h = y(\"iterator\");\n      H.exports = !m(function() {\n        var g = new URL(\"b?a=1&b=2&c=3\", \"http://a\"), f = g.searchParams, r = \"\";\n        return g.pathname = \"c%20d\", f.forEach(function(s, o) {\n          f.delete(\"b\"), r += o + s;\n        }), u && !g.toJSON || !f.sort || g.href !== \"http://a/c%20d?a=1&c=3\" || f.get(\"c\") !== \"3\" || String(new URLSearchParams(\"?a=1\")) !== \"a=1\" || !f[h] || new URL(\"https://a@b\").username !== \"a\" || new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") !== \"b\" || new URL(\"http://тест\").host !== \"xn--e1aybc\" || new URL(\"http://a#б\").hash !== \"#%D0%B1\" || r !== \"a1c3\" || new URL(\"http://x\", void 0).host !== \"x\";\n      });\n    }, { \"../internals/fails\": 51, \"../internals/is-pure\": 76, \"../internals/well-known-symbol\": 149 }], 86: [function(m, H, C) {\n      var y = m(\"../internals/global\"), m = m(\"../internals/inspect-source\"), y = y.WeakMap;\n      H.exports = typeof y == \"function\" && /native code/.test(m(y));\n    }, { \"../internals/global\": 60, \"../internals/inspect-source\": 69 }], 87: [function(t, H, C) {\n      function m(u) {\n        var h, g;\n        this.promise = new u(function(f, r) {\n          if (h !== void 0 || g !== void 0)\n            throw TypeError(\"Bad Promise constructor\");\n          h = f, g = r;\n        }), this.resolve = y(h), this.reject = y(g);\n      }\n      var y = t(\"../internals/a-function\");\n      H.exports.f = function(u) {\n        return new m(u);\n      };\n    }, { \"../internals/a-function\": 5 }], 88: [function(t, H, C) {\n      var m = t(\"../internals/is-regexp\");\n      H.exports = function(y) {\n        if (m(y))\n          throw TypeError(\"The method doesn't accept regular expressions\");\n        return y;\n      };\n    }, { \"../internals/is-regexp\": 77 }], 89: [function(t, H, C) {\n      var m = t(\"../internals/global\").isFinite;\n      H.exports = Number.isFinite || function(y) {\n        return typeof y == \"number\" && m(y);\n      };\n    }, { \"../internals/global\": 60 }], 90: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/fails\"), u = t(\"../internals/object-keys\"), h = t(\"../internals/object-get-own-property-symbols\"), g = t(\"../internals/object-property-is-enumerable\"), f = t(\"../internals/to-object\"), r = t(\"../internals/indexed-object\"), s = Object.assign, o = Object.defineProperty;\n      H.exports = !s || y(function() {\n        var i, l, n, a;\n        return !(!m || s({ b: 1 }, s(o({}, \"a\", { enumerable: !0, get: function() {\n          o(this, \"b\", { value: 3, enumerable: !1 });\n        } }), { b: 2 })).b === 1) || (l = {}, a = \"abcdefghijklmnopqrst\", (i = {})[n = Symbol()] = 7, a.split(\"\").forEach(function(c) {\n          l[c] = c;\n        }), s({}, i)[n] != 7 || u(s({}, l)).join(\"\") != a);\n      }) ? function(i, l) {\n        for (var n = f(i), a = arguments.length, c = 1, p = h.f, j = g.f; c < a; )\n          for (var T, _ = r(arguments[c++]), S = p ? u(_).concat(p(_)) : u(_), E = S.length, A = 0; A < E; )\n            T = S[A++], m && !j.call(_, T) || (n[T] = _[T]);\n        return n;\n      } : s;\n    }, { \"../internals/descriptors\": 43, \"../internals/fails\": 51, \"../internals/indexed-object\": 67, \"../internals/object-get-own-property-symbols\": 97, \"../internals/object-keys\": 100, \"../internals/object-property-is-enumerable\": 101, \"../internals/to-object\": 138 }], 91: [function(o, H, C) {\n      function m() {\n      }\n      var y, u = o(\"../internals/an-object\"), h = o(\"../internals/object-define-properties\"), g = o(\"../internals/enum-bug-keys\"), f = o(\"../internals/hidden-keys\"), r = o(\"../internals/html\"), s = o(\"../internals/document-create-element\"), o = o(\"../internals/shared-key\"), i = \"prototype\", l = \"script\", n = o(\"IE_PROTO\"), a = function(p) {\n        return \"<\" + l + \">\" + p + \"</\" + l + \">\";\n      }, c = function() {\n        try {\n          y = document.domain && new ActiveXObject(\"htmlfile\");\n        } catch {\n        }\n        c = y ? ((p = y).write(a(\"\")), p.close(), j = p.parentWindow.Object, p = null, j) : (p = s(\"iframe\"), j = \"java\" + l + \":\", p.style.display = \"none\", r.appendChild(p), p.src = String(j), (j = p.contentWindow.document).open(), j.write(a(\"document.F=Object\")), j.close(), j.F);\n        for (var p, j, T = g.length; T--; )\n          delete c[i][g[T]];\n        return c();\n      };\n      f[n] = !0, H.exports = Object.create || function(p, j) {\n        var T;\n        return p !== null ? (m[i] = u(p), T = new m(), m[i] = null, T[n] = p) : T = c(), j === void 0 ? T : h(T, j);\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/document-create-element\": 44, \"../internals/enum-bug-keys\": 49, \"../internals/hidden-keys\": 62, \"../internals/html\": 64, \"../internals/object-define-properties\": 92, \"../internals/shared-key\": 119 }], 92: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/object-define-property\"), u = t(\"../internals/an-object\"), h = t(\"../internals/object-keys\");\n      H.exports = m ? Object.defineProperties : function(g, f) {\n        u(g);\n        for (var r, s = h(f), o = s.length, i = 0; i < o; )\n          y.f(g, r = s[i++], f[r]);\n        return g;\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/descriptors\": 43, \"../internals/object-define-property\": 93, \"../internals/object-keys\": 100 }], 93: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/ie8-dom-define\"), u = t(\"../internals/an-object\"), h = t(\"../internals/to-primitive\"), g = Object.defineProperty;\n      C.f = m ? g : function(f, r, s) {\n        if (u(f), r = h(r, !0), u(s), y)\n          try {\n            return g(f, r, s);\n          } catch {\n          }\n        if (\"get\" in s || \"set\" in s)\n          throw TypeError(\"Accessors not supported\");\n        return \"value\" in s && (f[r] = s.value), f;\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/descriptors\": 43, \"../internals/ie8-dom-define\": 65, \"../internals/to-primitive\": 141 }], 94: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/object-property-is-enumerable\"), u = t(\"../internals/create-property-descriptor\"), h = t(\"../internals/to-indexed-object\"), g = t(\"../internals/to-primitive\"), f = t(\"../internals/has\"), r = t(\"../internals/ie8-dom-define\"), s = Object.getOwnPropertyDescriptor;\n      C.f = m ? s : function(o, i) {\n        if (o = h(o), i = g(i, !0), r)\n          try {\n            return s(o, i);\n          } catch {\n          }\n        if (f(o, i))\n          return u(!y.f.call(o, i), o[i]);\n      };\n    }, { \"../internals/create-property-descriptor\": 39, \"../internals/descriptors\": 43, \"../internals/has\": 61, \"../internals/ie8-dom-define\": 65, \"../internals/object-property-is-enumerable\": 101, \"../internals/to-indexed-object\": 135, \"../internals/to-primitive\": 141 }], 95: [function(t, H, C) {\n      var m = t(\"../internals/to-indexed-object\"), y = t(\"../internals/object-get-own-property-names\").f, u = {}.toString, h = typeof window == \"object\" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n      H.exports.f = function(g) {\n        if (!h || u.call(g) != \"[object Window]\")\n          return y(m(g));\n        try {\n          return y(g);\n        } catch {\n          return h.slice();\n        }\n      };\n    }, { \"../internals/object-get-own-property-names\": 96, \"../internals/to-indexed-object\": 135 }], 96: [function(t, H, C) {\n      var m = t(\"../internals/object-keys-internal\"), y = t(\"../internals/enum-bug-keys\").concat(\"length\", \"prototype\");\n      C.f = Object.getOwnPropertyNames || function(u) {\n        return m(u, y);\n      };\n    }, { \"../internals/enum-bug-keys\": 49, \"../internals/object-keys-internal\": 99 }], 97: [function(t, H, C) {\n      C.f = Object.getOwnPropertySymbols;\n    }, {}], 98: [function(h, H, C) {\n      var m = h(\"../internals/has\"), y = h(\"../internals/to-object\"), u = h(\"../internals/shared-key\"), h = h(\"../internals/correct-prototype-getter\"), g = u(\"IE_PROTO\"), f = Object.prototype;\n      H.exports = h ? Object.getPrototypeOf : function(r) {\n        return r = y(r), m(r, g) ? r[g] : typeof r.constructor == \"function\" && r instanceof r.constructor ? r.constructor.prototype : r instanceof Object ? f : null;\n      };\n    }, { \"../internals/correct-prototype-getter\": 35, \"../internals/has\": 61, \"../internals/shared-key\": 119, \"../internals/to-object\": 138 }], 99: [function(t, H, C) {\n      var m = t(\"../internals/has\"), y = t(\"../internals/to-indexed-object\"), u = t(\"../internals/array-includes\").indexOf, h = t(\"../internals/hidden-keys\");\n      H.exports = function(g, f) {\n        var r, s = y(g), o = 0, i = [];\n        for (r in s)\n          !m(h, r) && m(s, r) && i.push(r);\n        for (; f.length > o; )\n          !m(s, r = f[o++]) || ~u(i, r) || i.push(r);\n        return i;\n      };\n    }, { \"../internals/array-includes\": 18, \"../internals/has\": 61, \"../internals/hidden-keys\": 62, \"../internals/to-indexed-object\": 135 }], 100: [function(t, H, C) {\n      var m = t(\"../internals/object-keys-internal\"), y = t(\"../internals/enum-bug-keys\");\n      H.exports = Object.keys || function(u) {\n        return m(u, y);\n      };\n    }, { \"../internals/enum-bug-keys\": 49, \"../internals/object-keys-internal\": 99 }], 101: [function(t, H, C) {\n      var m = {}.propertyIsEnumerable, y = Object.getOwnPropertyDescriptor, u = y && !m.call({ 1: 2 }, 1);\n      C.f = u ? function(h) {\n        return h = y(this, h), !!h && h.enumerable;\n      } : m;\n    }, {}], 102: [function(t, H, C) {\n      var m = t(\"../internals/an-object\"), y = t(\"../internals/a-possible-prototype\");\n      H.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n        var u, h = !1, g = {};\n        try {\n          (u = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set).call(g, []), h = g instanceof Array;\n        } catch {\n        }\n        return function(f, r) {\n          return m(f), y(r), h ? u.call(f, r) : f.__proto__ = r, f;\n        };\n      }() : void 0);\n    }, { \"../internals/a-possible-prototype\": 6, \"../internals/an-object\": 10 }], 103: [function(t, H, C) {\n      var m = t(\"../internals/to-string-tag-support\"), y = t(\"../internals/classof\");\n      H.exports = m ? {}.toString : function() {\n        return \"[object \" + y(this) + \"]\";\n      };\n    }, { \"../internals/classof\": 29, \"../internals/to-string-tag-support\": 142 }], 104: [function(t, H, C) {\n      var m = t(\"../internals/get-built-in\"), y = t(\"../internals/object-get-own-property-names\"), u = t(\"../internals/object-get-own-property-symbols\"), h = t(\"../internals/an-object\");\n      H.exports = m(\"Reflect\", \"ownKeys\") || function(g) {\n        var f = y.f(h(g)), r = u.f;\n        return r ? f.concat(r(g)) : f;\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/get-built-in\": 57, \"../internals/object-get-own-property-names\": 96, \"../internals/object-get-own-property-symbols\": 97 }], 105: [function(t, H, C) {\n      t = t(\"../internals/global\"), H.exports = t;\n    }, { \"../internals/global\": 60 }], 106: [function(t, H, C) {\n      H.exports = function(m) {\n        try {\n          return { error: !1, value: m() };\n        } catch (y) {\n          return { error: !0, value: y };\n        }\n      };\n    }, {}], 107: [function(t, H, C) {\n      var m = t(\"../internals/an-object\"), y = t(\"../internals/is-object\"), u = t(\"../internals/new-promise-capability\");\n      H.exports = function(h, g) {\n        return m(h), y(g) && g.constructor === h ? g : ((0, (h = u.f(h)).resolve)(g), h.promise);\n      };\n    }, { \"../internals/an-object\": 10, \"../internals/is-object\": 75, \"../internals/new-promise-capability\": 87 }], 108: [function(t, H, C) {\n      var m = t(\"../internals/redefine\");\n      H.exports = function(y, u, h) {\n        for (var g in u)\n          m(y, g, u[g], h);\n        return y;\n      };\n    }, { \"../internals/redefine\": 109 }], 109: [function(f, H, C) {\n      var m = f(\"../internals/global\"), y = f(\"../internals/create-non-enumerable-property\"), u = f(\"../internals/has\"), h = f(\"../internals/set-global\"), g = f(\"../internals/inspect-source\"), f = f(\"../internals/internal-state\"), r = f.get, s = f.enforce, o = String(String).split(\"String\");\n      (H.exports = function(i, l, n, j) {\n        var c = !!j && !!j.unsafe, p = !!j && !!j.enumerable, j = !!j && !!j.noTargetGet;\n        typeof n == \"function\" && (typeof l != \"string\" || u(n, \"name\") || y(n, \"name\", l), s(n).source = o.join(typeof l == \"string\" ? l : \"\")), i === m ? p ? i[l] = n : h(l, n) : (c ? !j && i[l] && (p = !0) : delete i[l], p ? i[l] = n : y(i, l, n));\n      })(Function.prototype, \"toString\", function() {\n        return typeof this == \"function\" && r(this).source || g(this);\n      });\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/inspect-source\": 69, \"../internals/internal-state\": 71, \"../internals/set-global\": 116 }], 110: [function(t, H, C) {\n      var m = t(\"./classof-raw\"), y = t(\"./regexp-exec\");\n      H.exports = function(u, h) {\n        var g = u.exec;\n        if (typeof g == \"function\") {\n          if (g = g.call(u, h), typeof g != \"object\")\n            throw TypeError(\"RegExp exec method returned something other than an Object or null\");\n          return g;\n        }\n        if (m(u) !== \"RegExp\")\n          throw TypeError(\"RegExp#exec called on incompatible receiver\");\n        return y.call(u, h);\n      };\n    }, { \"./classof-raw\": 28, \"./regexp-exec\": 111 }], 111: [function(h, H, C) {\n      var m, y, u = h(\"./regexp-flags\"), h = h(\"./regexp-sticky-helpers\"), g = RegExp.prototype.exec, f = String.prototype.replace, r = g, s = (m = /a/, y = /b*/g, g.call(m, \"a\"), g.call(y, \"a\"), m.lastIndex !== 0 || y.lastIndex !== 0), o = h.UNSUPPORTED_Y || h.BROKEN_CARET, i = /()??/.exec(\"\")[1] !== void 0;\n      H.exports = r = s || i || o ? function(l) {\n        var n, a, c, p, j = this, T = o && j.sticky, _ = u.call(j), S = j.source, E = 0, A = l;\n        return T && ((_ = _.replace(\"y\", \"\")).indexOf(\"g\") === -1 && (_ += \"g\"), A = String(l).slice(j.lastIndex), 0 < j.lastIndex && (!j.multiline || j.multiline && l[j.lastIndex - 1] !== `\n`) && (S = \"(?: \" + S + \")\", A = \" \" + A, E++), a = new RegExp(\"^(?:\" + S + \")\", _)), i && (a = new RegExp(\"^\" + S + \"$(?!\\\\s)\", _)), s && (n = j.lastIndex), c = g.call(T ? a : j, A), T ? c ? (c.input = c.input.slice(E), c[0] = c[0].slice(E), c.index = j.lastIndex, j.lastIndex += c[0].length) : j.lastIndex = 0 : s && c && (j.lastIndex = j.global ? c.index + c[0].length : n), i && c && 1 < c.length && f.call(c[0], a, function() {\n          for (p = 1; p < arguments.length - 2; p++)\n            arguments[p] === void 0 && (c[p] = void 0);\n        }), c;\n      } : r;\n    }, { \"./regexp-flags\": 112, \"./regexp-sticky-helpers\": 113 }], 112: [function(t, H, C) {\n      var m = t(\"../internals/an-object\");\n      H.exports = function() {\n        var y = m(this), u = \"\";\n        return y.global && (u += \"g\"), y.ignoreCase && (u += \"i\"), y.multiline && (u += \"m\"), y.dotAll && (u += \"s\"), y.unicode && (u += \"u\"), y.sticky && (u += \"y\"), u;\n      };\n    }, { \"../internals/an-object\": 10 }], 113: [function(t, H, C) {\n      t = t(\"./fails\");\n      function m(y, u) {\n        return RegExp(y, u);\n      }\n      C.UNSUPPORTED_Y = t(function() {\n        var y = m(\"a\", \"y\");\n        return y.lastIndex = 2, y.exec(\"abcd\") != null;\n      }), C.BROKEN_CARET = t(function() {\n        var y = m(\"^r\", \"gy\");\n        return y.lastIndex = 2, y.exec(\"str\") != null;\n      });\n    }, { \"./fails\": 51 }], 114: [function(t, H, C) {\n      H.exports = function(m) {\n        if (m == null)\n          throw TypeError(\"Can't call method on \" + m);\n        return m;\n      };\n    }, {}], 115: [function(t, H, C) {\n      H.exports = Object.is || function(m, y) {\n        return m === y ? m !== 0 || 1 / m == 1 / y : m != m && y != y;\n      };\n    }, {}], 116: [function(t, H, C) {\n      var m = t(\"../internals/global\"), y = t(\"../internals/create-non-enumerable-property\");\n      H.exports = function(u, h) {\n        try {\n          y(m, u, h);\n        } catch {\n          m[u] = h;\n        }\n        return h;\n      };\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/global\": 60 }], 117: [function(t, H, C) {\n      var m = t(\"../internals/get-built-in\"), y = t(\"../internals/object-define-property\"), u = t(\"../internals/well-known-symbol\"), h = t(\"../internals/descriptors\"), g = u(\"species\");\n      H.exports = function(r) {\n        var r = m(r), s = y.f;\n        h && r && !r[g] && s(r, g, { configurable: !0, get: function() {\n          return this;\n        } });\n      };\n    }, { \"../internals/descriptors\": 43, \"../internals/get-built-in\": 57, \"../internals/object-define-property\": 93, \"../internals/well-known-symbol\": 149 }], 118: [function(t, H, C) {\n      var m = t(\"../internals/object-define-property\").f, y = t(\"../internals/has\"), u = t(\"../internals/well-known-symbol\")(\"toStringTag\");\n      H.exports = function(h, g, f) {\n        h && !y(h = f ? h : h.prototype, u) && m(h, u, { configurable: !0, value: g });\n      };\n    }, { \"../internals/has\": 61, \"../internals/object-define-property\": 93, \"../internals/well-known-symbol\": 149 }], 119: [function(t, H, C) {\n      var m = t(\"../internals/shared\"), y = t(\"../internals/uid\"), u = m(\"keys\");\n      H.exports = function(h) {\n        return u[h] || (u[h] = y(h));\n      };\n    }, { \"../internals/shared\": 121, \"../internals/uid\": 146 }], 120: [function(m, H, C) {\n      var u = m(\"../internals/global\"), m = m(\"../internals/set-global\"), y = \"__core-js_shared__\", u = u[y] || m(y, {});\n      H.exports = u;\n    }, { \"../internals/global\": 60, \"../internals/set-global\": 116 }], 121: [function(t, H, C) {\n      var m = t(\"../internals/is-pure\"), y = t(\"../internals/shared-store\");\n      (H.exports = function(u, h) {\n        return y[u] || (y[u] = h !== void 0 ? h : {});\n      })(\"versions\", []).push({ version: \"3.6.5\", mode: m ? \"pure\" : \"global\", copyright: \"© 2020 Denis Pushkarev (zloirock.ru)\" });\n    }, { \"../internals/is-pure\": 76, \"../internals/shared-store\": 120 }], 122: [function(t, H, C) {\n      var m = t(\"../internals/an-object\"), y = t(\"../internals/a-function\"), u = t(\"../internals/well-known-symbol\")(\"species\");\n      H.exports = function(f, g) {\n        var f = m(f).constructor;\n        return f === void 0 || (f = m(f)[u]) == null ? g : y(f);\n      };\n    }, { \"../internals/a-function\": 5, \"../internals/an-object\": 10, \"../internals/well-known-symbol\": 149 }], 123: [function(t, H, C) {\n      var m = t(\"../internals/fails\");\n      H.exports = function(y) {\n        return m(function() {\n          var u = \"\"[y]('\"');\n          return u !== u.toLowerCase() || 3 < u.split('\"').length;\n        });\n      };\n    }, { \"../internals/fails\": 51 }], 124: [function(t, H, C) {\n      function m(h) {\n        return function(s, o) {\n          var r, s = String(u(s)), o = y(o), i = s.length;\n          return o < 0 || i <= o ? h ? \"\" : void 0 : (r = s.charCodeAt(o)) < 55296 || 56319 < r || o + 1 === i || (i = s.charCodeAt(o + 1)) < 56320 || 57343 < i ? h ? s.charAt(o) : r : h ? s.slice(o, o + 2) : i - 56320 + (r - 55296 << 10) + 65536;\n        };\n      }\n      var y = t(\"../internals/to-integer\"), u = t(\"../internals/require-object-coercible\");\n      H.exports = { codeAt: m(!1), charAt: m(!0) };\n    }, { \"../internals/require-object-coercible\": 114, \"../internals/to-integer\": 136 }], 125: [function(t, H, C) {\n      t = t(\"../internals/engine-user-agent\"), H.exports = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(t);\n    }, { \"../internals/engine-user-agent\": 47 }], 126: [function(t, H, C) {\n      function m(f) {\n        return function(i, a, n) {\n          var i = String(h(i)), l = i.length, n = n === void 0 ? \" \" : String(n), a = y(a);\n          return a <= l || n == \"\" ? i : ((l = u.call(n, g((a = a - l) / n.length))).length > a && (l = l.slice(0, a)), f ? i + l : l + i);\n        };\n      }\n      var y = t(\"../internals/to-length\"), u = t(\"../internals/string-repeat\"), h = t(\"../internals/require-object-coercible\"), g = Math.ceil;\n      H.exports = { start: m(!1), end: m(!0) };\n    }, { \"../internals/require-object-coercible\": 114, \"../internals/string-repeat\": 128, \"../internals/to-length\": 137 }], 127: [function(t, H, C) {\n      function m(c) {\n        return c + 22 + 75 * (c < 26);\n      }\n      function y(c) {\n        var p, j = [], T = (c = function(W) {\n          for (var X = [], ne = 0, b = W.length; ne < b; ) {\n            var O, D = W.charCodeAt(ne++);\n            55296 <= D && D <= 56319 && ne < b ? (64512 & (O = W.charCodeAt(ne++))) == 56320 ? X.push(((1023 & D) << 10) + (1023 & O) + 65536) : (X.push(D), ne--) : X.push(D);\n          }\n          return X;\n        }(c)).length, _ = 128, S = 0, E = 72;\n        for (M = 0; M < c.length; M++)\n          (p = c[M]) < 128 && j.push(a(p));\n        var A = j.length, x = A;\n        for (A && j.push(\"-\"); x < T; ) {\n          for (var P = u, M = 0; M < c.length; M++)\n            _ <= (p = c[M]) && p < P && (P = p);\n          var R = x + 1;\n          if (P - _ > n((u - S) / R))\n            throw RangeError(i);\n          for (S += (P - _) * R, _ = P, M = 0; M < c.length; M++) {\n            if ((p = c[M]) < _ && ++S > u)\n              throw RangeError(i);\n            if (p == _) {\n              for (var L = S, F = h; ; F += h) {\n                var V = F <= E ? 1 : E + g <= F ? g : F - E;\n                if (L < V)\n                  break;\n                var G = L - V, U = h - V;\n                j.push(a(m(V + G % U))), L = n(G / U);\n              }\n              j.push(a(m(L))), E = function(W, X, ne) {\n                var b = 0;\n                for (W = ne ? n(W / r) : W >> 1, W += n(W / X); l * g >> 1 < W; b += h)\n                  W = n(W / l);\n                return n(b + (l + 1) * W / (W + f));\n              }(S, R, x == A), S = 0, ++x;\n            }\n          }\n          ++S, ++_;\n        }\n        return j.join(\"\");\n      }\n      var u = 2147483647, h = 36, g = 26, f = 38, r = 700, s = /[^\\0-\\u007E]/, o = /[.\\u3002\\uFF0E\\uFF61]/g, i = \"Overflow: input needs wider integers to process\", l = h - 1, n = Math.floor, a = String.fromCharCode;\n      H.exports = function(c) {\n        for (var p, j = [], T = c.toLowerCase().replace(o, \".\").split(\".\"), _ = 0; _ < T.length; _++)\n          p = T[_], j.push(s.test(p) ? \"xn--\" + y(p) : p);\n        return j.join(\".\");\n      };\n    }, {}], 128: [function(t, H, C) {\n      var m = t(\"../internals/to-integer\"), y = t(\"../internals/require-object-coercible\");\n      H.exports = \"\".repeat || function(u) {\n        var h = String(y(this)), g = \"\", f = m(u);\n        if (f < 0 || f == 1 / 0)\n          throw RangeError(\"Wrong number of repetitions\");\n        for (; 0 < f; (f >>>= 1) && (h += h))\n          1 & f && (g += h);\n        return g;\n      };\n    }, { \"../internals/require-object-coercible\": 114, \"../internals/to-integer\": 136 }], 129: [function(t, H, C) {\n      var m = t(\"../internals/fails\"), y = t(\"../internals/whitespaces\");\n      H.exports = function(u) {\n        return m(function() {\n          return !!y[u]() || \"​᠎\"[u]() != \"​᠎\" || y[u].name !== u;\n        });\n      };\n    }, { \"../internals/fails\": 51, \"../internals/whitespaces\": 150 }], 130: [function(u, H, C) {\n      function m(f) {\n        return function(r) {\n          return r = String(y(r)), 1 & f && (r = r.replace(h, \"\")), r = 2 & f ? r.replace(g, \"\") : r;\n        };\n      }\n      var y = u(\"../internals/require-object-coercible\"), u = \"[\" + u(\"../internals/whitespaces\") + \"]\", h = RegExp(\"^\" + u + u + \"*\"), g = RegExp(u + u + \"*$\");\n      H.exports = { start: m(1), end: m(2), trim: m(3) };\n    }, { \"../internals/require-object-coercible\": 114, \"../internals/whitespaces\": 150 }], 131: [function(l, H, C) {\n      function m(x) {\n        return function() {\n          A(x);\n        };\n      }\n      function y(x) {\n        A(x.data);\n      }\n      function u(x) {\n        g.postMessage(x + \"\", n.protocol + \"//\" + n.host);\n      }\n      var h, g = l(\"../internals/global\"), f = l(\"../internals/fails\"), r = l(\"../internals/classof-raw\"), s = l(\"../internals/function-bind-context\"), o = l(\"../internals/html\"), i = l(\"../internals/document-create-element\"), l = l(\"../internals/engine-is-ios\"), n = g.location, a = g.setImmediate, c = g.clearImmediate, p = g.process, j = g.MessageChannel, T = g.Dispatch, _ = 0, S = {}, E = \"onreadystatechange\", A = function(x) {\n        var P;\n        S.hasOwnProperty(x) && (P = S[x], delete S[x], P());\n      };\n      a && c || (a = function(x) {\n        for (var P = [], M = 1; M < arguments.length; )\n          P.push(arguments[M++]);\n        return S[++_] = function() {\n          (typeof x == \"function\" ? x : Function(x)).apply(void 0, P);\n        }, h(_), _;\n      }, c = function(x) {\n        delete S[x];\n      }, r(p) == \"process\" ? h = function(x) {\n        p.nextTick(m(x));\n      } : T && T.now ? h = function(x) {\n        T.now(m(x));\n      } : j && !l ? (l = (r = new j()).port2, r.port1.onmessage = y, h = s(l.postMessage, l, 1)) : !g.addEventListener || typeof postMessage != \"function\" || g.importScripts || f(u) || n.protocol === \"file:\" ? h = E in i(\"script\") ? function(x) {\n        o.appendChild(i(\"script\"))[E] = function() {\n          o.removeChild(this), A(x);\n        };\n      } : function(x) {\n        setTimeout(m(x), 0);\n      } : (h = u, g.addEventListener(\"message\", y, !1))), H.exports = { set: a, clear: c };\n    }, { \"../internals/classof-raw\": 28, \"../internals/document-create-element\": 44, \"../internals/engine-is-ios\": 46, \"../internals/fails\": 51, \"../internals/function-bind-context\": 55, \"../internals/global\": 60, \"../internals/html\": 64 }], 132: [function(t, H, C) {\n      var m = t(\"../internals/classof-raw\");\n      H.exports = function(y) {\n        if (typeof y != \"number\" && m(y) != \"Number\")\n          throw TypeError(\"Incorrect invocation\");\n        return +y;\n      };\n    }, { \"../internals/classof-raw\": 28 }], 133: [function(t, H, C) {\n      var m = t(\"../internals/to-integer\"), y = Math.max, u = Math.min;\n      H.exports = function(h, g) {\n        return h = m(h), h < 0 ? y(h + g, 0) : u(h, g);\n      };\n    }, { \"../internals/to-integer\": 136 }], 134: [function(t, H, C) {\n      var m = t(\"../internals/to-integer\"), y = t(\"../internals/to-length\");\n      H.exports = function(h) {\n        if (h === void 0)\n          return 0;\n        var h = m(h), g = y(h);\n        if (h !== g)\n          throw RangeError(\"Wrong length or index\");\n        return g;\n      };\n    }, { \"../internals/to-integer\": 136, \"../internals/to-length\": 137 }], 135: [function(t, H, C) {\n      var m = t(\"../internals/indexed-object\"), y = t(\"../internals/require-object-coercible\");\n      H.exports = function(u) {\n        return m(y(u));\n      };\n    }, { \"../internals/indexed-object\": 67, \"../internals/require-object-coercible\": 114 }], 136: [function(t, H, C) {\n      var m = Math.ceil, y = Math.floor;\n      H.exports = function(u) {\n        return isNaN(u = +u) ? 0 : (0 < u ? y : m)(u);\n      };\n    }, {}], 137: [function(t, H, C) {\n      var m = t(\"../internals/to-integer\"), y = Math.min;\n      H.exports = function(u) {\n        return 0 < u ? y(m(u), 9007199254740991) : 0;\n      };\n    }, { \"../internals/to-integer\": 136 }], 138: [function(t, H, C) {\n      var m = t(\"../internals/require-object-coercible\");\n      H.exports = function(y) {\n        return Object(m(y));\n      };\n    }, { \"../internals/require-object-coercible\": 114 }], 139: [function(t, H, C) {\n      var m = t(\"../internals/to-positive-integer\");\n      H.exports = function(y, u) {\n        if (y = m(y), y % u)\n          throw RangeError(\"Wrong offset\");\n        return y;\n      };\n    }, { \"../internals/to-positive-integer\": 140 }], 140: [function(t, H, C) {\n      var m = t(\"../internals/to-integer\");\n      H.exports = function(y) {\n        if (y = m(y), y < 0)\n          throw RangeError(\"The argument can't be less than 0\");\n        return y;\n      };\n    }, { \"../internals/to-integer\": 136 }], 141: [function(t, H, C) {\n      var m = t(\"../internals/is-object\");\n      H.exports = function(y, u) {\n        if (!m(y))\n          return y;\n        var h, g;\n        if (u && typeof (h = y.toString) == \"function\" && !m(g = h.call(y)) || typeof (h = y.valueOf) == \"function\" && !m(g = h.call(y)) || !u && typeof (h = y.toString) == \"function\" && !m(g = h.call(y)))\n          return g;\n        throw TypeError(\"Can't convert object to primitive value\");\n      };\n    }, { \"../internals/is-object\": 75 }], 142: [function(t, H, C) {\n      var m = {};\n      m[t(\"../internals/well-known-symbol\")(\"toStringTag\")] = \"z\", H.exports = String(m) === \"[object z]\";\n    }, { \"../internals/well-known-symbol\": 149 }], 143: [function(t, H, C) {\n      function m(fe, ge) {\n        for (var xe = 0, De = ge.length, Me = new (K(fe))(De); xe < De; )\n          Me[xe] = ge[xe++];\n        return Me;\n      }\n      function y(fe, ge) {\n        O(fe, ge, { get: function() {\n          return ne(this)[ge];\n        } });\n      }\n      function u(fe) {\n        return fe instanceof J || (fe = A(fe)) == \"ArrayBuffer\" || fe == \"SharedArrayBuffer\";\n      }\n      function h(fe, ge) {\n        return ae(fe) && typeof ge != \"symbol\" && ge in fe && String(+ge) == String(ge);\n      }\n      function g(fe, ge) {\n        return h(fe, ge = S(ge, !0)) ? c(2, fe[ge]) : D(fe, ge);\n      }\n      function f(fe, ge, xe) {\n        return !(h(fe, ge = S(ge, !0)) && x(xe) && E(xe, \"value\")) || E(xe, \"get\") || E(xe, \"set\") || xe.configurable || E(xe, \"writable\") && !xe.writable || E(xe, \"enumerable\") && !xe.enumerable ? O(fe, ge, xe) : (fe[ge] = xe.value, fe);\n      }\n      var r = t(\"../internals/export\"), s = t(\"../internals/global\"), o = t(\"../internals/descriptors\"), i = t(\"../internals/typed-array-constructors-require-wrappers\"), l = t(\"../internals/array-buffer-view-core\"), n = t(\"../internals/array-buffer\"), a = t(\"../internals/an-instance\"), c = t(\"../internals/create-property-descriptor\"), p = t(\"../internals/create-non-enumerable-property\"), j = t(\"../internals/to-length\"), T = t(\"../internals/to-index\"), _ = t(\"../internals/to-offset\"), S = t(\"../internals/to-primitive\"), E = t(\"../internals/has\"), A = t(\"../internals/classof\"), x = t(\"../internals/is-object\"), P = t(\"../internals/object-create\"), M = t(\"../internals/object-set-prototype-of\"), R = t(\"../internals/object-get-own-property-names\").f, L = t(\"../internals/typed-array-from\"), F = t(\"../internals/array-iteration\").forEach, V = t(\"../internals/set-species\"), G = t(\"../internals/object-define-property\"), U = t(\"../internals/object-get-own-property-descriptor\"), W = t(\"../internals/internal-state\"), X = t(\"../internals/inherit-if-required\"), ne = W.get, b = W.set, O = G.f, D = U.f, B = Math.round, Y = s.RangeError, J = n.ArrayBuffer, te = n.DataView, ce = l.NATIVE_ARRAY_BUFFER_VIEWS, re = l.TYPED_ARRAY_TAG, ue = l.TypedArray, le = l.TypedArrayPrototype, K = l.aTypedArrayConstructor, ae = l.isTypedArray, he = \"BYTES_PER_ELEMENT\", _e = \"Wrong length\";\n      o ? (ce || (U.f = g, G.f = f, y(le, \"buffer\"), y(le, \"byteOffset\"), y(le, \"byteLength\"), y(le, \"length\")), r({ target: \"Object\", stat: !0, forced: !ce }, { getOwnPropertyDescriptor: g, defineProperty: f }), H.exports = function(ve, ge, xe) {\n        function De(we, Z) {\n          O(we, Z, { get: function() {\n            var $ = this, q = Z;\n            return ($ = ne($)).view[ze](q * Me + $.byteOffset, !0);\n          }, set: function($) {\n            var q = this, ee = Z;\n            q = ne(q), xe && ($ = ($ = B($)) < 0 ? 0 : 255 < $ ? 255 : 255 & $), q.view[Ve](ee * Me + q.byteOffset, $, !0);\n          }, enumerable: !0 });\n        }\n        var Me = ve.match(/\\d+$/)[0] / 8, Qe = ve + (xe ? \"Clamped\" : \"\") + \"Array\", ze = \"get\" + ve, Ve = \"set\" + ve, Xe = s[Qe], He = Xe, ve = He && He.prototype, Re = {};\n        ce ? i && (He = ge(function(we, Z, $, q) {\n          return a(we, He, Qe), X(x(Z) ? u(Z) ? q !== void 0 ? new Xe(Z, _($, Me), q) : $ !== void 0 ? new Xe(Z, _($, Me)) : new Xe(Z) : ae(Z) ? m(He, Z) : L.call(He, Z) : new Xe(T(Z)), we, He);\n        }), M && M(He, ue), F(R(Xe), function(we) {\n          we in He || p(He, we, Xe[we]);\n        }), He.prototype = ve) : (He = ge(function(we, Z, $, q) {\n          a(we, He, Qe);\n          var ee, pe, je = 0, Ce = 0;\n          if (x(Z)) {\n            if (!u(Z))\n              return ae(Z) ? m(He, Z) : L.call(He, Z);\n            var Fe = Z, Ce = _($, Me), $ = Z.byteLength;\n            if (q === void 0) {\n              if ($ % Me || (ee = $ - Ce) < 0)\n                throw Y(_e);\n            } else if ($ < (ee = j(q) * Me) + Ce)\n              throw Y(_e);\n            pe = ee / Me;\n          } else\n            pe = T(Z), Fe = new J(ee = pe * Me);\n          for (b(we, { buffer: Fe, byteOffset: Ce, byteLength: ee, length: pe, view: new te(Fe) }); je < pe; )\n            De(we, je++);\n        }), M && M(He, ue), ve = He.prototype = P(le)), ve.constructor !== He && p(ve, \"constructor\", He), re && p(ve, re, Qe), Re[Qe] = He, r({ global: !0, forced: He != Xe, sham: !ce }, Re), he in He || p(He, he, Me), he in ve || p(ve, he, Me), V(Qe);\n      }) : H.exports = function() {\n      };\n    }, { \"../internals/an-instance\": 9, \"../internals/array-buffer\": 13, \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19, \"../internals/classof\": 29, \"../internals/create-non-enumerable-property\": 38, \"../internals/create-property-descriptor\": 39, \"../internals/descriptors\": 43, \"../internals/export\": 50, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/inherit-if-required\": 68, \"../internals/internal-state\": 71, \"../internals/is-object\": 75, \"../internals/object-create\": 91, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/object-get-own-property-names\": 96, \"../internals/object-set-prototype-of\": 102, \"../internals/set-species\": 117, \"../internals/to-index\": 134, \"../internals/to-length\": 137, \"../internals/to-offset\": 139, \"../internals/to-primitive\": 141, \"../internals/typed-array-constructors-require-wrappers\": 144, \"../internals/typed-array-from\": 145 }], 144: [function(h, H, C) {\n      var m = h(\"../internals/global\"), y = h(\"../internals/fails\"), u = h(\"../internals/check-correctness-of-iteration\"), h = h(\"../internals/array-buffer-view-core\").NATIVE_ARRAY_BUFFER_VIEWS, g = m.ArrayBuffer, f = m.Int8Array;\n      H.exports = !h || !y(function() {\n        f(1);\n      }) || !y(function() {\n        new f(-1);\n      }) || !u(function(r) {\n        new f(), new f(null), new f(1.5), new f(r);\n      }, !0) || y(function() {\n        return new f(new g(2), 1, void 0).length !== 1;\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/check-correctness-of-iteration\": 27, \"../internals/fails\": 51, \"../internals/global\": 60 }], 145: [function(t, H, C) {\n      var m = t(\"../internals/to-object\"), y = t(\"../internals/to-length\"), u = t(\"../internals/get-iterator-method\"), h = t(\"../internals/is-array-iterator-method\"), g = t(\"../internals/function-bind-context\"), f = t(\"../internals/array-buffer-view-core\").aTypedArrayConstructor;\n      H.exports = function(r) {\n        var s, o, i, l, n, a, c = m(r), p = arguments.length, j = 1 < p ? arguments[1] : void 0, T = j !== void 0, _ = u(c);\n        if (_ != null && !h(_))\n          for (a = (n = _.call(c)).next, c = []; !(l = a.call(n)).done; )\n            c.push(l.value);\n        for (T && 2 < p && (j = g(j, arguments[2], 2)), o = y(c.length), i = new (f(this))(o), s = 0; s < o; s++)\n          i[s] = T ? j(c[s], s) : c[s];\n        return i;\n      };\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/function-bind-context\": 55, \"../internals/get-iterator-method\": 58, \"../internals/is-array-iterator-method\": 72, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 146: [function(t, H, C) {\n      var m = 0, y = Math.random();\n      H.exports = function(u) {\n        return \"Symbol(\" + String(u === void 0 ? \"\" : u) + \")_\" + (++m + y).toString(36);\n      };\n    }, {}], 147: [function(t, H, C) {\n      t = t(\"../internals/native-symbol\"), H.exports = t && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    }, { \"../internals/native-symbol\": 84 }], 148: [function(t, H, C) {\n      t = t(\"../internals/well-known-symbol\"), C.f = t;\n    }, { \"../internals/well-known-symbol\": 149 }], 149: [function(f, H, C) {\n      var m = f(\"../internals/global\"), y = f(\"../internals/shared\"), u = f(\"../internals/has\"), h = f(\"../internals/uid\"), g = f(\"../internals/native-symbol\"), f = f(\"../internals/use-symbol-as-uid\"), r = y(\"wks\"), s = m.Symbol, o = f ? s : s && s.withoutSetter || h;\n      H.exports = function(i) {\n        return u(r, i) || (g && u(s, i) ? r[i] = s[i] : r[i] = o(\"Symbol.\" + i)), r[i];\n      };\n    }, { \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/native-symbol\": 84, \"../internals/shared\": 121, \"../internals/uid\": 146, \"../internals/use-symbol-as-uid\": 147 }], 150: [function(t, H, C) {\n      H.exports = `\t\n\\v\\f\\r                　\\u2028\\u2029\\uFEFF`;\n    }, {}], 151: [function(u, H, C) {\n      var m = u(\"../internals/export\"), y = u(\"../internals/global\"), g = u(\"../internals/array-buffer\"), u = u(\"../internals/set-species\"), h = \"ArrayBuffer\", g = g[h];\n      m({ global: !0, forced: y[h] !== g }, { ArrayBuffer: g }), u(h);\n    }, { \"../internals/array-buffer\": 13, \"../internals/export\": 50, \"../internals/global\": 60, \"../internals/set-species\": 117 }], 152: [function(c, H, C) {\n      var m = c(\"../internals/export\"), y = c(\"../internals/fails\"), u = c(\"../internals/is-array\"), h = c(\"../internals/is-object\"), g = c(\"../internals/to-object\"), f = c(\"../internals/to-length\"), r = c(\"../internals/create-property\"), s = c(\"../internals/array-species-create\"), o = c(\"../internals/array-method-has-species-support\"), a = c(\"../internals/well-known-symbol\"), c = c(\"../internals/engine-v8-version\"), i = a(\"isConcatSpreadable\"), l = 9007199254740991, n = \"Maximum allowed index exceeded\", a = 51 <= c || !y(function() {\n        var p = [];\n        return p[i] = !1, p.concat()[0] !== p;\n      }), c = o(\"concat\");\n      m({ target: \"Array\", proto: !0, forced: !a || !c }, { concat: function(p) {\n        for (var j, T, _, S, E, A = g(this), x = s(A, 0), P = 0, M = -1, R = arguments.length; M < R; M++)\n          if (E = void 0, !h(S = _ = M === -1 ? A : arguments[M]) || ((E = S[i]) !== void 0 ? !E : !u(S))) {\n            if (l <= P)\n              throw TypeError(n);\n            r(x, P++, _);\n          } else {\n            if (T = f(_.length), l < P + T)\n              throw TypeError(n);\n            for (j = 0; j < T; j++, P++)\n              j in _ && r(x, P, _[j]);\n          }\n        return x.length = P, x;\n      } });\n    }, { \"../internals/array-method-has-species-support\": 21, \"../internals/array-species-create\": 25, \"../internals/create-property\": 40, \"../internals/engine-v8-version\": 48, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/is-array\": 73, \"../internals/is-object\": 75, \"../internals/to-length\": 137, \"../internals/to-object\": 138, \"../internals/well-known-symbol\": 149 }], 153: [function(u, H, C) {\n      var m = u(\"../internals/export\"), y = u(\"../internals/array-copy-within\"), u = u(\"../internals/add-to-unscopables\");\n      m({ target: \"Array\", proto: !0 }, { copyWithin: y }), u(\"copyWithin\");\n    }, { \"../internals/add-to-unscopables\": 7, \"../internals/array-copy-within\": 14, \"../internals/export\": 50 }], 154: [function(h, H, C) {\n      var m = h(\"../internals/export\"), y = h(\"../internals/array-iteration\").every, u = h(\"../internals/array-method-is-strict\"), h = h(\"../internals/array-method-uses-to-length\"), u = u(\"every\"), h = h(\"every\");\n      m({ target: \"Array\", proto: !0, forced: !u || !h }, { every: function(g) {\n        return y(this, g, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/array-iteration\": 19, \"../internals/array-method-is-strict\": 22, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 155: [function(u, H, C) {\n      var m = u(\"../internals/export\"), y = u(\"../internals/array-fill\"), u = u(\"../internals/add-to-unscopables\");\n      m({ target: \"Array\", proto: !0 }, { fill: y }), u(\"fill\");\n    }, { \"../internals/add-to-unscopables\": 7, \"../internals/array-fill\": 15, \"../internals/export\": 50 }], 156: [function(h, H, C) {\n      var m = h(\"../internals/export\"), y = h(\"../internals/array-iteration\").filter, u = h(\"../internals/array-method-has-species-support\"), h = h(\"../internals/array-method-uses-to-length\"), u = u(\"filter\"), h = h(\"filter\");\n      m({ target: \"Array\", proto: !0, forced: !u || !h }, { filter: function(g) {\n        return y(this, g, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/array-iteration\": 19, \"../internals/array-method-has-species-support\": 21, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 157: [function(f, H, C) {\n      var m = f(\"../internals/export\"), y = f(\"../internals/array-iteration\").findIndex, u = f(\"../internals/add-to-unscopables\"), f = f(\"../internals/array-method-uses-to-length\"), h = \"findIndex\", g = !0, f = f(h);\n      h in [] && Array(1)[h](function() {\n        g = !1;\n      }), m({ target: \"Array\", proto: !0, forced: g || !f }, { findIndex: function(r) {\n        return y(this, r, 1 < arguments.length ? arguments[1] : void 0);\n      } }), u(h);\n    }, { \"../internals/add-to-unscopables\": 7, \"../internals/array-iteration\": 19, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 158: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/flatten-into-array\"), u = t(\"../internals/to-object\"), h = t(\"../internals/to-length\"), g = t(\"../internals/a-function\"), f = t(\"../internals/array-species-create\");\n      m({ target: \"Array\", proto: !0 }, { flatMap: function(r) {\n        var s, o = u(this), i = h(o.length);\n        return g(r), (s = f(o, 0)).length = y(s, o, o, i, 0, 1, r, 1 < arguments.length ? arguments[1] : void 0), s;\n      } });\n    }, { \"../internals/a-function\": 5, \"../internals/array-species-create\": 25, \"../internals/export\": 50, \"../internals/flatten-into-array\": 53, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 159: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/flatten-into-array\"), u = t(\"../internals/to-object\"), h = t(\"../internals/to-length\"), g = t(\"../internals/to-integer\"), f = t(\"../internals/array-species-create\");\n      m({ target: \"Array\", proto: !0 }, { flat: function() {\n        var r = arguments.length ? arguments[0] : void 0, s = u(this), o = h(s.length), i = f(s, 0);\n        return i.length = y(i, s, s, o, 0, r === void 0 ? 1 : g(r)), i;\n      } });\n    }, { \"../internals/array-species-create\": 25, \"../internals/export\": 50, \"../internals/flatten-into-array\": 53, \"../internals/to-integer\": 136, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 160: [function(y, H, C) {\n      var m = y(\"../internals/export\"), y = y(\"../internals/array-for-each\");\n      m({ target: \"Array\", proto: !0, forced: [].forEach != y }, { forEach: y });\n    }, { \"../internals/array-for-each\": 16, \"../internals/export\": 50 }], 161: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/array-from\");\n      m({ target: \"Array\", stat: !0, forced: !t(\"../internals/check-correctness-of-iteration\")(function(u) {\n        Array.from(u);\n      }) }, { from: y });\n    }, { \"../internals/array-from\": 17, \"../internals/check-correctness-of-iteration\": 27, \"../internals/export\": 50 }], 162: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/array-includes\").includes, u = t(\"../internals/add-to-unscopables\");\n      m({ target: \"Array\", proto: !0, forced: !t(\"../internals/array-method-uses-to-length\")(\"indexOf\", { ACCESSORS: !0, 1: 0 }) }, { includes: function(h) {\n        return y(this, h, 1 < arguments.length ? arguments[1] : void 0);\n      } }), u(\"includes\");\n    }, { \"../internals/add-to-unscopables\": 7, \"../internals/array-includes\": 18, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 163: [function(f, H, C) {\n      var m = f(\"../internals/export\"), y = f(\"../internals/array-includes\").indexOf, g = f(\"../internals/array-method-is-strict\"), f = f(\"../internals/array-method-uses-to-length\"), u = [].indexOf, h = !!u && 1 / [1].indexOf(1, -0) < 0, g = g(\"indexOf\"), f = f(\"indexOf\", { ACCESSORS: !0, 1: 0 });\n      m({ target: \"Array\", proto: !0, forced: h || !g || !f }, { indexOf: function(r) {\n        return h ? u.apply(this, arguments) || 0 : y(this, r, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/array-includes\": 18, \"../internals/array-method-is-strict\": 22, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 164: [function(g, H, C) {\n      var m = g(\"../internals/to-indexed-object\"), y = g(\"../internals/add-to-unscopables\"), u = g(\"../internals/iterators\"), h = g(\"../internals/internal-state\"), g = g(\"../internals/define-iterator\"), f = \"Array Iterator\", r = h.set, s = h.getterFor(f);\n      H.exports = g(Array, \"Array\", function(o, i) {\n        r(this, { type: f, target: m(o), index: 0, kind: i });\n      }, function() {\n        var o = s(this), i = o.target, l = o.kind, n = o.index++;\n        return !i || n >= i.length ? { value: o.target = void 0, done: !0 } : l == \"keys\" ? { value: n, done: !1 } : l == \"values\" ? { value: i[n], done: !1 } : { value: [n, i[n]], done: !1 };\n      }, \"values\"), u.Arguments = u.Array, y(\"keys\"), y(\"values\"), y(\"entries\");\n    }, { \"../internals/add-to-unscopables\": 7, \"../internals/define-iterator\": 41, \"../internals/internal-state\": 71, \"../internals/iterators\": 80, \"../internals/to-indexed-object\": 135 }], 165: [function(g, H, C) {\n      var m = g(\"../internals/export\"), h = g(\"../internals/indexed-object\"), y = g(\"../internals/to-indexed-object\"), g = g(\"../internals/array-method-is-strict\"), u = [].join, h = h != Object, g = g(\"join\", \",\");\n      m({ target: \"Array\", proto: !0, forced: h || !g }, { join: function(f) {\n        return u.call(y(this), f === void 0 ? \",\" : f);\n      } });\n    }, { \"../internals/array-method-is-strict\": 22, \"../internals/export\": 50, \"../internals/indexed-object\": 67, \"../internals/to-indexed-object\": 135 }], 166: [function(y, H, C) {\n      var m = y(\"../internals/export\"), y = y(\"../internals/array-last-index-of\");\n      m({ target: \"Array\", proto: !0, forced: y !== [].lastIndexOf }, { lastIndexOf: y });\n    }, { \"../internals/array-last-index-of\": 20, \"../internals/export\": 50 }], 167: [function(h, H, C) {\n      var m = h(\"../internals/export\"), y = h(\"../internals/array-iteration\").map, u = h(\"../internals/array-method-has-species-support\"), h = h(\"../internals/array-method-uses-to-length\"), u = u(\"map\"), h = h(\"map\");\n      m({ target: \"Array\", proto: !0, forced: !u || !h }, { map: function(g) {\n        return y(this, g, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/array-iteration\": 19, \"../internals/array-method-has-species-support\": 21, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 168: [function(i, H, C) {\n      var m = i(\"../internals/export\"), y = i(\"../internals/is-object\"), u = i(\"../internals/is-array\"), h = i(\"../internals/to-absolute-index\"), g = i(\"../internals/to-length\"), f = i(\"../internals/to-indexed-object\"), r = i(\"../internals/create-property\"), s = i(\"../internals/well-known-symbol\"), o = i(\"../internals/array-method-has-species-support\"), i = i(\"../internals/array-method-uses-to-length\"), o = o(\"slice\"), i = i(\"slice\", { ACCESSORS: !0, 0: 0, 1: 2 }), l = s(\"species\"), n = [].slice, a = Math.max;\n      m({ target: \"Array\", proto: !0, forced: !o || !i }, { slice: function(c, p) {\n        var j, T, _, S = f(this), E = g(S.length), A = h(c, E), x = h(p === void 0 ? E : p, E);\n        if (u(S) && ((j = typeof (j = S.constructor) == \"function\" && (j === Array || u(j.prototype)) || y(j) && (j = j[l]) === null ? void 0 : j) === Array || j === void 0))\n          return n.call(S, A, x);\n        for (T = new (j === void 0 ? Array : j)(a(x - A, 0)), _ = 0; A < x; A++, _++)\n          A in S && r(T, _, S[A]);\n        return T.length = _, T;\n      } });\n    }, { \"../internals/array-method-has-species-support\": 21, \"../internals/array-method-uses-to-length\": 23, \"../internals/create-property\": 40, \"../internals/export\": 50, \"../internals/is-array\": 73, \"../internals/is-object\": 75, \"../internals/to-absolute-index\": 133, \"../internals/to-indexed-object\": 135, \"../internals/to-length\": 137, \"../internals/well-known-symbol\": 149 }], 169: [function(h, H, C) {\n      var m = h(\"../internals/export\"), y = h(\"../internals/array-iteration\").some, u = h(\"../internals/array-method-is-strict\"), h = h(\"../internals/array-method-uses-to-length\"), u = u(\"some\"), h = h(\"some\");\n      m({ target: \"Array\", proto: !0, forced: !u || !h }, { some: function(g) {\n        return y(this, g, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/array-iteration\": 19, \"../internals/array-method-is-strict\": 22, \"../internals/array-method-uses-to-length\": 23, \"../internals/export\": 50 }], 170: [function(o, H, C) {\n      var m = o(\"../internals/export\"), y = o(\"../internals/to-absolute-index\"), u = o(\"../internals/to-integer\"), h = o(\"../internals/to-length\"), g = o(\"../internals/to-object\"), f = o(\"../internals/array-species-create\"), r = o(\"../internals/create-property\"), s = o(\"../internals/array-method-has-species-support\"), o = o(\"../internals/array-method-uses-to-length\"), s = s(\"splice\"), o = o(\"splice\", { ACCESSORS: !0, 0: 0, 1: 2 }), i = Math.max, l = Math.min;\n      m({ target: \"Array\", proto: !0, forced: !s || !o }, { splice: function(P, a) {\n        var c, p, j, T, _, S, E = g(this), A = h(E.length), x = y(P, A), P = arguments.length;\n        if (P === 0 ? c = p = 0 : p = P === 1 ? (c = 0, A - x) : (c = P - 2, l(i(u(a), 0), A - x)), 9007199254740991 < A + c - p)\n          throw TypeError(\"Maximum allowed length exceeded\");\n        for (j = f(E, p), T = 0; T < p; T++)\n          (_ = x + T) in E && r(j, T, E[_]);\n        if (c < (j.length = p)) {\n          for (T = x; T < A - p; T++)\n            S = T + c, (_ = T + p) in E ? E[S] = E[_] : delete E[S];\n          for (T = A; A - p + c < T; T--)\n            delete E[T - 1];\n        } else if (p < c)\n          for (T = A - p; x < T; T--)\n            S = T + c - 1, (_ = T + p - 1) in E ? E[S] = E[_] : delete E[S];\n        for (T = 0; T < c; T++)\n          E[T + x] = arguments[T + 2];\n        return E.length = A - p + c, j;\n      } });\n    }, { \"../internals/array-method-has-species-support\": 21, \"../internals/array-method-uses-to-length\": 23, \"../internals/array-species-create\": 25, \"../internals/create-property\": 40, \"../internals/export\": 50, \"../internals/to-absolute-index\": 133, \"../internals/to-integer\": 136, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 171: [function(t, H, C) {\n      t(\"../internals/add-to-unscopables\")(\"flatMap\");\n    }, { \"../internals/add-to-unscopables\": 7 }], 172: [function(t, H, C) {\n      t(\"../internals/add-to-unscopables\")(\"flat\");\n    }, { \"../internals/add-to-unscopables\": 7 }], 173: [function(y, H, C) {\n      var m = y(\"../internals/descriptors\"), y = y(\"../internals/object-define-property\").f, u = Function.prototype, h = u.toString, g = /^\\s*function ([^ (]*)/;\n      !m || \"name\" in u || y(u, \"name\", { configurable: !0, get: function() {\n        try {\n          return h.call(this).match(g)[1];\n        } catch {\n          return \"\";\n        }\n      } });\n    }, { \"../internals/descriptors\": 43, \"../internals/object-define-property\": 93 }], 174: [function(y, H, C) {\n      var m = y(\"../internals/collection\"), y = y(\"../internals/collection-strong\");\n      H.exports = m(\"Map\", function(u) {\n        return function() {\n          return u(this, arguments.length ? arguments[0] : void 0);\n        };\n      }, y);\n    }, { \"../internals/collection\": 32, \"../internals/collection-strong\": 30 }], 175: [function(m, H, C) {\n      var m = m(\"../internals/export\"), y = Math.hypot, u = Math.abs, h = Math.sqrt;\n      m({ target: \"Math\", stat: !0, forced: !!y && y(1 / 0, NaN) !== 1 / 0 }, { hypot: function(g, f) {\n        for (var r, s, o = 0, i = 0, l = arguments.length, n = 0; i < l; )\n          n < (r = u(arguments[i++])) ? (o = o * (s = n / r) * s + 1, n = r) : o += 0 < r ? (s = r / n) * s : r;\n        return n === 1 / 0 ? 1 / 0 : n * h(o);\n      } });\n    }, { \"../internals/export\": 50 }], 176: [function(m, H, C) {\n      var m = m(\"../internals/export\"), y = Math.log, u = Math.LN2;\n      m({ target: \"Math\", stat: !0 }, { log2: function(h) {\n        return y(h) / u;\n      } });\n    }, { \"../internals/export\": 50 }], 177: [function(t, H, C) {\n      t(\"../internals/export\")({ target: \"Math\", stat: !0 }, { sign: t(\"../internals/math-sign\") });\n    }, { \"../internals/export\": 50, \"../internals/math-sign\": 81 }], 178: [function(t, H, C) {\n      function m(M) {\n        var R, L, F, V, G, U, W, X = o(M, !1);\n        if (typeof X == \"string\" && 2 < X.length) {\n          if ((M = (X = p(X)).charCodeAt(0)) === 43 || M === 45) {\n            if ((R = X.charCodeAt(2)) === 88 || R === 120)\n              return NaN;\n          } else if (M === 48) {\n            switch (X.charCodeAt(1)) {\n              case 66:\n              case 98:\n                L = 2, F = 49;\n                break;\n              case 79:\n              case 111:\n                L = 8, F = 55;\n                break;\n              default:\n                return +X;\n            }\n            for (G = (V = X.slice(2)).length, U = 0; U < G; U++)\n              if ((W = V.charCodeAt(U)) < 48 || F < W)\n                return NaN;\n            return parseInt(V, L);\n          }\n        }\n        return +X;\n      }\n      var y = t(\"../internals/descriptors\"), u = t(\"../internals/global\"), h = t(\"../internals/is-forced\"), g = t(\"../internals/redefine\"), f = t(\"../internals/has\"), r = t(\"../internals/classof-raw\"), s = t(\"../internals/inherit-if-required\"), o = t(\"../internals/to-primitive\"), i = t(\"../internals/fails\"), l = t(\"../internals/object-create\"), n = t(\"../internals/object-get-own-property-names\").f, a = t(\"../internals/object-get-own-property-descriptor\").f, c = t(\"../internals/object-define-property\").f, p = t(\"../internals/string-trim\").trim, j = \"Number\", T = u[j], _ = T.prototype, S = r(l(_)) == j;\n      if (h(j, !T(\" 0o1\") || !T(\"0b1\") || T(\"+0x1\"))) {\n        for (var E, A = function(R) {\n          var R = arguments.length < 1 ? 0 : R, L = this;\n          return L instanceof A && (S ? i(function() {\n            _.valueOf.call(L);\n          }) : r(L) != j) ? s(new T(m(R)), L, A) : m(R);\n        }, x = y ? n(T) : \"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger\".split(\",\"), P = 0; x.length > P; P++)\n          f(T, E = x[P]) && !f(A, E) && c(A, E, a(T, E));\n        (A.prototype = _).constructor = A, g(u, j, A);\n      }\n    }, { \"../internals/classof-raw\": 28, \"../internals/descriptors\": 43, \"../internals/fails\": 51, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/inherit-if-required\": 68, \"../internals/is-forced\": 74, \"../internals/object-create\": 91, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/object-get-own-property-names\": 96, \"../internals/redefine\": 109, \"../internals/string-trim\": 130, \"../internals/to-primitive\": 141 }], 179: [function(t, H, C) {\n      t(\"../internals/export\")({ target: \"Number\", stat: !0 }, { isFinite: t(\"../internals/number-is-finite\") });\n    }, { \"../internals/export\": 50, \"../internals/number-is-finite\": 89 }], 180: [function(f, H, C) {\n      function m(o, i, l) {\n        return i === 0 ? l : i % 2 == 1 ? m(o, i - 1, l * o) : m(o * o, i / 2, l);\n      }\n      var y = f(\"../internals/export\"), u = f(\"../internals/to-integer\"), h = f(\"../internals/this-number-value\"), g = f(\"../internals/string-repeat\"), f = f(\"../internals/fails\"), r = 1 .toFixed, s = Math.floor;\n      y({ target: \"Number\", proto: !0, forced: r && (8e-5.toFixed(3) !== \"0.000\" || 0.9.toFixed(0) !== \"1\" || 1.255.toFixed(2) !== \"1.25\" || 1000000000000000100 .toFixed(0) !== \"1000000000000000128\") || !f(function() {\n        r.call({});\n      }) }, { toFixed: function(j) {\n        function i(E, A) {\n          for (var x = -1, P = A; ++x < 6; )\n            P += E * T[x], T[x] = P % 1e7, P = s(P / 1e7);\n        }\n        function l(E) {\n          for (var A = 6, x = 0; 0 <= --A; )\n            x += T[A], T[A] = s(x / E), x = x % E * 1e7;\n        }\n        function n() {\n          for (var E, A = 6, x = \"\"; 0 <= --A; )\n            x === \"\" && A !== 0 && T[A] === 0 || (E = String(T[A]), x = x === \"\" ? E : x + g.call(\"0\", 7 - E.length) + E);\n          return x;\n        }\n        var a, c, p = h(this), j = u(j), T = [0, 0, 0, 0, 0, 0], _ = \"\", S = \"0\";\n        if (j < 0 || 20 < j)\n          throw RangeError(\"Incorrect fraction digits\");\n        if (p != p)\n          return \"NaN\";\n        if (p <= -1e21 || 1e21 <= p)\n          return String(p);\n        if (p < 0 && (_ = \"-\", p = -p), 1e-21 < p)\n          if (p = (a = function(E) {\n            for (var A = 0, x = E; 4096 <= x; )\n              A += 12, x /= 4096;\n            for (; 2 <= x; )\n              A += 1, x /= 2;\n            return A;\n          }(p * m(2, 69, 1)) - 69) < 0 ? p * m(2, -a, 1) : p / m(2, a, 1), p *= 4503599627370496, 0 < (a = 52 - a)) {\n            for (i(0, p), c = j; 7 <= c; )\n              i(1e7, 0), c -= 7;\n            for (i(m(10, c, 1), 0), c = a - 1; 23 <= c; )\n              l(1 << 23), c -= 23;\n            l(1 << c), i(1, 1), l(2), S = n();\n          } else\n            i(0, p), i(1 << -a, 0), S = n() + g.call(\"0\", j);\n        return S = 0 < j ? _ + ((p = S.length) <= j ? \"0.\" + g.call(\"0\", j - p) + S : S.slice(0, p - j) + \".\" + S.slice(p - j)) : _ + S;\n      } });\n    }, { \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/string-repeat\": 128, \"../internals/this-number-value\": 132, \"../internals/to-integer\": 136 }], 181: [function(y, H, C) {\n      var m = y(\"../internals/export\"), y = y(\"../internals/object-assign\");\n      m({ target: \"Object\", stat: !0, forced: Object.assign !== y }, { assign: y });\n    }, { \"../internals/export\": 50, \"../internals/object-assign\": 90 }], 182: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/iterate\"), u = t(\"../internals/create-property\");\n      m({ target: \"Object\", stat: !0 }, { fromEntries: function(h) {\n        var g = {};\n        return y(h, function(f, r) {\n          u(g, f, r);\n        }, void 0, !0), g;\n      } });\n    }, { \"../internals/create-property\": 40, \"../internals/export\": 50, \"../internals/iterate\": 78 }], 183: [function(h, H, C) {\n      var m = h(\"../internals/export\"), g = h(\"../internals/fails\"), y = h(\"../internals/to-indexed-object\"), u = h(\"../internals/object-get-own-property-descriptor\").f, h = h(\"../internals/descriptors\"), g = g(function() {\n        u(1);\n      });\n      m({ target: \"Object\", stat: !0, forced: !h || g, sham: !h }, { getOwnPropertyDescriptor: function(f, r) {\n        return u(y(f), r);\n      } });\n    }, { \"../internals/descriptors\": 43, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/to-indexed-object\": 135 }], 184: [function(u, H, C) {\n      var m = u(\"../internals/export\"), y = u(\"../internals/fails\"), u = u(\"../internals/object-get-own-property-names-external\").f;\n      m({ target: \"Object\", stat: !0, forced: y(function() {\n        return !Object.getOwnPropertyNames(1);\n      }) }, { getOwnPropertyNames: u });\n    }, { \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/object-get-own-property-names-external\": 95 }], 185: [function(g, H, C) {\n      var m = g(\"../internals/export\"), y = g(\"../internals/fails\"), u = g(\"../internals/to-object\"), h = g(\"../internals/object-get-prototype-of\"), g = g(\"../internals/correct-prototype-getter\");\n      m({ target: \"Object\", stat: !0, forced: y(function() {\n        h(1);\n      }), sham: !g }, { getPrototypeOf: function(f) {\n        return h(u(f));\n      } });\n    }, { \"../internals/correct-prototype-getter\": 35, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/object-get-prototype-of\": 98, \"../internals/to-object\": 138 }], 186: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/to-object\"), u = t(\"../internals/object-keys\");\n      m({ target: \"Object\", stat: !0, forced: t(\"../internals/fails\")(function() {\n        u(1);\n      }) }, { keys: function(h) {\n        return u(y(h));\n      } });\n    }, { \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/object-keys\": 100, \"../internals/to-object\": 138 }], 187: [function(u, H, C) {\n      var m = u(\"../internals/to-string-tag-support\"), y = u(\"../internals/redefine\"), u = u(\"../internals/object-to-string\");\n      m || y(Object.prototype, \"toString\", u, { unsafe: !0 });\n    }, { \"../internals/object-to-string\": 103, \"../internals/redefine\": 109, \"../internals/to-string-tag-support\": 142 }], 188: [function(xe, H, C) {\n      var m, y, u, h, g = xe(\"../internals/export\"), f = xe(\"../internals/is-pure\"), r = xe(\"../internals/global\"), s = xe(\"../internals/get-built-in\"), o = xe(\"../internals/native-promise-constructor\"), i = xe(\"../internals/redefine\"), l = xe(\"../internals/redefine-all\"), n = xe(\"../internals/set-to-string-tag\"), a = xe(\"../internals/set-species\"), c = xe(\"../internals/is-object\"), p = xe(\"../internals/a-function\"), j = xe(\"../internals/an-instance\"), T = xe(\"../internals/classof-raw\"), _ = xe(\"../internals/inspect-source\"), S = xe(\"../internals/iterate\"), E = xe(\"../internals/check-correctness-of-iteration\"), A = xe(\"../internals/species-constructor\"), x = xe(\"../internals/task\").set, P = xe(\"../internals/microtask\"), M = xe(\"../internals/promise-resolve\"), R = xe(\"../internals/host-report-errors\"), L = xe(\"../internals/new-promise-capability\"), F = xe(\"../internals/perform\"), V = xe(\"../internals/internal-state\"), G = xe(\"../internals/is-forced\"), De = xe(\"../internals/well-known-symbol\"), U = xe(\"../internals/engine-v8-version\"), W = De(\"species\"), X = \"Promise\", ne = V.get, b = V.set, O = V.getterFor(X), D = o, B = r.TypeError, Y = r.document, J = r.process, te = s(\"fetch\"), ce = L.f, re = ce, ue = T(J) == \"process\", le = !!(Y && Y.createEvent && r.dispatchEvent), K = \"unhandledrejection\", ae = \"rejectionhandled\", he = 1, _e = 2, fe = 1, ge = 2, xe = G(X, function() {\n        var Re, we;\n        return _(D) === String(D) && (U === 66 || !ue && typeof PromiseRejectionEvent != \"function\") ? !0 : !(!f || D.prototype.finally) || !(51 <= U && /native code/.test(D)) && (we = function(Z) {\n          Z(function() {\n          }, function() {\n          });\n        }, ((Re = D.resolve(1)).constructor = {})[W] = we, !(Re.then(function() {\n        }) instanceof we));\n      }), De = xe || !E(function(Re) {\n        D.all(Re).catch(function() {\n        });\n      }), Me = function(Re) {\n        var we;\n        return !(!c(Re) || typeof (we = Re.then) != \"function\") && we;\n      }, Qe = function(Re, we, Z) {\n        var $;\n        we.notified || (we.notified = !0, $ = we.reactions, P(function() {\n          for (var q, ee, pe = we.value, je = we.state == he, Ce = 0; $.length > Ce; ) {\n            var Fe, Ne, Be, We = $[Ce++], st = je ? We.ok : We.fail, nt = We.resolve, Ke = We.reject, at = We.domain;\n            try {\n              st ? (je || (we.rejection === ge && function(ot, bt) {\n                x.call(r, function() {\n                  ue ? J.emit(\"rejectionHandled\", ot) : ze(ae, ot, bt.value);\n                });\n              }(Re, we), we.rejection = fe), st === !0 ? Fe = pe : (at && at.enter(), Fe = st(pe), at && (at.exit(), Be = !0)), Fe === We.promise ? Ke(B(\"Promise-chain cycle\")) : (Ne = Me(Fe)) ? Ne.call(Fe, nt, Ke) : nt(Fe)) : Ke(pe);\n            } catch (ot) {\n              at && !Be && at.exit(), Ke(ot);\n            }\n          }\n          we.reactions = [], we.notified = !1, Z && !we.rejection && (q = Re, ee = we, x.call(r, function() {\n            var ot = ee.value, bt = Ve(ee);\n            if (bt && (bt = F(function() {\n              ue ? J.emit(\"unhandledRejection\", ot, q) : ze(K, q, ot);\n            }), ee.rejection = ue || Ve(ee) ? ge : fe, bt.error))\n              throw bt.value;\n          }));\n        }));\n      }, ze = function(Re, we, Z) {\n        var $;\n        le ? (($ = Y.createEvent(\"Event\")).promise = we, $.reason = Z, $.initEvent(Re, !1, !0), r.dispatchEvent($)) : $ = { promise: we, reason: Z }, (we = r[\"on\" + Re]) ? we($) : Re === K && R(\"Unhandled promise rejection\", Z);\n      }, Ve = function(Re) {\n        return Re.rejection !== fe && !Re.parent;\n      }, Xe = function(Re, we, Z, $) {\n        return function(q) {\n          Re(we, Z, q, $);\n        };\n      }, He = function(Re, we, Z, $) {\n        we.done || (we.done = !0, (we = $ || we).value = Z, we.state = _e, Qe(Re, we, !0));\n      }, ve = function(Re, we, Z, $) {\n        if (!we.done) {\n          we.done = !0, $ && (we = $);\n          try {\n            if (Re === Z)\n              throw B(\"Promise can't be resolved itself\");\n            var q = Me(Z);\n            q ? P(function() {\n              var ee = { done: !1 };\n              try {\n                q.call(Z, Xe(ve, Re, ee, we), Xe(He, Re, ee, we));\n              } catch (pe) {\n                He(Re, ee, pe, we);\n              }\n            }) : (we.value = Z, we.state = he, Qe(Re, we, !1));\n          } catch (ee) {\n            He(Re, { done: !1 }, ee, we);\n          }\n        }\n      };\n      xe && (D = function(Re) {\n        j(this, D, X), p(Re), m.call(this);\n        var we = ne(this);\n        try {\n          Re(Xe(ve, this, we), Xe(He, this, we));\n        } catch (Z) {\n          He(this, we, Z);\n        }\n      }, (m = function(Re) {\n        b(this, { type: X, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: 0, value: void 0 });\n      }).prototype = l(D.prototype, { then: function(Re, we) {\n        var Z = O(this), $ = ce(A(this, D));\n        return $.ok = typeof Re != \"function\" || Re, $.fail = typeof we == \"function\" && we, $.domain = ue ? J.domain : void 0, Z.parent = !0, Z.reactions.push($), Z.state != 0 && Qe(this, Z, !1), $.promise;\n      }, catch: function(Re) {\n        return this.then(void 0, Re);\n      } }), y = function() {\n        var Re = new m(), we = ne(Re);\n        this.promise = Re, this.resolve = Xe(ve, Re, we), this.reject = Xe(He, Re, we);\n      }, L.f = ce = function(Re) {\n        return Re === D || Re === u ? new y() : re(Re);\n      }, f || typeof o != \"function\" || (h = o.prototype.then, i(o.prototype, \"then\", function(Re, we) {\n        var Z = this;\n        return new D(function($, q) {\n          h.call(Z, $, q);\n        }).then(Re, we);\n      }, { unsafe: !0 }), typeof te == \"function\" && g({ global: !0, enumerable: !0, forced: !0 }, { fetch: function(Re) {\n        return M(D, te.apply(r, arguments));\n      } }))), g({ global: !0, wrap: !0, forced: xe }, { Promise: D }), n(D, X, !1, !0), a(X), u = s(X), g({ target: X, stat: !0, forced: xe }, { reject: function(Re) {\n        var we = ce(this);\n        return we.reject.call(void 0, Re), we.promise;\n      } }), g({ target: X, stat: !0, forced: f || xe }, { resolve: function(Re) {\n        return M(f && this === u ? D : this, Re);\n      } }), g({ target: X, stat: !0, forced: De }, { all: function(Re) {\n        var we = this, Z = ce(we), $ = Z.resolve, q = Z.reject, ee = F(function() {\n          var pe = p(we.resolve), je = [], Ce = 0, Fe = 1;\n          S(Re, function(Ne) {\n            var Be = Ce++, We = !1;\n            je.push(void 0), Fe++, pe.call(we, Ne).then(function(st) {\n              We || (We = !0, je[Be] = st, --Fe || $(je));\n            }, q);\n          }), --Fe || $(je);\n        });\n        return ee.error && q(ee.value), Z.promise;\n      }, race: function(Re) {\n        var we = this, Z = ce(we), $ = Z.reject, q = F(function() {\n          var ee = p(we.resolve);\n          S(Re, function(pe) {\n            ee.call(we, pe).then(Z.resolve, $);\n          });\n        });\n        return q.error && $(q.value), Z.promise;\n      } });\n    }, { \"../internals/a-function\": 5, \"../internals/an-instance\": 9, \"../internals/check-correctness-of-iteration\": 27, \"../internals/classof-raw\": 28, \"../internals/engine-v8-version\": 48, \"../internals/export\": 50, \"../internals/get-built-in\": 57, \"../internals/global\": 60, \"../internals/host-report-errors\": 63, \"../internals/inspect-source\": 69, \"../internals/internal-state\": 71, \"../internals/is-forced\": 74, \"../internals/is-object\": 75, \"../internals/is-pure\": 76, \"../internals/iterate\": 78, \"../internals/microtask\": 82, \"../internals/native-promise-constructor\": 83, \"../internals/new-promise-capability\": 87, \"../internals/perform\": 106, \"../internals/promise-resolve\": 107, \"../internals/redefine\": 109, \"../internals/redefine-all\": 108, \"../internals/set-species\": 117, \"../internals/set-to-string-tag\": 118, \"../internals/species-constructor\": 122, \"../internals/task\": 131, \"../internals/well-known-symbol\": 149 }], 189: [function(r, H, C) {\n      var m = r(\"../internals/export\"), l = r(\"../internals/get-built-in\"), y = r(\"../internals/a-function\"), u = r(\"../internals/an-object\"), h = r(\"../internals/is-object\"), g = r(\"../internals/object-create\"), f = r(\"../internals/function-bind\"), r = r(\"../internals/fails\"), s = l(\"Reflect\", \"construct\"), o = r(function() {\n        function n() {\n        }\n        return !(s(function() {\n        }, [], n) instanceof n);\n      }), i = !r(function() {\n        s(function() {\n        });\n      }), l = o || i;\n      m({ target: \"Reflect\", stat: !0, forced: l, sham: l }, { construct: function(n, a) {\n        y(n), u(a);\n        var c = arguments.length < 3 ? n : y(arguments[2]);\n        if (i && !o)\n          return s(n, a, c);\n        if (n == c) {\n          switch (a.length) {\n            case 0:\n              return new n();\n            case 1:\n              return new n(a[0]);\n            case 2:\n              return new n(a[0], a[1]);\n            case 3:\n              return new n(a[0], a[1], a[2]);\n            case 4:\n              return new n(a[0], a[1], a[2], a[3]);\n          }\n          var p = [null];\n          return p.push.apply(p, a), new (f.apply(n, p))();\n        }\n        return p = c.prototype, c = g(h(p) ? p : Object.prototype), p = Function.apply.call(n, c, a), h(p) ? p : c;\n      } });\n    }, { \"../internals/a-function\": 5, \"../internals/an-object\": 10, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/function-bind\": 56, \"../internals/get-built-in\": 57, \"../internals/is-object\": 75, \"../internals/object-create\": 91 }], 190: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/is-object\"), u = t(\"../internals/an-object\"), h = t(\"../internals/has\"), g = t(\"../internals/object-get-own-property-descriptor\"), f = t(\"../internals/object-get-prototype-of\");\n      m({ target: \"Reflect\", stat: !0 }, { get: function r(s, o) {\n        var i, l = arguments.length < 3 ? s : arguments[2];\n        return u(s) === l ? s[o] : (i = g.f(s, o)) ? h(i, \"value\") ? i.value : i.get === void 0 ? void 0 : i.get.call(l) : y(i = f(s)) ? r(i, o, l) : void 0;\n      } });\n    }, { \"../internals/an-object\": 10, \"../internals/export\": 50, \"../internals/has\": 61, \"../internals/is-object\": 75, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/object-get-prototype-of\": 98 }], 191: [function(t, H, C) {\n      var m = t(\"../internals/descriptors\"), y = t(\"../internals/global\"), u = t(\"../internals/is-forced\"), h = t(\"../internals/inherit-if-required\"), g = t(\"../internals/object-define-property\").f, f = t(\"../internals/object-get-own-property-names\").f, r = t(\"../internals/is-regexp\"), s = t(\"../internals/regexp-flags\"), o = t(\"../internals/regexp-sticky-helpers\"), i = t(\"../internals/redefine\"), l = t(\"../internals/fails\"), n = t(\"../internals/internal-state\").set, a = t(\"../internals/set-species\"), c = t(\"../internals/well-known-symbol\")(\"match\"), p = y.RegExp, j = p.prototype, T = /a/g, _ = /a/g, S = new p(T) !== T, E = o.UNSUPPORTED_Y;\n      if (m && u(\"RegExp\", !S || E || l(function() {\n        return _[c] = !1, p(T) != T || p(_) == _ || p(T, \"i\") != \"/a/i\";\n      }))) {\n        for (var A = function(M, R) {\n          var L, F = this instanceof A, V = r(M), G = R === void 0;\n          return !F && V && M.constructor === A && G ? M : (S ? V && !G && (M = M.source) : M instanceof A && (G && (R = s.call(M)), M = M.source), E && (L = !!R && -1 < R.indexOf(\"y\")) && (R = R.replace(/y/g, \"\")), V = h(S ? new p(M, R) : p(M, R), F ? this : j, A), E && L && n(V, { sticky: L }), V);\n        }, x = f(p), P = 0; x.length > P; )\n          (function(M) {\n            M in A || g(A, M, { configurable: !0, get: function() {\n              return p[M];\n            }, set: function(R) {\n              p[M] = R;\n            } });\n          })(x[P++]);\n        (j.constructor = A).prototype = j, i(y, \"RegExp\", A);\n      }\n      a(\"RegExp\");\n    }, { \"../internals/descriptors\": 43, \"../internals/fails\": 51, \"../internals/global\": 60, \"../internals/inherit-if-required\": 68, \"../internals/internal-state\": 71, \"../internals/is-forced\": 74, \"../internals/is-regexp\": 77, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-names\": 96, \"../internals/redefine\": 109, \"../internals/regexp-flags\": 112, \"../internals/regexp-sticky-helpers\": 113, \"../internals/set-species\": 117, \"../internals/well-known-symbol\": 149 }], 192: [function(y, H, C) {\n      var m = y(\"../internals/export\"), y = y(\"../internals/regexp-exec\");\n      m({ target: \"RegExp\", proto: !0, forced: /./.exec !== y }, { exec: y });\n    }, { \"../internals/export\": 50, \"../internals/regexp-exec\": 111 }], 193: [function(h, H, C) {\n      var m = h(\"../internals/redefine\"), y = h(\"../internals/an-object\"), r = h(\"../internals/fails\"), u = h(\"../internals/regexp-flags\"), h = \"toString\", g = RegExp.prototype, f = g[h], r = r(function() {\n        return f.call({ source: \"a\", flags: \"b\" }) != \"/a/b\";\n      }), s = f.name != h;\n      (r || s) && m(RegExp.prototype, h, function() {\n        var o = y(this), i = String(o.source), l = o.flags;\n        return \"/\" + i + \"/\" + String(l === void 0 && o instanceof RegExp && !(\"flags\" in g) ? u.call(o) : l);\n      }, { unsafe: !0 });\n    }, { \"../internals/an-object\": 10, \"../internals/fails\": 51, \"../internals/redefine\": 109, \"../internals/regexp-flags\": 112 }], 194: [function(y, H, C) {\n      var m = y(\"../internals/collection\"), y = y(\"../internals/collection-strong\");\n      H.exports = m(\"Set\", function(u) {\n        return function() {\n          return u(this, arguments.length ? arguments[0] : void 0);\n        };\n      }, y);\n    }, { \"../internals/collection\": 32, \"../internals/collection-strong\": 30 }], 195: [function(f, H, C) {\n      var m = f(\"../internals/export\"), y = f(\"../internals/object-get-own-property-descriptor\").f, u = f(\"../internals/to-length\"), h = f(\"../internals/not-a-regexp\"), g = f(\"../internals/require-object-coercible\"), o = f(\"../internals/correct-is-regexp-logic\"), f = f(\"../internals/is-pure\"), r = \"\".endsWith, s = Math.min, o = o(\"endsWith\");\n      m({ target: \"String\", proto: !0, forced: !!(f || o || !(m = y(String.prototype, \"endsWith\")) || m.writable) && !o }, { endsWith: function(i) {\n        var l = String(g(this)), n = (h(i), 1 < arguments.length ? arguments[1] : void 0), a = u(l.length), n = n === void 0 ? a : s(u(n), a), a = String(i);\n        return r ? r.call(l, a, n) : l.slice(n - a.length, n) === a;\n      } });\n    }, { \"../internals/correct-is-regexp-logic\": 34, \"../internals/export\": 50, \"../internals/is-pure\": 76, \"../internals/not-a-regexp\": 88, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/require-object-coercible\": 114, \"../internals/to-length\": 137 }], 196: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/not-a-regexp\"), u = t(\"../internals/require-object-coercible\");\n      m({ target: \"String\", proto: !0, forced: !t(\"../internals/correct-is-regexp-logic\")(\"includes\") }, { includes: function(h) {\n        return !!~String(u(this)).indexOf(y(h), 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/correct-is-regexp-logic\": 34, \"../internals/export\": 50, \"../internals/not-a-regexp\": 88, \"../internals/require-object-coercible\": 114 }], 197: [function(u, H, C) {\n      var m = u(\"../internals/string-multibyte\").charAt, y = u(\"../internals/internal-state\"), u = u(\"../internals/define-iterator\"), h = \"String Iterator\", g = y.set, f = y.getterFor(h);\n      u(String, \"String\", function(r) {\n        g(this, { type: h, string: String(r), index: 0 });\n      }, function() {\n        var r = f(this), s = r.string, o = r.index;\n        return o >= s.length ? { value: void 0, done: !0 } : (s = m(s, o), r.index += s.length, { value: s, done: !1 });\n      });\n    }, { \"../internals/define-iterator\": 41, \"../internals/internal-state\": 71, \"../internals/string-multibyte\": 124 }], 198: [function(t, H, C) {\n      var m = t(\"../internals/fix-regexp-well-known-symbol-logic\"), y = t(\"../internals/an-object\"), u = t(\"../internals/to-length\"), h = t(\"../internals/require-object-coercible\"), g = t(\"../internals/advance-string-index\"), f = t(\"../internals/regexp-exec-abstract\");\n      m(\"match\", 1, function(r, s, o) {\n        return [function(i) {\n          var l = h(this), n = i == null ? void 0 : i[r];\n          return n !== void 0 ? n.call(i, l) : new RegExp(i)[r](String(l));\n        }, function(i) {\n          var l = o(s, i, this);\n          if (l.done)\n            return l.value;\n          var n = y(i), a = String(this);\n          if (!n.global)\n            return f(n, a);\n          for (var c = n.unicode, p = [], j = n.lastIndex = 0; (T = f(n, a)) !== null; ) {\n            var T = String(T[0]);\n            (p[j] = T) === \"\" && (n.lastIndex = g(a, u(n.lastIndex), c)), j++;\n          }\n          return j === 0 ? null : p;\n        }];\n      });\n    }, { \"../internals/advance-string-index\": 8, \"../internals/an-object\": 10, \"../internals/fix-regexp-well-known-symbol-logic\": 52, \"../internals/regexp-exec-abstract\": 110, \"../internals/require-object-coercible\": 114, \"../internals/to-length\": 137 }], 199: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/string-pad\").start;\n      m({ target: \"String\", proto: !0, forced: t(\"../internals/string-pad-webkit-bug\") }, { padStart: function(u) {\n        return y(this, u, 1 < arguments.length ? arguments[1] : void 0);\n      } });\n    }, { \"../internals/export\": 50, \"../internals/string-pad\": 126, \"../internals/string-pad-webkit-bug\": 125 }], 200: [function(t, H, C) {\n      t(\"../internals/export\")({ target: \"String\", proto: !0 }, { repeat: t(\"../internals/string-repeat\") });\n    }, { \"../internals/export\": 50, \"../internals/string-repeat\": 128 }], 201: [function(t, H, C) {\n      var m = t(\"../internals/fix-regexp-well-known-symbol-logic\"), y = t(\"../internals/an-object\"), u = t(\"../internals/to-object\"), h = t(\"../internals/to-length\"), g = t(\"../internals/to-integer\"), f = t(\"../internals/require-object-coercible\"), r = t(\"../internals/advance-string-index\"), s = t(\"../internals/regexp-exec-abstract\"), o = Math.max, i = Math.min, l = Math.floor, n = /\\$([$&'`]|\\d\\d?|<[^>]*>)/g, a = /\\$([$&'`]|\\d\\d?)/g;\n      m(\"replace\", 2, function(c, p, j, T) {\n        var _ = T.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, S = T.REPLACE_KEEPS_$0, E = _ ? \"$\" : \"$0\";\n        return [function(A, x) {\n          var P = f(this), M = A == null ? void 0 : A[c];\n          return M !== void 0 ? M.call(A, P, x) : p.call(String(P), A, x);\n        }, function(A, x) {\n          if (!_ && S || typeof x == \"string\" && x.indexOf(E) === -1) {\n            var P = j(p, A, this, x);\n            if (P.done)\n              return P.value;\n          }\n          for (var M, R = y(A), L = String(this), F = typeof x == \"function\", V = (F || (x = String(x)), R.global), G = (V && (M = R.unicode, R.lastIndex = 0), []); (b = s(R, L)) !== null && (G.push(b), V); )\n            String(b[0]) === \"\" && (R.lastIndex = r(L, h(R.lastIndex), M));\n          for (var U, W = \"\", X = 0, ne = 0; ne < G.length; ne++) {\n            for (var b = G[ne], O = String(b[0]), D = o(i(g(b.index), L.length), 0), B = [], Y = 1; Y < b.length; Y++)\n              B.push((U = b[Y]) === void 0 ? U : String(U));\n            var J = b.groups, te = F ? (te = [O].concat(B, D, L), J !== void 0 && te.push(J), String(x.apply(void 0, te))) : function(ce, re, ue, le, K, ae) {\n              var he = ue + ce.length, _e = le.length, fe = a;\n              return K !== void 0 && (K = u(K), fe = n), p.call(ae, fe, function(ge, xe) {\n                var De;\n                switch (xe.charAt(0)) {\n                  case \"$\":\n                    return \"$\";\n                  case \"&\":\n                    return ce;\n                  case \"`\":\n                    return re.slice(0, ue);\n                  case \"'\":\n                    return re.slice(he);\n                  case \"<\":\n                    De = K[xe.slice(1, -1)];\n                    break;\n                  default:\n                    var Me, Qe = +xe;\n                    if (Qe == 0)\n                      return ge;\n                    if (_e < Qe)\n                      return (Me = l(Qe / 10)) !== 0 && Me <= _e ? le[Me - 1] === void 0 ? xe.charAt(1) : le[Me - 1] + xe.charAt(1) : ge;\n                    De = le[Qe - 1];\n                }\n                return De === void 0 ? \"\" : De;\n              });\n            }(O, L, D, B, J, x);\n            X <= D && (W += L.slice(X, D) + te, X = D + O.length);\n          }\n          return W + L.slice(X);\n        }];\n      });\n    }, { \"../internals/advance-string-index\": 8, \"../internals/an-object\": 10, \"../internals/fix-regexp-well-known-symbol-logic\": 52, \"../internals/regexp-exec-abstract\": 110, \"../internals/require-object-coercible\": 114, \"../internals/to-integer\": 136, \"../internals/to-length\": 137, \"../internals/to-object\": 138 }], 202: [function(t, H, C) {\n      var m = t(\"../internals/fix-regexp-well-known-symbol-logic\"), y = t(\"../internals/an-object\"), u = t(\"../internals/require-object-coercible\"), h = t(\"../internals/same-value\"), g = t(\"../internals/regexp-exec-abstract\");\n      m(\"search\", 1, function(f, r, s) {\n        return [function(o) {\n          var i = u(this), l = o == null ? void 0 : o[f];\n          return l !== void 0 ? l.call(o, i) : new RegExp(o)[f](String(i));\n        }, function(o) {\n          var i, l = s(r, o, this);\n          return l.done ? l.value : (l = y(o), o = String(this), i = l.lastIndex, h(i, 0) || (l.lastIndex = 0), o = g(l, o), h(l.lastIndex, i) || (l.lastIndex = i), o === null ? -1 : o.index);\n        }];\n      });\n    }, { \"../internals/an-object\": 10, \"../internals/fix-regexp-well-known-symbol-logic\": 52, \"../internals/regexp-exec-abstract\": 110, \"../internals/require-object-coercible\": 114, \"../internals/same-value\": 115 }], 203: [function(i, H, C) {\n      var m = i(\"../internals/fix-regexp-well-known-symbol-logic\"), y = i(\"../internals/is-regexp\"), u = i(\"../internals/an-object\"), h = i(\"../internals/require-object-coercible\"), g = i(\"../internals/species-constructor\"), f = i(\"../internals/advance-string-index\"), r = i(\"../internals/to-length\"), s = i(\"../internals/regexp-exec-abstract\"), o = i(\"../internals/regexp-exec\"), i = i(\"../internals/fails\"), l = [].push, n = Math.min, a = 4294967295, c = !i(function() {\n        return !RegExp(a, \"y\");\n      });\n      m(\"split\", 2, function(p, j, T) {\n        var _ = \"abbc\".split(/(b)*/)[1] == \"c\" || \"test\".split(/(?:)/, -1).length != 4 || \"ab\".split(/(?:ab)*/).length != 2 || \".\".split(/(.?)(.?)/).length != 4 || 1 < \".\".split(/()()/).length || \"\".split(/.?/).length ? function(S, E) {\n          var A = String(h(this)), x = E === void 0 ? a : E >>> 0;\n          if (x == 0)\n            return [];\n          if (S === void 0)\n            return [A];\n          if (!y(S))\n            return j.call(A, S, x);\n          for (var P, M, R, L = [], E = (S.ignoreCase ? \"i\" : \"\") + (S.multiline ? \"m\" : \"\") + (S.unicode ? \"u\" : \"\") + (S.sticky ? \"y\" : \"\"), F = 0, V = new RegExp(S.source, E + \"g\"); (P = o.call(V, A)) && !(F < (M = V.lastIndex) && (L.push(A.slice(F, P.index)), 1 < P.length && P.index < A.length && l.apply(L, P.slice(1)), R = P[0].length, F = M, L.length >= x)); )\n            V.lastIndex === P.index && V.lastIndex++;\n          return F === A.length ? !R && V.test(\"\") || L.push(\"\") : L.push(A.slice(F)), L.length > x ? L.slice(0, x) : L;\n        } : \"0\".split(void 0, 0).length ? function(S, E) {\n          return S === void 0 && E === 0 ? [] : j.call(this, S, E);\n        } : j;\n        return [function(S, E) {\n          var A = h(this), x = S == null ? void 0 : S[p];\n          return x !== void 0 ? x.call(S, A, E) : _.call(String(A), S, E);\n        }, function(P, E) {\n          var A = T(_, P, this, E, _ !== j);\n          if (A.done)\n            return A.value;\n          var A = u(P), x = String(this), P = g(A, RegExp), M = A.unicode, R = (A.ignoreCase ? \"i\" : \"\") + (A.multiline ? \"m\" : \"\") + (A.unicode ? \"u\" : \"\") + (c ? \"y\" : \"g\"), L = new P(c ? A : \"^(?:\" + A.source + \")\", R), F = E === void 0 ? a : E >>> 0;\n          if (F == 0)\n            return [];\n          if (x.length === 0)\n            return s(L, x) === null ? [x] : [];\n          for (var V = 0, G = 0, U = []; G < x.length; ) {\n            L.lastIndex = c ? G : 0;\n            var W, X = s(L, c ? x : x.slice(G));\n            if (X === null || (W = n(r(L.lastIndex + (c ? 0 : G)), x.length)) === V)\n              G = f(x, G, M);\n            else {\n              if (U.push(x.slice(V, G)), U.length === F)\n                return U;\n              for (var ne = 1; ne <= X.length - 1; ne++)\n                if (U.push(X[ne]), U.length === F)\n                  return U;\n              G = V = W;\n            }\n          }\n          return U.push(x.slice(V)), U;\n        }];\n      }, !c);\n    }, { \"../internals/advance-string-index\": 8, \"../internals/an-object\": 10, \"../internals/fails\": 51, \"../internals/fix-regexp-well-known-symbol-logic\": 52, \"../internals/is-regexp\": 77, \"../internals/regexp-exec\": 111, \"../internals/regexp-exec-abstract\": 110, \"../internals/require-object-coercible\": 114, \"../internals/species-constructor\": 122, \"../internals/to-length\": 137 }], 204: [function(f, H, C) {\n      var m = f(\"../internals/export\"), y = f(\"../internals/object-get-own-property-descriptor\").f, u = f(\"../internals/to-length\"), h = f(\"../internals/not-a-regexp\"), g = f(\"../internals/require-object-coercible\"), o = f(\"../internals/correct-is-regexp-logic\"), f = f(\"../internals/is-pure\"), r = \"\".startsWith, s = Math.min, o = o(\"startsWith\");\n      m({ target: \"String\", proto: !0, forced: !!(f || o || !(m = y(String.prototype, \"startsWith\")) || m.writable) && !o }, { startsWith: function(a) {\n        var l = String(g(this)), n = (h(a), u(s(1 < arguments.length ? arguments[1] : void 0, l.length))), a = String(a);\n        return r ? r.call(l, a, n) : l.slice(n, n + a.length) === a;\n      } });\n    }, { \"../internals/correct-is-regexp-logic\": 34, \"../internals/export\": 50, \"../internals/is-pure\": 76, \"../internals/not-a-regexp\": 88, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/require-object-coercible\": 114, \"../internals/to-length\": 137 }], 205: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/create-html\");\n      m({ target: \"String\", proto: !0, forced: t(\"../internals/string-html-forced\")(\"sub\") }, { sub: function() {\n        return y(this, \"sub\", \"\", \"\");\n      } });\n    }, { \"../internals/create-html\": 36, \"../internals/export\": 50, \"../internals/string-html-forced\": 123 }], 206: [function(t, H, C) {\n      var m = t(\"../internals/export\"), y = t(\"../internals/string-trim\").trim;\n      m({ target: \"String\", proto: !0, forced: t(\"../internals/string-trim-forced\")(\"trim\") }, { trim: function() {\n        return y(this);\n      } });\n    }, { \"../internals/export\": 50, \"../internals/string-trim\": 130, \"../internals/string-trim-forced\": 129 }], 207: [function(n, H, C) {\n      var m, y, u, h, g, f = n(\"../internals/export\"), r = n(\"../internals/descriptors\"), s = n(\"../internals/global\"), o = n(\"../internals/has\"), i = n(\"../internals/is-object\"), l = n(\"../internals/object-define-property\").f, n = n(\"../internals/copy-constructor-properties\"), a = s.Symbol;\n      !r || typeof a != \"function\" || \"description\" in a.prototype && a().description === void 0 || (m = {}, n(y = function() {\n        var c = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]), p = this instanceof y ? new a(c) : c === void 0 ? a() : a(c);\n        return c === \"\" && (m[p] = !0), p;\n      }, a), (s = y.prototype = a.prototype).constructor = y, u = s.toString, h = String(a(\"test\")) == \"Symbol(test)\", g = /^Symbol\\((.*)\\)[^)]+$/, l(s, \"description\", { configurable: !0, get: function() {\n        var c = i(this) ? this.valueOf() : this, p = u.call(c);\n        return o(m, c) ? \"\" : (c = h ? p.slice(7, -1) : p.replace(g, \"$1\")) === \"\" ? void 0 : c;\n      } }), f({ global: !0, forced: !0 }, { Symbol: y }));\n    }, { \"../internals/copy-constructor-properties\": 33, \"../internals/descriptors\": 43, \"../internals/export\": 50, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/is-object\": 75, \"../internals/object-define-property\": 93 }], 208: [function(t, H, C) {\n      t(\"../internals/define-well-known-symbol\")(\"iterator\");\n    }, { \"../internals/define-well-known-symbol\": 42 }], 209: [function(re, H, C) {\n      function m(q, ee) {\n        var pe = De[q] = A(ae[ce]);\n        return ue(pe, { type: te, tag: q, description: ee }), o || (pe.description = ee), pe;\n      }\n      function y(q, je) {\n        j(q);\n        var pe = _(je), je = x(pe).concat($(pe));\n        return Y(je, function(Ce) {\n          o && !Z.call(pe, Ce) || we(q, Ce, pe[Ce]);\n        }), q;\n      }\n      function u(je, Ce) {\n        var pe, je = _(je), Ce = S(Ce, !0);\n        if (je !== K || !a(De, Ce) || a(Me, Ce))\n          return !(pe = _e(je, Ce)) || !a(De, Ce) || a(je, J) && je[J][Ce] || (pe.enumerable = !0), pe;\n      }\n      function h(ee) {\n        var ee = ge(_(ee)), pe = [];\n        return Y(ee, function(je) {\n          a(De, je) || a(X, je) || pe.push(je);\n        }), pe;\n      }\n      var g = re(\"../internals/export\"), f = re(\"../internals/global\"), r = re(\"../internals/get-built-in\"), s = re(\"../internals/is-pure\"), o = re(\"../internals/descriptors\"), i = re(\"../internals/native-symbol\"), l = re(\"../internals/use-symbol-as-uid\"), n = re(\"../internals/fails\"), a = re(\"../internals/has\"), c = re(\"../internals/is-array\"), p = re(\"../internals/is-object\"), j = re(\"../internals/an-object\"), T = re(\"../internals/to-object\"), _ = re(\"../internals/to-indexed-object\"), S = re(\"../internals/to-primitive\"), E = re(\"../internals/create-property-descriptor\"), A = re(\"../internals/object-create\"), x = re(\"../internals/object-keys\"), P = re(\"../internals/object-get-own-property-names\"), M = re(\"../internals/object-get-own-property-names-external\"), R = re(\"../internals/object-get-own-property-symbols\"), L = re(\"../internals/object-get-own-property-descriptor\"), F = re(\"../internals/object-define-property\"), V = re(\"../internals/object-property-is-enumerable\"), G = re(\"../internals/create-non-enumerable-property\"), U = re(\"../internals/redefine\"), W = re(\"../internals/shared\"), Ve = re(\"../internals/shared-key\"), X = re(\"../internals/hidden-keys\"), ne = re(\"../internals/uid\"), b = re(\"../internals/well-known-symbol\"), O = re(\"../internals/well-known-symbol-wrapped\"), D = re(\"../internals/define-well-known-symbol\"), B = re(\"../internals/set-to-string-tag\"), Xe = re(\"../internals/internal-state\"), Y = re(\"../internals/array-iteration\").forEach, J = Ve(\"hidden\"), te = \"Symbol\", ce = \"prototype\", re = b(\"toPrimitive\"), ue = Xe.set, le = Xe.getterFor(te), K = Object[ce], ae = f.Symbol, he = r(\"JSON\", \"stringify\"), _e = L.f, fe = F.f, ge = M.f, xe = V.f, De = W(\"symbols\"), Me = W(\"op-symbols\"), Qe = W(\"string-to-symbol-registry\"), ze = W(\"symbol-to-string-registry\"), Ve = W(\"wks\"), Xe = f.QObject, He = !Xe || !Xe[ce] || !Xe[ce].findChild, ve = o && n(function() {\n        return A(fe({}, \"a\", { get: function() {\n          return fe(this, \"a\", { value: 7 }).a;\n        } })).a != 7;\n      }) ? function(q, ee, pe) {\n        var je = _e(K, ee);\n        je && delete K[ee], fe(q, ee, pe), je && q !== K && fe(K, ee, je);\n      } : fe, Re = l ? function(q) {\n        return typeof q == \"symbol\";\n      } : function(q) {\n        return Object(q) instanceof ae;\n      }, we = function(q, ee, pe) {\n        return q === K && we(Me, ee, pe), j(q), ee = S(ee, !0), j(pe), (a(De, ee) ? (pe.enumerable ? (a(q, J) && q[J][ee] && (q[J][ee] = !1), pe = A(pe, { enumerable: E(0, !1) })) : (a(q, J) || fe(q, J, E(1, {})), q[J][ee] = !0), ve) : fe)(q, ee, pe);\n      }, Z = function(ee) {\n        var ee = S(ee, !0), pe = xe.call(this, ee);\n        return !(this === K && a(De, ee) && !a(Me, ee)) && (!(pe || !a(this, ee) || !a(De, ee) || a(this, J) && this[J][ee]) || pe);\n      }, $ = function(pe) {\n        var ee = pe === K, pe = ge(ee ? Me : _(pe)), je = [];\n        return Y(pe, function(Ce) {\n          !a(De, Ce) || ee && !a(K, Ce) || je.push(De[Ce]);\n        }), je;\n      };\n      i || (U((ae = function() {\n        if (this instanceof ae)\n          throw TypeError(\"Symbol is not a constructor\");\n        var q = arguments.length && arguments[0] !== void 0 ? String(arguments[0]) : void 0, ee = ne(q), pe = function(je) {\n          this === K && pe.call(Me, je), a(this, J) && a(this[J], ee) && (this[J][ee] = !1), ve(this, ee, E(1, je));\n        };\n        return o && He && ve(K, ee, { configurable: !0, set: pe }), m(ee, q);\n      })[ce], \"toString\", function() {\n        return le(this).tag;\n      }), U(ae, \"withoutSetter\", function(q) {\n        return m(ne(q), q);\n      }), V.f = Z, F.f = we, L.f = u, P.f = M.f = h, R.f = $, O.f = function(q) {\n        return m(b(q), q);\n      }, o && (fe(ae[ce], \"description\", { configurable: !0, get: function() {\n        return le(this).description;\n      } }), s || U(K, \"propertyIsEnumerable\", Z, { unsafe: !0 }))), g({ global: !0, wrap: !0, forced: !i, sham: !i }, { Symbol: ae }), Y(x(Ve), function(q) {\n        D(q);\n      }), g({ target: te, stat: !0, forced: !i }, { for: function(pe) {\n        var ee, pe = String(pe);\n        return a(Qe, pe) ? Qe[pe] : (ee = ae(pe), Qe[pe] = ee, ze[ee] = pe, ee);\n      }, keyFor: function(q) {\n        if (!Re(q))\n          throw TypeError(q + \" is not a symbol\");\n        if (a(ze, q))\n          return ze[q];\n      }, useSetter: function() {\n        He = !0;\n      }, useSimple: function() {\n        He = !1;\n      } }), g({ target: \"Object\", stat: !0, forced: !i, sham: !o }, { create: function(q, ee) {\n        return ee === void 0 ? A(q) : y(A(q), ee);\n      }, defineProperty: we, defineProperties: y, getOwnPropertyDescriptor: u }), g({ target: \"Object\", stat: !0, forced: !i }, { getOwnPropertyNames: h, getOwnPropertySymbols: $ }), g({ target: \"Object\", stat: !0, forced: n(function() {\n        R.f(1);\n      }) }, { getOwnPropertySymbols: function(q) {\n        return R.f(T(q));\n      } }), he && g({ target: \"JSON\", stat: !0, forced: !i || n(function() {\n        var q = ae();\n        return he([q]) != \"[null]\" || he({ a: q }) != \"{}\" || he(Object(q)) != \"{}\";\n      }) }, { stringify: function(q, ee, pe) {\n        for (var je, Ce = [q], Fe = 1; Fe < arguments.length; )\n          Ce.push(arguments[Fe++]);\n        if ((p(je = ee) || q !== void 0) && !Re(q))\n          return c(ee) || (ee = function(Ne, Be) {\n            if (typeof je == \"function\" && (Be = je.call(this, Ne, Be)), !Re(Be))\n              return Be;\n          }), Ce[1] = ee, he.apply(null, Ce);\n      } }), ae[ce][re] || G(ae[ce], re, ae[ce].valueOf), B(ae, te), X[J] = !0;\n    }, { \"../internals/an-object\": 10, \"../internals/array-iteration\": 19, \"../internals/create-non-enumerable-property\": 38, \"../internals/create-property-descriptor\": 39, \"../internals/define-well-known-symbol\": 42, \"../internals/descriptors\": 43, \"../internals/export\": 50, \"../internals/fails\": 51, \"../internals/get-built-in\": 57, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/hidden-keys\": 62, \"../internals/internal-state\": 71, \"../internals/is-array\": 73, \"../internals/is-object\": 75, \"../internals/is-pure\": 76, \"../internals/native-symbol\": 84, \"../internals/object-create\": 91, \"../internals/object-define-property\": 93, \"../internals/object-get-own-property-descriptor\": 94, \"../internals/object-get-own-property-names\": 96, \"../internals/object-get-own-property-names-external\": 95, \"../internals/object-get-own-property-symbols\": 97, \"../internals/object-keys\": 100, \"../internals/object-property-is-enumerable\": 101, \"../internals/redefine\": 109, \"../internals/set-to-string-tag\": 118, \"../internals/shared\": 121, \"../internals/shared-key\": 119, \"../internals/to-indexed-object\": 135, \"../internals/to-object\": 138, \"../internals/to-primitive\": 141, \"../internals/uid\": 146, \"../internals/use-symbol-as-uid\": 147, \"../internals/well-known-symbol\": 149, \"../internals/well-known-symbol-wrapped\": 148 }], 210: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-copy-within\"), u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"copyWithin\", function(h, g) {\n        return y.call(u(this), h, g, 2 < arguments.length ? arguments[2] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-copy-within\": 14 }], 211: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").every, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"every\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19 }], 212: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-fill\"), u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"fill\", function(h) {\n        return y.apply(u(this), arguments);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-fill\": 15 }], 213: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").filter, u = t(\"../internals/species-constructor\"), h = m.aTypedArray, g = m.aTypedArrayConstructor;\n      (0, m.exportTypedArrayMethod)(\"filter\", function(f) {\n        for (var r = y(h(this), f, 1 < arguments.length ? arguments[1] : void 0), f = u(this, this.constructor), s = 0, o = r.length, i = new (g(f))(o); s < o; )\n          i[s] = r[s++];\n        return i;\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19, \"../internals/species-constructor\": 122 }], 214: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").findIndex, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"findIndex\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19 }], 215: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").find, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"find\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19 }], 216: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Float32\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 217: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Float64\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 218: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").forEach, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"forEach\", function(h) {\n        y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19 }], 219: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-includes\").includes, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"includes\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-includes\": 18 }], 220: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-includes\").indexOf, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"indexOf\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-includes\": 18 }], 221: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Int16\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 222: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Int32\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 223: [function(y, H, C) {\n      function m() {\n        return u.call(f(this));\n      }\n      var o = y(\"../internals/global\"), s = y(\"../internals/array-buffer-view-core\"), r = y(\"../modules/es.array.iterator\"), y = y(\"../internals/well-known-symbol\")(\"iterator\"), o = o.Uint8Array, u = r.values, h = r.keys, g = r.entries, f = s.aTypedArray, r = s.exportTypedArrayMethod, s = o && o.prototype[y], o = !!s && (s.name == \"values\" || s.name == null);\n      r(\"entries\", function() {\n        return g.call(f(this));\n      }), r(\"keys\", function() {\n        return h.call(f(this));\n      }), r(\"values\", m, !o), r(y, m, !o);\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/global\": 60, \"../internals/well-known-symbol\": 149, \"../modules/es.array.iterator\": 164 }], 224: [function(y, H, C) {\n      var y = y(\"../internals/array-buffer-view-core\"), m = y.aTypedArray, y = y.exportTypedArrayMethod, u = [].join;\n      y(\"join\", function(h) {\n        return u.apply(m(this), arguments);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12 }], 225: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-last-index-of\"), u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"lastIndexOf\", function(h) {\n        return y.apply(u(this), arguments);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-last-index-of\": 20 }], 226: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").map, u = t(\"../internals/species-constructor\"), h = m.aTypedArray, g = m.aTypedArrayConstructor;\n      (0, m.exportTypedArrayMethod)(\"map\", function(f) {\n        return y(h(this), f, 1 < arguments.length ? arguments[1] : void 0, function(r, s) {\n          return new (g(u(r, r.constructor)))(s);\n        });\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19, \"../internals/species-constructor\": 122 }], 227: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-reduce\").right, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"reduceRight\", function(h) {\n        return y(u(this), h, arguments.length, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-reduce\": 24 }], 228: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-reduce\").left, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"reduce\", function(h) {\n        return y(u(this), h, arguments.length, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-reduce\": 24 }], 229: [function(y, H, C) {\n      var y = y(\"../internals/array-buffer-view-core\"), m = y.aTypedArray, y = y.exportTypedArrayMethod, u = Math.floor;\n      y(\"reverse\", function() {\n        for (var h, g = m(this).length, f = u(g / 2), r = 0; r < f; )\n          h = this[r], this[r++] = this[--g], this[g] = h;\n        return this;\n      });\n    }, { \"../internals/array-buffer-view-core\": 12 }], 230: [function(g, H, C) {\n      var m = g(\"../internals/array-buffer-view-core\"), y = g(\"../internals/to-length\"), u = g(\"../internals/to-offset\"), h = g(\"../internals/to-object\"), g = g(\"../internals/fails\"), f = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"set\", function(r) {\n        f(this);\n        var s = u(1 < arguments.length ? arguments[1] : void 0, 1), o = this.length, i = h(r), l = y(i.length), n = 0;\n        if (o < l + s)\n          throw RangeError(\"Wrong length\");\n        for (; n < l; )\n          this[s + n] = i[n++];\n      }, g(function() {\n        new Int8Array(1).set({});\n      }));\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/fails\": 51, \"../internals/to-length\": 137, \"../internals/to-object\": 138, \"../internals/to-offset\": 139 }], 231: [function(y, H, C) {\n      var g = y(\"../internals/array-buffer-view-core\"), m = y(\"../internals/species-constructor\"), y = y(\"../internals/fails\"), u = g.aTypedArray, h = g.aTypedArrayConstructor, g = g.exportTypedArrayMethod, f = [].slice;\n      g(\"slice\", function(r, s) {\n        for (var o = f.call(u(this), r, s), r = m(this, this.constructor), i = 0, l = o.length, n = new (h(r))(l); i < l; )\n          n[i] = o[i++];\n        return n;\n      }, y(function() {\n        new Int8Array(1).slice();\n      }));\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/fails\": 51, \"../internals/species-constructor\": 122 }], 232: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/array-iteration\").some, u = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"some\", function(h) {\n        return y(u(this), h, 1 < arguments.length ? arguments[1] : void 0);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/array-iteration\": 19 }], 233: [function(y, H, C) {\n      var y = y(\"../internals/array-buffer-view-core\"), m = y.aTypedArray, y = y.exportTypedArrayMethod, u = [].sort;\n      y(\"sort\", function(h) {\n        return u.call(m(this), h);\n      });\n    }, { \"../internals/array-buffer-view-core\": 12 }], 234: [function(t, H, C) {\n      var m = t(\"../internals/array-buffer-view-core\"), y = t(\"../internals/to-length\"), u = t(\"../internals/to-absolute-index\"), h = t(\"../internals/species-constructor\"), g = m.aTypedArray;\n      (0, m.exportTypedArrayMethod)(\"subarray\", function(i, r) {\n        var s = g(this), o = s.length, i = u(i, o);\n        return new (h(s, s.constructor))(s.buffer, s.byteOffset + i * s.BYTES_PER_ELEMENT, y((r === void 0 ? o : u(r, o)) - i));\n      });\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/species-constructor\": 122, \"../internals/to-absolute-index\": 133, \"../internals/to-length\": 137 }], 235: [function(y, H, C) {\n      var g = y(\"../internals/global\"), m = y(\"../internals/array-buffer-view-core\"), y = y(\"../internals/fails\"), u = g.Int8Array, h = m.aTypedArray, g = m.exportTypedArrayMethod, f = [].toLocaleString, r = [].slice, s = !!u && y(function() {\n        f.call(new u(1));\n      });\n      g(\"toLocaleString\", function() {\n        return f.apply(s ? r.call(h(this)) : h(this), arguments);\n      }, y(function() {\n        return [1, 2].toLocaleString() != new u([1, 2]).toLocaleString();\n      }) || !y(function() {\n        u.prototype.toLocaleString.call([1, 2]);\n      }));\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/fails\": 51, \"../internals/global\": 60 }], 236: [function(y, H, C) {\n      var m = y(\"../internals/array-buffer-view-core\").exportTypedArrayMethod, g = y(\"../internals/fails\"), y = y(\"../internals/global\").Uint8Array, y = y && y.prototype || {}, u = [].toString, h = [].join, g = (g(function() {\n        u.call({});\n      }) && (u = function() {\n        return h.call(this);\n      }), y.toString != u);\n      m(\"toString\", u, g);\n    }, { \"../internals/array-buffer-view-core\": 12, \"../internals/fails\": 51, \"../internals/global\": 60 }], 237: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Uint16\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 238: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Uint32\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 239: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Uint8\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      });\n    }, { \"../internals/typed-array-constructor\": 143 }], 240: [function(t, H, C) {\n      t(\"../internals/typed-array-constructor\")(\"Uint8\", function(m) {\n        return function(y, u, h) {\n          return m(this, y, u, h);\n        };\n      }, !0);\n    }, { \"../internals/typed-array-constructor\": 143 }], 241: [function(a, j, C) {\n      function m(T) {\n        return function() {\n          return T(this, arguments.length ? arguments[0] : void 0);\n        };\n      }\n      var y, u, h, g, f, c = a(\"../internals/global\"), r = a(\"../internals/redefine-all\"), s = a(\"../internals/internal-metadata\"), o = a(\"../internals/collection\"), i = a(\"../internals/collection-weak\"), l = a(\"../internals/is-object\"), n = a(\"../internals/internal-state\").enforce, a = a(\"../internals/native-weak-map\"), c = !c.ActiveXObject && \"ActiveXObject\" in c, p = Object.isExtensible, j = j.exports = o(\"WeakMap\", m, i);\n      a && c && (y = i.getConstructor(m, \"WeakMap\", !0), s.REQUIRED = !0, o = j.prototype, u = o.delete, h = o.has, g = o.get, f = o.set, r(o, { delete: function(T) {\n        var _;\n        return l(T) && !p(T) ? ((_ = n(this)).frozen || (_.frozen = new y()), u.call(this, T) || _.frozen.delete(T)) : u.call(this, T);\n      }, has: function(T) {\n        var _;\n        return l(T) && !p(T) ? ((_ = n(this)).frozen || (_.frozen = new y()), h.call(this, T) || _.frozen.has(T)) : h.call(this, T);\n      }, get: function(T) {\n        var _;\n        return !l(T) || p(T) || ((_ = n(this)).frozen || (_.frozen = new y()), h.call(this, T)) ? g.call(this, T) : _.frozen.get(T);\n      }, set: function(T, _) {\n        var S;\n        return !l(T) || p(T) || ((S = n(this)).frozen || (S.frozen = new y()), h.call(this, T)) ? f.call(this, T, _) : S.frozen.set(T, _), this;\n      } }));\n    }, { \"../internals/collection\": 32, \"../internals/collection-weak\": 31, \"../internals/global\": 60, \"../internals/internal-metadata\": 70, \"../internals/internal-state\": 71, \"../internals/is-object\": 75, \"../internals/native-weak-map\": 86, \"../internals/redefine-all\": 108 }], 242: [function(t, H, C) {\n      var m, y = t(\"../internals/global\"), u = t(\"../internals/dom-iterables\"), h = t(\"../internals/array-for-each\"), g = t(\"../internals/create-non-enumerable-property\");\n      for (m in u) {\n        var f = y[m], f = f && f.prototype;\n        if (f && f.forEach !== h)\n          try {\n            g(f, \"forEach\", h);\n          } catch {\n            f.forEach = h;\n          }\n      }\n    }, { \"../internals/array-for-each\": 16, \"../internals/create-non-enumerable-property\": 38, \"../internals/dom-iterables\": 45, \"../internals/global\": 60 }], 243: [function(f, H, C) {\n      var m, y = f(\"../internals/global\"), u = f(\"../internals/dom-iterables\"), h = f(\"../modules/es.array.iterator\"), g = f(\"../internals/create-non-enumerable-property\"), f = f(\"../internals/well-known-symbol\"), r = f(\"iterator\"), s = f(\"toStringTag\"), o = h.values;\n      for (m in u) {\n        var i = y[m], l = i && i.prototype;\n        if (l) {\n          if (l[r] !== o)\n            try {\n              g(l, r, o);\n            } catch {\n              l[r] = o;\n            }\n          if (l[s] || g(l, s, m), u[m]) {\n            for (var n in h)\n              if (l[n] !== h[n])\n                try {\n                  g(l, n, h[n]);\n                } catch {\n                  l[n] = h[n];\n                }\n          }\n        }\n      }\n    }, { \"../internals/create-non-enumerable-property\": 38, \"../internals/dom-iterables\": 45, \"../internals/global\": 60, \"../internals/well-known-symbol\": 149, \"../modules/es.array.iterator\": 164 }], 244: [function(J, H, C) {\n      J(\"../modules/es.array.iterator\");\n      function m(te) {\n        try {\n          return decodeURIComponent(te);\n        } catch {\n          return te;\n        }\n      }\n      function y(te) {\n        return D[te];\n      }\n      function u(te) {\n        return encodeURIComponent(te).replace(O, y);\n      }\n      function h(te) {\n        this.entries.length = 0, B(this.entries, te);\n      }\n      function g(te, ce) {\n        if (te < ce)\n          throw TypeError(\"Not enough arguments\");\n      }\n      function f() {\n        c(this, f, F);\n        var te, ce, re, ue, le, K, ae, he, _e = 0 < arguments.length ? arguments[0] : void 0, fe = [];\n        if (G(this, { type: F, entries: fe, updateURL: function() {\n        }, updateSearchParams: h }), _e !== void 0)\n          if (S(_e))\n            if (typeof (te = P(_e)) == \"function\")\n              for (re = (ce = te.call(_e)).next; !(ue = re.call(ce)).done; ) {\n                if ((K = (le = (ue = x(_(ue.value))).next).call(ue)).done || (ae = le.call(ue)).done || !le.call(ue).done)\n                  throw TypeError(\"Expected sequence with length 2\");\n                fe.push({ key: K.value + \"\", value: ae.value + \"\" });\n              }\n            else\n              for (he in _e)\n                p(_e, he) && fe.push({ key: he, value: _e[he] + \"\" });\n          else\n            B(fe, typeof _e == \"string\" ? _e.charAt(0) === \"?\" ? _e.slice(1) : _e : _e + \"\");\n      }\n      var r = J(\"../internals/export\"), L = J(\"../internals/get-built-in\"), s = J(\"../internals/native-url\"), o = J(\"../internals/redefine\"), i = J(\"../internals/redefine-all\"), l = J(\"../internals/set-to-string-tag\"), n = J(\"../internals/create-iterator-constructor\"), a = J(\"../internals/internal-state\"), c = J(\"../internals/an-instance\"), p = J(\"../internals/has\"), j = J(\"../internals/function-bind-context\"), T = J(\"../internals/classof\"), _ = J(\"../internals/an-object\"), S = J(\"../internals/is-object\"), E = J(\"../internals/object-create\"), A = J(\"../internals/create-property-descriptor\"), x = J(\"../internals/get-iterator\"), P = J(\"../internals/get-iterator-method\"), J = J(\"../internals/well-known-symbol\"), M = L(\"fetch\"), R = L(\"Headers\"), L = J(\"iterator\"), F = \"URLSearchParams\", V = F + \"Iterator\", G = a.set, U = a.getterFor(F), W = a.getterFor(V), X = /\\+/g, ne = Array(4), b = function(te) {\n        var ce, re = te.replace(X, \" \"), ue = 4;\n        try {\n          return decodeURIComponent(re);\n        } catch {\n          for (; ue; )\n            re = re.replace((ce = ue--, ne[ce - 1] || (ne[ce - 1] = RegExp(\"((?:%[\\\\da-f]{2}){\" + ce + \"})\", \"gi\"))), m);\n          return re;\n        }\n      }, O = /[!'()~]|%20/g, D = { \"!\": \"%21\", \"'\": \"%27\", \"(\": \"%28\", \")\": \"%29\", \"~\": \"%7E\", \"%20\": \"+\" }, B = function(te, ce) {\n        if (ce)\n          for (var re, ue = ce.split(\"&\"), le = 0; le < ue.length; )\n            (re = ue[le++]).length && (re = re.split(\"=\"), te.push({ key: b(re.shift()), value: b(re.join(\"=\")) }));\n      }, Y = n(function(te, ce) {\n        G(this, { type: V, iterator: x(U(te).entries), kind: ce });\n      }, \"Iterator\", function() {\n        var ce = W(this), te = ce.kind, ce = ce.iterator.next(), re = ce.value;\n        return ce.done || (ce.value = te === \"keys\" ? re.key : te === \"values\" ? re.value : [re.key, re.value]), ce;\n      }), J = f.prototype;\n      i(J, { append: function(te, ce) {\n        g(arguments.length, 2);\n        var re = U(this);\n        re.entries.push({ key: te + \"\", value: ce + \"\" }), re.updateURL();\n      }, delete: function(te) {\n        g(arguments.length, 1);\n        for (var ce = U(this), re = ce.entries, ue = te + \"\", le = 0; le < re.length; )\n          re[le].key === ue ? re.splice(le, 1) : le++;\n        ce.updateURL();\n      }, get: function(te) {\n        g(arguments.length, 1);\n        for (var ce = U(this).entries, re = te + \"\", ue = 0; ue < ce.length; ue++)\n          if (ce[ue].key === re)\n            return ce[ue].value;\n        return null;\n      }, getAll: function(te) {\n        g(arguments.length, 1);\n        for (var ce = U(this).entries, re = te + \"\", ue = [], le = 0; le < ce.length; le++)\n          ce[le].key === re && ue.push(ce[le].value);\n        return ue;\n      }, has: function(te) {\n        g(arguments.length, 1);\n        for (var ce = U(this).entries, re = te + \"\", ue = 0; ue < ce.length; )\n          if (ce[ue++].key === re)\n            return !0;\n        return !1;\n      }, set: function(te, ce) {\n        g(arguments.length, 1);\n        for (var re, ue = U(this), le = ue.entries, K = !1, ae = te + \"\", he = ce + \"\", _e = 0; _e < le.length; _e++)\n          (re = le[_e]).key === ae && (K ? le.splice(_e--, 1) : (K = !0, re.value = he));\n        K || le.push({ key: ae, value: he }), ue.updateURL();\n      }, sort: function() {\n        for (var te, ce, re = U(this), ue = re.entries, le = ue.slice(), K = ue.length = 0; K < le.length; K++) {\n          for (te = le[K], ce = 0; ce < K; ce++)\n            if (ue[ce].key > te.key) {\n              ue.splice(ce, 0, te);\n              break;\n            }\n          ce === K && ue.push(te);\n        }\n        re.updateURL();\n      }, forEach: function(te) {\n        for (var ce, re = U(this).entries, ue = j(te, 1 < arguments.length ? arguments[1] : void 0, 3), le = 0; le < re.length; )\n          ue((ce = re[le++]).value, ce.key, this);\n      }, keys: function() {\n        return new Y(this, \"keys\");\n      }, values: function() {\n        return new Y(this, \"values\");\n      }, entries: function() {\n        return new Y(this, \"entries\");\n      } }, { enumerable: !0 }), o(J, L, J.entries), o(J, \"toString\", function() {\n        for (var te, ce = U(this).entries, re = [], ue = 0; ue < ce.length; )\n          te = ce[ue++], re.push(u(te.key) + \"=\" + u(te.value));\n        return re.join(\"&\");\n      }, { enumerable: !0 }), l(f, F), r({ global: !0, forced: !s }, { URLSearchParams: f }), s || typeof M != \"function\" || typeof R != \"function\" || r({ global: !0, enumerable: !0, forced: !0 }, { fetch: function(le) {\n        var ce, re, ue, le = [le];\n        return 1 < arguments.length && (S(ce = arguments[1]) && (re = ce.body, T(re) === F && ((ue = ce.headers ? new R(ce.headers) : new R()).has(\"content-type\") || ue.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"), ce = E(ce, { body: A(0, String(re)), headers: A(0, ue) }))), le.push(ce)), M.apply(this, le);\n      } }), H.exports = { URLSearchParams: f, getState: U };\n    }, { \"../internals/an-instance\": 9, \"../internals/an-object\": 10, \"../internals/classof\": 29, \"../internals/create-iterator-constructor\": 37, \"../internals/create-property-descriptor\": 39, \"../internals/export\": 50, \"../internals/function-bind-context\": 55, \"../internals/get-built-in\": 57, \"../internals/get-iterator\": 59, \"../internals/get-iterator-method\": 58, \"../internals/has\": 61, \"../internals/internal-state\": 71, \"../internals/is-object\": 75, \"../internals/native-url\": 85, \"../internals/object-create\": 91, \"../internals/redefine\": 109, \"../internals/redefine-all\": 108, \"../internals/set-to-string-tag\": 118, \"../internals/well-known-symbol\": 149, \"../modules/es.array.iterator\": 164 }], 245: [function(x, H, C) {\n      x(\"../modules/es.string.iterator\");\n      function m(ie) {\n        var Oe, Ge, Le, rt;\n        if (typeof ie == \"number\") {\n          for (Oe = [], Ge = 0; Ge < 4; Ge++)\n            Oe.unshift(ie % 256), ie = V(ie / 256);\n          return Oe.join(\".\");\n        }\n        if (typeof ie != \"object\")\n          return ie;\n        for (Oe = \"\", Le = ae(ie), Ge = 0; Ge < 8; Ge++)\n          rt && ie[Ge] === 0 || (rt = rt && !1, Le === Ge ? (Oe += Ge ? \":\" : \"::\", rt = !0) : (Oe += ie[Ge].toString(16), Ge < 7 && (Oe += \":\")));\n        return \"[\" + Oe + \"]\";\n      }\n      function y(ie) {\n        return !ie.host || ie.cannotBeABaseURL || ie.scheme == \"file\";\n      }\n      function u(ie, Oe, Ge, Le) {\n        var rt, Pe, ct, qe = Ge || Re, ut = 0, Ze = \"\", At = !1, Ut = !1, Ct = !1;\n        for (Ge || (ie.scheme = \"\", ie.username = \"\", ie.password = \"\", ie.host = null, ie.port = null, ie.path = [], ie.query = null, ie.fragment = null, ie.cannotBeABaseURL = !1, Oe = Oe.replace(ue, \"\")), Oe = Oe.replace(le, \"\"), rt = T(Oe); ut <= rt.length; ) {\n          switch (Pe = rt[ut], qe) {\n            case Re:\n              if (!Pe || !b.test(Pe)) {\n                if (Ge)\n                  return W;\n                qe = Z;\n                continue;\n              }\n              Ze += Pe.toLowerCase(), qe = we;\n              break;\n            case we:\n              if (Pe && (O.test(Pe) || Pe == \"+\" || Pe == \"-\" || Pe == \".\"))\n                Ze += Pe.toLowerCase();\n              else {\n                if (Pe != \":\") {\n                  if (Ge)\n                    return W;\n                  Ze = \"\", qe = Z, ut = 0;\n                  continue;\n                }\n                if (Ge && (Me(ie) != p(De, Ze) || Ze == \"file\" && (Qe(ie) || ie.port !== null) || ie.scheme == \"file\" && !ie.host))\n                  return;\n                if (ie.scheme = Ze, Ge)\n                  return void (Me(ie) && De[ie.scheme] == ie.port && (ie.port = null));\n                Ze = \"\", ie.scheme == \"file\" ? qe = st : Me(ie) && Le && Le.scheme == ie.scheme ? qe = $ : Me(ie) ? qe = je : rt[ut + 1] == \"/\" ? (qe = q, ut++) : (ie.cannotBeABaseURL = !0, ie.path.push(\"\"), qe = bt);\n              }\n              break;\n            case Z:\n              if (!Le || Le.cannotBeABaseURL && Pe != \"#\")\n                return W;\n              if (Le.cannotBeABaseURL && Pe == \"#\") {\n                ie.scheme = Le.scheme, ie.path = Le.path.slice(), ie.query = Le.query, ie.fragment = \"\", ie.cannotBeABaseURL = !0, qe = Mt;\n                break;\n              }\n              qe = Le.scheme == \"file\" ? st : ee;\n              continue;\n            case $:\n              if (Pe != \"/\" || rt[ut + 1] != \"/\") {\n                qe = ee;\n                continue;\n              }\n              qe = Ce, ut++;\n              break;\n            case q:\n              if (Pe == \"/\") {\n                qe = Fe;\n                break;\n              }\n              qe = ot;\n              continue;\n            case ee:\n              if (ie.scheme = Le.scheme, Pe == f)\n                ie.username = Le.username, ie.password = Le.password, ie.host = Le.host, ie.port = Le.port, ie.path = Le.path.slice(), ie.query = Le.query;\n              else if (Pe == \"/\" || Pe == \"\\\\\" && Me(ie))\n                qe = pe;\n              else if (Pe == \"?\")\n                ie.username = Le.username, ie.password = Le.password, ie.host = Le.host, ie.port = Le.port, ie.path = Le.path.slice(), ie.query = \"\", qe = It;\n              else {\n                if (Pe != \"#\") {\n                  ie.username = Le.username, ie.password = Le.password, ie.host = Le.host, ie.port = Le.port, ie.path = Le.path.slice(), ie.path.pop(), qe = ot;\n                  continue;\n                }\n                ie.username = Le.username, ie.password = Le.password, ie.host = Le.host, ie.port = Le.port, ie.path = Le.path.slice(), ie.query = Le.query, ie.fragment = \"\", qe = Mt;\n              }\n              break;\n            case pe:\n              if (!Me(ie) || Pe != \"/\" && Pe != \"\\\\\") {\n                if (Pe != \"/\") {\n                  ie.username = Le.username, ie.password = Le.password, ie.host = Le.host, ie.port = Le.port, qe = ot;\n                  continue;\n                }\n                qe = Fe;\n              } else\n                qe = Ce;\n              break;\n            case je:\n              if (qe = Ce, Pe != \"/\" || Ze.charAt(ut + 1) != \"/\")\n                continue;\n              ut++;\n              break;\n            case Ce:\n              if (Pe == \"/\" || Pe == \"\\\\\")\n                break;\n              qe = Fe;\n              continue;\n            case Fe:\n              if (Pe == \"@\") {\n                At && (Ze = \"%40\" + Ze);\n                for (var At = !0, Nt = T(Ze), Kt = 0; Kt < Nt.length; Kt++) {\n                  var Xt = Nt[Kt];\n                  Xt != \":\" || Ct ? (Xt = xe(Xt, ge), Ct ? ie.password += Xt : ie.username += Xt) : Ct = !0;\n                }\n                Ze = \"\";\n              } else if (Pe == f || Pe == \"/\" || Pe == \"?\" || Pe == \"#\" || Pe == \"\\\\\" && Me(ie)) {\n                if (At && Ze == \"\")\n                  return U;\n                ut -= T(Ze).length + 1, Ze = \"\", qe = Ne;\n              } else\n                Ze += Pe;\n              break;\n            case Ne:\n            case Be:\n              if (Ge && ie.scheme == \"file\") {\n                qe = Ke;\n                continue;\n              }\n              if (Pe != \":\" || Ut) {\n                if (Pe == f || Pe == \"/\" || Pe == \"?\" || Pe == \"#\" || Pe == \"\\\\\" && Me(ie)) {\n                  if (Me(ie) && Ze == \"\")\n                    return X;\n                  if (Ge && Ze == \"\" && (Qe(ie) || ie.port !== null))\n                    return;\n                  if (ct = K(ie, Ze))\n                    return ct;\n                  if (Ze = \"\", qe = at, Ge)\n                    return;\n                  continue;\n                }\n                Pe == \"[\" ? Ut = !0 : Pe == \"]\" && (Ut = !1), Ze += Pe;\n              } else {\n                if (Ze == \"\")\n                  return X;\n                if (ct = K(ie, Ze))\n                  return ct;\n                if (Ze = \"\", qe = We, Ge == Be)\n                  return;\n              }\n              break;\n            case We:\n              if (!D.test(Pe)) {\n                if (Pe == f || Pe == \"/\" || Pe == \"?\" || Pe == \"#\" || Pe == \"\\\\\" && Me(ie) || Ge) {\n                  if (Ze != \"\") {\n                    var Jt = parseInt(Ze, 10);\n                    if (65535 < Jt)\n                      return ne;\n                    ie.port = Me(ie) && Jt === De[ie.scheme] ? null : Jt, Ze = \"\";\n                  }\n                  if (Ge)\n                    return;\n                  qe = at;\n                  continue;\n                }\n                return ne;\n              }\n              Ze += Pe;\n              break;\n            case st:\n              if (ie.scheme = \"file\", Pe == \"/\" || Pe == \"\\\\\")\n                qe = nt;\n              else {\n                if (!Le || Le.scheme != \"file\") {\n                  qe = ot;\n                  continue;\n                }\n                if (Pe == f)\n                  ie.host = Le.host, ie.path = Le.path.slice(), ie.query = Le.query;\n                else if (Pe == \"?\")\n                  ie.host = Le.host, ie.path = Le.path.slice(), ie.query = \"\", qe = It;\n                else {\n                  if (Pe != \"#\") {\n                    Ve(rt.slice(ut).join(\"\")) || (ie.host = Le.host, ie.path = Le.path.slice(), Xe(ie)), qe = ot;\n                    continue;\n                  }\n                  ie.host = Le.host, ie.path = Le.path.slice(), ie.query = Le.query, ie.fragment = \"\", qe = Mt;\n                }\n              }\n              break;\n            case nt:\n              if (Pe == \"/\" || Pe == \"\\\\\") {\n                qe = Ke;\n                break;\n              }\n              Le && Le.scheme == \"file\" && !Ve(rt.slice(ut).join(\"\")) && (ze(Le.path[0], !0) ? ie.path.push(Le.path[0]) : ie.host = Le.host), qe = ot;\n              continue;\n            case Ke:\n              if (Pe == f || Pe == \"/\" || Pe == \"\\\\\" || Pe == \"?\" || Pe == \"#\") {\n                if (!Ge && ze(Ze))\n                  qe = ot;\n                else {\n                  if (Ze == \"\") {\n                    if (ie.host = \"\", Ge)\n                      return;\n                  } else {\n                    if (ct = K(ie, Ze))\n                      return ct;\n                    if (ie.host == \"localhost\" && (ie.host = \"\"), Ge)\n                      return;\n                    Ze = \"\";\n                  }\n                  qe = at;\n                }\n                continue;\n              }\n              Ze += Pe;\n              break;\n            case at:\n              if (Me(ie)) {\n                if (qe = ot, Pe != \"/\" && Pe != \"\\\\\")\n                  continue;\n              } else if (Ge || Pe != \"?\")\n                if (Ge || Pe != \"#\") {\n                  if (Pe != f && (qe = ot, Pe != \"/\"))\n                    continue;\n                } else\n                  ie.fragment = \"\", qe = Mt;\n              else\n                ie.query = \"\", qe = It;\n              break;\n            case ot:\n              if (Pe == f || Pe == \"/\" || Pe == \"\\\\\" && Me(ie) || !Ge && (Pe == \"?\" || Pe == \"#\")) {\n                if (ve(Ze) ? (Xe(ie), Pe == \"/\" || Pe == \"\\\\\" && Me(ie) || ie.path.push(\"\")) : He(Ze) ? Pe == \"/\" || Pe == \"\\\\\" && Me(ie) || ie.path.push(\"\") : (ie.scheme == \"file\" && !ie.path.length && ze(Ze) && (ie.host && (ie.host = \"\"), Ze = Ze.charAt(0) + \":\"), ie.path.push(Ze)), Ze = \"\", ie.scheme == \"file\" && (Pe == f || Pe == \"?\" || Pe == \"#\"))\n                  for (; 1 < ie.path.length && ie.path[0] === \"\"; )\n                    ie.path.shift();\n                Pe == \"?\" ? (ie.query = \"\", qe = It) : Pe == \"#\" && (ie.fragment = \"\", qe = Mt);\n              } else\n                Ze += xe(Pe, fe);\n              break;\n            case bt:\n              Pe == \"?\" ? (ie.query = \"\", qe = It) : Pe == \"#\" ? (ie.fragment = \"\", qe = Mt) : Pe != f && (ie.path[0] += xe(Pe, he));\n              break;\n            case It:\n              Ge || Pe != \"#\" ? Pe != f && (Pe == \"'\" && Me(ie) ? ie.query += \"%27\" : ie.query += Pe == \"#\" ? \"%23\" : xe(Pe, he)) : (ie.fragment = \"\", qe = Mt);\n              break;\n            case Mt:\n              Pe != f && (ie.fragment += xe(Pe, _e));\n          }\n          ut++;\n        }\n      }\n      function h(Pe) {\n        var Oe, Ge, Le = c(this, h, \"URL\"), rt = 1 < arguments.length ? arguments[1] : void 0, Pe = String(Pe), ct = L(Le, { type: \"URL\" });\n        if (rt !== void 0) {\n          if (rt instanceof h)\n            Oe = F(rt);\n          else if (Ge = u(Oe = {}, String(rt)))\n            throw TypeError(Ge);\n        }\n        if (Ge = u(ct, Pe, null, Oe))\n          throw TypeError(Ge);\n        var qe = ct.searchParams = new M();\n        (rt = R(qe)).updateSearchParams(ct.query), rt.updateURL = function() {\n          ct.query = String(qe) || null;\n        }, i || (Le.href = jt.call(Le), Le.origin = ht.call(Le), Le.protocol = Dt.call(Le), Le.username = Pt.call(Le), Le.password = gt.call(Le), Le.host = Ft.call(Le), Le.hostname = me.call(Le), Le.port = Ue.call(Le), Le.pathname = Ye.call(Le), Le.search = it.call(Le), Le.searchParams = ft.call(Le), Le.hash = pt.call(Le));\n      }\n      function g(ie, Oe) {\n        return { get: ie, set: Oe, configurable: !0, enumerable: !0 };\n      }\n      var f, r, s, o = x(\"../internals/export\"), i = x(\"../internals/descriptors\"), l = x(\"../internals/native-url\"), mt = x(\"../internals/global\"), n = x(\"../internals/object-define-properties\"), a = x(\"../internals/redefine\"), c = x(\"../internals/an-instance\"), p = x(\"../internals/has\"), j = x(\"../internals/object-assign\"), T = x(\"../internals/array-from\"), _ = x(\"../internals/string-multibyte\").codeAt, S = x(\"../internals/string-punycode-to-ascii\"), E = x(\"../internals/set-to-string-tag\"), A = x(\"../modules/web.url-search-params\"), x = x(\"../internals/internal-state\"), P = mt.URL, M = A.URLSearchParams, R = A.getState, L = x.set, F = x.getterFor(\"URL\"), V = Math.floor, G = Math.pow, U = \"Invalid authority\", W = \"Invalid scheme\", X = \"Invalid host\", ne = \"Invalid port\", b = /[A-Za-z]/, O = /[\\d+-.A-Za-z]/, D = /\\d/, B = /^(0x|0X)/, Y = /^[0-7]+$/, J = /^\\d+$/, te = /^[\\dA-Fa-f]+$/, ce = /[\\u0000\\u0009\\u000A\\u000D #%/:?@[\\\\]]/, re = /[\\u0000\\u0009\\u000A\\u000D #/:?@[\\\\]]/, ue = /^[\\u0000-\\u001F ]+|[\\u0000-\\u001F ]+$/g, le = /[\\u0009\\u000A\\u000D]/g, K = function(ie, Oe) {\n        var Ge, Le, rt;\n        if (Oe.charAt(0) == \"[\")\n          return Oe.charAt(Oe.length - 1) == \"]\" && (Ge = function(Pe) {\n            var ct = [0, 0, 0, 0, 0, 0, 0, 0], qe = 0, ut = null, Ze = 0, At, Ut, Ct, Nt, Kt, Xt, Jt, Bt = function() {\n              return Pe.charAt(Ze);\n            };\n            if (Bt() == \":\") {\n              if (Pe.charAt(1) != \":\")\n                return;\n              Ze += 2, qe++, ut = qe;\n            }\n            for (; Bt(); ) {\n              if (qe == 8)\n                return;\n              if (Bt() == \":\") {\n                if (ut !== null)\n                  return;\n                Ze++, qe++, ut = qe;\n                continue;\n              }\n              for (At = Ut = 0; Ut < 4 && te.test(Bt()); )\n                At = At * 16 + parseInt(Bt(), 16), Ze++, Ut++;\n              if (Bt() == \".\") {\n                if (Ut == 0 || (Ze -= Ut, qe > 6))\n                  return;\n                for (Ct = 0; Bt(); ) {\n                  if (Nt = null, Ct > 0)\n                    if (Bt() == \".\" && Ct < 4)\n                      Ze++;\n                    else\n                      return;\n                  if (!D.test(Bt()))\n                    return;\n                  for (; D.test(Bt()); ) {\n                    if (Kt = parseInt(Bt(), 10), Nt === null)\n                      Nt = Kt;\n                    else {\n                      if (Nt == 0)\n                        return;\n                      Nt = Nt * 10 + Kt;\n                    }\n                    if (Nt > 255)\n                      return;\n                    Ze++;\n                  }\n                  ct[qe] = ct[qe] * 256 + Nt, Ct++, (Ct == 2 || Ct == 4) && qe++;\n                }\n                if (Ct != 4)\n                  return;\n                break;\n              } else if (Bt() == \":\") {\n                if (Ze++, !Bt())\n                  return;\n              } else if (Bt())\n                return;\n              ct[qe++] = At;\n            }\n            if (ut !== null)\n              for (Xt = qe - ut, qe = 7; qe != 0 && Xt > 0; )\n                Jt = ct[qe], ct[qe--] = ct[ut + Xt - 1], ct[ut + --Xt] = Jt;\n            else if (qe != 8)\n              return;\n            return ct;\n          }(Oe.slice(1, -1))) ? void (ie.host = Ge) : X;\n        if (Me(ie))\n          return Oe = S(Oe), ce.test(Oe) || (Ge = function(Pe) {\n            var ct = Pe.split(\".\"), qe, ut, Ze, At, Ut, Ct, Nt;\n            if (ct.length && ct[ct.length - 1] == \"\" && ct.pop(), (qe = ct.length) > 4)\n              return Pe;\n            for (ut = [], Ze = 0; Ze < qe; Ze++) {\n              if (At = ct[Ze], At == \"\")\n                return Pe;\n              if (Ut = 10, At.length > 1 && At.charAt(0) == \"0\" && (Ut = B.test(At) ? 16 : 8, At = At.slice(Ut == 8 ? 1 : 2)), At === \"\")\n                Ct = 0;\n              else {\n                if (!(Ut == 10 ? J : Ut == 8 ? Y : te).test(At))\n                  return Pe;\n                Ct = parseInt(At, Ut);\n              }\n              ut.push(Ct);\n            }\n            for (Ze = 0; Ze < qe; Ze++)\n              if (Ct = ut[Ze], Ze == qe - 1) {\n                if (Ct >= G(256, 5 - qe))\n                  return null;\n              } else if (Ct > 255)\n                return null;\n            for (Nt = ut.pop(), Ze = 0; Ze < ut.length; Ze++)\n              Nt += ut[Ze] * G(256, 3 - Ze);\n            return Nt;\n          }(Oe)) === null ? X : void (ie.host = Ge);\n        if (re.test(Oe))\n          return X;\n        for (Ge = \"\", Le = T(Oe), rt = 0; rt < Le.length; rt++)\n          Ge += xe(Le[rt], he);\n        ie.host = Ge;\n      }, ae = function(ie) {\n        for (var Oe = null, Ge = 1, Le = null, rt = 0, Pe = 0; Pe < 8; Pe++)\n          ie[Pe] !== 0 ? (Ge < rt && (Oe = Le, Ge = rt), Le = null, rt = 0) : (Le === null && (Le = Pe), ++rt);\n        return Ge < rt && (Oe = Le, Ge = rt), Oe;\n      }, he = {}, _e = j({}, he, { \" \": 1, '\"': 1, \"<\": 1, \">\": 1, \"`\": 1 }), fe = j({}, _e, { \"#\": 1, \"?\": 1, \"{\": 1, \"}\": 1 }), ge = j({}, fe, { \"/\": 1, \":\": 1, \";\": 1, \"=\": 1, \"@\": 1, \"[\": 1, \"\\\\\": 1, \"]\": 1, \"^\": 1, \"|\": 1 }), xe = function(ie, Oe) {\n        var Ge = _(ie, 0);\n        return 32 < Ge && Ge < 127 && !p(Oe, ie) ? ie : encodeURIComponent(ie);\n      }, De = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, Me = function(ie) {\n        return p(De, ie.scheme);\n      }, Qe = function(ie) {\n        return ie.username != \"\" || ie.password != \"\";\n      }, ze = function(ie, Oe) {\n        return ie.length == 2 && b.test(ie.charAt(0)) && ((ie = ie.charAt(1)) == \":\" || !Oe && ie == \"|\");\n      }, Ve = function(ie) {\n        return 1 < ie.length && ze(ie.slice(0, 2)) && (ie.length == 2 || (ie = ie.charAt(2)) === \"/\" || ie === \"\\\\\" || ie === \"?\" || ie === \"#\");\n      }, Xe = function(ie) {\n        var Oe = ie.path, Ge = Oe.length;\n        !Ge || ie.scheme == \"file\" && Ge == 1 && ze(Oe[0], !0) || Oe.pop();\n      }, He = function(ie) {\n        return ie === \".\" || ie.toLowerCase() === \"%2e\";\n      }, ve = function(ie) {\n        return (ie = ie.toLowerCase()) === \"..\" || ie === \"%2e.\" || ie === \".%2e\" || ie === \"%2e%2e\";\n      }, Re = {}, we = {}, Z = {}, $ = {}, q = {}, ee = {}, pe = {}, je = {}, Ce = {}, Fe = {}, Ne = {}, Be = {}, We = {}, st = {}, nt = {}, Ke = {}, at = {}, ot = {}, bt = {}, It = {}, Mt = {}, mt = h.prototype, jt = function() {\n        var ie = F(this), Oe = ie.scheme, Ge = ie.username, Le = ie.password, rt = ie.host, Pe = ie.port, ct = ie.path, qe = ie.query, ut = ie.fragment, Ze = Oe + \":\";\n        return rt !== null ? (Ze += \"//\", Qe(ie) && (Ze += Ge + (Le ? \":\" + Le : \"\") + \"@\"), Ze += m(rt), Pe !== null && (Ze += \":\" + Pe)) : Oe == \"file\" && (Ze += \"//\"), Ze += ie.cannotBeABaseURL ? ct[0] : ct.length ? \"/\" + ct.join(\"/\") : \"\", qe !== null && (Ze += \"?\" + qe), ut !== null && (Ze += \"#\" + ut), Ze;\n      }, ht = function() {\n        var ie = F(this), Oe = ie.scheme, Ge = ie.port;\n        if (Oe == \"blob\")\n          try {\n            return new URL(Oe.path[0]).origin;\n          } catch {\n            return \"null\";\n          }\n        return Oe != \"file\" && Me(ie) ? Oe + \"://\" + m(ie.host) + (Ge !== null ? \":\" + Ge : \"\") : \"null\";\n      }, Dt = function() {\n        return F(this).scheme + \":\";\n      }, Pt = function() {\n        return F(this).username;\n      }, gt = function() {\n        return F(this).password;\n      }, Ft = function() {\n        var Oe = F(this), ie = Oe.host, Oe = Oe.port;\n        return ie === null ? \"\" : Oe === null ? m(ie) : m(ie) + \":\" + Oe;\n      }, me = function() {\n        var ie = F(this).host;\n        return ie === null ? \"\" : m(ie);\n      }, Ue = function() {\n        var ie = F(this).port;\n        return ie === null ? \"\" : String(ie);\n      }, Ye = function() {\n        var ie = F(this), Oe = ie.path;\n        return ie.cannotBeABaseURL ? Oe[0] : Oe.length ? \"/\" + Oe.join(\"/\") : \"\";\n      }, it = function() {\n        var ie = F(this).query;\n        return ie ? \"?\" + ie : \"\";\n      }, ft = function() {\n        return F(this).searchParams;\n      }, pt = function() {\n        var ie = F(this).fragment;\n        return ie ? \"#\" + ie : \"\";\n      };\n      i && n(mt, { href: g(jt, function(Ge) {\n        var Oe = F(this), Ge = String(Ge), Ge = u(Oe, Ge);\n        if (Ge)\n          throw TypeError(Ge);\n        R(Oe.searchParams).updateSearchParams(Oe.query);\n      }), origin: g(ht), protocol: g(Dt, function(ie) {\n        var Oe = F(this);\n        u(Oe, String(ie) + \":\", Re);\n      }), username: g(Pt, function(ie) {\n        var Oe = F(this), Ge = T(String(ie));\n        if (!y(Oe)) {\n          Oe.username = \"\";\n          for (var Le = 0; Le < Ge.length; Le++)\n            Oe.username += xe(Ge[Le], ge);\n        }\n      }), password: g(gt, function(ie) {\n        var Oe = F(this), Ge = T(String(ie));\n        if (!y(Oe)) {\n          Oe.password = \"\";\n          for (var Le = 0; Le < Ge.length; Le++)\n            Oe.password += xe(Ge[Le], ge);\n        }\n      }), host: g(Ft, function(ie) {\n        var Oe = F(this);\n        Oe.cannotBeABaseURL || u(Oe, String(ie), Ne);\n      }), hostname: g(me, function(ie) {\n        var Oe = F(this);\n        Oe.cannotBeABaseURL || u(Oe, String(ie), Be);\n      }), port: g(Ue, function(ie) {\n        var Oe = F(this);\n        y(Oe) || ((ie = String(ie)) == \"\" ? Oe.port = null : u(Oe, ie, We));\n      }), pathname: g(Ye, function(ie) {\n        var Oe = F(this);\n        Oe.cannotBeABaseURL || (Oe.path = [], u(Oe, ie + \"\", at));\n      }), search: g(it, function(ie) {\n        var Oe = F(this);\n        (ie = String(ie)) == \"\" ? Oe.query = null : (ie.charAt(0) == \"?\" && (ie = ie.slice(1)), Oe.query = \"\", u(Oe, ie, It)), R(Oe.searchParams).updateSearchParams(Oe.query);\n      }), searchParams: g(ft), hash: g(pt, function(ie) {\n        var Oe = F(this);\n        (ie = String(ie)) == \"\" ? Oe.fragment = null : (ie.charAt(0) == \"#\" && (ie = ie.slice(1)), Oe.fragment = \"\", u(Oe, ie, Mt));\n      }) }), a(mt, \"toJSON\", function() {\n        return jt.call(this);\n      }, { enumerable: !0 }), a(mt, \"toString\", function() {\n        return jt.call(this);\n      }, { enumerable: !0 }), P && (r = P.createObjectURL, s = P.revokeObjectURL, r && a(h, \"createObjectURL\", function(ie) {\n        return r.apply(P, arguments);\n      }), s && a(h, \"revokeObjectURL\", function(ie) {\n        return s.apply(P, arguments);\n      })), E(h, \"URL\"), o({ global: !0, forced: !l, sham: !i }, { URL: h });\n    }, { \"../internals/an-instance\": 9, \"../internals/array-from\": 17, \"../internals/descriptors\": 43, \"../internals/export\": 50, \"../internals/global\": 60, \"../internals/has\": 61, \"../internals/internal-state\": 71, \"../internals/native-url\": 85, \"../internals/object-assign\": 90, \"../internals/object-define-properties\": 92, \"../internals/redefine\": 109, \"../internals/set-to-string-tag\": 118, \"../internals/string-multibyte\": 124, \"../internals/string-punycode-to-ascii\": 127, \"../modules/es.string.iterator\": 197, \"../modules/web.url-search-params\": 244 }], 246: [function(t, H, C) {\n      H.exports = t(\"./\").polyfill();\n    }, { \"./\": 247 }], 247: [function(t, H, C) {\n      (function(m, y) {\n        var u, h;\n        u = this, h = function() {\n          function g(K) {\n            return typeof K == \"function\";\n          }\n          var f = Array.isArray || function(K) {\n            return Object.prototype.toString.call(K) === \"[object Array]\";\n          }, r = 0, s = void 0, o = void 0, i = function(K, ae) {\n            j[r] = K, j[r + 1] = ae, (r += 2) === 2 && (o ? o(T) : M());\n          }, l = typeof window < \"u\" ? window : void 0, n = l || {}, n = n.MutationObserver || n.WebKitMutationObserver, a = typeof self > \"u\" && m !== void 0 && {}.toString.call(m) === \"[object process]\", c = typeof Uint8ClampedArray < \"u\" && typeof importScripts < \"u\" && typeof MessageChannel < \"u\";\n          function p() {\n            var K = setTimeout;\n            return function() {\n              return K(T, 1);\n            };\n          }\n          var j = new Array(1e3);\n          function T() {\n            for (var K = 0; K < r; K += 2)\n              (0, j[K])(j[K + 1]), j[K] = void 0, j[K + 1] = void 0;\n            r = 0;\n          }\n          function _() {\n            try {\n              var K = Function(\"return this\")().require(\"vertx\");\n              return (s = K.runOnLoop || K.runOnContext) !== void 0 ? function() {\n                s(T);\n              } : p();\n            } catch {\n              return p();\n            }\n          }\n          var S, E, A, M = void 0;\n          function x(K, ae) {\n            var he, _e = this, fe = new this.constructor(L), ge = (fe[R] === void 0 && te(fe), _e._state);\n            return ge ? (he = arguments[ge - 1], i(function() {\n              return Y(ge, fe, he, _e._result);\n            })) : D(_e, fe, K, ae), fe;\n          }\n          function P(K) {\n            var ae;\n            return K && typeof K == \"object\" && K.constructor === this ? K : (X(ae = new this(L), K), ae);\n          }\n          var M = a ? function() {\n            return m.nextTick(T);\n          } : n ? (E = 0, a = new n(T), A = document.createTextNode(\"\"), a.observe(A, { characterData: !0 }), function() {\n            A.data = E = ++E % 2;\n          }) : c ? ((S = new MessageChannel()).port1.onmessage = T, function() {\n            return S.port2.postMessage(0);\n          }) : (l === void 0 && typeof t == \"function\" ? _ : p)(), R = Math.random().toString(36).substring(2);\n          function L() {\n          }\n          var F = void 0, V = 1, G = 2;\n          function U(K, ae, he) {\n            i(function(_e) {\n              var fe = !1, ge = function(xe, De, Me, Qe) {\n                try {\n                  xe.call(De, Me, Qe);\n                } catch (ze) {\n                  return ze;\n                }\n              }(he, ae, function(xe) {\n                fe || (fe = !0, (ae !== xe ? X : b)(_e, xe));\n              }, function(xe) {\n                fe || (fe = !0, O(_e, xe));\n              }, _e._label);\n              !fe && ge && (fe = !0, O(_e, ge));\n            }, K);\n          }\n          function W(K, ae, he) {\n            var _e, fe;\n            ae.constructor === K.constructor && he === x && ae.constructor.resolve === P ? (_e = K, (fe = ae)._state === V ? b(_e, fe._result) : fe._state === G ? O(_e, fe._result) : D(fe, void 0, function(ge) {\n              return X(_e, ge);\n            }, function(ge) {\n              return O(_e, ge);\n            })) : he !== void 0 && g(he) ? U(K, ae, he) : b(K, ae);\n          }\n          function X(K, ae) {\n            if (K === ae)\n              O(K, new TypeError(\"You cannot resolve a promise with itself\"));\n            else if (he = typeof ae, ae === null || he != \"object\" && he != \"function\")\n              b(K, ae);\n            else {\n              he = void 0;\n              try {\n                he = ae.then;\n              } catch (_e) {\n                return void O(K, _e);\n              }\n              W(K, ae, he);\n            }\n            var he;\n          }\n          function ne(K) {\n            K._onerror && K._onerror(K._result), B(K);\n          }\n          function b(K, ae) {\n            K._state === F && (K._result = ae, K._state = V, K._subscribers.length !== 0 && i(B, K));\n          }\n          function O(K, ae) {\n            K._state === F && (K._state = G, K._result = ae, i(ne, K));\n          }\n          function D(K, ae, he, _e) {\n            var fe = K._subscribers, ge = fe.length;\n            K._onerror = null, fe[ge] = ae, fe[ge + V] = he, fe[ge + G] = _e, ge === 0 && K._state && i(B, K);\n          }\n          function B(K) {\n            var ae = K._subscribers, he = K._state;\n            if (ae.length !== 0) {\n              for (var _e, fe = void 0, ge = K._result, xe = 0; xe < ae.length; xe += 3)\n                _e = ae[xe], fe = ae[xe + he], _e ? Y(he, _e, fe, ge) : fe(ge);\n              K._subscribers.length = 0;\n            }\n          }\n          function Y(K, ae, he, _e) {\n            var fe = g(he), ge = void 0, xe = void 0, De = !0;\n            if (fe) {\n              try {\n                ge = he(_e);\n              } catch (Me) {\n                De = !1, xe = Me;\n              }\n              if (ae === ge)\n                return void O(ae, new TypeError(\"A promises callback cannot return that same promise.\"));\n            } else\n              ge = _e;\n            ae._state === F && (fe && De ? X(ae, ge) : De === !1 ? O(ae, xe) : K === V ? b(ae, ge) : K === G && O(ae, ge));\n          }\n          var J = 0;\n          function te(K) {\n            K[R] = J++, K._state = void 0, K._result = void 0, K._subscribers = [];\n          }\n          re.prototype._enumerate = function(K) {\n            for (var ae = 0; this._state === F && ae < K.length; ae++)\n              this._eachEntry(K[ae], ae);\n          }, re.prototype._eachEntry = function(K, ae) {\n            var he = this._instanceConstructor, _e = he.resolve;\n            if (_e === P) {\n              var fe, ge = void 0, xe = void 0, De = !1;\n              try {\n                ge = K.then;\n              } catch (Me) {\n                De = !0, xe = Me;\n              }\n              ge === x && K._state !== F ? this._settledAt(K._state, ae, K._result) : typeof ge != \"function\" ? (this._remaining--, this._result[ae] = K) : he === ue ? (fe = new he(L), De ? O(fe, xe) : W(fe, K, ge), this._willSettleAt(fe, ae)) : this._willSettleAt(new he(function(Me) {\n                return Me(K);\n              }), ae);\n            } else\n              this._willSettleAt(_e(K), ae);\n          }, re.prototype._settledAt = function(K, ae, he) {\n            var _e = this.promise;\n            _e._state === F && (this._remaining--, K === G ? O(_e, he) : this._result[ae] = he), this._remaining === 0 && b(_e, this._result);\n          }, re.prototype._willSettleAt = function(K, ae) {\n            var he = this;\n            D(K, void 0, function(_e) {\n              return he._settledAt(V, ae, _e);\n            }, function(_e) {\n              return he._settledAt(G, ae, _e);\n            });\n          };\n          var ce = re;\n          function re(K, ae) {\n            this._instanceConstructor = K, this.promise = new K(L), this.promise[R] || te(this.promise), f(ae) ? (this.length = ae.length, this._remaining = ae.length, this._result = new Array(this.length), this.length !== 0 && (this.length = this.length || 0, this._enumerate(ae), this._remaining !== 0) || b(this.promise, this._result)) : O(this.promise, new Error(\"Array Methods must be provided an Array\"));\n          }\n          le.prototype.catch = function(K) {\n            return this.then(null, K);\n          }, le.prototype.finally = function(K) {\n            var ae = this.constructor;\n            return g(K) ? this.then(function(he) {\n              return ae.resolve(K()).then(function() {\n                return he;\n              });\n            }, function(he) {\n              return ae.resolve(K()).then(function() {\n                throw he;\n              });\n            }) : this.then(K, K);\n          };\n          var ue = le;\n          function le(K) {\n            if (this[R] = J++, this._result = this._state = void 0, this._subscribers = [], L !== K) {\n              if (typeof K != \"function\")\n                throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\");\n              if (!(this instanceof le))\n                throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n              var ae = this;\n              try {\n                K(function(he) {\n                  X(ae, he);\n                }, function(he) {\n                  O(ae, he);\n                });\n              } catch (he) {\n                O(ae, he);\n              }\n            }\n          }\n          return ue.prototype.then = x, ue.all = function(K) {\n            return new ce(this, K).promise;\n          }, ue.race = function(K) {\n            var ae = this;\n            return f(K) ? new ae(function(he, _e) {\n              for (var fe = K.length, ge = 0; ge < fe; ge++)\n                ae.resolve(K[ge]).then(he, _e);\n            }) : new ae(function(he, _e) {\n              return _e(new TypeError(\"You must pass an array to race.\"));\n            });\n          }, ue.resolve = P, ue.reject = function(K) {\n            var ae = new this(L);\n            return O(ae, K), ae;\n          }, ue._setScheduler = function(K) {\n            o = K;\n          }, ue._setAsap = function(K) {\n            i = K;\n          }, ue._asap = i, ue.polyfill = function() {\n            var K = void 0;\n            if (y !== void 0)\n              K = y;\n            else if (typeof self < \"u\")\n              K = self;\n            else\n              try {\n                K = Function(\"return this\")();\n              } catch {\n                throw new Error(\"polyfill failed because global object is unavailable in this environment\");\n              }\n            var ae = K.Promise;\n            if (ae) {\n              var he = null;\n              try {\n                he = Object.prototype.toString.call(ae.resolve());\n              } catch {\n              }\n              if (he === \"[object Promise]\" && !ae.cast)\n                return;\n            }\n            K.Promise = ue;\n          }, ue.Promise = ue;\n        }, typeof C == \"object\" && H !== void 0 ? H.exports = h() : u.ES6Promise = h();\n      }).call(this, t(\"_process\"), typeof _r < \"u\" ? _r : typeof self < \"u\" ? self : typeof window < \"u\" ? window : {});\n    }, { _process: 256 }], 248: [function(t, H, C) {\n      var m, y;\n      m = this, y = function(u, h) {\n        var g = 5e3, f = \"callback\";\n        function r(o) {\n          try {\n            delete window[o];\n          } catch {\n            window[o] = void 0;\n          }\n        }\n        function s(o) {\n          o = document.getElementById(o), o && document.getElementsByTagName(\"head\")[0].removeChild(o);\n        }\n        h.exports = function(o) {\n          var i = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], l = o, n = i.timeout || g, a = i.jsonpCallback || f, c = void 0;\n          return new Promise(function(p, j) {\n            var T = i.jsonpCallbackFunction || \"jsonp_\" + Date.now() + \"_\" + Math.ceil(1e5 * Math.random()), _ = a + \"_\" + T, S = (window[T] = function(E) {\n              p({ ok: !0, json: function() {\n                return Promise.resolve(E);\n              } }), c && clearTimeout(c), s(_), r(T);\n            }, l += l.indexOf(\"?\") === -1 ? \"?\" : \"&\", document.createElement(\"script\"));\n            S.setAttribute(\"src\", \"\" + l + a + \"=\" + T), i.charset && S.setAttribute(\"charset\", i.charset), S.id = _, document.getElementsByTagName(\"head\")[0].appendChild(S), c = setTimeout(function() {\n              j(new Error(\"JSONP request to \" + o + \" timed out\")), r(T), s(_), window[T] = function() {\n                r(T);\n              };\n            }, n), S.onerror = function() {\n              j(new Error(\"JSONP request to \" + o + \" failed\")), r(T), s(_), c && clearTimeout(c);\n            };\n          });\n        };\n      }, C !== void 0 && H !== void 0 ? y(0, H) : (y(y = { exports: {} }, y), m.fetchJsonp = y.exports);\n    }, {}], 249: [function(t, H, C) {\n      var m = function(y) {\n        var u, h, g, f, r, s, o, i, l, n, a;\n        if (!(y === void 0 || typeof navigator < \"u\" && /MSIE [1-9]\\./.test(navigator.userAgent)))\n          return a = y.document, u = function() {\n            return y.URL || y.webkitURL || y;\n          }, h = a.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\"), g = \"download\" in h, f = /constructor/i.test(y.HTMLElement) || y.safari, r = /CriOS\\/[\\d]+/.test(navigator.userAgent), s = function(c) {\n            (y.setImmediate || y.setTimeout)(function() {\n              throw c;\n            }, 0);\n          }, o = 4e4, i = function(c) {\n            setTimeout(function() {\n              typeof c == \"string\" ? u().revokeObjectURL(c) : c.remove();\n            }, o);\n          }, l = function(c) {\n            return /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(c.type) ? new Blob([\"\\uFEFF\", c], { type: c.type }) : c;\n          }, a = (n = function(c, p, E) {\n            E || (c = l(c));\n            var T, _, S = this, E = c.type === \"application/octet-stream\", A = function() {\n              for (var x = S, P = \"writestart progress write writeend\".split(\" \"), M = void 0, R = (P = [].concat(P)).length; R--; ) {\n                var L = x[\"on\" + P[R]];\n                if (typeof L == \"function\")\n                  try {\n                    L.call(x, M || x);\n                  } catch (F) {\n                    s(F);\n                  }\n              }\n            };\n            S.readyState = S.INIT, g ? (T = u().createObjectURL(c), setTimeout(function() {\n              var x, P;\n              h.href = T, h.download = p, x = h, P = new MouseEvent(\"click\"), x.dispatchEvent(P), A(), i(T), S.readyState = S.DONE;\n            })) : (r || E && f) && y.FileReader ? ((_ = new FileReader()).onloadend = function() {\n              var x = r ? _.result : _.result.replace(/^data:[^;]*;/, \"data:attachment/file;\");\n              y.open(x, \"_blank\") || (y.location.href = x), x = void 0, S.readyState = S.DONE, A();\n            }, _.readAsDataURL(c), S.readyState = S.INIT) : (T = T || u().createObjectURL(c), !E && y.open(T, \"_blank\") || (y.location.href = T), S.readyState = S.DONE, A(), i(T));\n          }).prototype, typeof navigator < \"u\" && navigator.msSaveOrOpenBlob ? function(c, p, j) {\n            return p = p || c.name || \"download\", j || (c = l(c)), navigator.msSaveOrOpenBlob(c, p);\n          } : (a.abort = function() {\n          }, a.readyState = a.INIT = 0, a.WRITING = 1, a.DONE = 2, a.error = a.onwritestart = a.onprogress = a.onwrite = a.onabort = a.onerror = a.onwriteend = null, function(c, p, j) {\n            return new n(c, p || c.name || \"download\", j);\n          });\n      }(typeof self < \"u\" && self || typeof window < \"u\" && window || this.content);\n      H !== void 0 && H.exports ? H.exports.saveAs = m : Vt != null;\n    }, {}], 250: [function(t, H, C) {\n      var m, y = Object.defineProperty, u = (y(C, \"__esModule\", { value: !0 }), C), h = { GIFEncoder: () => A, applyPalette: () => function(F, V, G = \"rgb565\") {\n        if (!F || !F.buffer)\n          throw new Error(\"quantize() expected RGBA Uint8Array data\");\n        if (!(F instanceof Uint8Array || F instanceof Uint8ClampedArray))\n          throw new Error(\"quantize() expected RGBA Uint8Array data\");\n        if (256 < V.length)\n          throw new Error(\"applyPalette() only works with 256 colors or less\");\n        const U = new Uint32Array(F.buffer), W = U.length, X = G === \"rgb444\" ? 4096 : 65536, ne = new Uint8Array(W), b = new Array(X);\n        if (G === \"rgba4444\")\n          for (let le = 0; le < W; le++) {\n            var Y = U[le], O = Y >> 24 & 255, D = Y >> 16 & 255, B = Y >> 8 & 255, Y = 255 & Y, J = i(Y, B, D, O), J = J in b ? b[J] : b[J] = function(K, ae, he, _e, fe) {\n              let ge = 0, xe = 1e100;\n              for (let ze = 0; ze < fe.length; ze++) {\n                var De, Me = fe[ze], Qe = _(Me[3] - _e);\n                Qe > xe || (De = Me[0], (Qe += _(De - K)) > xe || (De = Me[1], (Qe += _(De - ae)) > xe || (De = Me[2], (Qe += _(De - he)) > xe || (xe = Qe, ge = ze))));\n              }\n              return ge;\n            }(Y, B, D, O, V);\n            ne[le] = J;\n          }\n        else {\n          const le = G === \"rgb444\" ? l : o;\n          for (let K = 0; K < W; K++) {\n            var re = U[K], te = re >> 16 & 255, ce = re >> 8 & 255, re = 255 & re, ue = le(re, ce, te), ue = ue in b ? b[ue] : b[ue] = function(ae, he, _e, fe) {\n              let ge = 0, xe = 1e100;\n              for (let ze = 0; ze < fe.length; ze++) {\n                var De, Me = fe[ze], Qe = _(Me[0] - ae);\n                Qe > xe || (De = Me[1], (Qe += _(De - he)) > xe || (De = Me[2], (Qe += _(De - _e)) > xe || (xe = Qe, ge = ze)));\n              }\n              return ge;\n            }(re, ce, te, V);\n            ne[K] = ue;\n          }\n        }\n        return ne;\n      }, default: () => L, nearestColor: () => function(F, V, G = j) {\n        return F[S(F, V, G)];\n      }, nearestColorIndex: () => S, nearestColorIndexWithDistance: () => E, prequantize: () => function(F, { roundRGB: V = 5, roundAlpha: G = 10, oneBitAlpha: U = null } = {}) {\n        const W = new Uint32Array(F.buffer);\n        for (let D = 0; D < W.length; D++) {\n          var O = W[D];\n          let B = O >> 24 & 255;\n          var X, ne = O >> 16 & 255, b = O >> 8 & 255, O = 255 & O;\n          B = T(B, G), U && (X = typeof U == \"number\" ? U : 127, B = B <= X ? 0 : 255), O = T(O, V), b = T(b, V), ne = T(ne, V), W[D] = B << 24 | ne << 16 | b << 8 | O << 0;\n        }\n      }, quantize: () => function(F, V, G = {}) {\n        var { format: U = \"rgb565\", clearAlpha: W = !0, clearAlphaColor: X = 0, clearAlphaThreshold: ne = 0, oneBitAlpha: b = !1 } = G;\n        if (!F || !F.buffer)\n          throw new Error(\"quantize() expected RGBA Uint8Array data\");\n        if (!(F instanceof Uint8Array || F instanceof Uint8ClampedArray))\n          throw new Error(\"quantize() expected RGBA Uint8Array data\");\n        F = new Uint32Array(F.buffer);\n        let O = G.useSqrt !== !1;\n        const D = U === \"rgba4444\", B = function(Ve, Xe) {\n          const He = Xe === \"rgb444\" ? 4096 : 65536, ve = new Array(He), Re = Ve.length;\n          if (Xe === \"rgba4444\")\n            for (let nt = 0; nt < Re; ++nt) {\n              var q = Ve[nt], we = q >> 24 & 255, Z = q >> 16 & 255, $ = q >> 8 & 255, q = 255 & q, ee = i(q, $, Z, we);\n              let Ke = ee in ve ? ve[ee] : ve[ee] = p();\n              Ke.rc += q, Ke.gc += $, Ke.bc += Z, Ke.ac += we, Ke.cnt++;\n            }\n          else if (Xe === \"rgb444\")\n            for (let nt = 0; nt < Re; ++nt) {\n              var Ce = Ve[nt], pe = Ce >> 16 & 255, je = Ce >> 8 & 255, Ce = 255 & Ce, Fe = l(Ce, je, pe);\n              let Ke = Fe in ve ? ve[Fe] : ve[Fe] = p();\n              Ke.rc += Ce, Ke.gc += je, Ke.bc += pe, Ke.cnt++;\n            }\n          else\n            for (let nt = 0; nt < Re; ++nt) {\n              var We = Ve[nt], Ne = We >> 16 & 255, Be = We >> 8 & 255, We = 255 & We, st = o(We, Be, Ne);\n              let Ke = st in ve ? ve[st] : ve[st] = p();\n              Ke.rc += We, Ke.gc += Be, Ke.bc += Ne, Ke.cnt++;\n            }\n          return ve;\n        }(F, U), Y = B.length, J = Y - 1, te = new Uint32Array(Y + 1);\n        for (var ce = 0, re = 0; re < Y; ++re) {\n          const Ve = B[re];\n          Ve != null && (Me = 1 / Ve.cnt, D && (Ve.ac *= Me), Ve.rc *= Me, Ve.gc *= Me, Ve.bc *= Me, B[ce++] = Ve);\n        }\n        a(V) / ce < 0.022 && (O = !1);\n        for (var ue, le, K, re = 0; re < ce - 1; ++re)\n          B[re].fw = re + 1, B[re + 1].bk = re, O && (B[re].cnt = Math.sqrt(B[re].cnt));\n        for (O && (B[re].cnt = Math.sqrt(B[re].cnt)), re = 0; re < ce; ++re) {\n          c(B, re);\n          var ae = B[re].err;\n          for (le = ++te[0]; 1 < le && (K = le >> 1, !(B[ue = te[K]].err <= ae)); le = K)\n            te[le] = ue;\n          te[le] = re;\n        }\n        var he, _e = ce - V;\n        for (re = 0; re < _e; ) {\n          for (; ; ) {\n            var fe = te[1];\n            if ((he = B[fe]).tm >= he.mtm && B[he.nn].mtm <= he.tm)\n              break;\n            for (he.mtm == J ? fe = te[1] = te[te[0]--] : (c(B, fe), he.tm = re), ae = B[fe].err, le = 1; (K = le + le) <= te[0] && (K < te[0] && B[te[K]].err > B[te[K + 1]].err && K++, !(ae <= B[ue = te[K]].err)); le = K)\n              te[le] = ue;\n            te[le] = fe;\n          }\n          var ge = B[he.nn], xe = he.cnt, De = ge.cnt, Me = 1 / (xe + De);\n          D && (he.ac = Me * (xe * he.ac + De * ge.ac)), he.rc = Me * (xe * he.rc + De * ge.rc), he.gc = Me * (xe * he.gc + De * ge.gc), he.bc = Me * (xe * he.bc + De * ge.bc), he.cnt += ge.cnt, he.mtm = ++re, B[ge.bk].fw = ge.fw, B[ge.fw].bk = ge.bk, ge.mtm = J;\n        }\n        let Qe = [];\n        for (re = 0; ; 0) {\n          let Ve = n(Math.round(B[re].rc), 0, 255), Xe = n(Math.round(B[re].gc), 0, 255), He = n(Math.round(B[re].bc), 0, 255), ve = 255;\n          D && (ve = n(Math.round(B[re].ac), 0, 255), b && (ze = typeof b == \"number\" ? b : 127, ve = ve <= ze ? 0 : 255), W && ve <= ne && (Ve = Xe = He = X, ve = 0));\n          var ze = D ? [Ve, Xe, He, ve] : [Ve, Xe, He];\n          if (function(Re, we) {\n            for (let q = 0; q < Re.length; q++) {\n              var $ = Re[q], Z = $[0] === we[0] && $[1] === we[1] && $[2] === we[2], $ = !(4 <= $.length && 4 <= we.length) || $[3] === we[3];\n              if (Z && $)\n                return !0;\n            }\n            return !1;\n          }(Qe, ze) || Qe.push(ze), (re = B[re].fw) == 0)\n            break;\n        }\n        return Qe;\n      }, snapColorsToPalette: () => function(F, V, G = 5) {\n        if (F.length && V.length) {\n          var U = F.map((O) => O.slice(0, 3)), W = G * G, X = F[0].length;\n          for (let O = 0; O < V.length; O++) {\n            let D = V[O];\n            D = D.length < X ? [D[0], D[1], D[2], 255] : D.length > X ? D.slice(0, 3) : D.slice();\n            var b = E(U, D.slice(0, 3), j), ne = b[0], b = b[1];\n            0 < b && b <= W && (F[ne] = D);\n          }\n        }\n      } };\n      for (m in h)\n        y(u, m, { get: h[m], enumerable: !0 });\n      var g = { signature: \"GIF\", version: \"89a\", trailer: 59, extensionIntroducer: 33, applicationExtensionLabel: 255, graphicControlExtensionLabel: 249, imageSeparator: 44, signatureSize: 3, versionSize: 3, globalColorTableFlagMask: 128, colorResolutionMask: 112, sortFlagMask: 8, globalColorTableSizeMask: 7, applicationIdentifierSize: 8, applicationAuthCodeSize: 3, disposalMethodMask: 28, userInputFlagMask: 2, transparentColorFlagMask: 1, localColorTableFlagMask: 128, interlaceFlagMask: 64, idSortFlagMask: 32, localColorTableSizeMask: 7 };\n      function f(F = 256) {\n        let V = 0, G = new Uint8Array(F);\n        return { get buffer() {\n          return G.buffer;\n        }, reset() {\n          V = 0;\n        }, bytesView() {\n          return G.subarray(0, V);\n        }, bytes() {\n          return G.slice(0, V);\n        }, writeByte(W) {\n          U(V + 1), G[V] = W, V++;\n        }, writeBytes(W, X = 0, ne = W.length) {\n          U(V + ne);\n          for (let b = 0; b < ne; b++)\n            G[V++] = W[b + X];\n        }, writeBytesView(W, X = 0, ne = W.byteLength) {\n          U(V + ne), G.set(W.subarray(X, X + ne), V), V += ne;\n        } };\n        function U(W) {\n          var X = G.length;\n          if (!(W <= X)) {\n            W = Math.max(W, X * (X < 1048576 ? 2 : 1.125) >>> 0), X != 0 && (W = Math.max(W, 256));\n            const ne = G;\n            G = new Uint8Array(W), 0 < V && G.set(ne.subarray(0, V), 0);\n          }\n        }\n      }\n      var r = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], s = function(F, V, G, D, W = f(512), X = new Uint8Array(256), ne = new Int32Array(5003), b = new Int32Array(5003)) {\n        var O = ne.length, D = Math.max(2, D);\n        X.fill(0), b.fill(0), ne.fill(-1);\n        let B = 0, Y = 0;\n        var J = D + 1;\n        const te = J;\n        let ce = !1, re = te, ue = (1 << re) - 1;\n        var le = 1 << J - 1;\n        const K = 1 + le;\n        let ae = 2 + le, he = 0, _e = G[0], fe = 0;\n        for (let ze = O; ze < 65536; ze *= 2)\n          ++fe;\n        fe = 8 - fe, W.writeByte(D), Qe(le);\n        var ge = G.length;\n        for (let ze = 1; ze < ge; ze++)\n          e: {\n            var xe = G[ze], De = (xe << 12) + _e;\n            let Ve = xe << fe ^ _e;\n            if (ne[Ve] === De)\n              _e = b[Ve];\n            else {\n              for (var Me = Ve === 0 ? 1 : O - Ve; 0 <= ne[Ve]; )\n                if ((Ve -= Me) < 0 && (Ve += O), ne[Ve] === De) {\n                  _e = b[Ve];\n                  break e;\n                }\n              Qe(_e), _e = xe, ae < 4096 ? (b[Ve] = ae++, ne[Ve] = De) : (ne.fill(-1), ae = 2 + le, ce = !0, Qe(le));\n            }\n          }\n        return Qe(_e), Qe(K), W.writeByte(0), W.bytesView();\n        function Qe(ze) {\n          for (B &= r[Y], 0 < Y ? B |= ze << Y : B = ze, Y += re; 8 <= Y; )\n            X[he++] = 255 & B, 254 <= he && (W.writeByte(he), W.writeBytesView(X, 0, he), he = 0), B >>= 8, Y -= 8;\n          if ((ae > ue || ce) && (ce ? (re = te, ue = (1 << re) - 1, ce = !1) : (++re, ue = re === 12 ? 1 << re : (1 << re) - 1)), ze == K) {\n            for (; 0 < Y; )\n              X[he++] = 255 & B, 254 <= he && (W.writeByte(he), W.writeBytesView(X, 0, he), he = 0), B >>= 8, Y -= 8;\n            0 < he && (W.writeByte(he), W.writeBytesView(X, 0, he), he = 0);\n          }\n        }\n      };\n      function o(F, V, G) {\n        return F << 8 & 63488 | V << 2 & 992 | G >> 3;\n      }\n      function i(F, V, G, U) {\n        return F >> 4 | 240 & V | (240 & G) << 4 | (240 & U) << 8;\n      }\n      function l(F, V, G) {\n        return F >> 4 << 8 | 240 & V | G >> 4;\n      }\n      function n(F, V, G) {\n        return F < V ? V : G < F ? G : F;\n      }\n      function a(F) {\n        return F * F;\n      }\n      function c(F, V, G) {\n        var U = 0, W = 1e100;\n        const X = F[V];\n        for (var ne = X.cnt, b = X.ac, O = X.rc, D = X.gc, B = X.bc, Y = X.fw; Y != 0; Y = F[Y].fw) {\n          var J, te = F[Y], ce = te.cnt, ce = ne * ce / (ne + ce);\n          W <= ce || (J = 0, W <= (J += ce * a(te.rc - O)) || W <= (J += ce * a(te.gc - D)) || W <= (J += ce * a(te.bc - B)) || (W = J, U = Y));\n        }\n        X.err = W, X.nn = U;\n      }\n      function p() {\n        return { ac: 0, rc: 0, gc: 0, bc: 0, cnt: 0, nn: 0, fw: 0, bk: 0, tm: 0, mtm: 0, err: 0 };\n      }\n      function j(F, V) {\n        for (var G = 0, U = 0; U < F.length; U++) {\n          var W = F[U] - V[U];\n          G += W * W;\n        }\n        return G;\n      }\n      function T(F, V) {\n        return 1 < V ? Math.round(F / V) * V : F;\n      }\n      function _(F) {\n        return F * F;\n      }\n      function S(F, V, G = j) {\n        let U = 1 / 0, W = -1;\n        for (let ne = 0; ne < F.length; ne++) {\n          var X = G(V, F[ne]);\n          X < U && (U = X, W = ne);\n        }\n        return W;\n      }\n      function E(F, V, G = j) {\n        let U = 1 / 0, W = -1;\n        for (let ne = 0; ne < F.length; ne++) {\n          var X = G(V, F[ne]);\n          X < U && (U = X, W = ne);\n        }\n        return [W, U];\n      }\n      function A(F = {}) {\n        const { initialCapacity: V = 4096, auto: G = !0 } = F, U = f(V), W = new Uint8Array(256), X = new Int32Array(5003), ne = new Int32Array(5003);\n        let b = !1;\n        return { reset() {\n          U.reset(), b = !1;\n        }, finish() {\n          U.writeByte(g.trailer);\n        }, bytes() {\n          return U.bytes();\n        }, bytesView() {\n          return U.bytesView();\n        }, get buffer() {\n          return U.buffer;\n        }, get stream() {\n          return U;\n        }, writeHeader: O, writeFrame(D, B, Y, _e = {}) {\n          var { transparent: te = !1, transparentIndex: ce = 0, delay: Me = 0, palette: re = null, repeat: ge = 0, colorDepth: ue = 8, dispose: le = -1 } = _e;\n          let K = !1;\n          if (G ? b || (K = !0, O(), b = !0) : K = !!_e.first, B = Math.max(0, Math.floor(B)), Y = Math.max(0, Math.floor(Y)), K) {\n            if (!re)\n              throw new Error(\"First frame must include a { palette } option\");\n            var [_e, xe, he, De, fe = 8] = [U, B, Y, re, ue];\n            De = R(De.length) - 1, fe = 128 | fe - 1 << 4 | De, P(_e, xe), P(_e, he), _e.writeBytes([fe, 0, 0]), x(U, re), 0 <= ge && (De = U, xe = ge, De.writeByte(33), De.writeByte(255), De.writeByte(11), M(De, \"NETSCAPE2.0\"), De.writeByte(3), De.writeByte(1), P(De, xe), De.writeByte(0));\n          }\n          var ae, he = Math.round(Me / 10), _e = U, fe = le, ge = he, xe = te, De = ce, Me = (_e.writeByte(33), _e.writeByte(249), _e.writeByte(4), De < 0 && (De = 0, xe = !1), xe = xe ? (ae = 1, 2) : ae = 0, 0 <= fe && (xe = 7 & fe), xe <<= 2, _e.writeByte(0 | xe | ae), P(_e, ge), _e.writeByte(De || 0), _e.writeByte(0), !!re && !K);\n          le = U, te = B, ce = Y, ae = Me ? re : null, le.writeByte(44), P(le, 0), P(le, 0), P(le, te), P(le, ce), ae ? (te = R(ae.length) - 1, le.writeByte(128 | te)) : le.writeByte(0), Me && x(U, re), [ge, _e, ce, te, le = 8, Me, re, D] = [U, D, B, Y, ue, W, X, ne], s(ce, te, _e, le, ge, Me, re, D);\n        } };\n        function O() {\n          M(U, \"GIF89a\");\n        }\n      }\n      function x(F, V) {\n        var G = 1 << R(V.length);\n        for (let U = 0; U < G; U++) {\n          let W = [0, 0, 0];\n          U < V.length && (W = V[U]), F.writeByte(W[0]), F.writeByte(W[1]), F.writeByte(W[2]);\n        }\n      }\n      function P(F, V) {\n        F.writeByte(255 & V), F.writeByte(V >> 8 & 255);\n      }\n      function M(F, V) {\n        for (var G = 0; G < V.length; G++)\n          F.writeByte(V.charCodeAt(G));\n      }\n      function R(F) {\n        return Math.max(Math.ceil(Math.log2(F)), 1);\n      }\n      var L = A;\n    }, {}], 251: [function(t, H, C) {\n      C.read = function(m, y, u, h, c) {\n        var f, r, s = 8 * c - h - 1, o = (1 << s) - 1, i = o >> 1, l = -7, n = u ? c - 1 : 0, a = u ? -1 : 1, c = m[y + n];\n        for (n += a, f = c & (1 << -l) - 1, c >>= -l, l += s; 0 < l; f = 256 * f + m[y + n], n += a, l -= 8)\n          ;\n        for (r = f & (1 << -l) - 1, f >>= -l, l += h; 0 < l; r = 256 * r + m[y + n], n += a, l -= 8)\n          ;\n        if (f === 0)\n          f = 1 - i;\n        else {\n          if (f === o)\n            return r ? NaN : 1 / 0 * (c ? -1 : 1);\n          r += Math.pow(2, h), f -= i;\n        }\n        return (c ? -1 : 1) * r * Math.pow(2, f - h);\n      }, C.write = function(m, y, u, h, g, p) {\n        var r, s, o = 8 * p - g - 1, i = (1 << o) - 1, l = i >> 1, n = g === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, a = h ? 0 : p - 1, c = h ? 1 : -1, p = y < 0 || y === 0 && 1 / y < 0 ? 1 : 0;\n        for (y = Math.abs(y), isNaN(y) || y === 1 / 0 ? (s = isNaN(y) ? 1 : 0, r = i) : (r = Math.floor(Math.log(y) / Math.LN2), y * (h = Math.pow(2, -r)) < 1 && (r--, h *= 2), 2 <= (y += 1 <= r + l ? n / h : n * Math.pow(2, 1 - l)) * h && (r++, h /= 2), i <= r + l ? (s = 0, r = i) : 1 <= r + l ? (s = (y * h - 1) * Math.pow(2, g), r += l) : (s = y * Math.pow(2, l - 1) * Math.pow(2, g), r = 0)); 8 <= g; m[u + a] = 255 & s, a += c, s /= 256, g -= 8)\n          ;\n        for (r = r << g | s, o += g; 0 < o; m[u + a] = 255 & r, a += c, r /= 256, o -= 8)\n          ;\n        m[u + a - c] |= 128 * p;\n      };\n    }, {}], 252: [function(t, H, C) {\n      var m;\n      function y(Z, $) {\n        return Z.b === $.b && Z.a === $.a;\n      }\n      function u(Z, $) {\n        return Z.b < $.b || Z.b === $.b && Z.a <= $.a;\n      }\n      function h(Z, $, q) {\n        var ee = $.b - Z.b, pe = q.b - $.b;\n        return 0 < ee + pe ? ee < pe ? $.a - Z.a + ee / (ee + pe) * (Z.a - q.a) : $.a - q.a + pe / (ee + pe) * (q.a - Z.a) : 0;\n      }\n      function g(Z, $, q) {\n        var ee = $.b - Z.b, pe = q.b - $.b;\n        return 0 < ee + pe ? ($.a - q.a) * ee + ($.a - Z.a) * pe : 0;\n      }\n      function f(Z, $) {\n        return Z.a < $.a || Z.a === $.a && Z.b <= $.b;\n      }\n      function r(Z, $, q) {\n        var ee = $.a - Z.a, pe = q.a - $.a;\n        return 0 < ee + pe ? ee < pe ? $.b - Z.b + ee / (ee + pe) * (Z.b - q.b) : $.b - q.b + pe / (ee + pe) * (q.b - Z.b) : 0;\n      }\n      function s(Z, $, q) {\n        var ee = $.a - Z.a, pe = q.a - $.a;\n        return 0 < ee + pe ? ($.b - q.b) * ee + ($.b - Z.b) * pe : 0;\n      }\n      function o(Z, $, q, ee) {\n        return (Z = Z < 0 ? 0 : Z) <= (q = q < 0 ? 0 : q) ? q === 0 ? ($ + ee) / 2 : $ + Z / (Z + q) * (ee - $) : ee + q / (Z + q) * ($ - ee);\n      }\n      function i(Z) {\n        var $ = p(Z.b);\n        return T($, Z.c), T($.b, Z.c), _($, Z.a), $;\n      }\n      function l(Z, $) {\n        var q = !1, ee = !1;\n        Z !== $ && ($.a !== Z.a && (ee = !0, E($.a, Z.a)), $.d !== Z.d && (q = !0, A($.d, Z.d)), j($, Z), ee || (T($, Z.a), Z.a.c = Z), q || (_($, Z.d), Z.d.a = Z));\n      }\n      function n(Z) {\n        var $ = Z.b, q = !1;\n        Z.d !== Z.b.d && (q = !0, A(Z.d, Z.b.d)), Z.c === Z ? E(Z.a, null) : (Z.b.d.a = Z.b.e, Z.a.c = Z.c, j(Z, Z.b.e), q || _(Z, Z.d)), $.c === $ ? (E($.a, null), A($.d, null)) : (Z.d.a = $.b.e, $.a.c = $.c, j($, $.b.e)), S(Z);\n      }\n      function a(Z) {\n        var $ = p(Z), q = $.b;\n        return j($, Z.e), $.a = Z.b.a, T(q, $.a), $.d = q.d = Z.d, $ = $.b, j(Z.b, Z.b.b.e), j(Z.b, $), Z.b.a = $.a, $.b.a.c = $.b, $.b.d = Z.b.d, $.f = Z.f, $.b.f = Z.b.f, $;\n      }\n      function c(Z, $) {\n        var q = !1, ee = p(Z), pe = ee.b;\n        return $.d !== Z.d && (q = !0, A($.d, Z.d)), j(ee, Z.e), j(pe, $), ee.a = Z.b.a, pe.a = $.a, ee.d = pe.d = Z.d, Z.d.a = pe, q || _(ee, Z.d), ee;\n      }\n      function p(Z) {\n        var $ = new he(), q = new he(), ee = Z.b.h;\n        return (((q.h = ee).b.h = $).h = Z).b.h = q, $.b = q, (($.c = $).e = q).b = $, (q.c = q).e = $;\n      }\n      function j(Z, $) {\n        var q = Z.c, ee = $.c;\n        q.b.e = $, (ee.b.e = Z).c = ee, $.c = q;\n      }\n      function T(Z, $) {\n        var q = $.f, ee = new fe($, q);\n        for (q.e = ee, q = ($.f = ee).c = Z; q.a = ee, (q = q.c) !== Z; )\n          ;\n      }\n      function _(Z, $) {\n        var q = $.d, ee = new ae($, q);\n        for (q.b = ee, ($.d = ee).a = Z, ee.c = $.c, q = Z; q.d = ee, (q = q.e) !== Z; )\n          ;\n      }\n      function S(Z) {\n        var $ = Z.h;\n        Z = Z.b.h, ($.b.h = Z).b.h = $;\n      }\n      function E(Z, $) {\n        for (var q = Z.c, ee = q; ee.a = $, (ee = ee.c) !== q; )\n          ;\n        q = Z.f, ((ee = Z.e).f = q).e = ee;\n      }\n      function A(Z, $) {\n        for (var q = Z.a, ee = q; ee.d = $, (ee = ee.e) !== q; )\n          ;\n        q = Z.d, ((ee = Z.b).d = q).b = ee;\n      }\n      function x(Z) {\n        var $ = 0;\n        return Math.abs(Z[1]) > Math.abs(Z[0]) && ($ = 1), $ = Math.abs(Z[2]) > Math.abs(Z[$]) ? 2 : $;\n      }\n      function P(Z, $) {\n        Z.f += $.f, Z.b.f += $.b.f;\n      }\n      function M(Z, $, q) {\n        return Z = Z.a, $ = $.a, q = q.a, $.b.a === Z ? q.b.a === Z ? u($.a, q.a) ? g(q.b.a, $.a, q.a) <= 0 : 0 <= g($.b.a, q.a, $.a) : g(q.b.a, Z, q.a) <= 0 : q.b.a === Z ? 0 <= g($.b.a, Z, $.a) : ($ = h($.b.a, Z, $.a), (Z = h(q.b.a, Z, q.a)) <= $);\n      }\n      function R(Z) {\n        Z.a.i = null;\n        var $ = Z.e;\n        $.a.c = $.c, $.c.a = $.a, Z.e = null;\n      }\n      function L(Z, $) {\n        n(Z.a), Z.c = !1, (Z.a = $).i = Z;\n      }\n      function F(Z) {\n        for (var $ = Z.a.a; (Z = we(Z)).a.a === $; )\n          ;\n        return Z.c && (L(Z, $ = c(Re(Z).a.b, Z.a.e)), Z = we(Z)), Z;\n      }\n      function V(Z, $, q) {\n        var ee = new ve();\n        return ee.a = q, ee.e = ce(Z.f, $.e, ee), q.i = ee;\n      }\n      function G(Z, $) {\n        switch (Z.s) {\n          case 100130:\n            return (1 & $) != 0;\n          case 100131:\n            return $ !== 0;\n          case 100132:\n            return 0 < $;\n          case 100133:\n            return $ < 0;\n          case 100134:\n            return 2 <= $ || $ <= -2;\n        }\n        return !1;\n      }\n      function U(Z) {\n        var $ = Z.a, q = $.d;\n        q.c = Z.d, q.a = $, R(Z);\n      }\n      function W(Z, $, q) {\n        for ($ = (Z = $).a; Z !== q; ) {\n          Z.c = !1;\n          var ee = Re(Z), pe = ee.a;\n          if (pe.a !== $.a) {\n            if (!ee.c) {\n              U(Z);\n              break;\n            }\n            L(ee, pe = c($.c.b, pe.b));\n          }\n          $.c !== pe && (l(pe.b.e, pe), l($, pe)), U(Z), $ = ee.a, Z = ee;\n        }\n        return $;\n      }\n      function X(Z, $, q, ee, pe, je) {\n        for (var Ce = !0; V(Z, $, q.b), (q = q.c) !== ee; )\n          ;\n        for (pe === null && (pe = Re($).a.b.c); (q = (ee = Re($)).a.b).a === pe.a; )\n          q.c !== pe && (l(q.b.e, q), l(pe.b.e, q)), ee.f = $.f - q.f, ee.d = G(Z, ee.f), $.b = !0, !Ce && D(Z, $) && (P(q, pe), R($), n(pe)), Ce = !1, $ = ee, pe = q;\n        $.b = !0, je && Y(Z, $);\n      }\n      function ne(Z, $, q, ee, pe) {\n        var je = [$.g[0], $.g[1], $.g[2]];\n        $.d = null, $.d = Z.o && Z.o(je, q, ee, Z.c) || null, $.d === null && (pe ? Z.n || (K(Z, 100156), Z.n = !0) : $.d = q[0]);\n      }\n      function b(Z, $, q) {\n        var ee = [null, null, null, null];\n        ee[0] = $.a.d, ee[1] = q.a.d, ne(Z, $.a, ee, [0.5, 0.5, 0, 0], !1), l($, q);\n      }\n      function O(Z, $, q, ee, pe) {\n        var je = Math.abs($.b - Z.b) + Math.abs($.a - Z.a), Ce = Math.abs(q.b - Z.b) + Math.abs(q.a - Z.a), Fe = pe + 1;\n        ee[pe] = 0.5 * Ce / (je + Ce), ee[Fe] = 0.5 * je / (je + Ce), Z.g[0] += ee[pe] * $.g[0] + ee[Fe] * q.g[0], Z.g[1] += ee[pe] * $.g[1] + ee[Fe] * q.g[1], Z.g[2] += ee[pe] * $.g[2] + ee[Fe] * q.g[2];\n      }\n      function D(Z, $) {\n        var q = Re($), ee = $.a, pe = q.a;\n        if (u(ee.a, pe.a)) {\n          if (0 < g(pe.b.a, ee.a, pe.a))\n            return;\n          if (y(ee.a, pe.a)) {\n            if (ee.a !== pe.a) {\n              var q = Z.e, je = ee.a.h;\n              if (0 <= je) {\n                var Ce = (q = q.b).d, Fe = q.e, Ne = q.c, Be = Ne[je];\n                Ce[Be] = Ce[q.a], (Ne[Ce[Be]] = Be) <= --q.a && (Be <= 1 || u(Fe[Ce[Be >> 1]], Fe[Ce[Be]]) ? Xe : He)(q, Be), Fe[je] = null, Ne[je] = q.b, q.b = je;\n              } else\n                for (q.c[-(je + 1)] = null; 0 < q.a && q.c[q.d[q.a - 1]] === null; )\n                  --q.a;\n              b(Z, pe.b.e, ee);\n            }\n          } else\n            a(pe.b), l(ee, pe.b.e), $.b = q.b = !0;\n        } else {\n          if (g(ee.b.a, pe.a, ee.a) < 0)\n            return;\n          we($).b = $.b = !0, a(ee.b), l(pe.b.e, ee);\n        }\n        return 1;\n      }\n      function B(Z, $) {\n        var q = Re($), ee = $.a, pe = q.a, je = ee.a, Ce = pe.a, Fe = ee.b.a, Ne = pe.b.a, Be = new fe();\n        if (g(Fe, Z.a, je), g(Ne, Z.a, Ce), !(je === Ce || Math.min(je.a, Fe.a) > Math.max(Ce.a, Ne.a))) {\n          if (u(je, Ce)) {\n            if (0 < g(Ne, je, Ce))\n              return;\n          } else if (g(Fe, Ce, je) < 0)\n            return;\n          var We, st, nt = Fe, Ke = je, at = Ne, ot = Ce;\n          if (u(nt, Ke) || (We = nt, nt = Ke, Ke = We), u(at, ot) || (We = at, at = ot, ot = We), u(nt, at) || (We = nt, nt = at, at = We, We = Ke, Ke = ot, ot = We), u(at, Ke) ? u(Ke, ot) ? ((We = h(nt, at, Ke)) + (st = h(at, Ke, ot)) < 0 && (We = -We, st = -st), Be.b = o(We, at.b, st, Ke.b)) : ((We = g(nt, at, Ke)) + (st = -g(nt, ot, Ke)) < 0 && (We = -We, st = -st), Be.b = o(We, at.b, st, ot.b)) : Be.b = (at.b + Ke.b) / 2, f(nt, Ke) || (We = nt, nt = Ke, Ke = We), f(at, ot) || (We = at, at = ot, ot = We), f(nt, at) || (We = nt, nt = at, at = We, We = Ke, Ke = ot, ot = We), f(at, Ke) ? f(Ke, ot) ? ((We = r(nt, at, Ke)) + (st = r(at, Ke, ot)) < 0 && (We = -We, st = -st), Be.a = o(We, at.a, st, Ke.a)) : ((We = s(nt, at, Ke)) + (st = -s(nt, ot, Ke)) < 0 && (We = -We, st = -st), Be.a = o(We, at.a, st, ot.a)) : Be.a = (at.a + Ke.a) / 2, u(Be, Z.a) && (Be.b = Z.a.b, Be.a = Z.a.a), nt = u(je, Ce) ? je : Ce, u(nt, Be) && (Be.b = nt.b, Be.a = nt.a), y(Be, je) || y(Be, Ce))\n            return D(Z, $), 0;\n          if (!y(Fe, Z.a) && 0 <= g(Fe, Z.a, Be) || !y(Ne, Z.a) && g(Ne, Z.a, Be) <= 0) {\n            if (Ne === Z.a)\n              a(ee.b), l(pe.b, ee), ee = Re($ = F($)).a, W(Z, Re($), q), X(Z, $, ee.b.e, ee, ee, !0);\n            else {\n              if (Fe !== Z.a)\n                return 0 <= g(Fe, Z.a, Be) && (we($).b = $.b = !0, a(ee.b), ee.a.b = Z.a.b, ee.a.a = Z.a.a), void (g(Ne, Z.a, Be) <= 0 && ($.b = q.b = !0, a(pe.b), pe.a.b = Z.a.b, pe.a.a = Z.a.a));\n              for (a(pe.b), l(ee.e, pe.b.e), Ce = (je = q = $).a.b.a; (je = we(je)).a.b.a === Ce; )\n                ;\n              je = Re($ = je).a.b.c, q.a = pe.b.e, X(Z, $, (pe = W(Z, q, null)).c, ee.b.c, je, !0);\n            }\n            return 1;\n          }\n          a(ee.b), a(pe.b), l(pe.b.e, ee), ee.a.b = Be.b, ee.a.a = Be.a, ee.a.h = xe(Z.e, ee.a), ee = ee.a, pe = [0, 0, 0, 0], Be = [je.d, Fe.d, Ce.d, Ne.d], ee.g[0] = ee.g[1] = ee.g[2] = 0, O(ee, je, Fe, pe, 0), O(ee, Ce, Ne, pe, 2), ne(Z, ee, Be, pe, !0), we($).b = $.b = q.b = !0;\n        }\n      }\n      function Y(Z, $) {\n        for (var q = Re($); ; ) {\n          for (; q.b; )\n            q = Re($ = q);\n          if (!$.b && (($ = we(q = $)) === null || !$.b))\n            break;\n          $.b = !1;\n          var ee = $.a, pe = q.a;\n          if (je = ee.b.a !== pe.b.a)\n            e: {\n              var je, Ce = Re(je = $), Fe = je.a, Ne = Ce.a, Be = void 0;\n              if (u(Fe.b.a, Ne.b.a)) {\n                if (g(Fe.b.a, Ne.b.a, Fe.a) < 0) {\n                  je = !1;\n                  break e;\n                }\n                we(je).b = je.b = !0, Be = a(Fe), l(Ne.b, Be), Be.d.c = je.d;\n              } else {\n                if (0 < g(Ne.b.a, Fe.b.a, Ne.a)) {\n                  je = !1;\n                  break e;\n                }\n                je.b = Ce.b = !0, Be = a(Ne), l(Fe.e, Ne.b), Be.b.d.c = je.d;\n              }\n              je = !0;\n            }\n          if (je && (q.c ? (R(q), n(pe), pe = (q = Re($)).a) : $.c && (R($), n(ee), ee = ($ = we(q)).a)), ee.a !== pe.a) {\n            if (ee.b.a === pe.b.a || $.c || q.c || ee.b.a !== Z.a && pe.b.a !== Z.a)\n              D(Z, $);\n            else if (B(Z, $))\n              break;\n          }\n          ee.a === pe.a && ee.b.a === pe.b.a && (P(pe, ee), R($), n(ee), $ = we(q));\n        }\n      }\n      function J(Z, $) {\n        var q = new ve(), ee = i(Z.b);\n        ee.a.b = 4e150, ee.a.a = $, ee.b.a.b = -4e150, ee.b.a.a = $, Z.a = ee.b.a, q.a = ee, q.f = 0, q.d = !1, q.c = !1, q.h = !0, q.b = !1, ee = ce(ee = Z.f, ee.a, q), q.e = ee;\n      }\n      function te(Z) {\n        this.a = new re(), this.b = Z, this.c = M;\n      }\n      function ce(Z, $, q) {\n        for (; ($ = $.c).b !== null && !Z.c(Z.b, $.b, q); )\n          ;\n        return Z = new re(q, $.a, $), $.a.c = Z, $.a = Z;\n      }\n      function re(Z, $, q) {\n        this.b = Z || null, this.a = $ || this, this.c = q || this;\n      }\n      function ue() {\n        this.d = 0, this.p = this.b = this.q = null, this.j = [0, 0, 0], this.s = 100130, this.n = !1, this.o = this.a = this.e = this.f = null, this.m = !1, this.c = this.r = this.i = this.k = this.l = this.h = null;\n      }\n      function le(Z, $) {\n        if (Z.d !== $)\n          for (; Z.d !== $; )\n            if (Z.d < $)\n              switch (Z.d) {\n                case 0:\n                  K(Z, 100151), Z.u(null);\n                  break;\n                case 1:\n                  K(Z, 100152), Z.t();\n              }\n            else\n              switch (Z.d) {\n                case 2:\n                  K(Z, 100154), Z.v();\n                  break;\n                case 1:\n                  K(Z, 100153), Z.w();\n              }\n      }\n      function K(Z, $) {\n        Z.p && Z.p($, Z.c);\n      }\n      function ae(Z, $) {\n        this.b = Z || this, this.d = $ || this, this.a = null, this.c = !1;\n      }\n      function he() {\n        (this.h = this).i = this.d = this.a = this.e = this.c = this.b = null, this.f = 0;\n      }\n      function _e() {\n        this.c = new fe(), this.a = new ae(), this.b = new he(), this.d = new he(), this.b.b = this.d, this.d.b = this.b;\n      }\n      function fe(Z, $) {\n        this.e = Z || this, this.f = $ || this, this.d = this.c = null, this.g = [0, 0, 0], this.h = this.a = this.b = 0;\n      }\n      function ge() {\n        this.c = [], this.d = null, this.a = 0, this.e = !1, this.b = new Me();\n      }\n      function xe(Z, $) {\n        var q, ee, pe;\n        return Z.e ? (2 * (ee = ++(q = Z.b).a) > q.f && (q.f *= 2, q.c = Qe(q.c, q.f + 1)), q.b === 0 ? pe = ee : (pe = q.b, q.b = q.c[q.b]), q.e[pe] = $, q.c[pe] = ee, q.d[ee] = pe, q.h && He(q, ee), pe) : (q = Z.a++, Z.c[q] = $, -(q + 1));\n      }\n      function De(Z) {\n        if (Z.a === 0)\n          return Ve(Z.b);\n        var $ = Z.c[Z.d[Z.a - 1]];\n        if (Z.b.a !== 0 && u(ze(Z.b), $))\n          return Ve(Z.b);\n        for (; --Z.a, 0 < Z.a && Z.c[Z.d[Z.a - 1]] === null; )\n          ;\n        return $;\n      }\n      function Me() {\n        this.d = Qe([0], 33), this.e = [null, null], this.c = [0, 0], this.a = 0, this.f = 32, this.b = 0, this.h = !1, this.d[1] = 1;\n      }\n      function Qe(Z, $) {\n        for (var q = Array($), ee = 0; ee < Z.length; ee++)\n          q[ee] = Z[ee];\n        for (; ee < $; ee++)\n          q[ee] = 0;\n        return q;\n      }\n      function ze(Z) {\n        return Z.e[Z.d[1]];\n      }\n      function Ve(Z) {\n        var $ = Z.d, q = Z.e, ee = Z.c, pe = $[1], je = q[pe];\n        return 0 < Z.a && ($[1] = $[Z.a], ee[$[1]] = 1, q[pe] = null, ee[pe] = Z.b, Z.b = pe, 0 < --Z.a && Xe(Z, 1)), je;\n      }\n      function Xe(Z, $) {\n        for (var q = Z.d, ee = Z.e, pe = Z.c, je = $, Ce = q[je]; ; ) {\n          var Fe = je << 1, Ne = (Fe < Z.a && u(ee[q[Fe + 1]], ee[q[Fe]]) && (Fe += 1), q[Fe]);\n          if (Fe > Z.a || u(ee[Ce], ee[Ne])) {\n            pe[q[je] = Ce] = je;\n            break;\n          }\n          pe[q[je] = Ne] = je, je = Fe;\n        }\n      }\n      function He(Z, $) {\n        for (var q = Z.d, ee = Z.e, pe = Z.c, je = $, Ce = q[je]; ; ) {\n          var Fe = je >> 1, Ne = q[Fe];\n          if (Fe == 0 || u(ee[Ne], ee[Ce])) {\n            pe[q[je] = Ce] = je;\n            break;\n          }\n          pe[q[je] = Ne] = je, je = Fe;\n        }\n      }\n      function ve() {\n        this.e = this.a = null, this.f = 0, this.c = this.b = this.h = this.d = !1;\n      }\n      function Re(Z) {\n        return Z.e.c.b;\n      }\n      function we(Z) {\n        return Z.e.a.b;\n      }\n      (m = ue.prototype).x = function() {\n        le(this, 0);\n      }, m.B = function(Z, $) {\n        switch (Z) {\n          case 100142:\n            return;\n          case 100140:\n            switch ($) {\n              case 100130:\n              case 100131:\n              case 100132:\n              case 100133:\n              case 100134:\n                return void (this.s = $);\n            }\n            break;\n          case 100141:\n            return void (this.m = !!$);\n          default:\n            return void K(this, 100900);\n        }\n        K(this, 100901);\n      }, m.y = function(Z) {\n        switch (Z) {\n          case 100142:\n            return 0;\n          case 100140:\n            return this.s;\n          case 100141:\n            return this.m;\n          default:\n            K(this, 100900);\n        }\n        return !1;\n      }, m.A = function(Z, $, q) {\n        this.j[0] = Z, this.j[1] = $, this.j[2] = q;\n      }, m.z = function(Z, $) {\n        var q = $ || null;\n        switch (Z) {\n          case 100100:\n          case 100106:\n            this.h = q;\n            break;\n          case 100104:\n          case 100110:\n            this.l = q;\n            break;\n          case 100101:\n          case 100107:\n            this.k = q;\n            break;\n          case 100102:\n          case 100108:\n            this.i = q;\n            break;\n          case 100103:\n          case 100109:\n            this.p = q;\n            break;\n          case 100105:\n          case 100111:\n            this.o = q;\n            break;\n          case 100112:\n            this.r = q;\n            break;\n          default:\n            K(this, 100900);\n        }\n      }, m.C = function(Z, $) {\n        var q = !1, ee = [0, 0, 0];\n        le(this, 2);\n        for (var pe = 0; pe < 3; ++pe) {\n          var je = Z[pe];\n          je < -1e150 && (je = -1e150, q = !0), 1e150 < je && (je = 1e150, q = !0), ee[pe] = je;\n        }\n        q && K(this, 100155), (q = this.q) === null ? l(q = i(this.b), q.b) : (a(q), q = q.e), q.a.d = $, q.a.g[0] = ee[0], q.a.g[1] = ee[1], q.a.g[2] = ee[2], q.f = 1, q.b.f = -1, this.q = q;\n      }, m.u = function(Z) {\n        le(this, 0), this.d = 1, this.b = new _e(), this.c = Z;\n      }, m.t = function() {\n        le(this, 1), this.d = 2, this.q = null;\n      }, m.v = function() {\n        le(this, 2), this.d = 1;\n      }, m.w = function() {\n        le(this, 1), this.d = 0;\n        var Z, $, q = this.j[0], ee = this.j[1], pe = this.j[2], je = !1, Ce = [q, ee, pe];\n        if (q === 0 && ee === 0 && pe === 0) {\n          for (var ee = [-2e150, -2e150, -2e150], Fe = [2e150, 2e150, 2e150], pe = [], Ne = [], q = (je = this.b.c).e; q !== je; q = q.e)\n            for (var Be = 0; Be < 3; ++Be) {\n              var We = q.g[Be];\n              We < Fe[Be] && (Fe[Be] = We, Ne[Be] = q), We > ee[Be] && (ee[Be] = We, pe[Be] = q);\n            }\n          if (ee[1] - Fe[1] > ee[q = 0] - Fe[0] && (q = 1), Fe[q = ee[2] - Fe[2] > ee[q] - Fe[q] ? 2 : q] >= ee[q])\n            Ce[0] = 0, Ce[1] = 0, Ce[2] = 1;\n          else {\n            for (Fe = Ne[q], pe = pe[q], Ne = [ee = 0, 0, 0], Fe = [Fe.g[0] - pe.g[0], Fe.g[1] - pe.g[1], Fe.g[2] - pe.g[2]], Be = [0, 0, 0], q = je.e; q !== je; q = q.e)\n              Be[0] = q.g[0] - pe.g[0], Be[1] = q.g[1] - pe.g[1], Be[2] = q.g[2] - pe.g[2], Ne[0] = Fe[1] * Be[2] - Fe[2] * Be[1], Ne[1] = Fe[2] * Be[0] - Fe[0] * Be[2], Ne[2] = Fe[0] * Be[1] - Fe[1] * Be[0], ee < (We = Ne[0] * Ne[0] + Ne[1] * Ne[1] + Ne[2] * Ne[2]) && (ee = We, Ce[0] = Ne[0], Ce[1] = Ne[1], Ce[2] = Ne[2]);\n            ee <= 0 && (Ce[0] = Ce[1] = Ce[2] = 0, Ce[x(Fe)] = 1);\n          }\n          je = !0;\n        }\n        for (Ne = x(Ce), q = this.b.c, ee = (Ne + 1) % 3, pe = (Ne + 2) % 3, Ne = 0 < Ce[Ne] ? 1 : -1, Ce = q.e; Ce !== q; Ce = Ce.e)\n          Ce.b = Ce.g[ee], Ce.a = Ne * Ce.g[pe];\n        if (je) {\n          for (Ce = 0, q = (je = this.b.a).b; q !== je; q = q.b)\n            if (!((ee = q.a).f <= 0))\n              for (; Ce += (ee.a.b - ee.b.a.b) * (ee.a.a + ee.b.a.a), (ee = ee.e) !== q.a; )\n                ;\n          if (Ce < 0)\n            for (je = (Ce = this.b.c).e; je !== Ce; je = je.e)\n              je.a = -je.a;\n        }\n        for (this.n = !1, Ce = this.b.b, q = Ce.h; q !== Ce; q = je)\n          je = q.h, ee = q.e, y(q.a, q.b.a) && q.e.e !== q && (b(this, ee, q), n(q), ee = (q = ee).e), ee.e === q && (ee !== q && (ee !== je && ee !== je.b || (je = je.h), n(ee)), q !== je && q !== je.b || (je = je.h), n(q));\n        for (this.e = Ce = new ge(), je = this.b.c, q = je.e; q !== je; q = q.e)\n          q.h = xe(Ce, q);\n        var st = Ce;\n        st.d = [];\n        for (var nt = 0; nt < st.a; nt++)\n          st.d[nt] = nt;\n        st.d.sort(/* @__PURE__ */ function(ot) {\n          return function(bt, It) {\n            return u(ot[bt], ot[It]) ? 1 : -1;\n          };\n        }(st.c)), st.e = !0;\n        for (var Ke = st.b, at = Ke.a; 1 <= at; --at)\n          Xe(Ke, at);\n        for (Ke.h = !0, this.f = new te(this), J(this, -4e150), J(this, 4e150); (Ce = De(this.e)) !== null; ) {\n          for (; ; ) {\n            e:\n              if ((q = this.e).a === 0)\n                je = ze(q.b);\n              else if (je = q.c[q.d[q.a - 1]], q.b.a !== 0 && u(q = ze(q.b), je)) {\n                je = q;\n                break e;\n              }\n            if (je === null || !y(je, Ce))\n              break;\n            je = De(this.e), b(this, Ce.c, je.c);\n          }\n          (function ot(bt, It) {\n            for (var Mt, mt = (bt.a = It).c; mt.i === null; )\n              if ((mt = mt.c) === It.c) {\n                var mt = bt, jt = It;\n                (gt = new ve()).a = jt.c.b;\n                for (var Ft = (ht = mt.f).a; (Ft = Ft.a).b !== null && !ht.c(ht.b, gt, Ft.b); )\n                  ;\n                var ht, Dt, Pt = Re(ht = Ft.b), gt = ht.a, Ft = Pt.a;\n                return void (g(gt.b.a, jt, gt.a) === 0 ? y((gt = ht.a).a, jt) || y(gt.b.a, jt) || (a(gt.b), ht.c && (n(gt.c), ht.c = !1), l(jt.c, gt), ot(mt, jt)) : (Dt = u(Ft.b.a, gt.b.a) ? ht : Pt, Pt = void 0, ht.d || Dt.c ? (Pt = Dt === ht ? c(jt.c.b, gt.e) : c(Ft.b.c.b, jt.c).b, Dt.c ? L(Dt, Pt) : ((ht = V(gt = mt, ht, Pt)).f = we(ht).f + ht.a.f, ht.d = G(gt, ht.f)), ot(mt, jt)) : X(mt, ht, jt.c, jt.c, null, !0)));\n              }\n            ht = (gt = Re(mt = F(mt.i))).a, (gt = W(bt, gt, null)).c === ht ? (gt = (ht = gt).c, Ft = Re(mt), Pt = mt.a, Dt = Ft.a, Mt = !1, Pt.b.a !== Dt.b.a && B(bt, mt), y(Pt.a, bt.a) && (l(gt.b.e, Pt), gt = Re(mt = F(mt)).a, W(bt, Re(mt), Ft), Mt = !0), y(Dt.a, bt.a) && (l(ht, Dt.b.e), ht = W(bt, Ft, null), Mt = !0), Mt ? X(bt, mt, ht.c, gt, gt, !0) : (jt = u(Dt.a, Pt.a) ? Dt.b.e : Pt, X(bt, mt, jt = c(ht.c.b, jt), jt.c, jt.c, !1), jt.b.i.c = !0, Y(bt, mt))) : X(bt, mt, gt.c, ht, ht, !0);\n          })(this, Ce);\n        }\n        for (this.a = this.f.a.a.b.a.a, Ce = 0; (je = this.f.a.a.b) !== null; )\n          je.h || ++Ce, R(je);\n        for (this.f = null, (Ce = this.e).b = null, Ce.d = null, this.e = Ce.c = null, Ce = this.b, q = Ce.a.b; q !== Ce.a; q = je)\n          je = q.b, (q = q.a).e.e === q && (P(q.c, q), n(q));\n        if (!this.n) {\n          if (Ce = this.b, this.m)\n            for (q = Ce.b.h; q !== Ce.b; q = je)\n              je = q.h, q.b.d.c !== q.d.c ? q.f = q.d.c ? 1 : -1 : n(q);\n          else\n            for (q = Ce.a.b; q !== Ce.a; q = je)\n              if (je = q.b, q.c) {\n                for (q = q.a; u(q.b.a, q.a); q = q.c.b)\n                  ;\n                for (; u(q.a, q.b.a); q = q.e)\n                  ;\n                for (ee = q.c.b, pe = void 0; q.e !== ee; )\n                  if (u(q.b.a, ee.a)) {\n                    for (; ee.e !== q && (u(($ = ee.e).b.a, $.a) || g(ee.a, ee.b.a, ee.e.b.a) <= 0); )\n                      ee = (pe = c(ee.e, ee)).b;\n                    ee = ee.c.b;\n                  } else {\n                    for (; ee.e !== q && (u((Z = q.c.b).a, Z.b.a) || 0 <= g(q.b.a, q.a, q.c.b.a)); )\n                      q = (pe = c(q, q.c.b)).b;\n                    q = q.e;\n                  }\n                for (; ee.e.e !== q; )\n                  pe = c(ee.e, ee), ee = pe.b;\n              }\n          if (this.h || this.i || this.k || this.l)\n            if (this.m) {\n              for (je = (Ce = this.b).a.b; je !== Ce.a; je = je.b)\n                if (je.c) {\n                  for (this.h && this.h(2, this.c), q = je.a; this.k && this.k(q.a.d, this.c), (q = q.e) !== je.a; )\n                    ;\n                  this.i && this.i(this.c);\n                }\n            } else {\n              for (Ce = this.b, je = !!this.l, q = !1, ee = -1, pe = Ce.a.d; pe !== Ce.a; pe = pe.d)\n                if (pe.c)\n                  for (q || (this.h && this.h(4, this.c), q = !0), Ne = pe.a; je && (Fe = Ne.b.d.c ? 0 : 1, ee !== Fe && (ee = Fe, this.l && this.l(!!ee, this.c))), this.k && this.k(Ne.a.d, this.c), (Ne = Ne.e) !== pe.a; )\n                    ;\n              q && this.i && this.i(this.c);\n            }\n          if (this.r) {\n            for (Ce = this.b, q = Ce.a.b; q !== Ce.a; q = je)\n              if (je = q.b, !q.c) {\n                for (pe = (ee = q.a).e, Ne = void 0; pe = (Ne = pe).e, (Ne.d = null) === Ne.b.d && (Ne.c === Ne ? E(Ne.a, null) : (Ne.a.c = Ne.c, j(Ne, Ne.b.e)), (Fe = Ne.b).c === Fe ? E(Fe.a, null) : (Fe.a.c = Fe.c, j(Fe, Fe.b.e)), S(Ne)), Ne !== ee; )\n                  ;\n                ee = q.d, ((q = q.b).d = ee).b = q;\n              }\n            return this.r(this.b), void (this.c = this.b = null);\n          }\n        }\n        this.b = this.c = null;\n      }, this.libtess = { GluTesselator: ue, windingRule: { GLU_TESS_WINDING_ODD: 100130, GLU_TESS_WINDING_NONZERO: 100131, GLU_TESS_WINDING_POSITIVE: 100132, GLU_TESS_WINDING_NEGATIVE: 100133, GLU_TESS_WINDING_ABS_GEQ_TWO: 100134 }, primitiveType: { GL_LINE_LOOP: 2, GL_TRIANGLES: 4, GL_TRIANGLE_STRIP: 5, GL_TRIANGLE_FAN: 6 }, errorType: { GLU_TESS_MISSING_BEGIN_POLYGON: 100151, GLU_TESS_MISSING_END_POLYGON: 100153, GLU_TESS_MISSING_BEGIN_CONTOUR: 100152, GLU_TESS_MISSING_END_CONTOUR: 100154, GLU_TESS_COORD_TOO_LARGE: 100155, GLU_TESS_NEED_COMBINE_CALLBACK: 100156 }, gluEnum: { GLU_TESS_MESH: 100112, GLU_TESS_TOLERANCE: 100142, GLU_TESS_WINDING_RULE: 100140, GLU_TESS_BOUNDARY_ONLY: 100141, GLU_INVALID_ENUM: 100900, GLU_INVALID_VALUE: 100901, GLU_TESS_BEGIN: 100100, GLU_TESS_VERTEX: 100101, GLU_TESS_END: 100102, GLU_TESS_ERROR: 100103, GLU_TESS_EDGE_FLAG: 100104, GLU_TESS_COMBINE: 100105, GLU_TESS_BEGIN_DATA: 100106, GLU_TESS_VERTEX_DATA: 100107, GLU_TESS_END_DATA: 100108, GLU_TESS_ERROR_DATA: 100109, GLU_TESS_EDGE_FLAG_DATA: 100110, GLU_TESS_COMBINE_DATA: 100111 } }, ue.prototype.gluDeleteTess = ue.prototype.x, ue.prototype.gluTessProperty = ue.prototype.B, ue.prototype.gluGetTessProperty = ue.prototype.y, ue.prototype.gluTessNormal = ue.prototype.A, ue.prototype.gluTessCallback = ue.prototype.z, ue.prototype.gluTessVertex = ue.prototype.C, ue.prototype.gluTessBeginPolygon = ue.prototype.u, ue.prototype.gluTessBeginContour = ue.prototype.t, ue.prototype.gluTessEndContour = ue.prototype.v, ue.prototype.gluTessEndPolygon = ue.prototype.w, H !== void 0 && (H.exports = this.libtess);\n    }, {}], 253: [function(t, H, C) {\n      function m(u, h, g, f) {\n        var r = 0, s = (f = f === void 0 ? {} : f).loop === void 0 ? null : f.loop, o = f.palette === void 0 ? null : f.palette;\n        if (h <= 0 || g <= 0 || 65535 < h || 65535 < g)\n          throw new Error(\"Width/Height invalid.\");\n        function i(_) {\n          if (_ = _.length, _ < 2 || 256 < _ || _ & _ - 1)\n            throw new Error(\"Invalid code/color length, must be power of 2 and 2 .. 256.\");\n          return _;\n        }\n        u[r++] = 71, u[r++] = 73, u[r++] = 70, u[r++] = 56, u[r++] = 57, u[r++] = 97;\n        var l = 0, n = 0;\n        if (o !== null) {\n          for (var a = i(o); a >>= 1; )\n            ++l;\n          if (a = 1 << l, --l, f.background !== void 0) {\n            if (a <= (n = f.background))\n              throw new Error(\"Background index out of range.\");\n            if (n === 0)\n              throw new Error(\"Background index explicitly passed as 0.\");\n          }\n        }\n        if (u[r++] = 255 & h, u[r++] = h >> 8 & 255, u[r++] = 255 & g, u[r++] = g >> 8 & 255, u[r++] = (o !== null ? 128 : 0) | l, u[r++] = n, u[r++] = 0, o !== null)\n          for (var c = 0, p = o.length; c < p; ++c) {\n            var j = o[c];\n            u[r++] = j >> 16 & 255, u[r++] = j >> 8 & 255, u[r++] = 255 & j;\n          }\n        if (s !== null) {\n          if (s < 0 || 65535 < s)\n            throw new Error(\"Loop count invalid.\");\n          u[r++] = 33, u[r++] = 255, u[r++] = 11, u[r++] = 78, u[r++] = 69, u[r++] = 84, u[r++] = 83, u[r++] = 67, u[r++] = 65, u[r++] = 80, u[r++] = 69, u[r++] = 50, u[r++] = 46, u[r++] = 48, u[r++] = 3, u[r++] = 1, u[r++] = 255 & s, u[r++] = s >> 8 & 255, u[r++] = 0;\n        }\n        var T = !1;\n        this.addFrame = function(_, S, E, A, x, P) {\n          if (T === !0 && (--r, T = !1), P = P === void 0 ? {} : P, _ < 0 || S < 0 || 65535 < _ || 65535 < S)\n            throw new Error(\"x/y invalid.\");\n          if (E <= 0 || A <= 0 || 65535 < E || 65535 < A)\n            throw new Error(\"Width/Height invalid.\");\n          if (x.length < E * A)\n            throw new Error(\"Not enough pixels for the frame size.\");\n          var M = !0, R = P.palette;\n          if (R == null && (M = !1, R = o), R == null)\n            throw new Error(\"Must supply either a local or global palette.\");\n          for (var F = i(R), L = 0; F >>= 1; )\n            ++L;\n          var F = 1 << L, V = P.delay === void 0 ? 0 : P.delay, G = P.disposal === void 0 ? 0 : P.disposal;\n          if (G < 0 || 3 < G)\n            throw new Error(\"Disposal out of range.\");\n          var U = !1, W = 0;\n          if (P.transparent !== void 0 && P.transparent !== null && (U = !0, (W = P.transparent) < 0 || F <= W))\n            throw new Error(\"Transparent color index.\");\n          if (G === 0 && !U && V === 0 || (u[r++] = 33, u[r++] = 249, u[r++] = 4, u[r++] = G << 2 | (U === !0 ? 1 : 0), u[r++] = 255 & V, u[r++] = V >> 8 & 255, u[r++] = W, u[r++] = 0), u[r++] = 44, u[r++] = 255 & _, u[r++] = _ >> 8 & 255, u[r++] = 255 & S, u[r++] = S >> 8 & 255, u[r++] = 255 & E, u[r++] = E >> 8 & 255, u[r++] = 255 & A, u[r++] = A >> 8 & 255, u[r++] = M === !0 ? 128 | L - 1 : 0, M === !0)\n            for (var X = 0, ne = R.length; X < ne; ++X) {\n              var b = R[X];\n              u[r++] = b >> 16 & 255, u[r++] = b >> 8 & 255, u[r++] = 255 & b;\n            }\n          return r = function(O, D, B, Y) {\n            O[D++] = B;\n            var J = D++, te = 1 << B, ce = te - 1, re = 1 + te, ue = 1 + re, le = B + 1, K = 0, ae = 0;\n            function he(Ve) {\n              for (; Ve <= K; )\n                O[D++] = 255 & ae, ae >>= 8, K -= 8, D === J + 256 && (O[J] = 255, J = D++);\n            }\n            function _e(Ve) {\n              ae |= Ve << K, K += le, he(8);\n            }\n            var fe = Y[0] & ce, ge = {};\n            _e(te);\n            for (var xe = 1, De = Y.length; xe < De; ++xe) {\n              var Me = Y[xe] & ce, Qe = fe << 8 | Me, ze = ge[Qe];\n              if (ze === void 0) {\n                for (ae |= fe << K, K += le; 8 <= K; )\n                  O[D++] = 255 & ae, ae >>= 8, K -= 8, D === J + 256 && (O[J] = 255, J = D++);\n                ue === 4096 ? (_e(te), ue = 1 + re, le = B + 1, ge = {}) : (1 << le <= ue && ++le, ge[Qe] = ue++), fe = Me;\n              } else\n                fe = ze;\n            }\n            return _e(fe), _e(re), he(1), J + 1 === D ? O[J] = 0 : (O[J] = D - J - 1, O[D++] = 0), D;\n          }(u, r, L < 2 ? 2 : L, x);\n        }, this.end = function() {\n          return T === !1 && (u[r++] = 59, T = !0), r;\n        }, this.getOutputBuffer = function() {\n          return u;\n        }, this.setOutputBuffer = function(_) {\n          u = _;\n        }, this.getOutputBufferPosition = function() {\n          return r;\n        }, this.setOutputBufferPosition = function(_) {\n          r = _;\n        };\n      }\n      function y(u, h, g, f) {\n        for (var r = u[h++], s = 1 << r, o = 1 + s, i = 1 + o, l = r + 1, n = (1 << l) - 1, a = 0, c = 0, p = 0, j = u[h++], T = new Int32Array(4096), _ = null; ; ) {\n          for (; a < 16 && j !== 0; )\n            c |= u[h++] << a, a += 8, j === 1 ? j = u[h++] : --j;\n          if (a < l)\n            break;\n          var S = c & n;\n          if (c >>= l, a -= l, S == s)\n            i = 1 + o, n = (1 << (l = r + 1)) - 1, _ = null;\n          else {\n            if (S == o)\n              break;\n            for (var E = S < i ? S : _, A = 0, x = E; s < x; )\n              x = T[x] >> 8, ++A;\n            var P = x;\n            if (f < p + A + (E !== S ? 1 : 0))\n              return void console.log(\"Warning, gif stream longer than expected.\");\n            g[p++] = P;\n            var M = p += A;\n            for (E !== S && (g[p++] = P), x = E; A--; )\n              x = T[x], g[--M] = 255 & x, x >>= 8;\n            _ !== null && i < 4096 && (T[i++] = _ << 8 | P, n + 1 <= i && l < 12 && (++l, n = n << 1 | 1)), _ = S;\n          }\n        }\n        p !== f && console.log(\"Warning, gif stream shorter than expected.\");\n      }\n      try {\n        C.GifWriter = m, C.GifReader = function(u) {\n          var h = 0;\n          if (u[h++] !== 71 || u[h++] !== 73 || u[h++] !== 70 || u[h++] !== 56 || (u[h++] + 1 & 253) != 56 || u[h++] !== 97)\n            throw new Error(\"Invalid GIF 87a/89a header.\");\n          var g = u[h++] | u[h++] << 8, f = u[h++] | u[h++] << 8, r = u[h++], s = 1 << 1 + (7 & r), o = (u[h++], u[h++], null), i = null, l = (r >> 7 && (o = h, h += 3 * (i = s)), !0), n = [], a = 0, c = null, p = 0, j = null;\n          for (this.width = g, this.height = f; l && h < u.length; )\n            switch (u[h++]) {\n              case 33:\n                switch (u[h++]) {\n                  case 255:\n                    if (u[h] !== 11 || u[h + 1] == 78 && u[h + 2] == 69 && u[h + 3] == 84 && u[h + 4] == 83 && u[h + 5] == 67 && u[h + 6] == 65 && u[h + 7] == 80 && u[h + 8] == 69 && u[h + 9] == 50 && u[h + 10] == 46 && u[h + 11] == 48 && u[h + 12] == 3 && u[h + 13] == 1 && u[h + 16] == 0)\n                      h += 14, j = u[h++] | u[h++] << 8, h++;\n                    else\n                      for (h += 12; ; ) {\n                        if (!(0 <= (_ = u[h++])))\n                          throw Error(\"Invalid block size\");\n                        if (_ === 0)\n                          break;\n                        h += _;\n                      }\n                    break;\n                  case 249:\n                    if (u[h++] !== 4 || u[h + 4] !== 0)\n                      throw new Error(\"Invalid graphics extension block.\");\n                    var T = u[h++], a = u[h++] | u[h++] << 8, c = u[h++];\n                    !(1 & T) && (c = null), p = T >> 2 & 7, h++;\n                    break;\n                  case 254:\n                    for (; ; ) {\n                      if (!(0 <= (_ = u[h++])))\n                        throw Error(\"Invalid block size\");\n                      if (_ === 0)\n                        break;\n                      h += _;\n                    }\n                    break;\n                  default:\n                    throw new Error(\"Unknown graphic control label: 0x\" + u[h - 1].toString(16));\n                }\n                break;\n              case 44:\n                var _, S = u[h++] | u[h++] << 8, E = u[h++] | u[h++] << 8, A = u[h++] | u[h++] << 8, x = u[h++] | u[h++] << 8, V = u[h++], P = V >> 6 & 1, M = 1 << 1 + (7 & V), R = o, L = i, F = !1, V = (V >> 7 && (F = !0, R = h, h += 3 * (L = M)), h);\n                for (h++; ; ) {\n                  if (!(0 <= (_ = u[h++])))\n                    throw Error(\"Invalid block size\");\n                  if (_ === 0)\n                    break;\n                  h += _;\n                }\n                n.push({ x: S, y: E, width: A, height: x, has_local_palette: F, palette_offset: R, palette_size: L, data_offset: V, data_length: h - V, transparent_index: c, interlaced: !!P, delay: a, disposal: p });\n                break;\n              case 59:\n                l = !1;\n                break;\n              default:\n                throw new Error(\"Unknown gif block: 0x\" + u[h - 1].toString(16));\n            }\n          this.numFrames = function() {\n            return n.length;\n          }, this.loopCount = function() {\n            return j;\n          }, this.frameInfo = function(G) {\n            if (G < 0 || G >= n.length)\n              throw new Error(\"Frame index out of range.\");\n            return n[G];\n          }, this.decodeAndBlitFrameBGRA = function(G, U) {\n            for (var G = this.frameInfo(G), W = G.width * G.height, X = new Uint8Array(W), ne = (y(u, G.data_offset, X, W), G.palette_offset), b = G.transparent_index, O = (b === null && (b = 256), G.width), D = g - O, B = O, Y = 4 * (G.y * g + G.x), J = 4 * ((G.y + G.height) * g + G.x), te = Y, ce = 4 * D, re = (G.interlaced === !0 && (ce += 4 * g * 7), 8), ue = 0, le = X.length; ue < le; ++ue) {\n              var K, ae, he = X[ue];\n              B === 0 && (B = O, J <= (te += ce) && (ce = 4 * D + 4 * g * (re - 1), te = Y + (O + D) * (re << 1), re >>= 1)), he === b ? te += 4 : (K = u[ne + 3 * he], ae = u[ne + 3 * he + 1], he = u[ne + 3 * he + 2], U[te++] = he, U[te++] = ae, U[te++] = K, U[te++] = 255), --B;\n            }\n          }, this.decodeAndBlitFrameRGBA = function(G, U) {\n            for (var G = this.frameInfo(G), W = G.width * G.height, X = new Uint8Array(W), ne = (y(u, G.data_offset, X, W), G.palette_offset), b = G.transparent_index, O = (b === null && (b = 256), G.width), D = g - O, B = O, Y = 4 * (G.y * g + G.x), J = 4 * ((G.y + G.height) * g + G.x), te = Y, ce = 4 * D, re = (G.interlaced === !0 && (ce += 4 * g * 7), 8), ue = 0, le = X.length; ue < le; ++ue) {\n              var K, ae, he = X[ue];\n              B === 0 && (B = O, J <= (te += ce) && (ce = 4 * D + 4 * g * (re - 1), te = Y + (O + D) * (re << 1), re >>= 1)), he === b ? te += 4 : (K = u[ne + 3 * he], ae = u[ne + 3 * he + 1], he = u[ne + 3 * he + 2], U[te++] = K, U[te++] = ae, U[te++] = he, U[te++] = 255), --B;\n            }\n          };\n        };\n      } catch {\n      }\n    }, {}], 254: [function(t, H, C) {\n      (function(m) {\n        var y, u;\n        y = this, u = function(h) {\n          function g(I) {\n            if (this == null)\n              throw TypeError();\n            var v, w = String(this), k = w.length, I = I ? Number(I) : 0;\n            if (!((I = I != I ? 0 : I) < 0 || k <= I))\n              return 55296 <= (v = w.charCodeAt(I)) && v <= 56319 && I + 1 < k && 56320 <= (k = w.charCodeAt(I + 1)) && k <= 57343 ? 1024 * (v - 55296) + k - 56320 + 65536 : v;\n          }\n          String.prototype.codePointAt || ((f = function() {\n            try {\n              var d = {}, v = Object.defineProperty, w = v(d, d, d) && v;\n            } catch {\n            }\n            return w;\n          }()) ? f(String.prototype, \"codePointAt\", { value: g, configurable: !0, writable: !0 }) : String.prototype.codePointAt = g);\n          var f, r = 0, s = -3;\n          function o() {\n            this.table = new Uint16Array(16), this.trans = new Uint16Array(288);\n          }\n          function i(d, v) {\n            this.source = d, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = v, this.destLen = 0, this.ltree = new o(), this.dtree = new o();\n          }\n          var l = new o(), n = new o(), a = new Uint8Array(30), c = new Uint16Array(30), p = new Uint8Array(30), j = new Uint16Array(30), T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _ = new o(), S = new Uint8Array(320);\n          function E(d, v, w, k) {\n            for (var I, N = 0; N < w; ++N)\n              d[N] = 0;\n            for (N = 0; N < 30 - w; ++N)\n              d[N + w] = N / w | 0;\n            for (I = k, N = 0; N < 30; ++N)\n              v[N] = I, I += 1 << d[N];\n          }\n          var A = new Uint16Array(16);\n          function x(d, v, w, k) {\n            for (var I, N = 0; N < 16; ++N)\n              d.table[N] = 0;\n            for (N = 0; N < k; ++N)\n              d.table[v[w + N]]++;\n            for (N = I = d.table[0] = 0; N < 16; ++N)\n              A[N] = I, I += d.table[N];\n            for (N = 0; N < k; ++N)\n              v[w + N] && (d.trans[A[v[w + N]]++] = N);\n          }\n          function P(d, v, w) {\n            if (!v)\n              return w;\n            for (; d.bitcount < 24; )\n              d.tag |= d.source[d.sourceIndex++] << d.bitcount, d.bitcount += 8;\n            var k = d.tag & 65535 >>> 16 - v;\n            return d.tag >>>= v, d.bitcount -= v, k + w;\n          }\n          function M(d, v) {\n            for (; d.bitcount < 24; )\n              d.tag |= d.source[d.sourceIndex++] << d.bitcount, d.bitcount += 8;\n            for (var w = 0, k = 0, I = 0, N = d.tag; k = 2 * k + (1 & N), N >>>= 1, w += v.table[++I], 0 <= (k -= v.table[I]); )\n              ;\n            return d.tag = N, d.bitcount -= I, v.trans[w + k];\n          }\n          function R(d, v, w) {\n            for (; ; ) {\n              var k = M(d, v);\n              if (k === 256)\n                return r;\n              if (k < 256)\n                d.dest[d.destLen++] = k;\n              else\n                for (var I, N = P(d, a[k -= 257], c[k]), k = M(d, w), z = I = d.destLen - P(d, p[k], j[k]); z < I + N; ++z)\n                  d.dest[d.destLen++] = d.dest[z];\n            }\n          }\n          for (var L = l, F = n, V = 0; V < 7; ++V)\n            L.table[V] = 0;\n          for (L.table[7] = 24, L.table[8] = 152, L.table[9] = 112, V = 0; V < 24; ++V)\n            L.trans[V] = 256 + V;\n          for (V = 0; V < 144; ++V)\n            L.trans[24 + V] = V;\n          for (V = 0; V < 8; ++V)\n            L.trans[168 + V] = 280 + V;\n          for (V = 0; V < 112; ++V)\n            L.trans[176 + V] = 144 + V;\n          for (V = 0; V < 5; ++V)\n            F.table[V] = 0;\n          for (F.table[5] = 32, V = 0; V < 32; ++V)\n            F.trans[V] = V;\n          E(a, c, 4, 3), E(p, j, 2, 1), a[28] = 0, c[28] = 258;\n          var G = function(d, v) {\n            var w, k, I, N = new i(d, v);\n            do {\n              switch (I = void 0, (k = N).bitcount-- || (k.tag = k.source[k.sourceIndex++], k.bitcount = 7), I = 1 & k.tag, k.tag >>>= 1, k = I, P(N, 2, 0)) {\n                case 0:\n                  w = function(Ee) {\n                    for (var $e, lt; 8 < Ee.bitcount; )\n                      Ee.sourceIndex--, Ee.bitcount -= 8;\n                    if (($e = 256 * Ee.source[Ee.sourceIndex + 1] + Ee.source[Ee.sourceIndex]) !== (65535 & ~(256 * Ee.source[Ee.sourceIndex + 3] + Ee.source[Ee.sourceIndex + 2])))\n                      return s;\n                    for (Ee.sourceIndex += 4, lt = $e; lt; --lt)\n                      Ee.dest[Ee.destLen++] = Ee.source[Ee.sourceIndex++];\n                    return Ee.bitcount = 0, r;\n                  }(N);\n                  break;\n                case 1:\n                  w = R(N, l, n);\n                  break;\n                case 2:\n                  Ae = ke = Ie = Te = z = de = be = Se = ye = oe = se = Q = void 0;\n                  for (var z, Q = N, se = N.ltree, oe = N.dtree, ye = P(Q, 5, 257), Se = P(Q, 5, 1), be = P(Q, 4, 4), de = 0; de < 19; ++de)\n                    S[de] = 0;\n                  for (de = 0; de < be; ++de) {\n                    var Ie = P(Q, 3, 0);\n                    S[T[de]] = Ie;\n                  }\n                  for (x(_, S, 0, 19), z = 0; z < ye + Se; ) {\n                    var ke = M(Q, _);\n                    switch (ke) {\n                      case 16:\n                        for (var Ae = S[z - 1], Te = P(Q, 2, 3); Te; --Te)\n                          S[z++] = Ae;\n                        break;\n                      case 17:\n                        for (Te = P(Q, 3, 3); Te; --Te)\n                          S[z++] = 0;\n                        break;\n                      case 18:\n                        for (Te = P(Q, 7, 11); Te; --Te)\n                          S[z++] = 0;\n                        break;\n                      default:\n                        S[z++] = ke;\n                    }\n                  }\n                  x(se, S, 0, ye), x(oe, S, ye, Se), w = R(N, N.ltree, N.dtree);\n                  break;\n                default:\n                  w = s;\n              }\n              if (w !== r)\n                throw new Error(\"Data error\");\n            } while (!k);\n            return N.destLen < N.dest.length ? typeof N.dest.slice == \"function\" ? N.dest.slice(0, N.destLen) : N.dest.subarray(0, N.destLen) : N.dest;\n          };\n          function U(d, v, w, k, I) {\n            return Math.pow(1 - I, 3) * d + 3 * Math.pow(1 - I, 2) * I * v + 3 * (1 - I) * Math.pow(I, 2) * w + Math.pow(I, 3) * k;\n          }\n          function W() {\n            this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;\n          }\n          function X() {\n            this.commands = [], this.fill = \"black\", this.stroke = null, this.strokeWidth = 1;\n          }\n          function ne(d) {\n            throw new Error(d);\n          }\n          function b(d, v) {\n            d || ne(v);\n          }\n          W.prototype.isEmpty = function() {\n            return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n          }, W.prototype.addPoint = function(d, v) {\n            typeof d == \"number\" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = d, this.x2 = d), d < this.x1 && (this.x1 = d), d > this.x2 && (this.x2 = d)), typeof v == \"number\" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = v, this.y2 = v), v < this.y1 && (this.y1 = v), v > this.y2 && (this.y2 = v));\n          }, W.prototype.addX = function(d) {\n            this.addPoint(d, null);\n          }, W.prototype.addY = function(d) {\n            this.addPoint(null, d);\n          }, W.prototype.addBezier = function(d, v, w, k, I, N, z, Q) {\n            var se = [d, v], oe = [w, k], ye = [I, N], Se = [z, Q];\n            this.addPoint(d, v), this.addPoint(z, Q);\n            for (var be = 0; be <= 1; be++) {\n              var de, Ie = 6 * se[be] - 12 * oe[be] + 6 * ye[be], ke = -3 * se[be] + 9 * oe[be] - 9 * ye[be] + 3 * Se[be], Ae = 3 * oe[be] - 3 * se[be];\n              ke == 0 ? Ie == 0 || 0 < (de = -Ae / Ie) && de < 1 && (be === 0 && this.addX(U(se[be], oe[be], ye[be], Se[be], de)), be === 1 && this.addY(U(se[be], oe[be], ye[be], Se[be], de))) : (de = Math.pow(Ie, 2) - 4 * Ae * ke) < 0 || (0 < (Ae = (-Ie + Math.sqrt(de)) / (2 * ke)) && Ae < 1 && (be === 0 && this.addX(U(se[be], oe[be], ye[be], Se[be], Ae)), be === 1 && this.addY(U(se[be], oe[be], ye[be], Se[be], Ae))), 0 < (Ae = (-Ie - Math.sqrt(de)) / (2 * ke)) && Ae < 1 && (be === 0 && this.addX(U(se[be], oe[be], ye[be], Se[be], Ae)), be === 1 && this.addY(U(se[be], oe[be], ye[be], Se[be], Ae))));\n            }\n          }, W.prototype.addQuad = function(d, v, w, k, I, N) {\n            w = d + 2 / 3 * (w - d), k = v + 2 / 3 * (k - v), this.addBezier(d, v, w, k, w + 1 / 3 * (I - d), k + 1 / 3 * (N - v), I, N);\n          }, X.prototype.moveTo = function(d, v) {\n            this.commands.push({ type: \"M\", x: d, y: v });\n          }, X.prototype.lineTo = function(d, v) {\n            this.commands.push({ type: \"L\", x: d, y: v });\n          }, X.prototype.curveTo = X.prototype.bezierCurveTo = function(d, v, w, k, I, N) {\n            this.commands.push({ type: \"C\", x1: d, y1: v, x2: w, y2: k, x: I, y: N });\n          }, X.prototype.quadTo = X.prototype.quadraticCurveTo = function(d, v, w, k) {\n            this.commands.push({ type: \"Q\", x1: d, y1: v, x: w, y: k });\n          }, X.prototype.close = X.prototype.closePath = function() {\n            this.commands.push({ type: \"Z\" });\n          }, X.prototype.extend = function(d) {\n            var v;\n            if (d.commands)\n              d = d.commands;\n            else if (d instanceof W)\n              return v = d, this.moveTo(v.x1, v.y1), this.lineTo(v.x2, v.y1), this.lineTo(v.x2, v.y2), this.lineTo(v.x1, v.y2), void this.close();\n            Array.prototype.push.apply(this.commands, d);\n          }, X.prototype.getBoundingBox = function() {\n            for (var d = new W(), v = 0, w = 0, k = 0, I = 0, N = 0; N < this.commands.length; N++) {\n              var z = this.commands[N];\n              switch (z.type) {\n                case \"M\":\n                  d.addPoint(z.x, z.y), v = k = z.x, w = I = z.y;\n                  break;\n                case \"L\":\n                  d.addPoint(z.x, z.y), k = z.x, I = z.y;\n                  break;\n                case \"Q\":\n                  d.addQuad(k, I, z.x1, z.y1, z.x, z.y), k = z.x, I = z.y;\n                  break;\n                case \"C\":\n                  d.addBezier(k, I, z.x1, z.y1, z.x2, z.y2, z.x, z.y), k = z.x, I = z.y;\n                  break;\n                case \"Z\":\n                  k = v, I = w;\n                  break;\n                default:\n                  throw new Error(\"Unexpected path command \" + z.type);\n              }\n            }\n            return d.isEmpty() && d.addPoint(0, 0), d;\n          }, X.prototype.draw = function(d) {\n            d.beginPath();\n            for (var v = 0; v < this.commands.length; v += 1) {\n              var w = this.commands[v];\n              w.type === \"M\" ? d.moveTo(w.x, w.y) : w.type === \"L\" ? d.lineTo(w.x, w.y) : w.type === \"C\" ? d.bezierCurveTo(w.x1, w.y1, w.x2, w.y2, w.x, w.y) : w.type === \"Q\" ? d.quadraticCurveTo(w.x1, w.y1, w.x, w.y) : w.type === \"Z\" && d.closePath();\n            }\n            this.fill && (d.fillStyle = this.fill, d.fill()), this.stroke && (d.strokeStyle = this.stroke, d.lineWidth = this.strokeWidth, d.stroke());\n          }, X.prototype.toPathData = function(d) {\n            function v() {\n              for (var N = arguments, z = \"\", Q = 0; Q < arguments.length; Q += 1) {\n                var se = N[Q];\n                0 <= se && 0 < Q && (z += \" \"), z += (se = se, Math.round(se) === se ? \"\" + Math.round(se) : se.toFixed(d));\n              }\n              return z;\n            }\n            d = d !== void 0 ? d : 2;\n            for (var w = \"\", k = 0; k < this.commands.length; k += 1) {\n              var I = this.commands[k];\n              I.type === \"M\" ? w += \"M\" + v(I.x, I.y) : I.type === \"L\" ? w += \"L\" + v(I.x, I.y) : I.type === \"C\" ? w += \"C\" + v(I.x1, I.y1, I.x2, I.y2, I.x, I.y) : I.type === \"Q\" ? w += \"Q\" + v(I.x1, I.y1, I.x, I.y) : I.type === \"Z\" && (w += \"Z\");\n            }\n            return w;\n          }, X.prototype.toSVG = function(d) {\n            var v = (v = '<path d=\"') + this.toPathData(d) + '\"';\n            return this.fill && this.fill !== \"black\" && (this.fill === null ? v += ' fill=\"none\"' : v += ' fill=\"' + this.fill + '\"'), this.stroke && (v += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"'), v += \"/>\";\n          }, X.prototype.toDOMElement = function(v) {\n            var v = this.toPathData(v), w = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            return w.setAttribute(\"d\", v), w;\n          };\n          var O = { fail: ne, argument: b, assert: b }, D = {}, B = {}, Y = {};\n          function J(d) {\n            return function() {\n              return d;\n            };\n          }\n          B.BYTE = function(d) {\n            return O.argument(0 <= d && d <= 255, \"Byte value should be between 0 and 255.\"), [d];\n          }, Y.BYTE = J(1), B.CHAR = function(d) {\n            return [d.charCodeAt(0)];\n          }, Y.CHAR = J(1), B.CHARARRAY = function(d) {\n            for (var v = [], w = 0; w < d.length; w += 1)\n              v[w] = d.charCodeAt(w);\n            return v;\n          }, Y.CHARARRAY = function(d) {\n            return d.length;\n          }, B.USHORT = function(d) {\n            return [d >> 8 & 255, 255 & d];\n          }, Y.USHORT = J(2), B.SHORT = function(d) {\n            return [(d = 32768 <= d ? -(65536 - d) : d) >> 8 & 255, 255 & d];\n          }, Y.SHORT = J(2), B.UINT24 = function(d) {\n            return [d >> 16 & 255, d >> 8 & 255, 255 & d];\n          }, Y.UINT24 = J(3), B.ULONG = function(d) {\n            return [d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];\n          }, Y.ULONG = J(4), B.LONG = function(d) {\n            return [(d = 2147483648 <= d ? -(4294967296 - d) : d) >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];\n          }, Y.LONG = J(4), B.FIXED = B.ULONG, Y.FIXED = Y.ULONG, B.FWORD = B.SHORT, Y.FWORD = Y.SHORT, B.UFWORD = B.USHORT, Y.UFWORD = Y.USHORT, B.LONGDATETIME = function(d) {\n            return [0, 0, 0, 0, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];\n          }, Y.LONGDATETIME = J(8), B.TAG = function(d) {\n            return O.argument(d.length === 4, \"Tag should be exactly 4 ASCII characters.\"), [d.charCodeAt(0), d.charCodeAt(1), d.charCodeAt(2), d.charCodeAt(3)];\n          }, Y.TAG = J(4), B.Card8 = B.BYTE, Y.Card8 = Y.BYTE, B.Card16 = B.USHORT, Y.Card16 = Y.USHORT, B.OffSize = B.BYTE, Y.OffSize = Y.BYTE, B.SID = B.USHORT, Y.SID = Y.USHORT, B.NUMBER = function(d) {\n            return -107 <= d && d <= 107 ? [d + 139] : 108 <= d && d <= 1131 ? [247 + ((d -= 108) >> 8), 255 & d] : -1131 <= d && d <= -108 ? [251 + ((d = -d - 108) >> 8), 255 & d] : -32768 <= d && d <= 32767 ? B.NUMBER16(d) : B.NUMBER32(d);\n          }, Y.NUMBER = function(d) {\n            return B.NUMBER(d).length;\n          }, B.NUMBER16 = function(d) {\n            return [28, d >> 8 & 255, 255 & d];\n          }, Y.NUMBER16 = J(3), B.NUMBER32 = function(d) {\n            return [29, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];\n          }, Y.NUMBER32 = J(5), B.REAL = function(d) {\n            for (var v = d.toString(), w = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(v), k = (w && (w = parseFloat(\"1e\" + ((w[2] ? +w[2] : 0) + w[1].length)), v = (Math.round(d * w) / w).toString()), \"\"), I = 0, N = v.length; I < N; I += 1) {\n              var z = v[I];\n              k += z === \"e\" ? v[++I] === \"-\" ? \"c\" : \"b\" : z === \".\" ? \"a\" : z === \"-\" ? \"e\" : z;\n            }\n            for (var Q = [30], se = 0, oe = (k += 1 & k.length ? \"f\" : \"ff\").length; se < oe; se += 2)\n              Q.push(parseInt(k.substr(se, 2), 16));\n            return Q;\n          }, Y.REAL = function(d) {\n            return B.REAL(d).length;\n          }, B.NAME = B.CHARARRAY, Y.NAME = Y.CHARARRAY, B.STRING = B.CHARARRAY, Y.STRING = Y.CHARARRAY, D.UTF8 = function(d, v, w) {\n            for (var k = [], I = w, N = 0; N < I; N++, v += 1)\n              k[N] = d.getUint8(v);\n            return String.fromCharCode.apply(null, k);\n          }, D.UTF16 = function(d, v, w) {\n            for (var k = [], I = w / 2, N = 0; N < I; N++, v += 2)\n              k[N] = d.getUint16(v);\n            return String.fromCharCode.apply(null, k);\n          }, B.UTF16 = function(d) {\n            for (var v = [], w = 0; w < d.length; w += 1) {\n              var k = d.charCodeAt(w);\n              v[v.length] = k >> 8 & 255, v[v.length] = 255 & k;\n            }\n            return v;\n          }, Y.UTF16 = function(d) {\n            return 2 * d.length;\n          };\n          var te, ce = { \"x-mac-croatian\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ\", \"x-mac-cyrillic\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю\", \"x-mac-gaelic\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ\", \"x-mac-greek\": \"Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­\", \"x-mac-icelandic\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\", \"x-mac-inuit\": \"ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł\", \"x-mac-ce\": \"ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ\", macintosh: \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\", \"x-mac-romanian\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\", \"x-mac-turkish\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ\" }, re = (D.MACSTRING = function(d, v, w, k) {\n            var I = ce[k];\n            if (I !== void 0) {\n              for (var N = \"\", z = 0; z < w; z++) {\n                var Q = d.getUint8(v + z);\n                N += Q <= 127 ? String.fromCharCode(Q) : I[127 & Q];\n              }\n              return N;\n            }\n          }, typeof WeakMap == \"function\" && /* @__PURE__ */ new WeakMap());\n          function ue(d) {\n            return -128 <= d && d <= 127;\n          }\n          B.MACSTRING = function(d, v) {\n            var w = function(z) {\n              if (!te)\n                for (var Q in te = {}, ce)\n                  te[Q] = new String(Q);\n              var se = te[z];\n              if (se !== void 0) {\n                if (re) {\n                  var oe = re.get(se);\n                  if (oe !== void 0)\n                    return oe;\n                }\n                var ye = ce[z];\n                if (ye !== void 0) {\n                  for (var Se = {}, be = 0; be < ye.length; be++)\n                    Se[ye.charCodeAt(be)] = be + 128;\n                  return re && re.set(se, Se), Se;\n                }\n              }\n            }(v);\n            if (w !== void 0) {\n              for (var k = [], I = 0; I < d.length; I++) {\n                var N = d.charCodeAt(I);\n                if (128 <= N && (N = w[N]) === void 0)\n                  return;\n                k[I] = N;\n              }\n              return k;\n            }\n          }, Y.MACSTRING = function(d, v) {\n            return d = B.MACSTRING(d, v), d !== void 0 ? d.length : 0;\n          }, B.VARDELTAS = function(d) {\n            for (var k = 0, v = []; k < d.length; )\n              var w = d[k], k = (w === 0 ? function(I, N, z) {\n                for (var Q = 0, se = I.length; N < se && Q < 64 && I[N] === 0; )\n                  ++N, ++Q;\n                return z.push(128 | Q - 1), N;\n              } : -128 <= w && w <= 127 ? function(I, N, z) {\n                for (var Q = 0, se = I.length, oe = N; oe < se && Q < 64; ) {\n                  var ye = I[oe];\n                  if (!ue(ye) || ye === 0 && oe + 1 < se && I[oe + 1] === 0)\n                    break;\n                  ++oe, ++Q;\n                }\n                z.push(Q - 1);\n                for (var Se = N; Se < oe; ++Se)\n                  z.push(I[Se] + 256 & 255);\n                return oe;\n              } : function(I, N, z) {\n                for (var Q = 0, se = I.length, oe = N; oe < se && Q < 64; ) {\n                  var ye = I[oe];\n                  if (ye === 0 || ue(ye) && oe + 1 < se && ue(I[oe + 1]))\n                    break;\n                  ++oe, ++Q;\n                }\n                z.push(64 | Q - 1);\n                for (var Se = N; Se < oe; ++Se) {\n                  var be = I[Se];\n                  z.push(be + 65536 >> 8 & 255, be + 256 & 255);\n                }\n                return oe;\n              })(d, k, v);\n            return v;\n          }, B.INDEX = function(d) {\n            for (var v = 1, w = [v], k = [], I = 0; I < d.length; I += 1) {\n              var N = B.OBJECT(d[I]);\n              Array.prototype.push.apply(k, N), v += N.length, w.push(v);\n            }\n            if (k.length === 0)\n              return [0, 0];\n            for (var z = [], Q = 1 + Math.floor(Math.log(v) / Math.log(2)) / 8 | 0, se = [void 0, B.BYTE, B.USHORT, B.UINT24, B.ULONG][Q], oe = 0; oe < w.length; oe += 1) {\n              var ye = se(w[oe]);\n              Array.prototype.push.apply(z, ye);\n            }\n            return Array.prototype.concat(B.Card16(d.length), B.OffSize(Q), z, k);\n          }, Y.INDEX = function(d) {\n            return B.INDEX(d).length;\n          }, B.DICT = function(d) {\n            for (var v = [], w = Object.keys(d), k = w.length, I = 0; I < k; I += 1) {\n              var N = parseInt(w[I], 0), z = d[N];\n              v = (v = v.concat(B.OPERAND(z.value, z.type))).concat(B.OPERATOR(N));\n            }\n            return v;\n          }, Y.DICT = function(d) {\n            return B.DICT(d).length;\n          }, B.OPERATOR = function(d) {\n            return d < 1200 ? [d] : [12, d - 1200];\n          }, B.OPERAND = function(d, v) {\n            var w = [];\n            if (Array.isArray(v))\n              for (var k = 0; k < v.length; k += 1)\n                O.argument(d.length === v.length, \"Not enough arguments given for type\" + v), w = w.concat(B.OPERAND(d[k], v[k]));\n            else if (v === \"SID\")\n              w = w.concat(B.NUMBER(d));\n            else if (v === \"offset\")\n              w = w.concat(B.NUMBER32(d));\n            else if (v === \"number\")\n              w = w.concat(B.NUMBER(d));\n            else {\n              if (v !== \"real\")\n                throw new Error(\"Unknown operand type \" + v);\n              w = w.concat(B.REAL(d));\n            }\n            return w;\n          }, B.OP = B.BYTE, Y.OP = Y.BYTE;\n          var le = typeof WeakMap == \"function\" && /* @__PURE__ */ new WeakMap();\n          function K(d, v, w) {\n            for (var k = 0; k < v.length; k += 1) {\n              var I = v[k];\n              this[I.name] = I.value;\n            }\n            if (this.tableName = d, this.fields = v, w)\n              for (var N = Object.keys(w), z = 0; z < N.length; z += 1) {\n                var Q = N[z], se = w[Q];\n                this[Q] !== void 0 && (this[Q] = se);\n              }\n          }\n          function ae(d, v, w) {\n            w === void 0 && (w = v.length);\n            var k = new Array(v.length + 1);\n            k[0] = { name: d + \"Count\", type: \"USHORT\", value: w };\n            for (var I = 0; I < v.length; I++)\n              k[I + 1] = { name: d + I, type: \"USHORT\", value: v[I] };\n            return k;\n          }\n          function he(d, v, w) {\n            var k = v.length, I = new Array(k + 1);\n            I[0] = { name: d + \"Count\", type: \"USHORT\", value: k };\n            for (var N = 0; N < k; N++)\n              I[N + 1] = { name: d + N, type: \"TABLE\", value: w(v[N], N) };\n            return I;\n          }\n          function _e(d, v, w) {\n            var k = v.length, I = [];\n            I[0] = { name: d + \"Count\", type: \"USHORT\", value: k };\n            for (var N = 0; N < k; N++)\n              I = I.concat(w(v[N], N));\n            return I;\n          }\n          function fe(d) {\n            d.format === 1 ? K.call(this, \"coverageTable\", [{ name: \"coverageFormat\", type: \"USHORT\", value: 1 }].concat(ae(\"glyph\", d.glyphs))) : O.assert(!1, \"Can't create coverage table format 2 yet.\");\n          }\n          function ge(d) {\n            K.call(this, \"scriptListTable\", _e(\"scriptRecord\", d, function(v, w) {\n              var k = v.script, I = k.defaultLangSys;\n              return O.assert(!!I, \"Unable to write GSUB: script \" + v.tag + \" has no default language system.\"), [{ name: \"scriptTag\" + w, type: \"TAG\", value: v.tag }, { name: \"script\" + w, type: \"TABLE\", value: new K(\"scriptTable\", [{ name: \"defaultLangSys\", type: \"TABLE\", value: new K(\"defaultLangSys\", [{ name: \"lookupOrder\", type: \"USHORT\", value: 0 }, { name: \"reqFeatureIndex\", type: \"USHORT\", value: I.reqFeatureIndex }].concat(ae(\"featureIndex\", I.featureIndexes))) }].concat(_e(\"langSys\", k.langSysRecords, function(N, z) {\n                var Q = N.langSys;\n                return [{ name: \"langSysTag\" + z, type: \"TAG\", value: N.tag }, { name: \"langSys\" + z, type: \"TABLE\", value: new K(\"langSys\", [{ name: \"lookupOrder\", type: \"USHORT\", value: 0 }, { name: \"reqFeatureIndex\", type: \"USHORT\", value: Q.reqFeatureIndex }].concat(ae(\"featureIndex\", Q.featureIndexes))) }];\n              }))) }];\n            }));\n          }\n          function xe(d) {\n            K.call(this, \"featureListTable\", _e(\"featureRecord\", d, function(v, w) {\n              var k = v.feature;\n              return [{ name: \"featureTag\" + w, type: \"TAG\", value: v.tag }, { name: \"feature\" + w, type: \"TABLE\", value: new K(\"featureTable\", [{ name: \"featureParams\", type: \"USHORT\", value: k.featureParams }].concat(ae(\"lookupListIndex\", k.lookupListIndexes))) }];\n            }));\n          }\n          function De(d, v) {\n            K.call(this, \"lookupListTable\", he(\"lookup\", d, function(w) {\n              var k = v[w.lookupType];\n              return O.assert(!!k, \"Unable to write GSUB lookup type \" + w.lookupType + \" tables.\"), new K(\"lookupTable\", [{ name: \"lookupType\", type: \"USHORT\", value: w.lookupType }, { name: \"lookupFlag\", type: \"USHORT\", value: w.lookupFlag }].concat(he(\"subtable\", w.subtables, k)));\n            }));\n          }\n          B.CHARSTRING = function(d) {\n            if (le) {\n              var v = le.get(d);\n              if (v !== void 0)\n                return v;\n            }\n            for (var N = [], w = d.length, k = 0; k < w; k += 1)\n              var I = d[k], N = N.concat(B[I.type](I.value));\n            return le && le.set(d, N), N;\n          }, Y.CHARSTRING = function(d) {\n            return B.CHARSTRING(d).length;\n          }, B.OBJECT = function(d) {\n            var v = B[d.type];\n            return O.argument(v !== void 0, \"No encoding function for type \" + d.type), v(d.value);\n          }, Y.OBJECT = function(d) {\n            var v = Y[d.type];\n            return O.argument(v !== void 0, \"No sizeOf function for type \" + d.type), v(d.value);\n          }, B.TABLE = function(d) {\n            for (var v = [], w = d.fields.length, k = [], I = [], N = 0; N < w; N += 1) {\n              var z = d.fields[N], se = B[z.type], Q = (O.argument(se !== void 0, \"No encoding function for field type \" + z.type + \" (\" + z.name + \")\"), d[z.name]), se = se(Q = Q === void 0 ? z.value : Q);\n              z.type === \"TABLE\" ? (I.push(v.length), v = v.concat([0, 0]), k.push(se)) : v = v.concat(se);\n            }\n            for (var oe = 0; oe < k.length; oe += 1) {\n              var ye = I[oe], Se = v.length;\n              O.argument(Se < 65536, \"Table \" + d.tableName + \" too big.\"), v[ye] = Se >> 8, v[ye + 1] = 255 & Se, v = v.concat(k[oe]);\n            }\n            return v;\n          }, Y.TABLE = function(d) {\n            for (var v = 0, w = d.fields.length, k = 0; k < w; k += 1) {\n              var I = d.fields[k], N = Y[I.type], z = (O.argument(N !== void 0, \"No sizeOf function for field type \" + I.type + \" (\" + I.name + \")\"), d[I.name]);\n              v += N(z = z === void 0 ? I.value : z), I.type === \"TABLE\" && (v += 2);\n            }\n            return v;\n          }, B.RECORD = B.TABLE, Y.RECORD = Y.TABLE, B.LITERAL = function(d) {\n            return d;\n          }, Y.LITERAL = function(d) {\n            return d.length;\n          }, K.prototype.encode = function() {\n            return B.TABLE(this);\n          }, K.prototype.sizeOf = function() {\n            return Y.TABLE(this);\n          };\n          var Me = { Table: K, Record: K, Coverage: (fe.prototype = Object.create(K.prototype)).constructor = fe, ScriptList: (ge.prototype = Object.create(K.prototype)).constructor = ge, FeatureList: (xe.prototype = Object.create(K.prototype)).constructor = xe, LookupList: (De.prototype = Object.create(K.prototype)).constructor = De, ushortList: ae, tableList: he, recordList: _e };\n          function Qe(d, v) {\n            return d.getUint8(v);\n          }\n          function ze(d, v) {\n            return d.getUint16(v, !1);\n          }\n          function Ve(d, v) {\n            return d.getUint32(v, !1);\n          }\n          function Xe(d, v) {\n            return d.getInt16(v, !1) + d.getUint16(v + 2, !1) / 65535;\n          }\n          var He = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };\n          function ve(d, v) {\n            this.data = d, this.offset = v, this.relativeOffset = 0;\n          }\n          ve.prototype.parseByte = function() {\n            var d = this.data.getUint8(this.offset + this.relativeOffset);\n            return this.relativeOffset += 1, d;\n          }, ve.prototype.parseChar = function() {\n            var d = this.data.getInt8(this.offset + this.relativeOffset);\n            return this.relativeOffset += 1, d;\n          }, ve.prototype.parseCard8 = ve.prototype.parseByte, ve.prototype.parseCard16 = ve.prototype.parseUShort = function() {\n            var d = this.data.getUint16(this.offset + this.relativeOffset);\n            return this.relativeOffset += 2, d;\n          }, ve.prototype.parseSID = ve.prototype.parseUShort, ve.prototype.parseOffset16 = ve.prototype.parseUShort, ve.prototype.parseShort = function() {\n            var d = this.data.getInt16(this.offset + this.relativeOffset);\n            return this.relativeOffset += 2, d;\n          }, ve.prototype.parseF2Dot14 = function() {\n            var d = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n            return this.relativeOffset += 2, d;\n          }, ve.prototype.parseOffset32 = ve.prototype.parseULong = function() {\n            var d = Ve(this.data, this.offset + this.relativeOffset);\n            return this.relativeOffset += 4, d;\n          }, ve.prototype.parseFixed = function() {\n            var d = Xe(this.data, this.offset + this.relativeOffset);\n            return this.relativeOffset += 4, d;\n          }, ve.prototype.parseString = function(d) {\n            var v = this.data, w = this.offset + this.relativeOffset, k = \"\";\n            this.relativeOffset += d;\n            for (var I = 0; I < d; I++)\n              k += String.fromCharCode(v.getUint8(w + I));\n            return k;\n          }, ve.prototype.parseTag = function() {\n            return this.parseString(4);\n          }, ve.prototype.parseLongDateTime = function() {\n            var d = Ve(this.data, this.offset + this.relativeOffset + 4);\n            return d -= 2082844800, this.relativeOffset += 8, d;\n          }, ve.prototype.parseVersion = function(d) {\n            var v = ze(this.data, this.offset + this.relativeOffset), w = ze(this.data, this.offset + this.relativeOffset + 2);\n            return this.relativeOffset += 4, v + w / (d = d === void 0 ? 4096 : d) / 10;\n          }, ve.prototype.skip = function(d, v) {\n            this.relativeOffset += He[d] * (v = v === void 0 ? 1 : v);\n          }, ve.prototype.parseULongList = function(d) {\n            d === void 0 && (d = this.parseULong());\n            for (var v = new Array(d), w = this.data, k = this.offset + this.relativeOffset, I = 0; I < d; I++)\n              v[I] = w.getUint32(k), k += 4;\n            return this.relativeOffset += 4 * d, v;\n          }, ve.prototype.parseOffset16List = ve.prototype.parseUShortList = function(d) {\n            d === void 0 && (d = this.parseUShort());\n            for (var v = new Array(d), w = this.data, k = this.offset + this.relativeOffset, I = 0; I < d; I++)\n              v[I] = w.getUint16(k), k += 2;\n            return this.relativeOffset += 2 * d, v;\n          }, ve.prototype.parseShortList = function(d) {\n            for (var v = new Array(d), w = this.data, k = this.offset + this.relativeOffset, I = 0; I < d; I++)\n              v[I] = w.getInt16(k), k += 2;\n            return this.relativeOffset += 2 * d, v;\n          }, ve.prototype.parseByteList = function(d) {\n            for (var v = new Array(d), w = this.data, k = this.offset + this.relativeOffset, I = 0; I < d; I++)\n              v[I] = w.getUint8(k++);\n            return this.relativeOffset += d, v;\n          }, ve.prototype.parseList = function(d, v) {\n            v || (v = d, d = this.parseUShort());\n            for (var w = new Array(d), k = 0; k < d; k++)\n              w[k] = v.call(this);\n            return w;\n          }, ve.prototype.parseList32 = function(d, v) {\n            v || (v = d, d = this.parseULong());\n            for (var w = new Array(d), k = 0; k < d; k++)\n              w[k] = v.call(this);\n            return w;\n          }, ve.prototype.parseRecordList = function(d, v) {\n            v || (v = d, d = this.parseUShort());\n            for (var w = new Array(d), k = Object.keys(v), I = 0; I < d; I++) {\n              for (var N = {}, z = 0; z < k.length; z++) {\n                var Q = k[z], se = v[Q];\n                N[Q] = se.call(this);\n              }\n              w[I] = N;\n            }\n            return w;\n          }, ve.prototype.parseRecordList32 = function(d, v) {\n            v || (v = d, d = this.parseULong());\n            for (var w = new Array(d), k = Object.keys(v), I = 0; I < d; I++) {\n              for (var N = {}, z = 0; z < k.length; z++) {\n                var Q = k[z], se = v[Q];\n                N[Q] = se.call(this);\n              }\n              w[I] = N;\n            }\n            return w;\n          }, ve.prototype.parseStruct = function(d) {\n            if (typeof d == \"function\")\n              return d.call(this);\n            for (var v = Object.keys(d), w = {}, k = 0; k < v.length; k++) {\n              var I = v[k], N = d[I];\n              w[I] = N.call(this);\n            }\n            return w;\n          }, ve.prototype.parseValueRecord = function(d) {\n            var v;\n            if ((d = d === void 0 ? this.parseUShort() : d) !== 0)\n              return v = {}, 1 & d && (v.xPlacement = this.parseShort()), 2 & d && (v.yPlacement = this.parseShort()), 4 & d && (v.xAdvance = this.parseShort()), 8 & d && (v.yAdvance = this.parseShort()), 16 & d && (v.xPlaDevice = void 0, this.parseShort()), 32 & d && (v.yPlaDevice = void 0, this.parseShort()), 64 & d && (v.xAdvDevice = void 0, this.parseShort()), 128 & d && (v.yAdvDevice = void 0, this.parseShort()), v;\n          }, ve.prototype.parseValueRecordList = function() {\n            for (var d = this.parseUShort(), v = this.parseUShort(), w = new Array(v), k = 0; k < v; k++)\n              w[k] = this.parseValueRecord(d);\n            return w;\n          }, ve.prototype.parsePointer = function(d) {\n            var v = this.parseOffset16();\n            if (0 < v)\n              return new ve(this.data, this.offset + v).parseStruct(d);\n          }, ve.prototype.parsePointer32 = function(d) {\n            var v = this.parseOffset32();\n            if (0 < v)\n              return new ve(this.data, this.offset + v).parseStruct(d);\n          }, ve.prototype.parseListOfLists = function(d) {\n            for (var v = this.parseOffset16List(), w = v.length, k = this.relativeOffset, I = new Array(w), N = 0; N < w; N++) {\n              var z = v[N];\n              if (z === 0)\n                I[N] = void 0;\n              else if (this.relativeOffset = z, d) {\n                for (var Q = this.parseOffset16List(), se = new Array(Q.length), oe = 0; oe < Q.length; oe++)\n                  this.relativeOffset = z + Q[oe], se[oe] = d.call(this);\n                I[N] = se;\n              } else\n                I[N] = this.parseUShortList();\n            }\n            return this.relativeOffset = k, I;\n          }, ve.prototype.parseCoverage = function() {\n            var d = this.offset + this.relativeOffset, v = this.parseUShort(), w = this.parseUShort();\n            if (v === 1)\n              return { format: 1, glyphs: this.parseUShortList(w) };\n            if (v !== 2)\n              throw new Error(\"0x\" + d.toString(16) + \": Coverage format must be 1 or 2.\");\n            for (var k = new Array(w), I = 0; I < w; I++)\n              k[I] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };\n            return { format: 2, ranges: k };\n          }, ve.prototype.parseClassDef = function() {\n            var d = this.offset + this.relativeOffset, v = this.parseUShort();\n            if (v === 1)\n              return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };\n            if (v === 2)\n              return { format: 2, ranges: this.parseRecordList({ start: ve.uShort, end: ve.uShort, classId: ve.uShort }) };\n            throw new Error(\"0x\" + d.toString(16) + \": ClassDef format must be 1 or 2.\");\n          }, ve.list = function(d, v) {\n            return function() {\n              return this.parseList(d, v);\n            };\n          }, ve.list32 = function(d, v) {\n            return function() {\n              return this.parseList32(d, v);\n            };\n          }, ve.recordList = function(d, v) {\n            return function() {\n              return this.parseRecordList(d, v);\n            };\n          }, ve.recordList32 = function(d, v) {\n            return function() {\n              return this.parseRecordList32(d, v);\n            };\n          }, ve.pointer = function(d) {\n            return function() {\n              return this.parsePointer(d);\n            };\n          }, ve.pointer32 = function(d) {\n            return function() {\n              return this.parsePointer32(d);\n            };\n          }, ve.tag = ve.prototype.parseTag, ve.byte = ve.prototype.parseByte, ve.uShort = ve.offset16 = ve.prototype.parseUShort, ve.uShortList = ve.prototype.parseUShortList, ve.uLong = ve.offset32 = ve.prototype.parseULong, ve.uLongList = ve.prototype.parseULongList, ve.struct = ve.prototype.parseStruct, ve.coverage = ve.prototype.parseCoverage, ve.classDef = ve.prototype.parseClassDef;\n          var Re = { reserved: ve.uShort, reqFeatureIndex: ve.uShort, featureIndexes: ve.uShortList }, we = (ve.prototype.parseScriptList = function() {\n            return this.parsePointer(ve.recordList({ tag: ve.tag, script: ve.pointer({ defaultLangSys: ve.pointer(Re), langSysRecords: ve.recordList({ tag: ve.tag, langSys: ve.pointer(Re) }) }) })) || [];\n          }, ve.prototype.parseFeatureList = function() {\n            return this.parsePointer(ve.recordList({ tag: ve.tag, feature: ve.pointer({ featureParams: ve.offset16, lookupListIndexes: ve.uShortList }) })) || [];\n          }, ve.prototype.parseLookupList = function(d) {\n            return this.parsePointer(ve.list(ve.pointer(function() {\n              var v = this.parseUShort(), w = (O.argument(1 <= v && v <= 9, \"GPOS/GSUB lookup type \" + v + \" unknown.\"), this.parseUShort()), k = 16 & w;\n              return { lookupType: v, lookupFlag: w, subtables: this.parseList(ve.pointer(d[v])), markFilteringSet: k ? this.parseUShort() : void 0 };\n            }))) || [];\n          }, ve.prototype.parseFeatureVariationsList = function() {\n            return this.parsePointer32(function() {\n              var d = this.parseUShort(), v = this.parseUShort();\n              return O.argument(d === 1 && v < 1, \"GPOS/GSUB feature variations table unknown.\"), this.parseRecordList32({ conditionSetOffset: ve.offset32, featureTableSubstitutionOffset: ve.offset32 });\n            }) || [];\n          }, { getByte: Qe, getCard8: Qe, getUShort: ze, getCard16: ze, getShort: function(d, v) {\n            return d.getInt16(v, !1);\n          }, getULong: Ve, getFixed: Xe, getTag: function(d, v) {\n            for (var w = \"\", k = v; k < v + 4; k += 1)\n              w += String.fromCharCode(d.getInt8(k));\n            return w;\n          }, getOffset: function(d, v, w) {\n            for (var k = 0, I = 0; I < w; I += 1)\n              k = (k <<= 8) + d.getUint8(v + I);\n            return k;\n          }, getBytes: function(d, v, w) {\n            for (var k = [], I = v; I < w; I += 1)\n              k.push(d.getUint8(I));\n            return k;\n          }, bytesToString: function(d) {\n            for (var v = \"\", w = 0; w < d.length; w += 1)\n              v += String.fromCharCode(d[w]);\n            return v;\n          }, Parser: ve }), Z = { parse: function(d, v) {\n            for (var w = {}, k = (w.version = we.getUShort(d, v), O.argument(w.version === 0, \"cmap table version should be 0.\"), w.numTables = we.getUShort(d, v + 2), -1), I = w.numTables - 1; 0 <= I; --I) {\n              var N = we.getUShort(d, v + 4 + 8 * I), z = we.getUShort(d, v + 4 + 8 * I + 2);\n              if (N === 3 && (z === 0 || z === 1 || z === 10) || N === 0 && (z === 0 || z === 1 || z === 2 || z === 3 || z === 4)) {\n                k = we.getULong(d, v + 4 + 8 * I + 4);\n                break;\n              }\n            }\n            if (k === -1)\n              throw new Error(\"No valid cmap sub-tables found.\");\n            var Q = new we.Parser(d, v + k);\n            if (w.format = Q.parseUShort(), w.format === 12) {\n              var se, oe = w, ye = Q;\n              ye.parseUShort(), oe.length = ye.parseULong(), oe.language = ye.parseULong(), oe.groupCount = se = ye.parseULong(), oe.glyphIndexMap = {};\n              for (var Se = 0; Se < se; Se += 1)\n                for (var be = ye.parseULong(), de = ye.parseULong(), Ie = ye.parseULong(), ke = be; ke <= de; ke += 1)\n                  oe.glyphIndexMap[ke] = Ie, Ie++;\n            } else {\n              if (w.format !== 4)\n                throw new Error(\"Only format 4 and 12 cmap tables are supported (found format \" + w.format + \").\");\n              var Ae = w, Te = d, Ee = v, $e = k;\n              Ae.length = Q.parseUShort(), Ae.language = Q.parseUShort(), Ae.segCount = lt = Q.parseUShort() >> 1, Q.skip(\"uShort\", 3), Ae.glyphIndexMap = {};\n              for (var lt, et = new we.Parser(Te, Ee + $e + 14), tt = new we.Parser(Te, Ee + $e + 16 + 2 * lt), dt = new we.Parser(Te, Ee + $e + 16 + 4 * lt), wt = new we.Parser(Te, Ee + $e + 16 + 6 * lt), Ot = Ee + $e + 16 + 8 * lt, Rt = 0; Rt < lt - 1; Rt += 1)\n                for (var Ht = void 0, Wt = et.parseUShort(), Qt = tt.parseUShort(), xt = dt.parseShort(), St = wt.parseUShort(), vt = Qt; vt <= Wt; vt += 1)\n                  St !== 0 ? (Ot = (Ot = wt.offset + wt.relativeOffset - 2) + St + 2 * (vt - Qt), (Ht = we.getUShort(Te, Ot)) !== 0 && (Ht = Ht + xt & 65535)) : Ht = vt + xt & 65535, Ae.glyphIndexMap[vt] = Ht;\n            }\n            return w;\n          }, make: function(d) {\n            for (var v = !0, w = d.length - 1; 0 < w; --w)\n              if (65535 < d.get(w).unicode) {\n                console.log(\"Adding CMAP format 12 (needed!)\"), v = !1;\n                break;\n              }\n            var k, I, N = [{ name: \"version\", type: \"USHORT\", value: 0 }, { name: \"numTables\", type: \"USHORT\", value: v ? 1 : 2 }, { name: \"platformID\", type: \"USHORT\", value: 3 }, { name: \"encodingID\", type: \"USHORT\", value: 1 }, { name: \"offset\", type: \"ULONG\", value: v ? 12 : 20 }], z = (N = (N = v ? N : N.concat([{ name: \"cmap12PlatformID\", type: \"USHORT\", value: 3 }, { name: \"cmap12EncodingID\", type: \"USHORT\", value: 10 }, { name: \"cmap12Offset\", type: \"ULONG\", value: 0 }])).concat([{ name: \"format\", type: \"USHORT\", value: 4 }, { name: \"cmap4Length\", type: \"USHORT\", value: 0 }, { name: \"language\", type: \"USHORT\", value: 0 }, { name: \"segCountX2\", type: \"USHORT\", value: 0 }, { name: \"searchRange\", type: \"USHORT\", value: 0 }, { name: \"entrySelector\", type: \"USHORT\", value: 0 }, { name: \"rangeShift\", type: \"USHORT\", value: 0 }]), new Me.Table(\"cmap\", N));\n            for (z.segments = [], w = 0; w < d.length; w += 1) {\n              for (var Q = d.get(w), se = 0; se < Q.unicodes.length; se += 1)\n                k = Q.unicodes[se], I = w, z.segments.push({ end: k, start: k, delta: -(k - I), offset: 0, glyphIndex: I });\n              z.segments = z.segments.sort(function(Ee, $e) {\n                return Ee.start - $e.start;\n              });\n            }\n            z.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });\n            var oe = z.segments.length, ye = 0, Se = [], be = [], de = [], Ie = [], ke = [], Ae = [];\n            for (w = 0; w < oe; w += 1) {\n              var Te = z.segments[w];\n              Te.end <= 65535 && Te.start <= 65535 ? (Se = Se.concat({ name: \"end_\" + w, type: \"USHORT\", value: Te.end }), be = be.concat({ name: \"start_\" + w, type: \"USHORT\", value: Te.start }), de = de.concat({ name: \"idDelta_\" + w, type: \"SHORT\", value: Te.delta }), Ie = Ie.concat({ name: \"idRangeOffset_\" + w, type: \"USHORT\", value: Te.offset }), Te.glyphId !== void 0 && (ke = ke.concat({ name: \"glyph_\" + w, type: \"USHORT\", value: Te.glyphId }))) : ye += 1, v || Te.glyphIndex === void 0 || (Ae = (Ae = (Ae = Ae.concat({ name: \"cmap12Start_\" + w, type: \"ULONG\", value: Te.start })).concat({ name: \"cmap12End_\" + w, type: \"ULONG\", value: Te.end })).concat({ name: \"cmap12Glyph_\" + w, type: \"ULONG\", value: Te.glyphIndex }));\n            }\n            return z.segCountX2 = 2 * (oe - ye), z.searchRange = 2 * Math.pow(2, Math.floor(Math.log(oe - ye) / Math.log(2))), z.entrySelector = Math.log(z.searchRange / 2) / Math.log(2), z.rangeShift = z.segCountX2 - z.searchRange, z.fields = z.fields.concat(Se), z.fields.push({ name: \"reservedPad\", type: \"USHORT\", value: 0 }), z.fields = z.fields.concat(be), z.fields = z.fields.concat(de), z.fields = z.fields.concat(Ie), z.fields = z.fields.concat(ke), z.cmap4Length = 14 + 2 * Se.length + 2 + 2 * be.length + 2 * de.length + 2 * Ie.length + 2 * ke.length, v || (N = 16 + 4 * Ae.length, z.cmap12Offset = 20 + z.cmap4Length, z.fields = z.fields.concat([{ name: \"cmap12Format\", type: \"USHORT\", value: 12 }, { name: \"cmap12Reserved\", type: \"USHORT\", value: 0 }, { name: \"cmap12Length\", type: \"ULONG\", value: N }, { name: \"cmap12Language\", type: \"ULONG\", value: 0 }, { name: \"cmap12nGroups\", type: \"ULONG\", value: Ae.length / 3 }]), z.fields = z.fields.concat(Ae)), z;\n          } }, $ = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"266 ff\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"], q = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"\", \"questiondown\", \"\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"\", \"ring\", \"cedilla\", \"\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"AE\", \"\", \"ordfeminine\", \"\", \"\", \"\", \"\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"\", \"\", \"\", \"\", \"\", \"ae\", \"\", \"\", \"\", \"dotlessi\", \"\", \"\", \"lslash\", \"oslash\", \"oe\", \"germandbls\"], ee = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"\", \"\", \"isuperior\", \"\", \"\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"\", \"\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"\", \"\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"\", \"Dotaccentsmall\", \"\", \"\", \"Macronsmall\", \"\", \"\", \"figuredash\", \"hypheninferior\", \"\", \"\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"], pe = [\".notdef\", \".null\", \"nonmarkingreturn\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"nonbreakingspace\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"Lslash\", \"lslash\", \"Scaron\", \"scaron\", \"Zcaron\", \"zcaron\", \"brokenbar\", \"Eth\", \"eth\", \"Yacute\", \"yacute\", \"Thorn\", \"thorn\", \"minus\", \"multiply\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"onehalf\", \"onequarter\", \"threequarters\", \"franc\", \"Gbreve\", \"gbreve\", \"Idotaccent\", \"Scedilla\", \"scedilla\", \"Cacute\", \"cacute\", \"Ccaron\", \"ccaron\", \"dcroat\"];\n          function je(d) {\n            this.font = d;\n          }\n          function Ce(d) {\n            this.cmap = d;\n          }\n          function Fe(d, v) {\n            this.encoding = d, this.charset = v;\n          }\n          function Ne(d) {\n            switch (d.version) {\n              case 1:\n                this.names = pe.slice();\n                break;\n              case 2:\n                this.names = new Array(d.numberOfGlyphs);\n                for (var v = 0; v < d.numberOfGlyphs; v++)\n                  d.glyphNameIndex[v] < pe.length ? this.names[v] = pe[d.glyphNameIndex[v]] : this.names[v] = d.names[d.glyphNameIndex[v] - pe.length];\n                break;\n              case 2.5:\n                this.names = new Array(d.numberOfGlyphs);\n                for (var w = 0; w < d.numberOfGlyphs; w++)\n                  this.names[w] = pe[w + d.glyphNameIndex[w]];\n                break;\n              default:\n                this.names = [];\n            }\n          }\n          je.prototype.charToGlyphIndex = function(d) {\n            var v = d.codePointAt(0), w = this.font.glyphs;\n            if (w) {\n              for (var k = 0; k < w.length; k += 1)\n                for (var I = w.get(k), N = 0; N < I.unicodes.length; N += 1)\n                  if (I.unicodes[N] === v)\n                    return k;\n            }\n            return null;\n          }, Ce.prototype.charToGlyphIndex = function(d) {\n            return this.cmap.glyphIndexMap[d.codePointAt(0)] || 0;\n          }, Fe.prototype.charToGlyphIndex = function(d) {\n            return d = d.codePointAt(0), d = this.encoding[d], this.charset.indexOf(d);\n          }, Ne.prototype.nameToGlyphIndex = function(d) {\n            return this.names.indexOf(d);\n          }, Ne.prototype.glyphIndexToName = function(d) {\n            return this.names[d];\n          };\n          var Be = { line: function(d, v, w, k, I) {\n            d.beginPath(), d.moveTo(v, w), d.lineTo(k, I), d.stroke();\n          } };\n          function We(d) {\n            this.bindConstructorValues(d);\n          }\n          function st(d, v, w) {\n            Object.defineProperty(d, v, { get: function() {\n              return d.path, d[w];\n            }, set: function(k) {\n              d[w] = k;\n            }, enumerable: !0, configurable: !0 });\n          }\n          function nt(d, v) {\n            if (this.font = d, this.glyphs = {}, Array.isArray(v))\n              for (var w = 0; w < v.length; w++)\n                this.glyphs[w] = v[w];\n            this.length = v && v.length || 0;\n          }\n          We.prototype.bindConstructorValues = function(d) {\n            var v;\n            this.index = d.index || 0, this.name = d.name || null, this.unicode = d.unicode || void 0, this.unicodes = d.unicodes || d.unicode !== void 0 ? [d.unicode] : [], d.xMin && (this.xMin = d.xMin), d.yMin && (this.yMin = d.yMin), d.xMax && (this.xMax = d.xMax), d.yMax && (this.yMax = d.yMax), d.advanceWidth && (this.advanceWidth = d.advanceWidth), Object.defineProperty(this, \"path\", (d = d.path, v = d || new X(), { configurable: !0, get: function() {\n              return v = typeof v == \"function\" ? v() : v;\n            }, set: function(w) {\n              v = w;\n            } }));\n          }, We.prototype.addUnicode = function(d) {\n            this.unicodes.length === 0 && (this.unicode = d), this.unicodes.push(d);\n          }, We.prototype.getBoundingBox = function() {\n            return this.path.getBoundingBox();\n          }, We.prototype.getPath = function(d, v, w, k, I) {\n            d = d !== void 0 ? d : 0, v = v !== void 0 ? v : 0, w = w !== void 0 ? w : 72;\n            for (var N, z, Q = (k = k || {}).xScale, se = k.yScale, oe = ((N = k.hinting && I && I.hinting ? this.path && I.hinting.exec(this, w) : N) ? (z = I.hinting.getCommands(N), d = Math.round(d), v = Math.round(v), Q = se = 1) : (z = this.path.commands, k = 1 / this.path.unitsPerEm * w, Q === void 0 && (Q = k), se === void 0 && (se = k)), new X()), ye = 0; ye < z.length; ye += 1) {\n              var Se = z[ye];\n              Se.type === \"M\" ? oe.moveTo(d + Se.x * Q, v + -Se.y * se) : Se.type === \"L\" ? oe.lineTo(d + Se.x * Q, v + -Se.y * se) : Se.type === \"Q\" ? oe.quadraticCurveTo(d + Se.x1 * Q, v + -Se.y1 * se, d + Se.x * Q, v + -Se.y * se) : Se.type === \"C\" ? oe.curveTo(d + Se.x1 * Q, v + -Se.y1 * se, d + Se.x2 * Q, v + -Se.y2 * se, d + Se.x * Q, v + -Se.y * se) : Se.type === \"Z\" && oe.closePath();\n            }\n            return oe;\n          }, We.prototype.getContours = function() {\n            if (this.points === void 0)\n              return [];\n            for (var d = [], v = [], w = 0; w < this.points.length; w += 1) {\n              var k = this.points[w];\n              v.push(k), k.lastPointOfContour && (d.push(v), v = []);\n            }\n            return O.argument(v.length === 0, \"There are still points left in the current contour.\"), d;\n          }, We.prototype.getMetrics = function() {\n            for (var d = this.path.commands, v = [], w = [], k = 0; k < d.length; k += 1) {\n              var I = d[k];\n              I.type !== \"Z\" && (v.push(I.x), w.push(I.y)), I.type !== \"Q\" && I.type !== \"C\" || (v.push(I.x1), w.push(I.y1)), I.type === \"C\" && (v.push(I.x2), w.push(I.y2));\n            }\n            var N = { xMin: Math.min.apply(null, v), yMin: Math.min.apply(null, w), xMax: Math.max.apply(null, v), yMax: Math.max.apply(null, w), leftSideBearing: this.leftSideBearing };\n            return isFinite(N.xMin) || (N.xMin = 0), isFinite(N.xMax) || (N.xMax = this.advanceWidth), isFinite(N.yMin) || (N.yMin = 0), isFinite(N.yMax) || (N.yMax = 0), N.rightSideBearing = this.advanceWidth - N.leftSideBearing - (N.xMax - N.xMin), N;\n          }, We.prototype.draw = function(d, v, w, k, I) {\n            this.getPath(v, w, k, I).draw(d);\n          }, We.prototype.drawPoints = function(d, v, w, k) {\n            function I(ye, Se, be, de) {\n              var Ie = 2 * Math.PI;\n              d.beginPath();\n              for (var ke = 0; ke < ye.length; ke += 1)\n                d.moveTo(Se + ye[ke].x * de, be + ye[ke].y * de), d.arc(Se + ye[ke].x * de, be + ye[ke].y * de, 2, 0, Ie, !1);\n              d.closePath(), d.fill();\n            }\n            v = v !== void 0 ? v : 0, w = w !== void 0 ? w : 0;\n            for (var k = 1 / this.path.unitsPerEm * (k = k !== void 0 ? k : 24), N = [], z = [], Q = this.path, se = 0; se < Q.commands.length; se += 1) {\n              var oe = Q.commands[se];\n              oe.x !== void 0 && N.push({ x: oe.x, y: -oe.y }), oe.x1 !== void 0 && z.push({ x: oe.x1, y: -oe.y1 }), oe.x2 !== void 0 && z.push({ x: oe.x2, y: -oe.y2 });\n            }\n            d.fillStyle = \"blue\", I(N, v, w, k), d.fillStyle = \"red\", I(z, v, w, k);\n          }, We.prototype.drawMetrics = function(d, v, w, k) {\n            v = v !== void 0 ? v : 0, w = w !== void 0 ? w : 0, k = 1 / this.path.unitsPerEm * (k = k !== void 0 ? k : 24), d.lineWidth = 1, d.strokeStyle = \"black\", Be.line(d, v, -1e4, v, 1e4), Be.line(d, -1e4, w, 1e4, w);\n            var I = this.xMin || 0, N = this.yMin || 0, z = this.xMax || 0, Q = this.yMax || 0, se = this.advanceWidth || 0;\n            d.strokeStyle = \"blue\", Be.line(d, v + I * k, -1e4, v + I * k, 1e4), Be.line(d, v + z * k, -1e4, v + z * k, 1e4), Be.line(d, -1e4, w + -N * k, 1e4, w + -N * k), Be.line(d, -1e4, w + -Q * k, 1e4, w + -Q * k), d.strokeStyle = \"green\", Be.line(d, v + se * k, -1e4, v + se * k, 1e4);\n          }, nt.prototype.get = function(d) {\n            return typeof this.glyphs[d] == \"function\" && (this.glyphs[d] = this.glyphs[d]()), this.glyphs[d];\n          }, nt.prototype.push = function(d, v) {\n            this.glyphs[d] = v, this.length++;\n          };\n          var Ke = { GlyphSet: nt, glyphLoader: function(d, v) {\n            return new We({ index: v, font: d });\n          }, ttfGlyphLoader: function(d, v, w, k, I, N) {\n            return function() {\n              var z = new We({ index: v, font: d });\n              return z.path = function() {\n                w(z, k, I);\n                var Q = N(d.glyphs, z);\n                return Q.unitsPerEm = d.unitsPerEm, Q;\n              }, st(z, \"xMin\", \"_xMin\"), st(z, \"xMax\", \"_xMax\"), st(z, \"yMin\", \"_yMin\"), st(z, \"yMax\", \"_yMax\"), z;\n            };\n          }, cffGlyphLoader: function(d, v, w, k) {\n            return function() {\n              var I = new We({ index: v, font: d });\n              return I.path = function() {\n                var N = w(d, I, k);\n                return N.unitsPerEm = d.unitsPerEm, N;\n              }, I;\n            };\n          } };\n          function at(d) {\n            return d = d.length < 1240 ? 107 : d.length < 33900 ? 1131 : 32768, d;\n          }\n          function ot(d, v, w) {\n            var k, I = [], N = [], z = we.getCard16(d, v);\n            if (z !== 0) {\n              for (var Q = we.getByte(d, v + 2), se = v + (z + 1) * Q + 2, oe = v + 3, ye = 0; ye < z + 1; ye += 1)\n                I.push(we.getOffset(d, oe, Q)), oe += Q;\n              k = se + I[z];\n            } else\n              k = v + 2;\n            for (var Se = 0; Se < I.length - 1; Se += 1) {\n              var be = we.getBytes(d, se + I[Se], se + I[Se + 1]);\n              w && (be = w(be)), N.push(be);\n            }\n            return { objects: N, startOffset: v, endOffset: k };\n          }\n          function bt(d, v) {\n            if (v === 28)\n              return d.parseByte() << 8 | d.parseByte();\n            if (v === 29)\n              return d.parseByte() << 24 | d.parseByte() << 16 | d.parseByte() << 8 | d.parseByte();\n            if (v === 30) {\n              for (var w = d, k = \"\", I = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\", \"E\", \"E-\", null, \"-\"]; ; ) {\n                var z = w.parseByte(), N = z >> 4, z = 15 & z;\n                if (N == 15 || (k += I[N], z == 15))\n                  break;\n                k += I[z];\n              }\n              return parseFloat(k);\n            }\n            if (32 <= v && v <= 246)\n              return v - 139;\n            if (247 <= v && v <= 250)\n              return 256 * (v - 247) + d.parseByte() + 108;\n            if (251 <= v && v <= 254)\n              return 256 * -(v - 251) - d.parseByte() - 108;\n            throw new Error(\"Invalid b0 \" + v);\n          }\n          function It(d, v, w) {\n            var k = new we.Parser(d, v = v !== void 0 ? v : 0), I = [], N = [];\n            for (w = w !== void 0 ? w : d.length; k.relativeOffset < w; ) {\n              var z = k.parseByte();\n              z <= 21 ? (z === 12 && (z = 1200 + k.parseByte()), I.push([z, N]), N = []) : N.push(bt(k, z));\n            }\n            for (var Q = I, se = {}, oe = 0; oe < Q.length; oe += 1) {\n              var ye = Q[oe][0], Se = Q[oe][1], be = void 0, be = Se.length === 1 ? Se[0] : Se;\n              if (se.hasOwnProperty(ye) && !isNaN(se[ye]))\n                throw new Error(\"Object \" + se + \" already has key \" + ye);\n              se[ye] = be;\n            }\n            return se;\n          }\n          function Mt(d, v) {\n            return v = v <= 390 ? $[v] : d[v - 391];\n          }\n          function mt(d, v, w) {\n            for (var k, I = {}, N = 0; N < v.length; N += 1) {\n              var z = v[N];\n              if (Array.isArray(z.type)) {\n                var Q = [];\n                Q.length = z.type.length;\n                for (var se = 0; se < z.type.length; se++)\n                  (k = d[z.op] !== void 0 ? d[z.op][se] : void 0) === void 0 && (k = z.value !== void 0 && z.value[se] !== void 0 ? z.value[se] : null), z.type[se] === \"SID\" && (k = Mt(w, k)), Q[se] = k;\n                I[z.name] = Q;\n              } else\n                (k = d[z.op]) === void 0 && (k = z.value !== void 0 ? z.value : null), z.type === \"SID\" && (k = Mt(w, k)), I[z.name] = k;\n            }\n            return I;\n          }\n          var jt = [{ name: \"version\", op: 0, type: \"SID\" }, { name: \"notice\", op: 1, type: \"SID\" }, { name: \"copyright\", op: 1200, type: \"SID\" }, { name: \"fullName\", op: 2, type: \"SID\" }, { name: \"familyName\", op: 3, type: \"SID\" }, { name: \"weight\", op: 4, type: \"SID\" }, { name: \"isFixedPitch\", op: 1201, type: \"number\", value: 0 }, { name: \"italicAngle\", op: 1202, type: \"number\", value: 0 }, { name: \"underlinePosition\", op: 1203, type: \"number\", value: -100 }, { name: \"underlineThickness\", op: 1204, type: \"number\", value: 50 }, { name: \"paintType\", op: 1205, type: \"number\", value: 0 }, { name: \"charstringType\", op: 1206, type: \"number\", value: 2 }, { name: \"fontMatrix\", op: 1207, type: [\"real\", \"real\", \"real\", \"real\", \"real\", \"real\"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: \"uniqueId\", op: 13, type: \"number\" }, { name: \"fontBBox\", op: 5, type: [\"number\", \"number\", \"number\", \"number\"], value: [0, 0, 0, 0] }, { name: \"strokeWidth\", op: 1208, type: \"number\", value: 0 }, { name: \"xuid\", op: 14, type: [], value: null }, { name: \"charset\", op: 15, type: \"offset\", value: 0 }, { name: \"encoding\", op: 16, type: \"offset\", value: 0 }, { name: \"charStrings\", op: 17, type: \"offset\", value: 0 }, { name: \"private\", op: 18, type: [\"number\", \"offset\"], value: [0, 0] }, { name: \"ros\", op: 1230, type: [\"SID\", \"SID\", \"number\"] }, { name: \"cidFontVersion\", op: 1231, type: \"number\", value: 0 }, { name: \"cidFontRevision\", op: 1232, type: \"number\", value: 0 }, { name: \"cidFontType\", op: 1233, type: \"number\", value: 0 }, { name: \"cidCount\", op: 1234, type: \"number\", value: 8720 }, { name: \"uidBase\", op: 1235, type: \"number\" }, { name: \"fdArray\", op: 1236, type: \"offset\" }, { name: \"fdSelect\", op: 1237, type: \"offset\" }, { name: \"fontName\", op: 1238, type: \"SID\" }], ht = [{ name: \"subrs\", op: 19, type: \"offset\", value: 0 }, { name: \"defaultWidthX\", op: 20, type: \"number\", value: 0 }, { name: \"nominalWidthX\", op: 21, type: \"number\", value: 0 }];\n          function Dt(d, v, w, k) {\n            return mt(It(d, v, w), ht, k);\n          }\n          function Pt(d, v, w, k) {\n            for (var I = [], N = 0; N < w.length; N += 1) {\n              var z = new DataView(new Uint8Array(w[N]).buffer), z = (Q = k, mt(It(z, 0, z.byteLength), jt, Q)), Q = (z._subrs = [], z._subrsBias = 0, z.private[0]), se = z.private[1];\n              Q !== 0 && se !== 0 && (Q = Dt(d, se + v, Q, k), z._defaultWidthX = Q.defaultWidthX, z._nominalWidthX = Q.nominalWidthX, Q.subrs !== 0 && (se = ot(d, se + Q.subrs + v), z._subrs = se.objects, z._subrsBias = at(z._subrs)), z._privateDict = Q), I.push(z);\n            }\n            return I;\n          }\n          function gt(d, v, w) {\n            var k, I, N, z, Q, se, oe, ye, Se, be = new X(), de = [], Ie = 0, ke = !1, Ae = !1, Te = 0, Ee = 0, $e = (Se = (d.isCIDFont ? (Q = d.tables.cff.topDict._fdSelect[v.index], Q = d.tables.cff.topDict._fdArray[Q], se = Q._subrs, oe = Q._subrsBias, ye = Q._defaultWidthX, Q) : (se = d.tables.cff.topDict._subrs, oe = d.tables.cff.topDict._subrsBias, ye = d.tables.cff.topDict._defaultWidthX, d.tables.cff.topDict))._nominalWidthX, ye);\n            function lt(tt, dt) {\n              Ae && be.closePath(), be.moveTo(tt, dt), Ae = !0;\n            }\n            function et() {\n              de.length % 2 == 0 || ke || ($e = de.shift() + Se), Ie += de.length >> 1, de.length = 0, ke = !0;\n            }\n            return function tt(dt) {\n              for (var wt, Ot, Rt, Ht, Wt, Qt, xt, St, vt, qt, kt, zt, Tt = 0; Tt < dt.length; ) {\n                var Gt = dt[Tt];\n                switch (Tt += 1, Gt) {\n                  case 1:\n                  case 3:\n                    et();\n                    break;\n                  case 4:\n                    1 < de.length && !ke && ($e = de.shift() + Se, ke = !0), Ee += de.pop(), lt(Te, Ee);\n                    break;\n                  case 5:\n                    for (; 0 < de.length; )\n                      Te += de.shift(), Ee += de.shift(), be.lineTo(Te, Ee);\n                    break;\n                  case 6:\n                    for (; 0 < de.length && (Te += de.shift(), be.lineTo(Te, Ee), de.length !== 0); )\n                      Ee += de.shift(), be.lineTo(Te, Ee);\n                    break;\n                  case 7:\n                    for (; 0 < de.length && (Ee += de.shift(), be.lineTo(Te, Ee), de.length !== 0); )\n                      Te += de.shift(), be.lineTo(Te, Ee);\n                    break;\n                  case 8:\n                    for (; 0 < de.length; )\n                      k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z + de.shift(), be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  case 10:\n                    Wt = de.pop() + oe, (Qt = se[Wt]) && tt(Qt);\n                    break;\n                  case 11:\n                    return;\n                  case 12:\n                    switch (Gt = dt[Tt], Tt += 1, Gt) {\n                      case 35:\n                        k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), xt = N + de.shift(), St = z + de.shift(), vt = xt + de.shift(), qt = St + de.shift(), kt = vt + de.shift(), zt = qt + de.shift(), Te = kt + de.shift(), Ee = zt + de.shift(), de.shift(), be.curveTo(k, I, N, z, xt, St), be.curveTo(vt, qt, kt, zt, Te, Ee);\n                        break;\n                      case 34:\n                        k = Te + de.shift(), I = Ee, N = k + de.shift(), z = I + de.shift(), xt = N + de.shift(), St = z, vt = xt + de.shift(), qt = z, kt = vt + de.shift(), zt = Ee, Te = kt + de.shift(), be.curveTo(k, I, N, z, xt, St), be.curveTo(vt, qt, kt, zt, Te, Ee);\n                        break;\n                      case 36:\n                        k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), xt = N + de.shift(), St = z, vt = xt + de.shift(), qt = z, kt = vt + de.shift(), zt = qt + de.shift(), Te = kt + de.shift(), be.curveTo(k, I, N, z, xt, St), be.curveTo(vt, qt, kt, zt, Te, Ee);\n                        break;\n                      case 37:\n                        k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), xt = N + de.shift(), St = z + de.shift(), vt = xt + de.shift(), qt = St + de.shift(), kt = vt + de.shift(), zt = qt + de.shift(), Math.abs(kt - Te) > Math.abs(zt - Ee) ? Te = kt + de.shift() : Ee = zt + de.shift(), be.curveTo(k, I, N, z, xt, St), be.curveTo(vt, qt, kt, zt, Te, Ee);\n                        break;\n                      default:\n                        console.log(\"Glyph \" + v.index + \": unknown operator 1200\" + Gt), de.length = 0;\n                    }\n                    break;\n                  case 14:\n                    0 < de.length && !ke && ($e = de.shift() + Se, ke = !0), Ae && (be.closePath(), Ae = !1);\n                    break;\n                  case 18:\n                    et();\n                    break;\n                  case 19:\n                  case 20:\n                    et(), Tt += Ie + 7 >> 3;\n                    break;\n                  case 21:\n                    2 < de.length && !ke && ($e = de.shift() + Se, ke = !0), Ee += de.pop(), lt(Te += de.pop(), Ee);\n                    break;\n                  case 22:\n                    1 < de.length && !ke && ($e = de.shift() + Se, ke = !0), lt(Te += de.pop(), Ee);\n                    break;\n                  case 23:\n                    et();\n                    break;\n                  case 24:\n                    for (; 2 < de.length; )\n                      k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z + de.shift(), be.curveTo(k, I, N, z, Te, Ee);\n                    Te += de.shift(), Ee += de.shift(), be.lineTo(Te, Ee);\n                    break;\n                  case 25:\n                    for (; 6 < de.length; )\n                      Te += de.shift(), Ee += de.shift(), be.lineTo(Te, Ee);\n                    k = Te + de.shift(), I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z + de.shift(), be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  case 26:\n                    for (de.length % 2 && (Te += de.shift()); 0 < de.length; )\n                      k = Te, I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N, Ee = z + de.shift(), be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  case 27:\n                    for (de.length % 2 && (Ee += de.shift()); 0 < de.length; )\n                      k = Te + de.shift(), I = Ee, N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z, be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  case 28:\n                    wt = dt[Tt], Ot = dt[Tt + 1], de.push((wt << 24 | Ot << 16) >> 16), Tt += 2;\n                    break;\n                  case 29:\n                    Wt = de.pop() + d.gsubrsBias, (Qt = d.gsubrs[Wt]) && tt(Qt);\n                    break;\n                  case 30:\n                    for (; 0 < de.length && (k = Te, I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z + (de.length === 1 ? de.shift() : 0), be.curveTo(k, I, N, z, Te, Ee), de.length !== 0); )\n                      k = Te + de.shift(), I = Ee, N = k + de.shift(), z = I + de.shift(), Ee = z + de.shift(), Te = N + (de.length === 1 ? de.shift() : 0), be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  case 31:\n                    for (; 0 < de.length && (k = Te + de.shift(), I = Ee, N = k + de.shift(), z = I + de.shift(), Ee = z + de.shift(), Te = N + (de.length === 1 ? de.shift() : 0), be.curveTo(k, I, N, z, Te, Ee), de.length !== 0); )\n                      k = Te, I = Ee + de.shift(), N = k + de.shift(), z = I + de.shift(), Te = N + de.shift(), Ee = z + (de.length === 1 ? de.shift() : 0), be.curveTo(k, I, N, z, Te, Ee);\n                    break;\n                  default:\n                    Gt < 32 ? console.log(\"Glyph \" + v.index + \": unknown operator \" + Gt) : Gt < 247 ? de.push(Gt - 139) : Gt < 251 ? (wt = dt[Tt], Tt += 1, de.push(256 * (Gt - 247) + wt + 108)) : Gt < 255 ? (wt = dt[Tt], Tt += 1, de.push(256 * -(Gt - 251) - wt - 108)) : (wt = dt[Tt], Ot = dt[Tt + 1], Rt = dt[Tt + 2], Ht = dt[Tt + 3], Tt += 4, de.push((wt << 24 | Ot << 16 | Rt << 8 | Ht) / 65536));\n                }\n              }\n            }(w), v.advanceWidth = $e, be;\n          }\n          function Ft(d, v) {\n            var w, k = $.indexOf(d);\n            return 0 <= k && (w = k), 0 <= (k = v.indexOf(d)) ? w = k + $.length : (w = $.length + v.length, v.push(d)), w;\n          }\n          function me(d, v, w) {\n            for (var k = {}, I = 0; I < d.length; I += 1) {\n              var N = d[I], z = v[N.name];\n              z === void 0 || function Q(se, oe) {\n                if (se === oe)\n                  return 1;\n                if (Array.isArray(se) && Array.isArray(oe) && se.length === oe.length) {\n                  for (var ye = 0; ye < se.length; ye += 1)\n                    if (!Q(se[ye], oe[ye]))\n                      return;\n                  return 1;\n                }\n              }(z, N.value) || (N.type === \"SID\" && (z = Ft(z, w)), k[N.op] = { name: N.name, type: N.type, value: z });\n            }\n            return k;\n          }\n          function Ue(d, v) {\n            var w = new Me.Record(\"Top DICT\", [{ name: \"dict\", type: \"DICT\", value: {} }]);\n            return w.dict = me(jt, d, v), w;\n          }\n          function Ye(d) {\n            var v = new Me.Record(\"Top DICT INDEX\", [{ name: \"topDicts\", type: \"INDEX\", value: [] }]);\n            return v.topDicts = [{ name: \"topDict_0\", type: \"TABLE\", value: d }], v;\n          }\n          function it(d) {\n            for (var v = new Me.Record(\"CharStrings INDEX\", [{ name: \"charStrings\", type: \"INDEX\", value: [] }]), w = 0; w < d.length; w += 1) {\n              var k = d.get(w), I = function(N) {\n                for (var z = [], Q = N.path, se = (z.push({ name: \"width\", type: \"NUMBER\", value: N.advanceWidth }), 0), oe = 0, ye = 0; ye < Q.commands.length; ye += 1) {\n                  var Se, be, de, Ie, ke = void 0, Ae = void 0, Te = Q.commands[ye];\n                  (Te = Te.type === \"Q\" ? { type: \"C\", x: Te.x, y: Te.y, x1: 1 / 3 * se + 2 / 3 * Te.x1, y1: 1 / 3 * oe + 2 / 3 * Te.y1, x2: 1 / 3 * Te.x + 2 / 3 * Te.x1, y2: 1 / 3 * Te.y + 2 / 3 * Te.y1 } : Te).type === \"M\" ? (ke = Math.round(Te.x - se), Ae = Math.round(Te.y - oe), z.push({ name: \"dx\", type: \"NUMBER\", value: ke }), z.push({ name: \"dy\", type: \"NUMBER\", value: Ae }), z.push({ name: \"rmoveto\", type: \"OP\", value: 21 }), se = Math.round(Te.x), oe = Math.round(Te.y)) : Te.type === \"L\" ? (ke = Math.round(Te.x - se), Ae = Math.round(Te.y - oe), z.push({ name: \"dx\", type: \"NUMBER\", value: ke }), z.push({ name: \"dy\", type: \"NUMBER\", value: Ae }), z.push({ name: \"rlineto\", type: \"OP\", value: 5 }), se = Math.round(Te.x), oe = Math.round(Te.y)) : Te.type === \"C\" && (Se = Math.round(Te.x1 - se), be = Math.round(Te.y1 - oe), de = Math.round(Te.x2 - Te.x1), Ie = Math.round(Te.y2 - Te.y1), ke = Math.round(Te.x - Te.x2), Ae = Math.round(Te.y - Te.y2), z.push({ name: \"dx1\", type: \"NUMBER\", value: Se }), z.push({ name: \"dy1\", type: \"NUMBER\", value: be }), z.push({ name: \"dx2\", type: \"NUMBER\", value: de }), z.push({ name: \"dy2\", type: \"NUMBER\", value: Ie }), z.push({ name: \"dx\", type: \"NUMBER\", value: ke }), z.push({ name: \"dy\", type: \"NUMBER\", value: Ae }), z.push({ name: \"rrcurveto\", type: \"OP\", value: 8 }), se = Math.round(Te.x), oe = Math.round(Te.y));\n                }\n                return z.push({ name: \"endchar\", type: \"OP\", value: 14 }), z;\n              }(k);\n              v.charStrings.push({ name: k.name, type: \"CHARSTRING\", value: I });\n            }\n            return v;\n          }\n          var ft = { parse: function(d, v, w) {\n            w.tables.cff = {}, Q = d, k = v, (I = {}).formatMajor = we.getCard8(Q, k), I.formatMinor = we.getCard8(Q, k + 1), I.size = we.getCard8(Q, k + 2), I.offsetSize = we.getCard8(Q, k + 3), I.startOffset = k, I.endOffset = k + 4;\n            var Q = ot(d, I.endOffset, we.bytesToString), k = ot(d, Q.endOffset), I = ot(d, k.endOffset, we.bytesToString), Q = ot(d, I.endOffset);\n            if (w.gsubrs = Q.objects, w.gsubrsBias = at(w.gsubrs), (Q = Pt(d, v, k.objects, I.objects)).length !== 1)\n              throw new Error(\"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" + Q.length);\n            if (k = Q[0], (w.tables.cff.topDict = k)._privateDict && (w.defaultWidthX = k._privateDict.defaultWidthX, w.nominalWidthX = k._privateDict.nominalWidthX), k.ros[0] !== void 0 && k.ros[1] !== void 0 && (w.isCIDFont = !0), w.isCIDFont) {\n              var Q = k.fdArray, N = k.fdSelect;\n              if (Q === 0 || N === 0)\n                throw new Error(\"Font is marked as a CID font, but FDArray and/or FDSelect information is missing\");\n              Q = Pt(d, v, ot(d, Q += v).objects, I.objects), k._fdArray = Q, k._fdSelect = function(be, de, Ie, ke) {\n                var Ae, Te = [], Ee = new we.Parser(be, de);\n                if ((be = Ee.parseCard8()) === 0)\n                  for (var $e = 0; $e < Ie; $e++) {\n                    if (ke <= (Ae = Ee.parseCard8()))\n                      throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + Ae + \" (FD count \" + ke + \")\");\n                    Te.push(Ae);\n                  }\n                else {\n                  if (be !== 3)\n                    throw new Error(\"CFF Table CID Font FDSelect table has unsupported format \" + be);\n                  var lt, et = Ee.parseCard16(), tt = Ee.parseCard16();\n                  if (tt !== 0)\n                    throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad initial GID \" + tt);\n                  for (var dt = 0; dt < et; dt++) {\n                    if (Ae = Ee.parseCard8(), lt = Ee.parseCard16(), ke <= Ae)\n                      throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + Ae + \" (FD count \" + ke + \")\");\n                    if (Ie < lt)\n                      throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad GID \" + lt);\n                    for (; tt < lt; tt++)\n                      Te.push(Ae);\n                    tt = lt;\n                  }\n                  if (lt !== Ie)\n                    throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad final GID \" + lt);\n                }\n                return Te;\n              }(d, N += v, w.numGlyphs, Q.length);\n            }\n            var N = v + k.private[1], Q = Dt(d, N, k.private[0], I.objects), z = (w.defaultWidthX = Q.defaultWidthX, w.nominalWidthX = Q.nominalWidthX, Q.subrs !== 0 ? (N = ot(d, N + Q.subrs), w.subrs = N.objects, w.subrsBias = at(w.subrs)) : (w.subrs = [], w.subrsBias = 0), ot(d, v + k.charStrings)), Q = (w.nGlyphs = z.objects.length, function(ye, Se, be, de) {\n              var Ie = new we.Parser(ye, Se), ke = (--be, [\".notdef\"]);\n              if ((ye = Ie.parseCard8()) === 0)\n                for (var Ae = 0; Ae < be; Ae += 1)\n                  Te = Ie.parseSID(), ke.push(Mt(de, Te));\n              else if (ye === 1)\n                for (; ke.length <= be; )\n                  for (var Te = Ie.parseSID(), Ee = Ie.parseCard8(), $e = 0; $e <= Ee; $e += 1)\n                    ke.push(Mt(de, Te)), Te += 1;\n              else {\n                if (ye !== 2)\n                  throw new Error(\"Unknown charset format \" + ye);\n                for (; ke.length <= be; ) {\n                  Te = Ie.parseSID(), Ee = Ie.parseCard16();\n                  for (var lt = 0; lt <= Ee; lt += 1)\n                    ke.push(Mt(de, Te)), Te += 1;\n                }\n              }\n              return ke;\n            }(d, v + k.charset, w.nGlyphs, I.objects));\n            k.encoding === 0 ? w.cffEncoding = new Fe(q, Q) : k.encoding === 1 ? w.cffEncoding = new Fe(ee, Q) : w.cffEncoding = function(ye, Se, be) {\n              var de = {}, Ie = new we.Parser(ye, Se);\n              if ((ye = Ie.parseCard8()) === 0)\n                for (var ke = Ie.parseCard8(), Ae = 0; Ae < ke; Ae += 1)\n                  de[Ee = Ie.parseCard8()] = Ae;\n              else {\n                if (ye !== 1)\n                  throw new Error(\"Unknown encoding format \" + ye);\n                for (var Te = Ie.parseCard8(), Ee = 1, $e = 0; $e < Te; $e += 1)\n                  for (var lt = Ie.parseCard8(), et = Ie.parseCard8(), tt = lt; tt <= lt + et; tt += 1)\n                    de[tt] = Ee, Ee += 1;\n              }\n              return new Fe(de, be);\n            }(d, v + k.encoding, Q), w.encoding = w.encoding || w.cffEncoding, w.glyphs = new Ke.GlyphSet(w);\n            for (var se = 0; se < w.nGlyphs; se += 1) {\n              var oe = z.objects[se];\n              w.glyphs.push(se, Ke.cffGlyphLoader(w, se, gt, oe));\n            }\n          }, make: function(d, ye) {\n            for (var w, k = new Me.Table(\"CFF \", [{ name: \"header\", type: \"RECORD\" }, { name: \"nameIndex\", type: \"RECORD\" }, { name: \"topDictIndex\", type: \"RECORD\" }, { name: \"stringIndex\", type: \"RECORD\" }, { name: \"globalSubrIndex\", type: \"RECORD\" }, { name: \"charsets\", type: \"RECORD\" }, { name: \"charStringsIndex\", type: \"RECORD\" }, { name: \"privateDict\", type: \"RECORD\" }]), I = 1 / ye.unitsPerEm, I = { version: ye.version, fullName: ye.fullName, familyName: ye.familyName, weight: ye.weightName, fontBBox: ye.fontBBox || [0, 0, 0, 0], fontMatrix: [I, 0, 0, I, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, N = [], z = 1; z < d.length; z += 1)\n              w = d.get(z), N.push(w.name);\n            var Q, se, oe = [], ye = (k.header = new Me.Record(\"Header\", [{ name: \"major\", type: \"Card8\", value: 1 }, { name: \"minor\", type: \"Card8\", value: 0 }, { name: \"hdrSize\", type: \"Card8\", value: 4 }, { name: \"major\", type: \"Card8\", value: 1 }]), k.nameIndex = function(be) {\n              var de = new Me.Record(\"Name INDEX\", [{ name: \"names\", type: \"INDEX\", value: [] }]);\n              de.names = [];\n              for (var Ie = 0; Ie < be.length; Ie += 1)\n                de.names.push({ name: \"name_\" + Ie, type: \"NAME\", value: be[Ie] });\n              return de;\n            }([ye.postScriptName]), Ue(I, oe)), Se = (k.topDictIndex = Ye(ye), k.globalSubrIndex = new Me.Record(\"Global Subr INDEX\", [{ name: \"subrs\", type: \"INDEX\", value: [] }]), k.charsets = function(be, de) {\n              for (var Ie = new Me.Record(\"Charsets\", [{ name: \"format\", type: \"Card8\", value: 0 }]), ke = 0; ke < be.length; ke += 1) {\n                var Ae = Ft(be[ke], de);\n                Ie.fields.push({ name: \"glyph_\" + ke, type: \"SID\", value: Ae });\n              }\n              return Ie;\n            }(N, oe), k.charStringsIndex = it(d), k.privateDict = (Se = {}, Q = oe, (se = new Me.Record(\"Private DICT\", [{ name: \"dict\", type: \"DICT\", value: {} }])).dict = me(ht, Se, Q), se), k.stringIndex = function(be) {\n              var de = new Me.Record(\"String INDEX\", [{ name: \"strings\", type: \"INDEX\", value: [] }]);\n              de.strings = [];\n              for (var Ie = 0; Ie < be.length; Ie += 1)\n                de.strings.push({ name: \"string_\" + Ie, type: \"STRING\", value: be[Ie] });\n              return de;\n            }(oe), k.header.sizeOf() + k.nameIndex.sizeOf() + k.topDictIndex.sizeOf() + k.stringIndex.sizeOf() + k.globalSubrIndex.sizeOf());\n            return I.charset = Se, I.encoding = 0, I.charStrings = I.charset + k.charsets.sizeOf(), I.private[1] = I.charStrings + k.charStringsIndex.sizeOf(), ye = Ue(I, oe), k.topDictIndex = Ye(ye), k;\n          } }, pt = { parse: function(k, v) {\n            var w = {}, k = new we.Parser(k, v);\n            return w.version = k.parseVersion(), w.fontRevision = Math.round(1e3 * k.parseFixed()) / 1e3, w.checkSumAdjustment = k.parseULong(), w.magicNumber = k.parseULong(), O.argument(w.magicNumber === 1594834165, \"Font header has wrong magic number.\"), w.flags = k.parseUShort(), w.unitsPerEm = k.parseUShort(), w.created = k.parseLongDateTime(), w.modified = k.parseLongDateTime(), w.xMin = k.parseShort(), w.yMin = k.parseShort(), w.xMax = k.parseShort(), w.yMax = k.parseShort(), w.macStyle = k.parseUShort(), w.lowestRecPPEM = k.parseUShort(), w.fontDirectionHint = k.parseShort(), w.indexToLocFormat = k.parseShort(), w.glyphDataFormat = k.parseShort(), w;\n          }, make: function(d) {\n            var v = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800, w = v;\n            return d.createdTimestamp && (w = d.createdTimestamp + 2082844800), new Me.Table(\"head\", [{ name: \"version\", type: \"FIXED\", value: 65536 }, { name: \"fontRevision\", type: \"FIXED\", value: 65536 }, { name: \"checkSumAdjustment\", type: \"ULONG\", value: 0 }, { name: \"magicNumber\", type: \"ULONG\", value: 1594834165 }, { name: \"flags\", type: \"USHORT\", value: 0 }, { name: \"unitsPerEm\", type: \"USHORT\", value: 1e3 }, { name: \"created\", type: \"LONGDATETIME\", value: w }, { name: \"modified\", type: \"LONGDATETIME\", value: v }, { name: \"xMin\", type: \"SHORT\", value: 0 }, { name: \"yMin\", type: \"SHORT\", value: 0 }, { name: \"xMax\", type: \"SHORT\", value: 0 }, { name: \"yMax\", type: \"SHORT\", value: 0 }, { name: \"macStyle\", type: \"USHORT\", value: 0 }, { name: \"lowestRecPPEM\", type: \"USHORT\", value: 0 }, { name: \"fontDirectionHint\", type: \"SHORT\", value: 2 }, { name: \"indexToLocFormat\", type: \"SHORT\", value: 0 }, { name: \"glyphDataFormat\", type: \"SHORT\", value: 0 }], d);\n          } }, ie = { parse: function(k, v) {\n            var w = {}, k = new we.Parser(k, v);\n            return w.version = k.parseVersion(), w.ascender = k.parseShort(), w.descender = k.parseShort(), w.lineGap = k.parseShort(), w.advanceWidthMax = k.parseUShort(), w.minLeftSideBearing = k.parseShort(), w.minRightSideBearing = k.parseShort(), w.xMaxExtent = k.parseShort(), w.caretSlopeRise = k.parseShort(), w.caretSlopeRun = k.parseShort(), w.caretOffset = k.parseShort(), k.relativeOffset += 8, w.metricDataFormat = k.parseShort(), w.numberOfHMetrics = k.parseUShort(), w;\n          }, make: function(d) {\n            return new Me.Table(\"hhea\", [{ name: \"version\", type: \"FIXED\", value: 65536 }, { name: \"ascender\", type: \"FWORD\", value: 0 }, { name: \"descender\", type: \"FWORD\", value: 0 }, { name: \"lineGap\", type: \"FWORD\", value: 0 }, { name: \"advanceWidthMax\", type: \"UFWORD\", value: 0 }, { name: \"minLeftSideBearing\", type: \"FWORD\", value: 0 }, { name: \"minRightSideBearing\", type: \"FWORD\", value: 0 }, { name: \"xMaxExtent\", type: \"FWORD\", value: 0 }, { name: \"caretSlopeRise\", type: \"SHORT\", value: 1 }, { name: \"caretSlopeRun\", type: \"SHORT\", value: 0 }, { name: \"caretOffset\", type: \"SHORT\", value: 0 }, { name: \"reserved1\", type: \"SHORT\", value: 0 }, { name: \"reserved2\", type: \"SHORT\", value: 0 }, { name: \"reserved3\", type: \"SHORT\", value: 0 }, { name: \"reserved4\", type: \"SHORT\", value: 0 }, { name: \"metricDataFormat\", type: \"SHORT\", value: 0 }, { name: \"numberOfHMetrics\", type: \"USHORT\", value: 0 }], d);\n          } }, Oe = { parse: function(d, v, w, k, I) {\n            for (var N, z, Q = new we.Parser(d, v), se = 0; se < k; se += 1) {\n              se < w && (N = Q.parseUShort(), z = Q.parseShort());\n              var oe = I.get(se);\n              oe.advanceWidth = N, oe.leftSideBearing = z;\n            }\n          }, make: function(d) {\n            for (var v = new Me.Table(\"hmtx\", []), w = 0; w < d.length; w += 1) {\n              var I = d.get(w), k = I.advanceWidth || 0, I = I.leftSideBearing || 0;\n              v.fields.push({ name: \"advanceWidth_\" + w, type: \"USHORT\", value: k }), v.fields.push({ name: \"leftSideBearing_\" + w, type: \"SHORT\", value: I });\n            }\n            return v;\n          } }, Ge = { make: function(d) {\n            for (var v = new Me.Table(\"ltag\", [{ name: \"version\", type: \"ULONG\", value: 1 }, { name: \"flags\", type: \"ULONG\", value: 0 }, { name: \"numTags\", type: \"ULONG\", value: d.length }]), w = \"\", k = 12 + 4 * d.length, I = 0; I < d.length; ++I) {\n              var N = w.indexOf(d[I]);\n              N < 0 && (N = w.length, w += d[I]), v.fields.push({ name: \"offset \" + I, type: \"USHORT\", value: k + N }), v.fields.push({ name: \"length \" + I, type: \"USHORT\", value: d[I].length });\n            }\n            return v.fields.push({ name: \"stringPool\", type: \"CHARARRAY\", value: w }), v;\n          }, parse: function(d, v) {\n            for (var w = new we.Parser(d, v), k = w.parseULong(), I = (O.argument(k === 1, \"Unsupported ltag table version.\"), w.skip(\"uLong\", 1), w.parseULong()), N = [], z = 0; z < I; z++) {\n              for (var Q = \"\", se = v + w.parseUShort(), oe = w.parseUShort(), ye = se; ye < se + oe; ++ye)\n                Q += String.fromCharCode(d.getInt8(ye));\n              N.push(Q);\n            }\n            return N;\n          } }, Le = { parse: function(k, v) {\n            var w = {}, k = new we.Parser(k, v);\n            return w.version = k.parseVersion(), w.numGlyphs = k.parseUShort(), w.version === 1 && (w.maxPoints = k.parseUShort(), w.maxContours = k.parseUShort(), w.maxCompositePoints = k.parseUShort(), w.maxCompositeContours = k.parseUShort(), w.maxZones = k.parseUShort(), w.maxTwilightPoints = k.parseUShort(), w.maxStorage = k.parseUShort(), w.maxFunctionDefs = k.parseUShort(), w.maxInstructionDefs = k.parseUShort(), w.maxStackElements = k.parseUShort(), w.maxSizeOfInstructions = k.parseUShort(), w.maxComponentElements = k.parseUShort(), w.maxComponentDepth = k.parseUShort()), w;\n          }, make: function(d) {\n            return new Me.Table(\"maxp\", [{ name: \"version\", type: \"FIXED\", value: 20480 }, { name: \"numGlyphs\", type: \"USHORT\", value: d }]);\n          } }, rt = [\"copyright\", \"fontFamily\", \"fontSubfamily\", \"uniqueID\", \"fullName\", \"version\", \"postScriptName\", \"trademark\", \"manufacturer\", \"designer\", \"description\", \"manufacturerURL\", \"designerURL\", \"license\", \"licenseURL\", \"reserved\", \"preferredFamily\", \"preferredSubfamily\", \"compatibleFullName\", \"sampleText\", \"postScriptFindFontName\", \"wwsFamily\", \"wwsSubfamily\"], Pe = { 0: \"en\", 1: \"fr\", 2: \"de\", 3: \"it\", 4: \"nl\", 5: \"sv\", 6: \"es\", 7: \"da\", 8: \"pt\", 9: \"no\", 10: \"he\", 11: \"ja\", 12: \"ar\", 13: \"fi\", 14: \"el\", 15: \"is\", 16: \"mt\", 17: \"tr\", 18: \"hr\", 19: \"zh-Hant\", 20: \"ur\", 21: \"hi\", 22: \"th\", 23: \"ko\", 24: \"lt\", 25: \"pl\", 26: \"hu\", 27: \"es\", 28: \"lv\", 29: \"se\", 30: \"fo\", 31: \"fa\", 32: \"ru\", 33: \"zh\", 34: \"nl-BE\", 35: \"ga\", 36: \"sq\", 37: \"ro\", 38: \"cz\", 39: \"sk\", 40: \"si\", 41: \"yi\", 42: \"sr\", 43: \"mk\", 44: \"bg\", 45: \"uk\", 46: \"be\", 47: \"uz\", 48: \"kk\", 49: \"az-Cyrl\", 50: \"az-Arab\", 51: \"hy\", 52: \"ka\", 53: \"mo\", 54: \"ky\", 55: \"tg\", 56: \"tk\", 57: \"mn-CN\", 58: \"mn\", 59: \"ps\", 60: \"ks\", 61: \"ku\", 62: \"sd\", 63: \"bo\", 64: \"ne\", 65: \"sa\", 66: \"mr\", 67: \"bn\", 68: \"as\", 69: \"gu\", 70: \"pa\", 71: \"or\", 72: \"ml\", 73: \"kn\", 74: \"ta\", 75: \"te\", 76: \"si\", 77: \"my\", 78: \"km\", 79: \"lo\", 80: \"vi\", 81: \"id\", 82: \"tl\", 83: \"ms\", 84: \"ms-Arab\", 85: \"am\", 86: \"ti\", 87: \"om\", 88: \"so\", 89: \"sw\", 90: \"rw\", 91: \"rn\", 92: \"ny\", 93: \"mg\", 94: \"eo\", 128: \"cy\", 129: \"eu\", 130: \"ca\", 131: \"la\", 132: \"qu\", 133: \"gn\", 134: \"ay\", 135: \"tt\", 136: \"ug\", 137: \"dz\", 138: \"jv\", 139: \"su\", 140: \"gl\", 141: \"af\", 142: \"br\", 143: \"iu\", 144: \"gd\", 145: \"gv\", 146: \"ga\", 147: \"to\", 148: \"el-polyton\", 149: \"kl\", 150: \"az\", 151: \"nn\" }, ct = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 }, qe = { 1078: \"af\", 1052: \"sq\", 1156: \"gsw\", 1118: \"am\", 5121: \"ar-DZ\", 15361: \"ar-BH\", 3073: \"ar\", 2049: \"ar-IQ\", 11265: \"ar-JO\", 13313: \"ar-KW\", 12289: \"ar-LB\", 4097: \"ar-LY\", 6145: \"ary\", 8193: \"ar-OM\", 16385: \"ar-QA\", 1025: \"ar-SA\", 10241: \"ar-SY\", 7169: \"aeb\", 14337: \"ar-AE\", 9217: \"ar-YE\", 1067: \"hy\", 1101: \"as\", 2092: \"az-Cyrl\", 1068: \"az\", 1133: \"ba\", 1069: \"eu\", 1059: \"be\", 2117: \"bn\", 1093: \"bn-IN\", 8218: \"bs-Cyrl\", 5146: \"bs\", 1150: \"br\", 1026: \"bg\", 1027: \"ca\", 3076: \"zh-HK\", 5124: \"zh-MO\", 2052: \"zh\", 4100: \"zh-SG\", 1028: \"zh-TW\", 1155: \"co\", 1050: \"hr\", 4122: \"hr-BA\", 1029: \"cs\", 1030: \"da\", 1164: \"prs\", 1125: \"dv\", 2067: \"nl-BE\", 1043: \"nl\", 3081: \"en-AU\", 10249: \"en-BZ\", 4105: \"en-CA\", 9225: \"en-029\", 16393: \"en-IN\", 6153: \"en-IE\", 8201: \"en-JM\", 17417: \"en-MY\", 5129: \"en-NZ\", 13321: \"en-PH\", 18441: \"en-SG\", 7177: \"en-ZA\", 11273: \"en-TT\", 2057: \"en-GB\", 1033: \"en\", 12297: \"en-ZW\", 1061: \"et\", 1080: \"fo\", 1124: \"fil\", 1035: \"fi\", 2060: \"fr-BE\", 3084: \"fr-CA\", 1036: \"fr\", 5132: \"fr-LU\", 6156: \"fr-MC\", 4108: \"fr-CH\", 1122: \"fy\", 1110: \"gl\", 1079: \"ka\", 3079: \"de-AT\", 1031: \"de\", 5127: \"de-LI\", 4103: \"de-LU\", 2055: \"de-CH\", 1032: \"el\", 1135: \"kl\", 1095: \"gu\", 1128: \"ha\", 1037: \"he\", 1081: \"hi\", 1038: \"hu\", 1039: \"is\", 1136: \"ig\", 1057: \"id\", 1117: \"iu\", 2141: \"iu-Latn\", 2108: \"ga\", 1076: \"xh\", 1077: \"zu\", 1040: \"it\", 2064: \"it-CH\", 1041: \"ja\", 1099: \"kn\", 1087: \"kk\", 1107: \"km\", 1158: \"quc\", 1159: \"rw\", 1089: \"sw\", 1111: \"kok\", 1042: \"ko\", 1088: \"ky\", 1108: \"lo\", 1062: \"lv\", 1063: \"lt\", 2094: \"dsb\", 1134: \"lb\", 1071: \"mk\", 2110: \"ms-BN\", 1086: \"ms\", 1100: \"ml\", 1082: \"mt\", 1153: \"mi\", 1146: \"arn\", 1102: \"mr\", 1148: \"moh\", 1104: \"mn\", 2128: \"mn-CN\", 1121: \"ne\", 1044: \"nb\", 2068: \"nn\", 1154: \"oc\", 1096: \"or\", 1123: \"ps\", 1045: \"pl\", 1046: \"pt\", 2070: \"pt-PT\", 1094: \"pa\", 1131: \"qu-BO\", 2155: \"qu-EC\", 3179: \"qu\", 1048: \"ro\", 1047: \"rm\", 1049: \"ru\", 9275: \"smn\", 4155: \"smj-NO\", 5179: \"smj\", 3131: \"se-FI\", 1083: \"se\", 2107: \"se-SE\", 8251: \"sms\", 6203: \"sma-NO\", 7227: \"sms\", 1103: \"sa\", 7194: \"sr-Cyrl-BA\", 3098: \"sr\", 6170: \"sr-Latn-BA\", 2074: \"sr-Latn\", 1132: \"nso\", 1074: \"tn\", 1115: \"si\", 1051: \"sk\", 1060: \"sl\", 11274: \"es-AR\", 16394: \"es-BO\", 13322: \"es-CL\", 9226: \"es-CO\", 5130: \"es-CR\", 7178: \"es-DO\", 12298: \"es-EC\", 17418: \"es-SV\", 4106: \"es-GT\", 18442: \"es-HN\", 2058: \"es-MX\", 19466: \"es-NI\", 6154: \"es-PA\", 15370: \"es-PY\", 10250: \"es-PE\", 20490: \"es-PR\", 3082: \"es\", 1034: \"es\", 21514: \"es-US\", 14346: \"es-UY\", 8202: \"es-VE\", 2077: \"sv-FI\", 1053: \"sv\", 1114: \"syr\", 1064: \"tg\", 2143: \"tzm\", 1097: \"ta\", 1092: \"tt\", 1098: \"te\", 1054: \"th\", 1105: \"bo\", 1055: \"tr\", 1090: \"tk\", 1152: \"ug\", 1058: \"uk\", 1070: \"hsb\", 1056: \"ur\", 2115: \"uz-Cyrl\", 1091: \"uz\", 1066: \"vi\", 1106: \"cy\", 1160: \"wo\", 1157: \"sah\", 1144: \"ii\", 1130: \"yo\" }, ut = \"utf-16\", Ze = { 0: \"macintosh\", 1: \"x-mac-japanese\", 2: \"x-mac-chinesetrad\", 3: \"x-mac-korean\", 6: \"x-mac-greek\", 7: \"x-mac-cyrillic\", 9: \"x-mac-devanagai\", 10: \"x-mac-gurmukhi\", 11: \"x-mac-gujarati\", 12: \"x-mac-oriya\", 13: \"x-mac-bengali\", 14: \"x-mac-tamil\", 15: \"x-mac-telugu\", 16: \"x-mac-kannada\", 17: \"x-mac-malayalam\", 18: \"x-mac-sinhalese\", 19: \"x-mac-burmese\", 20: \"x-mac-khmer\", 21: \"x-mac-thai\", 22: \"x-mac-lao\", 23: \"x-mac-georgian\", 24: \"x-mac-armenian\", 25: \"x-mac-chinesesimp\", 26: \"x-mac-tibetan\", 27: \"x-mac-mongolian\", 28: \"x-mac-ethiopic\", 29: \"x-mac-ce\", 30: \"x-mac-vietnamese\", 31: \"x-mac-extarabic\" }, At = { 15: \"x-mac-icelandic\", 17: \"x-mac-turkish\", 18: \"x-mac-croatian\", 24: \"x-mac-ce\", 25: \"x-mac-ce\", 26: \"x-mac-ce\", 27: \"x-mac-ce\", 28: \"x-mac-ce\", 30: \"x-mac-icelandic\", 37: \"x-mac-romanian\", 38: \"x-mac-ce\", 39: \"x-mac-ce\", 40: \"x-mac-ce\", 143: \"x-mac-inuit\", 146: \"x-mac-gaelic\" };\n          function Ut(d, v, w) {\n            switch (d) {\n              case 0:\n                return ut;\n              case 1:\n                return At[w] || Ze[v];\n              case 3:\n                if (v === 1 || v === 10)\n                  return ut;\n            }\n          }\n          function Ct(d) {\n            var v, w = {};\n            for (v in d)\n              w[d[v]] = parseInt(v);\n            return w;\n          }\n          function Nt(d, v, w, k, I, N) {\n            return new Me.Record(\"NameRecord\", [{ name: \"platformID\", type: \"USHORT\", value: d }, { name: \"encodingID\", type: \"USHORT\", value: v }, { name: \"languageID\", type: \"USHORT\", value: w }, { name: \"nameID\", type: \"USHORT\", value: k }, { name: \"length\", type: \"USHORT\", value: I }, { name: \"offset\", type: \"USHORT\", value: N }]);\n          }\n          function Kt(d, v) {\n            if ((w = function(N, z) {\n              var Q = N.length, se = z.length - Q + 1;\n              e:\n                for (var oe = 0; oe < se; oe++)\n                  for (; oe < se; oe++) {\n                    for (var ye = 0; ye < Q; ye++)\n                      if (z[oe + ye] !== N[ye])\n                        continue e;\n                    return oe;\n                  }\n              return -1;\n            }(d, v)) < 0)\n              for (var w = v.length, k = 0, I = d.length; k < I; ++k)\n                v.push(d[k]);\n            return w;\n          }\n          var Xt = { parse: function(d, v, w) {\n            for (var k = {}, I = new we.Parser(d, v), v = I.parseUShort(), N = I.parseUShort(), z = I.offset + I.parseUShort(), Q = 0; Q < N; Q++) {\n              var Ie = I.parseUShort(), se = I.parseUShort(), oe = I.parseUShort(), ye = I.parseUShort(), ye = rt[ye] || ye, Se = I.parseUShort(), be = I.parseUShort(), de = function(Ae, Te, Ee) {\n                switch (Ae) {\n                  case 0:\n                    if (Te === 65535)\n                      return \"und\";\n                    if (Ee)\n                      return Ee[Te];\n                    break;\n                  case 1:\n                    return Pe[Te];\n                  case 3:\n                    return qe[Te];\n                }\n              }(Ie, oe, w), Ie = Ut(Ie, se, oe);\n              Ie !== void 0 && de !== void 0 && (se = void 0, (se = Ie === ut ? D.UTF16(d, z + be, Se) : D.MACSTRING(d, z + be, Se, Ie)) && ((oe = (oe = k[ye]) === void 0 ? k[ye] = {} : oe)[de] = se));\n            }\n            return v === 1 && I.parseUShort(), k;\n          }, make: function(d, v) {\n            var w, k = [], I = {}, N = Ct(rt);\n            for (w in d) {\n              var z = N[w];\n              if (z === void 0 && (z = w), be = parseInt(z), isNaN(be))\n                throw new Error('Name table entry \"' + w + '\" does not exist, see nameTableNames for complete list.');\n              I[be] = d[w], k.push(be);\n            }\n            for (var Q = Ct(Pe), se = Ct(qe), oe = [], ye = [], Se = 0; Se < k.length; Se++) {\n              var be, de, Ie = I[be = k[Se]];\n              for (de in Ie) {\n                var ke = Ie[de], lt = 1, Ae = Q[de], Te = ct[Ae], Ee = Ut(lt, Te, Ae), Ee = B.MACSTRING(ke, Ee), $e = (Ee === void 0 && (lt = 0, (Ae = v.indexOf(de)) < 0 && (Ae = v.length, v.push(de)), Te = 4, Ee = B.UTF16(ke)), Kt(Ee, ye)), lt = (oe.push(Nt(lt, Te, Ae, be, Ee.length, $e)), se[de]);\n                lt !== void 0 && (Ae = Kt(Te = B.UTF16(ke), ye), oe.push(Nt(3, 1, lt, be, Te.length, Ae)));\n              }\n            }\n            oe.sort(function(dt, wt) {\n              return dt.platformID - wt.platformID || dt.encodingID - wt.encodingID || dt.languageID - wt.languageID || dt.nameID - wt.nameID;\n            });\n            for (var et = new Me.Table(\"name\", [{ name: \"format\", type: \"USHORT\", value: 0 }, { name: \"count\", type: \"USHORT\", value: oe.length }, { name: \"stringOffset\", type: \"USHORT\", value: 6 + 12 * oe.length }]), tt = 0; tt < oe.length; tt++)\n              et.fields.push({ name: \"record_\" + tt, type: \"RECORD\", value: oe[tt] });\n            return et.fields.push({ name: \"strings\", type: \"LITERAL\", value: ye }), et;\n          } }, Jt = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }], Bt = { parse: function(d, v) {\n            var w = {}, k = new we.Parser(d, v);\n            w.version = k.parseUShort(), w.xAvgCharWidth = k.parseShort(), w.usWeightClass = k.parseUShort(), w.usWidthClass = k.parseUShort(), w.fsType = k.parseUShort(), w.ySubscriptXSize = k.parseShort(), w.ySubscriptYSize = k.parseShort(), w.ySubscriptXOffset = k.parseShort(), w.ySubscriptYOffset = k.parseShort(), w.ySuperscriptXSize = k.parseShort(), w.ySuperscriptYSize = k.parseShort(), w.ySuperscriptXOffset = k.parseShort(), w.ySuperscriptYOffset = k.parseShort(), w.yStrikeoutSize = k.parseShort(), w.yStrikeoutPosition = k.parseShort(), w.sFamilyClass = k.parseShort(), w.panose = [];\n            for (var I = 0; I < 10; I++)\n              w.panose[I] = k.parseByte();\n            return w.ulUnicodeRange1 = k.parseULong(), w.ulUnicodeRange2 = k.parseULong(), w.ulUnicodeRange3 = k.parseULong(), w.ulUnicodeRange4 = k.parseULong(), w.achVendID = String.fromCharCode(k.parseByte(), k.parseByte(), k.parseByte(), k.parseByte()), w.fsSelection = k.parseUShort(), w.usFirstCharIndex = k.parseUShort(), w.usLastCharIndex = k.parseUShort(), w.sTypoAscender = k.parseShort(), w.sTypoDescender = k.parseShort(), w.sTypoLineGap = k.parseShort(), w.usWinAscent = k.parseUShort(), w.usWinDescent = k.parseUShort(), 1 <= w.version && (w.ulCodePageRange1 = k.parseULong(), w.ulCodePageRange2 = k.parseULong()), 2 <= w.version && (w.sxHeight = k.parseShort(), w.sCapHeight = k.parseShort(), w.usDefaultChar = k.parseUShort(), w.usBreakChar = k.parseUShort(), w.usMaxContent = k.parseUShort()), w;\n          }, make: function(d) {\n            return new Me.Table(\"OS/2\", [{ name: \"version\", type: \"USHORT\", value: 3 }, { name: \"xAvgCharWidth\", type: \"SHORT\", value: 0 }, { name: \"usWeightClass\", type: \"USHORT\", value: 0 }, { name: \"usWidthClass\", type: \"USHORT\", value: 0 }, { name: \"fsType\", type: \"USHORT\", value: 0 }, { name: \"ySubscriptXSize\", type: \"SHORT\", value: 650 }, { name: \"ySubscriptYSize\", type: \"SHORT\", value: 699 }, { name: \"ySubscriptXOffset\", type: \"SHORT\", value: 0 }, { name: \"ySubscriptYOffset\", type: \"SHORT\", value: 140 }, { name: \"ySuperscriptXSize\", type: \"SHORT\", value: 650 }, { name: \"ySuperscriptYSize\", type: \"SHORT\", value: 699 }, { name: \"ySuperscriptXOffset\", type: \"SHORT\", value: 0 }, { name: \"ySuperscriptYOffset\", type: \"SHORT\", value: 479 }, { name: \"yStrikeoutSize\", type: \"SHORT\", value: 49 }, { name: \"yStrikeoutPosition\", type: \"SHORT\", value: 258 }, { name: \"sFamilyClass\", type: \"SHORT\", value: 0 }, { name: \"bFamilyType\", type: \"BYTE\", value: 0 }, { name: \"bSerifStyle\", type: \"BYTE\", value: 0 }, { name: \"bWeight\", type: \"BYTE\", value: 0 }, { name: \"bProportion\", type: \"BYTE\", value: 0 }, { name: \"bContrast\", type: \"BYTE\", value: 0 }, { name: \"bStrokeVariation\", type: \"BYTE\", value: 0 }, { name: \"bArmStyle\", type: \"BYTE\", value: 0 }, { name: \"bLetterform\", type: \"BYTE\", value: 0 }, { name: \"bMidline\", type: \"BYTE\", value: 0 }, { name: \"bXHeight\", type: \"BYTE\", value: 0 }, { name: \"ulUnicodeRange1\", type: \"ULONG\", value: 0 }, { name: \"ulUnicodeRange2\", type: \"ULONG\", value: 0 }, { name: \"ulUnicodeRange3\", type: \"ULONG\", value: 0 }, { name: \"ulUnicodeRange4\", type: \"ULONG\", value: 0 }, { name: \"achVendID\", type: \"CHARARRAY\", value: \"XXXX\" }, { name: \"fsSelection\", type: \"USHORT\", value: 0 }, { name: \"usFirstCharIndex\", type: \"USHORT\", value: 0 }, { name: \"usLastCharIndex\", type: \"USHORT\", value: 0 }, { name: \"sTypoAscender\", type: \"SHORT\", value: 0 }, { name: \"sTypoDescender\", type: \"SHORT\", value: 0 }, { name: \"sTypoLineGap\", type: \"SHORT\", value: 0 }, { name: \"usWinAscent\", type: \"USHORT\", value: 0 }, { name: \"usWinDescent\", type: \"USHORT\", value: 0 }, { name: \"ulCodePageRange1\", type: \"ULONG\", value: 0 }, { name: \"ulCodePageRange2\", type: \"ULONG\", value: 0 }, { name: \"sxHeight\", type: \"SHORT\", value: 0 }, { name: \"sCapHeight\", type: \"SHORT\", value: 0 }, { name: \"usDefaultChar\", type: \"USHORT\", value: 0 }, { name: \"usBreakChar\", type: \"USHORT\", value: 0 }, { name: \"usMaxContext\", type: \"USHORT\", value: 0 }], d);\n          }, unicodeRanges: Jt, getUnicodeRange: function(d) {\n            for (var v = 0; v < Jt.length; v += 1) {\n              var w = Jt[v];\n              if (d >= w.begin && d < w.end)\n                return v;\n            }\n            return -1;\n          } }, Lr = { parse: function(d, v) {\n            var w = {}, k = new we.Parser(d, v);\n            switch (w.version = k.parseVersion(), w.italicAngle = k.parseFixed(), w.underlinePosition = k.parseShort(), w.underlineThickness = k.parseShort(), w.isFixedPitch = k.parseULong(), w.minMemType42 = k.parseULong(), w.maxMemType42 = k.parseULong(), w.minMemType1 = k.parseULong(), w.maxMemType1 = k.parseULong(), w.version) {\n              case 1:\n                w.names = pe.slice();\n                break;\n              case 2:\n                w.numberOfGlyphs = k.parseUShort(), w.glyphNameIndex = new Array(w.numberOfGlyphs);\n                for (var I = 0; I < w.numberOfGlyphs; I++)\n                  w.glyphNameIndex[I] = k.parseUShort();\n                w.names = [];\n                for (var N, z = 0; z < w.numberOfGlyphs; z++)\n                  w.glyphNameIndex[z] >= pe.length && (N = k.parseChar(), w.names.push(k.parseString(N)));\n                break;\n              case 2.5:\n                w.numberOfGlyphs = k.parseUShort(), w.offset = new Array(w.numberOfGlyphs);\n                for (var Q = 0; Q < w.numberOfGlyphs; Q++)\n                  w.offset[Q] = k.parseChar();\n            }\n            return w;\n          }, make: function() {\n            return new Me.Table(\"post\", [{ name: \"version\", type: \"FIXED\", value: 196608 }, { name: \"italicAngle\", type: \"FIXED\", value: 0 }, { name: \"underlinePosition\", type: \"FWORD\", value: 0 }, { name: \"underlineThickness\", type: \"FWORD\", value: 0 }, { name: \"isFixedPitch\", type: \"ULONG\", value: 0 }, { name: \"minMemType42\", type: \"ULONG\", value: 0 }, { name: \"maxMemType42\", type: \"ULONG\", value: 0 }, { name: \"minMemType1\", type: \"ULONG\", value: 0 }, { name: \"maxMemType1\", type: \"ULONG\", value: 0 }]);\n          } }, Yt = new Array(9), ar = (Yt[1] = function() {\n            var d = this.offset + this.relativeOffset, v = this.parseUShort();\n            return v === 1 ? { substFormat: 1, coverage: this.parsePointer(ve.coverage), deltaGlyphId: this.parseUShort() } : v === 2 ? { substFormat: 2, coverage: this.parsePointer(ve.coverage), substitute: this.parseOffset16List() } : void O.assert(!1, \"0x\" + d.toString(16) + \": lookup type 1 format must be 1 or 2.\");\n          }, Yt[2] = function() {\n            var d = this.parseUShort();\n            return O.argument(d === 1, \"GSUB Multiple Substitution Subtable identifier-format must be 1\"), { substFormat: d, coverage: this.parsePointer(ve.coverage), sequences: this.parseListOfLists() };\n          }, Yt[3] = function() {\n            var d = this.parseUShort();\n            return O.argument(d === 1, \"GSUB Alternate Substitution Subtable identifier-format must be 1\"), { substFormat: d, coverage: this.parsePointer(ve.coverage), alternateSets: this.parseListOfLists() };\n          }, Yt[4] = function() {\n            var d = this.parseUShort();\n            return O.argument(d === 1, \"GSUB ligature table identifier-format must be 1\"), { substFormat: d, coverage: this.parsePointer(ve.coverage), ligatureSets: this.parseListOfLists(function() {\n              return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };\n            }) };\n          }, { sequenceIndex: ve.uShort, lookupListIndex: ve.uShort });\n          Yt[5] = function() {\n            var d, v, w = this.offset + this.relativeOffset, k = this.parseUShort();\n            return k === 1 ? { substFormat: k, coverage: this.parsePointer(ve.coverage), ruleSets: this.parseListOfLists(function() {\n              var I = this.parseUShort(), N = this.parseUShort();\n              return { input: this.parseUShortList(I - 1), lookupRecords: this.parseRecordList(N, ar) };\n            }) } : k === 2 ? { substFormat: k, coverage: this.parsePointer(ve.coverage), classDef: this.parsePointer(ve.classDef), classSets: this.parseListOfLists(function() {\n              var I = this.parseUShort(), N = this.parseUShort();\n              return { classes: this.parseUShortList(I - 1), lookupRecords: this.parseRecordList(N, ar) };\n            }) } : k === 3 ? (d = this.parseUShort(), v = this.parseUShort(), { substFormat: k, coverages: this.parseList(d, ve.pointer(ve.coverage)), lookupRecords: this.parseRecordList(v, ar) }) : void O.assert(!1, \"0x\" + w.toString(16) + \": lookup type 5 format must be 1, 2 or 3.\");\n          }, Yt[6] = function() {\n            var d = this.offset + this.relativeOffset, v = this.parseUShort();\n            return v === 1 ? { substFormat: 1, coverage: this.parsePointer(ve.coverage), chainRuleSets: this.parseListOfLists(function() {\n              return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(ar) };\n            }) } : v === 2 ? { substFormat: 2, coverage: this.parsePointer(ve.coverage), backtrackClassDef: this.parsePointer(ve.classDef), inputClassDef: this.parsePointer(ve.classDef), lookaheadClassDef: this.parsePointer(ve.classDef), chainClassSet: this.parseListOfLists(function() {\n              return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(ar) };\n            }) } : v === 3 ? { substFormat: 3, backtrackCoverage: this.parseList(ve.pointer(ve.coverage)), inputCoverage: this.parseList(ve.pointer(ve.coverage)), lookaheadCoverage: this.parseList(ve.pointer(ve.coverage)), lookupRecords: this.parseRecordList(ar) } : void O.assert(!1, \"0x\" + d.toString(16) + \": lookup type 6 format must be 1, 2 or 3.\");\n          }, Yt[7] = function() {\n            var d = this.parseUShort(), d = (O.argument(d === 1, \"GSUB Extension Substitution subtable identifier-format must be 1\"), this.parseUShort()), v = new ve(this.data, this.offset + this.parseULong());\n            return { substFormat: 1, lookupType: d, extension: Yt[d].call(v) };\n          }, Yt[8] = function() {\n            var d = this.parseUShort();\n            return O.argument(d === 1, \"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1\"), { substFormat: d, coverage: this.parsePointer(ve.coverage), backtrackCoverage: this.parseList(ve.pointer(ve.coverage)), lookaheadCoverage: this.parseList(ve.pointer(ve.coverage)), substitutes: this.parseUShortList() };\n          };\n          var yr = new Array(9);\n          yr[1] = function(d) {\n            return d.substFormat === 1 ? new Me.Table(\"substitutionTable\", [{ name: \"substFormat\", type: \"USHORT\", value: 1 }, { name: \"coverage\", type: \"TABLE\", value: new Me.Coverage(d.coverage) }, { name: \"deltaGlyphID\", type: \"USHORT\", value: d.deltaGlyphId }]) : new Me.Table(\"substitutionTable\", [{ name: \"substFormat\", type: \"USHORT\", value: 2 }, { name: \"coverage\", type: \"TABLE\", value: new Me.Coverage(d.coverage) }].concat(Me.ushortList(\"substitute\", d.substitute)));\n          }, yr[3] = function(d) {\n            return O.assert(d.substFormat === 1, \"Lookup type 3 substFormat must be 1.\"), new Me.Table(\"substitutionTable\", [{ name: \"substFormat\", type: \"USHORT\", value: 1 }, { name: \"coverage\", type: \"TABLE\", value: new Me.Coverage(d.coverage) }].concat(Me.tableList(\"altSet\", d.alternateSets, function(v) {\n              return new Me.Table(\"alternateSetTable\", Me.ushortList(\"alternate\", v));\n            })));\n          }, yr[4] = function(d) {\n            return O.assert(d.substFormat === 1, \"Lookup type 4 substFormat must be 1.\"), new Me.Table(\"substitutionTable\", [{ name: \"substFormat\", type: \"USHORT\", value: 1 }, { name: \"coverage\", type: \"TABLE\", value: new Me.Coverage(d.coverage) }].concat(Me.tableList(\"ligSet\", d.ligatureSets, function(v) {\n              return new Me.Table(\"ligatureSetTable\", Me.tableList(\"ligature\", v, function(w) {\n                return new Me.Table(\"ligatureTable\", [{ name: \"ligGlyph\", type: \"USHORT\", value: w.ligGlyph }].concat(Me.ushortList(\"component\", w.components, w.components.length + 1)));\n              }));\n            })));\n          };\n          var Rr = { parse: function(d, v) {\n            return v = (d = new ve(d, v = v || 0)).parseVersion(1), O.argument(v === 1 || v === 1.1, \"Unsupported GSUB table version.\"), v === 1 ? { version: v, scripts: d.parseScriptList(), features: d.parseFeatureList(), lookups: d.parseLookupList(Yt) } : { version: v, scripts: d.parseScriptList(), features: d.parseFeatureList(), lookups: d.parseLookupList(Yt), variations: d.parseFeatureVariationsList() };\n          }, make: function(d) {\n            return new Me.Table(\"GSUB\", [{ name: \"version\", type: \"ULONG\", value: 65536 }, { name: \"scripts\", type: \"TABLE\", value: new Me.ScriptList(d.scripts) }, { name: \"features\", type: \"TABLE\", value: new Me.FeatureList(d.features) }, { name: \"lookups\", type: \"TABLE\", value: new Me.LookupList(d.lookups, yr) }]);\n          } }, Ir = { parse: function(d, v) {\n            for (var w = new we.Parser(d, v), k = w.parseULong(), I = (O.argument(k === 1, \"Unsupported META table version.\"), w.parseULong(), w.parseULong(), w.parseULong()), N = {}, z = 0; z < I; z++) {\n              var Q = w.parseTag(), oe = w.parseULong(), se = w.parseULong(), oe = D.UTF8(d, v + oe, se);\n              N[Q] = oe;\n            }\n            return N;\n          }, make: function(d) {\n            var v, w = Object.keys(d).length, k = \"\", I = 16 + 12 * w, N = new Me.Table(\"meta\", [{ name: \"version\", type: \"ULONG\", value: 1 }, { name: \"flags\", type: \"ULONG\", value: 0 }, { name: \"offset\", type: \"ULONG\", value: I }, { name: \"numTags\", type: \"ULONG\", value: w }]);\n            for (v in d) {\n              var z = k.length;\n              k += d[v], N.fields.push({ name: \"tag \" + v, type: \"TAG\", value: v }), N.fields.push({ name: \"offset \" + v, type: \"ULONG\", value: I + z }), N.fields.push({ name: \"length \" + v, type: \"ULONG\", value: d[v].length });\n            }\n            return N.fields.push({ name: \"stringPool\", type: \"CHARARRAY\", value: k }), N;\n          } };\n          function Dr(d) {\n            return Math.log(d) / Math.log(2) | 0;\n          }\n          function Sr(d) {\n            for (; d.length % 4 != 0; )\n              d.push(0);\n            for (var v = 0, w = 0; w < d.length; w += 4)\n              v += (d[w] << 24) + (d[w + 1] << 16) + (d[w + 2] << 8) + d[w + 3];\n            return v %= Math.pow(2, 32);\n          }\n          function Fr(d, v, w, k) {\n            return new Me.Record(\"Table Record\", [{ name: \"tag\", type: \"TAG\", value: d !== void 0 ? d : \"\" }, { name: \"checkSum\", type: \"ULONG\", value: v !== void 0 ? v : 0 }, { name: \"offset\", type: \"ULONG\", value: w !== void 0 ? w : 0 }, { name: \"length\", type: \"ULONG\", value: k !== void 0 ? k : 0 }]);\n          }\n          function Ur(d) {\n            for (var v = new Me.Table(\"sfnt\", [{ name: \"version\", type: \"TAG\", value: \"OTTO\" }, { name: \"numTables\", type: \"USHORT\", value: 0 }, { name: \"searchRange\", type: \"USHORT\", value: 0 }, { name: \"entrySelector\", type: \"USHORT\", value: 0 }, { name: \"rangeShift\", type: \"USHORT\", value: 0 }]), w = (v.tables = d, v.numTables = d.length, Math.pow(2, Dr(v.numTables))), k = (v.searchRange = 16 * w, v.entrySelector = Dr(w), v.rangeShift = 16 * v.numTables - v.searchRange, []), I = [], N = v.sizeOf() + Fr().sizeOf() * v.numTables; N % 4 != 0; )\n              N += 1, I.push({ name: \"padding\", type: \"BYTE\", value: 0 });\n            for (var z = 0; z < d.length; z += 1) {\n              var Q = d[z], se = (O.argument(Q.tableName.length === 4, \"Table name\" + Q.tableName + \" is invalid.\"), Q.sizeOf()), oe = Fr(Q.tableName, Sr(Q.encode()), N, se);\n              for (k.push({ name: oe.tag + \" Table Record\", type: \"RECORD\", value: oe }), I.push({ name: Q.tableName + \" table\", type: \"RECORD\", value: Q }), N += se, O.argument(!isNaN(N), \"Something went wrong calculating the offset.\"); N % 4 != 0; )\n                N += 1, I.push({ name: \"padding\", type: \"BYTE\", value: 0 });\n            }\n            return k.sort(function(ye, Se) {\n              return ye.value.tag > Se.value.tag ? 1 : -1;\n            }), v.fields = v.fields.concat(k), v.fields = v.fields.concat(I), v;\n          }\n          function Nr(d, v, w) {\n            for (var k = 0; k < v.length; k += 1) {\n              var I = d.charToGlyphIndex(v[k]);\n              if (0 < I)\n                return d.glyphs.get(I).getMetrics();\n            }\n            return w;\n          }\n          var Sn = { make: Ur, fontToTable: function(d) {\n            for (var v, w = [], k = [], I = [], N = [], z = [], Q = [], se = [], oe = 0, ye = 0, Se = 0, be = 0, de = 0, Ie = 0; Ie < d.glyphs.length; Ie += 1) {\n              var ke = d.glyphs.get(Ie), Ae = 0 | ke.unicode;\n              if (isNaN(ke.advanceWidth))\n                throw new Error(\"Glyph \" + ke.name + \" (\" + Ie + \"): advanceWidth is not a number.\");\n              (Ae < v || v === void 0) && 0 < Ae && (v = Ae), oe < Ae && (oe = Ae);\n              var Ae = Bt.getUnicodeRange(Ae);\n              if (Ae < 32)\n                ye |= 1 << Ae;\n              else if (Ae < 64)\n                Se |= 1 << Ae - 32;\n              else if (Ae < 96)\n                be |= 1 << Ae - 64;\n              else {\n                if (!(Ae < 123))\n                  throw new Error(\"Unicode ranges bits > 123 are reserved for internal usage\");\n                de |= 1 << Ae - 96;\n              }\n              ke.name !== \".notdef\" && (Ae = ke.getMetrics(), w.push(Ae.xMin), k.push(Ae.yMin), I.push(Ae.xMax), N.push(Ae.yMax), Q.push(Ae.leftSideBearing), se.push(Ae.rightSideBearing), z.push(ke.advanceWidth));\n            }\n            var Te, Ee = { xMin: Math.min.apply(null, w), yMin: Math.min.apply(null, k), xMax: Math.max.apply(null, I), yMax: Math.max.apply(null, N), advanceWidthMax: Math.max.apply(null, z), advanceWidthAvg: function(Gt) {\n              for (var fr = 0, ur = 0; ur < Gt.length; ur += 1)\n                fr += Gt[ur];\n              return fr / Gt.length;\n            }(z), minLeftSideBearing: Math.min.apply(null, Q), maxLeftSideBearing: Math.max.apply(null, Q), minRightSideBearing: Math.min.apply(null, se) }, $e = (Ee.ascender = d.ascender, Ee.descender = d.descender, pt.make({ flags: 3, unitsPerEm: d.unitsPerEm, xMin: Ee.xMin, yMin: Ee.yMin, xMax: Ee.xMax, yMax: Ee.yMax, lowestRecPPEM: 3, createdTimestamp: d.createdTimestamp })), lt = ie.make({ ascender: Ee.ascender, descender: Ee.descender, advanceWidthMax: Ee.advanceWidthMax, minLeftSideBearing: Ee.minLeftSideBearing, minRightSideBearing: Ee.minRightSideBearing, xMaxExtent: Ee.maxLeftSideBearing + (Ee.xMax - Ee.xMin), numberOfHMetrics: d.glyphs.length }), et = Le.make(d.glyphs.length), tt = Bt.make({ xAvgCharWidth: Math.round(Ee.advanceWidthAvg), usWeightClass: d.tables.os2.usWeightClass, usWidthClass: d.tables.os2.usWidthClass, usFirstCharIndex: v, usLastCharIndex: oe, ulUnicodeRange1: ye, ulUnicodeRange2: Se, ulUnicodeRange3: be, ulUnicodeRange4: de, fsSelection: d.tables.os2.fsSelection, sTypoAscender: Ee.ascender, sTypoDescender: Ee.descender, sTypoLineGap: 0, usWinAscent: Ee.yMax, usWinDescent: Math.abs(Ee.yMin), ulCodePageRange1: 1, sxHeight: Nr(d, \"xyvw\", { yMax: Math.round(Ee.ascender / 2) }).yMax, sCapHeight: Nr(d, \"HIKLEFJMNTZBDPRAGOQSUVWXY\", Ee).yMax, usDefaultChar: d.hasChar(\" \") ? 32 : 0, usBreakChar: d.hasChar(\" \") ? 32 : 0 }), dt = Oe.make(d.glyphs), wt = Z.make(d.glyphs), St = d.getEnglishName(\"fontFamily\"), vt = d.getEnglishName(\"fontSubfamily\"), xt = St + \" \" + vt, Ot = (Ot = d.getEnglishName(\"postScriptName\")) || St.replace(/\\s/g, \"\") + \"-\" + vt, Rt = {};\n            for (Te in d.names)\n              Rt[Te] = d.names[Te];\n            Rt.uniqueID || (Rt.uniqueID = { en: d.getEnglishName(\"manufacturer\") + \":\" + xt }), Rt.postScriptName || (Rt.postScriptName = { en: Ot }), Rt.preferredFamily || (Rt.preferredFamily = d.names.fontFamily), Rt.preferredSubfamily || (Rt.preferredSubfamily = d.names.fontSubfamily);\n            var Wt = [], Ht = Xt.make(Rt, Wt), Wt = 0 < Wt.length ? Ge.make(Wt) : void 0, Qt = Lr.make(), xt = ft.make(d.glyphs, { version: d.getEnglishName(\"version\"), fullName: xt, familyName: St, weightName: vt, postScriptName: Ot, unitsPerEm: d.unitsPerEm, fontBBox: [0, Ee.yMin, Ee.ascender, Ee.advanceWidthMax] }), St = d.metas && 0 < Object.keys(d.metas).length ? Ir.make(d.metas) : void 0, vt = [$e, lt, et, tt, Ht, wt, Qt, xt, dt];\n            Wt && vt.push(Wt), d.tables.gsub && vt.push(Rr.make(d.tables.gsub)), St && vt.push(St);\n            for (var qt = Sr((Ot = Ur(vt)).encode()), kt = Ot.fields, zt = !1, Tt = 0; Tt < kt.length; Tt += 1)\n              if (kt[Tt].name === \"head table\") {\n                kt[Tt].value.checkSumAdjustment = 2981146554 - qt, zt = !0;\n                break;\n              }\n            if (zt)\n              return Ot;\n            throw new Error(\"Could not find head table with checkSum to adjust.\");\n          }, computeCheckSum: Sr };\n          function Tr(d, v) {\n            for (var w = 0, k = d.length - 1; w <= k; ) {\n              var I = w + k >>> 1, N = d[I].tag;\n              if (N === v)\n                return I;\n              N < v ? w = 1 + I : k = I - 1;\n            }\n            return -w - 1;\n          }\n          function Br(d, v) {\n            for (var w = 0, k = d.length - 1; w <= k; ) {\n              var I = w + k >>> 1, N = d[I];\n              if (N === v)\n                return I;\n              N < v ? w = 1 + I : k = I - 1;\n            }\n            return -w - 1;\n          }\n          function Gr(d, v) {\n            for (var w = 0, k = d.length - 1; w <= k; ) {\n              var I, N = w + k >>> 1, z = (I = d[N]).start;\n              if (z === v)\n                return I;\n              z < v ? w = 1 + N : k = N - 1;\n            }\n            if (0 < w)\n              return v > (I = d[w - 1]).end ? 0 : I;\n          }\n          function gr(d, v) {\n            this.font = d, this.tableName = v;\n          }\n          function vr(d) {\n            gr.call(this, d, \"gpos\");\n          }\n          function $t(d) {\n            gr.call(this, d, \"gsub\");\n          }\n          function Vr(d, v, w) {\n            for (var k = d.subtables, I = 0; I < k.length; I++) {\n              var N = k[I];\n              if (N.substFormat === v)\n                return N;\n            }\n            if (w)\n              return k.push(w), w;\n          }\n          function zr(d) {\n            for (var v = new ArrayBuffer(d.length), w = new Uint8Array(v), k = 0; k < d.length; ++k)\n              w[k] = d[k];\n            return v;\n          }\n          function ir(d, v) {\n            if (!d)\n              throw v;\n          }\n          function Hr(d, v, w, k, I) {\n            var N = 0 < (v & k) ? (N = d.parseByte(), w + (N = v & I ? N : -N)) : 0 < (v & I) ? w : w + d.parseShort();\n            return N;\n          }\n          function Tn(d, v, w) {\n            var k, I = new we.Parser(v, w);\n            if (d.numberOfContours = I.parseShort(), d._xMin = I.parseShort(), d._yMin = I.parseShort(), d._xMax = I.parseShort(), d._yMax = I.parseShort(), 0 < d.numberOfContours) {\n              for (var N = d.endPointIndices = [], z = 0; z < d.numberOfContours; z += 1)\n                N.push(I.parseUShort());\n              d.instructionLength = I.parseUShort(), d.instructions = [];\n              for (var Q = 0; Q < d.instructionLength; Q += 1)\n                d.instructions.push(I.parseByte());\n              for (var se = N[N.length - 1] + 1, oe = [], ye = 0; ye < se; ye += 1)\n                if (k = I.parseByte(), oe.push(k), 0 < (8 & k))\n                  for (var Se = I.parseByte(), be = 0; be < Se; be += 1)\n                    oe.push(k), ye += 1;\n              if (O.argument(oe.length === se, \"Bad flags.\"), 0 < N.length) {\n                var de, Ie = [];\n                if (0 < se) {\n                  for (var ke = 0; ke < se; ke += 1)\n                    k = oe[ke], (de = {}).onCurve = !!(1 & k), de.lastPointOfContour = 0 <= N.indexOf(ke), Ie.push(de);\n                  for (var Ae = 0, Te = 0; Te < se; Te += 1)\n                    k = oe[Te], (de = Ie[Te]).x = Hr(I, k, Ae, 2, 16), Ae = de.x;\n                  for (var Ee = 0, $e = 0; $e < se; $e += 1)\n                    k = oe[$e], (de = Ie[$e]).y = Hr(I, k, Ee, 4, 32), Ee = de.y;\n                }\n                d.points = Ie;\n              } else\n                d.points = [];\n            } else if (d.numberOfContours === 0)\n              d.points = [];\n            else {\n              d.isComposite = !0, d.points = [], d.components = [];\n              for (var lt = !0; lt; ) {\n                oe = I.parseUShort();\n                var et = { glyphIndex: I.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };\n                0 < (1 & oe) ? 0 < (2 & oe) ? (et.dx = I.parseShort(), et.dy = I.parseShort()) : et.matchedPoints = [I.parseUShort(), I.parseUShort()] : 0 < (2 & oe) ? (et.dx = I.parseChar(), et.dy = I.parseChar()) : et.matchedPoints = [I.parseByte(), I.parseByte()], 0 < (8 & oe) ? et.xScale = et.yScale = I.parseF2Dot14() : 0 < (64 & oe) ? (et.xScale = I.parseF2Dot14(), et.yScale = I.parseF2Dot14()) : 0 < (128 & oe) && (et.xScale = I.parseF2Dot14(), et.scale01 = I.parseF2Dot14(), et.scale10 = I.parseF2Dot14(), et.yScale = I.parseF2Dot14()), d.components.push(et), lt = !!(32 & oe);\n              }\n              if (256 & oe) {\n                d.instructionLength = I.parseUShort(), d.instructions = [];\n                for (var tt = 0; tt < d.instructionLength; tt += 1)\n                  d.instructions.push(I.parseByte());\n              }\n            }\n          }\n          function Er(d, v) {\n            for (var w = [], k = 0; k < d.length; k += 1) {\n              var I = d[k], I = { x: v.xScale * I.x + v.scale01 * I.y + v.dx, y: v.scale10 * I.x + v.yScale * I.y + v.dy, onCurve: I.onCurve, lastPointOfContour: I.lastPointOfContour };\n              w.push(I);\n            }\n            return w;\n          }\n          function Wr(d) {\n            var v = new X();\n            if (d)\n              for (var w = function(Se) {\n                for (var be = [], de = [], Ie = 0; Ie < Se.length; Ie += 1) {\n                  var ke = Se[Ie];\n                  de.push(ke), ke.lastPointOfContour && (be.push(de), de = []);\n                }\n                return O.argument(de.length === 0, \"There are still points left in the current contour.\"), be;\n              }(d), k = 0; k < w.length; ++k) {\n                var I, N = w[k], z = N[N.length - 1], Q = N[0];\n                z.onCurve ? v.moveTo(z.x, z.y) : Q.onCurve ? v.moveTo(Q.x, Q.y) : (I = { x: 0.5 * (z.x + Q.x), y: 0.5 * (z.y + Q.y) }, v.moveTo(I.x, I.y));\n                for (var se = 0; se < N.length; ++se) {\n                  var oe, ye = z, z = Q, Q = N[(se + 1) % N.length];\n                  z.onCurve ? v.lineTo(z.x, z.y) : (oe = Q, ye.onCurve || (z.x, ye.x, z.y, ye.y), Q.onCurve || (oe = { x: 0.5 * (z.x + Q.x), y: 0.5 * (z.y + Q.y) }), v.quadraticCurveTo(z.x, z.y, oe.x, oe.y));\n                }\n                v.closePath();\n              }\n            return v;\n          }\n          function En(d, v) {\n            if (v.isComposite)\n              for (var w = 0; w < v.components.length; w += 1) {\n                var k = v.components[w], I = d.get(k.glyphIndex);\n                if (I.getPath(), I.points) {\n                  var N = void 0;\n                  if (k.matchedPoints === void 0)\n                    N = Er(I.points, k);\n                  else {\n                    if (k.matchedPoints[0] > v.points.length - 1 || k.matchedPoints[1] > I.points.length - 1)\n                      throw Error(\"Matched points out of range in \" + v.name);\n                    var z = v.points[k.matchedPoints[0]], Q = I.points[k.matchedPoints[1]], k = { xScale: k.xScale, scale01: k.scale01, scale10: k.scale10, yScale: k.yScale, dx: 0, dy: 0 }, Q = Er([Q], k)[0];\n                    k.dx = z.x - Q.x, k.dy = z.y - Q.y, N = Er(I.points, k);\n                  }\n                  v.points = v.points.concat(N);\n                }\n              }\n            return Wr(v.points);\n          }\n          (vr.prototype = gr.prototype = { searchTag: Tr, binSearch: Br, getTable: function(d) {\n            var v = this.font.tables[this.tableName];\n            return v = !v && d ? this.font.tables[this.tableName] = this.createDefaultTable() : v;\n          }, getScriptNames: function() {\n            var d = this.getTable();\n            return d ? d.scripts.map(function(v) {\n              return v.tag;\n            }) : [];\n          }, getDefaultScriptName: function() {\n            var d = this.getTable();\n            if (d) {\n              for (var v = !1, w = 0; w < d.scripts.length; w++) {\n                var k = d.scripts[w].tag;\n                if (k === \"DFLT\")\n                  return k;\n                k === \"latn\" && (v = !0);\n              }\n              return v ? \"latn\" : void 0;\n            }\n          }, getScriptTable: function(d, v) {\n            var w, k = this.getTable(v);\n            if (k)\n              return w = k.scripts, 0 <= (k = Tr(k.scripts, d = d || \"DFLT\")) ? w[k].script : v ? (w.splice(-1 - k, 0, v = { tag: d, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }), v.script) : void 0;\n          }, getLangSysTable: function(I, v, w) {\n            var k, I = this.getScriptTable(I, w);\n            if (I)\n              return v && v !== \"dflt\" && v !== \"DFLT\" ? 0 <= (k = Tr(I.langSysRecords, v)) ? I.langSysRecords[k].langSys : w ? (I.langSysRecords.splice(-1 - k, 0, w = { tag: v, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } }), w.langSys) : void 0 : I.defaultLangSys;\n          }, getFeatureTable: function(d, v, w, k) {\n            if (d = this.getLangSysTable(d, v, k), d) {\n              for (var I, N = d.featureIndexes, z = this.font.tables[this.tableName].features, Q = 0; Q < N.length; Q++)\n                if ((I = z[N[Q]]).tag === w)\n                  return I.feature;\n              if (k)\n                return v = z.length, O.assert(v === 0 || w >= z[v - 1].tag, \"Features must be added in alphabetical order.\"), z.push(I = { tag: w, feature: { params: 0, lookupListIndexes: [] } }), N.push(v), I.feature;\n            }\n          }, getLookupTables: function(N, v, w, k, I) {\n            var N = this.getFeatureTable(N, v, w, I), z = [];\n            if (N) {\n              for (var Q, se = N.lookupListIndexes, oe = this.font.tables[this.tableName].lookups, ye = 0; ye < se.length; ye++)\n                (Q = oe[se[ye]]).lookupType === k && z.push(Q);\n              if (z.length === 0 && I)\n                return v = oe.length, oe.push(Q = { lookupType: k, lookupFlag: 0, subtables: [], markFilteringSet: void 0 }), se.push(v), [Q];\n            }\n            return z;\n          }, getGlyphClass: function(d, v) {\n            switch (d.format) {\n              case 1:\n                return d.startGlyph <= v && v < d.startGlyph + d.classes.length ? d.classes[v - d.startGlyph] : 0;\n              case 2:\n                var w = Gr(d.ranges, v);\n                return w ? w.classId : 0;\n            }\n          }, getCoverageIndex: function(d, v) {\n            switch (d.format) {\n              case 1:\n                var w = Br(d.glyphs, v);\n                return 0 <= w ? w : -1;\n              case 2:\n                return w = Gr(d.ranges, v), w ? w.index + v - w.start : -1;\n            }\n          }, expandCoverage: function(d) {\n            if (d.format === 1)\n              return d.glyphs;\n            for (var v = [], w = d.ranges, k = 0; k < w.length; k++)\n              for (var I = w[k], N = I.start, z = I.end, Q = N; Q <= z; Q++)\n                v.push(Q);\n            return v;\n          } }).init = function() {\n            var d = this.getDefaultScriptName();\n            this.defaultKerningTables = this.getKerningTables(d);\n          }, vr.prototype.getKerningValue = function(d, v, w) {\n            for (var k = 0; k < d.length; k++)\n              for (var I = d[k].subtables, N = 0; N < I.length; N++) {\n                var z = I[N], Q = this.getCoverageIndex(z.coverage, v);\n                if (!(Q < 0))\n                  switch (z.posFormat) {\n                    case 1:\n                      for (var se = z.pairSets[Q], oe = 0; oe < se.length; oe++) {\n                        var ye = se[oe];\n                        if (ye.secondGlyph === w)\n                          return ye.value1 && ye.value1.xAdvance || 0;\n                      }\n                      break;\n                    case 2:\n                      var be = this.getGlyphClass(z.classDef1, v), Se = this.getGlyphClass(z.classDef2, w), be = z.classRecords[be][Se];\n                      return be.value1 && be.value1.xAdvance || 0;\n                  }\n              }\n            return 0;\n          }, vr.prototype.getKerningTables = function(d, v) {\n            if (this.font.tables.gpos)\n              return this.getLookupTables(d, v, \"kern\", 2);\n          }, ($t.prototype = gr.prototype).createDefaultTable = function() {\n            return { version: 1, scripts: [{ tag: \"DFLT\", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };\n          }, $t.prototype.getSingle = function(d, v, w) {\n            for (var k = [], I = this.getLookupTables(v, w, d, 1), N = 0; N < I.length; N++)\n              for (var z = I[N].subtables, Q = 0; Q < z.length; Q++) {\n                var se = z[Q], oe = this.expandCoverage(se.coverage), ye = void 0;\n                if (se.substFormat === 1)\n                  for (var Se = se.deltaGlyphId, ye = 0; ye < oe.length; ye++) {\n                    var be = oe[ye];\n                    k.push({ sub: be, by: be + Se });\n                  }\n                else {\n                  var de = se.substitute;\n                  for (ye = 0; ye < oe.length; ye++)\n                    k.push({ sub: oe[ye], by: de[ye] });\n                }\n              }\n            return k;\n          }, $t.prototype.getAlternates = function(d, v, w) {\n            for (var k = [], I = this.getLookupTables(v, w, d, 3), N = 0; N < I.length; N++)\n              for (var z = I[N].subtables, Q = 0; Q < z.length; Q++)\n                for (var se = z[Q], oe = this.expandCoverage(se.coverage), ye = se.alternateSets, Se = 0; Se < oe.length; Se++)\n                  k.push({ sub: oe[Se], by: ye[Se] });\n            return k;\n          }, $t.prototype.getLigatures = function(d, v, w) {\n            for (var k = [], I = this.getLookupTables(v, w, d, 4), N = 0; N < I.length; N++)\n              for (var z = I[N].subtables, Q = 0; Q < z.length; Q++)\n                for (var se = z[Q], oe = this.expandCoverage(se.coverage), ye = se.ligatureSets, Se = 0; Se < oe.length; Se++)\n                  for (var be = oe[Se], de = ye[Se], Ie = 0; Ie < de.length; Ie++) {\n                    var ke = de[Ie];\n                    k.push({ sub: [be].concat(ke.components), by: ke.ligGlyph });\n                  }\n            return k;\n          }, $t.prototype.addSingle = function(d, v, w, k) {\n            w = Vr(this.getLookupTables(w, k, d, 1, !0)[0], 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] }), O.assert(w.coverage.format === 1, \"Ligature: unable to modify coverage table format \" + w.coverage.format), k = v.sub, d = this.binSearch(w.coverage.glyphs, k), d < 0 && (w.coverage.glyphs.splice(d = -1 - d, 0, k), w.substitute.splice(d, 0, 0)), w.substitute[d] = v.by;\n          }, $t.prototype.addAlternate = function(d, v, w, k) {\n            w = Vr(this.getLookupTables(w, k, d, 3, !0)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] }), O.assert(w.coverage.format === 1, \"Ligature: unable to modify coverage table format \" + w.coverage.format), k = v.sub, d = this.binSearch(w.coverage.glyphs, k), d < 0 && (w.coverage.glyphs.splice(d = -1 - d, 0, k), w.alternateSets.splice(d, 0, 0)), w.alternateSets[d] = v.by;\n          }, $t.prototype.addLigature = function(N, se, Q, I) {\n            var Q = this.getLookupTables(Q, I, N, 4, !0)[0], I = Q.subtables[0], N = (I || (Q.subtables[0] = I = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }), O.assert(I.coverage.format === 1, \"Ligature: unable to modify coverage table format \" + I.coverage.format), se.sub[0]), z = se.sub.slice(1), Q = { ligGlyph: se.by, components: z }, se = this.binSearch(I.coverage.glyphs, N);\n            if (0 <= se) {\n              for (var oe = I.ligatureSets[se], ye = 0; ye < oe.length; ye++)\n                if (function(Se, be) {\n                  var de = Se.length;\n                  if (de === be.length) {\n                    for (var Ie = 0; Ie < de; Ie++)\n                      if (Se[Ie] !== be[Ie])\n                        return;\n                    return 1;\n                  }\n                }(oe[ye].components, z))\n                  return;\n              oe.push(Q);\n            } else\n              I.coverage.glyphs.splice(se = -1 - se, 0, N), I.ligatureSets.splice(se, 0, [Q]);\n          }, $t.prototype.getFeature = function(d, v, w) {\n            if (/ss\\d\\d/.test(d))\n              return this.getSingle(d, v, w);\n            switch (d) {\n              case \"aalt\":\n              case \"salt\":\n                return this.getSingle(d, v, w).concat(this.getAlternates(d, v, w));\n              case \"dlig\":\n              case \"liga\":\n              case \"rlig\":\n                return this.getLigatures(d, v, w);\n            }\n          }, $t.prototype.add = function(d, v, w, k) {\n            if (/ss\\d\\d/.test(d))\n              return this.addSingle(d, v, w, k);\n            switch (d) {\n              case \"aalt\":\n              case \"salt\":\n                return typeof v.by == \"number\" ? this.addSingle(d, v, w, k) : this.addAlternate(d, v, w, k);\n              case \"dlig\":\n              case \"liga\":\n              case \"rlig\":\n                return this.addLigature(d, v, w, k);\n            }\n          };\n          var qr = { getPath: Wr, parse: function(d, v, w, k) {\n            for (var I = new Ke.GlyphSet(k), N = 0; N < w.length - 1; N += 1) {\n              var z = w[N];\n              z !== w[N + 1] ? I.push(N, Ke.ttfGlyphLoader(k, N, Tn, d, v + z, En)) : I.push(N, Ke.glyphLoader(k, N));\n            }\n            return I;\n          } };\n          function Xr(d) {\n            this.font = d, this.getCommands = function(v) {\n              return qr.getPath(v).commands;\n            }, this._fpgmState = this._prepState = void 0, this._errorState = 0;\n          }\n          function Mn(d) {\n            return d;\n          }\n          function Yr(d) {\n            return Math.sign(d) * Math.round(Math.abs(d));\n          }\n          function kn(d) {\n            return Math.sign(d) * Math.round(Math.abs(2 * d)) / 2;\n          }\n          function Cn(d) {\n            return Math.sign(d) * (Math.round(Math.abs(d) + 0.5) - 0.5);\n          }\n          function On(d) {\n            return Math.sign(d) * Math.ceil(Math.abs(d));\n          }\n          function An(d) {\n            return Math.sign(d) * Math.floor(Math.abs(d));\n          }\n          function Zr(d) {\n            var v = this.srPeriod, w = this.srPhase, k = 1;\n            return d < 0 && (d = -d, k = -1), d += this.srThreshold - w, d = Math.trunc(d / v) * v, (d += w) < 0 ? w * k : d * k;\n          }\n          var er = { x: 1, y: 0, axis: \"x\", distance: function(d, v, w, k) {\n            return (w ? d.xo : d.x) - (k ? v.xo : v.x);\n          }, interpolate: function(d, v, w, k) {\n            var I, N, z, Q, se, oe, ye;\n            if (!k || k === this)\n              return I = d.xo - v.xo, N = d.xo - w.xo, se = v.x - v.xo, oe = w.x - w.xo, (ye = (z = Math.abs(I)) + (Q = Math.abs(N))) === 0 ? void (d.x = d.xo + (se + oe) / 2) : void (d.x = d.xo + (se * Q + oe * z) / ye);\n            I = k.distance(d, v, !0, !0), N = k.distance(d, w, !0, !0), se = k.distance(v, v, !1, !0), oe = k.distance(w, w, !1, !0), (ye = (z = Math.abs(I)) + (Q = Math.abs(N))) === 0 ? er.setRelative(d, d, (se + oe) / 2, k, !0) : er.setRelative(d, d, (se * Q + oe * z) / ye, k, !0);\n          }, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(d, v, w, k, I) {\n            var N, z;\n            k && k !== this ? (N = I ? v.xo : v.x, z = I ? v.yo : v.y, N += w * k.x, z += w * k.y, d.x = N + (d.y - z) / k.normalSlope) : d.x = (I ? v.xo : v.x) + w;\n          }, slope: 0, touch: function(d) {\n            d.xTouched = !0;\n          }, touched: function(d) {\n            return d.xTouched;\n          }, untouch: function(d) {\n            d.xTouched = !1;\n          } }, tr = { x: 0, y: 1, axis: \"y\", distance: function(d, v, w, k) {\n            return (w ? d.yo : d.y) - (k ? v.yo : v.y);\n          }, interpolate: function(d, v, w, k) {\n            var I, N, z, Q, se, oe, ye;\n            if (!k || k === this)\n              return I = d.yo - v.yo, N = d.yo - w.yo, se = v.y - v.yo, oe = w.y - w.yo, (ye = (z = Math.abs(I)) + (Q = Math.abs(N))) === 0 ? void (d.y = d.yo + (se + oe) / 2) : void (d.y = d.yo + (se * Q + oe * z) / ye);\n            I = k.distance(d, v, !0, !0), N = k.distance(d, w, !0, !0), se = k.distance(v, v, !1, !0), oe = k.distance(w, w, !1, !0), (ye = (z = Math.abs(I)) + (Q = Math.abs(N))) === 0 ? tr.setRelative(d, d, (se + oe) / 2, k, !0) : tr.setRelative(d, d, (se * Q + oe * z) / ye, k, !0);\n          }, normalSlope: 0, setRelative: function(d, v, w, k, I) {\n            var N, z;\n            k && k !== this ? (N = I ? v.xo : v.x, z = I ? v.yo : v.y, N += w * k.x, z += w * k.y, d.y = z + k.normalSlope * (d.x - N)) : d.y = (I ? v.yo : v.y) + w;\n          }, slope: Number.POSITIVE_INFINITY, touch: function(d) {\n            d.yTouched = !0;\n          }, touched: function(d) {\n            return d.yTouched;\n          }, untouch: function(d) {\n            d.yTouched = !1;\n          } };\n          function cr(d, v) {\n            this.x = d, this.y = v, this.axis = void 0, this.slope = v / d, this.normalSlope = -d / v, Object.freeze(this);\n          }\n          function dr(d, v) {\n            var w = Math.sqrt(d * d + v * v);\n            return v /= w, (d /= w) === 1 && v === 0 ? er : d === 0 && v === 1 ? tr : new cr(d, v);\n          }\n          function rr(d, v, w, k) {\n            this.x = this.xo = Math.round(64 * d) / 64, this.y = this.yo = Math.round(64 * v) / 64, this.lastPointOfContour = w, this.onCurve = k, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this);\n          }\n          Object.freeze(er), Object.freeze(tr), cr.prototype.distance = function(d, v, w, k) {\n            return this.x * er.distance(d, v, w, k) + this.y * tr.distance(d, v, w, k);\n          }, cr.prototype.interpolate = function(d, I, N, k) {\n            var z = k.distance(d, I, !0, !0), Q = k.distance(d, N, !0, !0), I = k.distance(I, I, !1, !0), N = k.distance(N, N, !1, !0), z = Math.abs(z), Q = Math.abs(Q), se = z + Q;\n            se === 0 ? this.setRelative(d, d, (I + N) / 2, k, !0) : this.setRelative(d, d, (I * Q + N * z) / se, k, !0);\n          }, cr.prototype.setRelative = function(d, N, se, oe, Q) {\n            var z = Q ? N.xo : N.x, Q = Q ? N.yo : N.y, N = z + se * (oe = oe || this).x, z = Q + se * oe.y, Q = oe.normalSlope, se = this.slope, oe = d.x, ye = d.y;\n            d.x = (se * oe - Q * N + z - ye) / (se - Q), d.y = se * (d.x - oe) + ye;\n          }, cr.prototype.touch = function(d) {\n            d.xTouched = !0, d.yTouched = !0;\n          }, rr.prototype.nextTouched = function(d) {\n            for (var v = this.nextPointOnContour; !d.touched(v) && v !== this; )\n              v = v.nextPointOnContour;\n            return v;\n          }, rr.prototype.prevTouched = function(d) {\n            for (var v = this.prevPointOnContour; !d.touched(v) && v !== this; )\n              v = v.prevPointOnContour;\n            return v;\n          };\n          var hr = Object.freeze(new rr(0, 0)), Pn = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: !0 };\n          function nr(d, v) {\n            switch (this.env = d, this.stack = [], this.prog = v, d) {\n              case \"glyf\":\n                this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;\n              case \"prep\":\n                this.fv = this.pv = this.dpv = er, this.round = Yr;\n            }\n          }\n          function br(d) {\n            for (var v = d.tZone = new Array(d.gZone.length), w = 0; w < v.length; w++)\n              v[w] = new rr(0, 0);\n          }\n          function Qr(d, v) {\n            var w, k = d.prog, I = d.ip, N = 1;\n            do\n              if ((w = k[++I]) === 88)\n                N++;\n              else if (w === 89)\n                N--;\n              else if (w === 64)\n                I += k[I + 1] + 1;\n              else if (w === 65)\n                I += 2 * k[I + 1] + 1;\n              else if (176 <= w && w <= 183)\n                I += w - 176 + 1;\n              else if (184 <= w && w <= 191)\n                I += 2 * (w - 184 + 1);\n              else if (v && N === 1 && w === 27)\n                break;\n            while (0 < N);\n            d.ip = I;\n          }\n          function Kr(d, v) {\n            h.DEBUG && console.log(v.step, \"SVTCA[\" + d.axis + \"]\"), v.fv = v.pv = v.dpv = d;\n          }\n          function Jr(d, v) {\n            h.DEBUG && console.log(v.step, \"SPVTCA[\" + d.axis + \"]\"), v.pv = v.dpv = d;\n          }\n          function $r(d, v) {\n            h.DEBUG && console.log(v.step, \"SFVTCA[\" + d.axis + \"]\"), v.fv = d;\n          }\n          function en(d, v) {\n            var w, I = v.stack, k = I.pop(), I = I.pop(), N = v.z2[k], z = v.z1[I];\n            h.DEBUG && console.log(\"SPVTL[\" + d + \"]\", k, I), k = d ? (w = N.y - z.y, z.x - N.x) : (w = z.x - N.x, z.y - N.y), v.pv = v.dpv = dr(w, k);\n          }\n          function tn(d, v) {\n            var w, I = v.stack, k = I.pop(), I = I.pop(), N = v.z2[k], z = v.z1[I];\n            h.DEBUG && console.log(\"SFVTL[\" + d + \"]\", k, I), k = d ? (w = N.y - z.y, z.x - N.x) : (w = z.x - N.x, z.y - N.y), v.fv = dr(w, k);\n          }\n          function Mr(d) {\n            h.DEBUG && console.log(d.step, \"POP[]\"), d.stack.pop();\n          }\n          function rn(d, v) {\n            var w = v.stack.pop(), k = v.z0[w], I = v.fv, N = v.pv, z = (h.DEBUG && console.log(v.step, \"MDAP[\" + d + \"]\", w), N.distance(k, hr));\n            d && (z = v.round(z)), I.setRelative(k, hr, z, N), I.touch(k), v.rp0 = v.rp1 = w;\n          }\n          function nn(d, v) {\n            var w, k, I, N = v.z2, z = N.length - 2;\n            h.DEBUG && console.log(v.step, \"IUP[\" + d.axis + \"]\");\n            for (var Q = 0; Q < z; Q++)\n              w = N[Q], d.touched(w) || (k = w.prevTouched(d)) !== w && (k === (I = w.nextTouched(d)) && d.setRelative(w, w, d.distance(k, k, !1, !0), d, !0), d.interpolate(w, k, I, d));\n          }\n          function on(d, v) {\n            for (var w = v.stack, k = d ? v.rp1 : v.rp2, I = (d ? v.z0 : v.z1)[k], N = v.fv, z = v.pv, Q = v.loop, se = v.z2; Q--; ) {\n              var oe = w.pop(), ye = se[oe], Se = z.distance(I, I, !1, !0);\n              N.setRelative(ye, ye, Se, z), N.touch(ye), h.DEBUG && console.log(v.step, (1 < v.loop ? \"loop \" + (v.loop - Q) + \": \" : \"\") + \"SHP[\" + (d ? \"rp1\" : \"rp2\") + \"]\", oe);\n            }\n            v.loop = 1;\n          }\n          function sn(d, v) {\n            for (var w = v.stack, z = d ? v.rp1 : v.rp2, k = (d ? v.z0 : v.z1)[z], I = v.fv, N = v.pv, z = w.pop(), Q = v.z2[v.contours[z]], se = Q, oe = (h.DEBUG && console.log(v.step, \"SHC[\" + d + \"]\", z), N.distance(k, k, !1, !0)); se !== k && I.setRelative(se, se, oe, N), (se = se.nextPointOnContour) !== Q; )\n              ;\n          }\n          function an(d, v) {\n            var w, k, Q = v.stack, I = d ? v.rp1 : v.rp2, I = (d ? v.z0 : v.z1)[I], N = v.fv, z = v.pv, Q = Q.pop();\n            switch (h.DEBUG && console.log(v.step, \"SHZ[\" + d + \"]\", Q), Q) {\n              case 0:\n                w = v.tZone;\n                break;\n              case 1:\n                w = v.gZone;\n                break;\n              default:\n                throw new Error(\"Invalid zone\");\n            }\n            for (var se = z.distance(I, I, !1, !0), oe = w.length - 2, ye = 0; ye < oe; ye++)\n              k = w[ye], N.setRelative(k, k, se, z);\n          }\n          function ln(d, v) {\n            var k = v.stack, w = k.pop() / 64, k = k.pop(), I = v.z1[k], N = v.z0[v.rp0], z = v.fv, Q = v.pv;\n            z.setRelative(I, N, w, Q), z.touch(I), h.DEBUG && console.log(v.step, \"MSIRP[\" + d + \"]\", w, k), v.rp1 = v.rp0, v.rp2 = k, d && (v.rp0 = k);\n          }\n          function un(d, v) {\n            var w = v.stack, Q = w.pop(), w = w.pop(), k = v.z0[w], I = v.fv, N = v.pv, z = v.cvt[Q], Q = (h.DEBUG && console.log(v.step, \"MIAP[\" + d + \"]\", Q, \"(\", z, \")\", w), N.distance(k, hr));\n            d && (Math.abs(Q - z) < v.cvCutIn && (Q = z), Q = v.round(Q)), I.setRelative(k, hr, Q, N), v.zp0 === 0 && (k.xo = k.x, k.yo = k.y), I.touch(k), v.rp0 = v.rp1 = w;\n          }\n          function cn(d, v) {\n            var w = v.stack, k = w.pop(), I = v.z2[k];\n            h.DEBUG && console.log(v.step, \"GC[\" + d + \"]\", k), w.push(64 * v.dpv.distance(I, hr, d, !1));\n          }\n          function dn(d, v) {\n            var k = v.stack, w = k.pop(), k = k.pop(), I = v.z1[w], N = v.z0[k], N = v.dpv.distance(N, I, d, d);\n            h.DEBUG && console.log(v.step, \"MD[\" + d + \"]\", w, k, \"->\", N), v.stack.push(Math.round(64 * N));\n          }\n          function kr(d, v) {\n            var w = v.stack, k = w.pop(), I = v.fv, N = v.pv, z = v.ppem, Q = v.deltaBase + 16 * (d - 1), se = v.deltaShift, oe = v.z0;\n            h.DEBUG && console.log(v.step, \"DELTAP[\" + d + \"]\", k, w);\n            for (var ye = 0; ye < k; ye++) {\n              var Se = w.pop(), be = w.pop();\n              Q + ((240 & be) >> 4) === z && (0 <= (be = (15 & be) - 8) && be++, h.DEBUG && console.log(v.step, \"DELTAPFIX\", Se, \"by\", be * se), Se = oe[Se], I.setRelative(Se, Se, be * se, N));\n            }\n          }\n          function jr(d, v) {\n            var w = v.stack, k = w.pop();\n            h.DEBUG && console.log(v.step, \"ROUND[]\"), w.push(64 * v.round(k / 64));\n          }\n          function Cr(d, v) {\n            var w = v.stack, k = w.pop(), I = v.ppem, N = v.deltaBase + 16 * (d - 1), z = v.deltaShift;\n            h.DEBUG && console.log(v.step, \"DELTAC[\" + d + \"]\", k, w);\n            for (var Q = 0; Q < k; Q++) {\n              var se = w.pop(), oe = w.pop();\n              N + ((240 & oe) >> 4) === I && (0 <= (oe = (15 & oe) - 8) && oe++, oe = oe * z, h.DEBUG && console.log(v.step, \"DELTACFIX\", se, \"by\", oe), v.cvt[se] += oe);\n            }\n          }\n          function hn(d, v) {\n            var w, I = v.stack, k = I.pop(), I = I.pop(), N = v.z2[k], z = v.z1[I];\n            h.DEBUG && console.log(v.step, \"SDPVTL[\" + d + \"]\", k, I), k = d ? (w = N.y - z.y, z.x - N.x) : (w = z.x - N.x, z.y - N.y), v.dpv = dr(w, k);\n          }\n          function or(d, v) {\n            var w = v.stack, k = v.prog, I = v.ip;\n            h.DEBUG && console.log(v.step, \"PUSHB[\" + d + \"]\");\n            for (var N = 0; N < d; N++)\n              w.push(k[++I]);\n            v.ip = I;\n          }\n          function sr(d, v) {\n            var w = v.ip, k = v.prog, I = v.stack;\n            h.DEBUG && console.log(v.ip, \"PUSHW[\" + d + \"]\");\n            for (var N = 0; N < d; N++) {\n              var z = k[++w] << 8 | k[++w];\n              32768 & z && (z = -(1 + (65535 ^ z))), I.push(z);\n            }\n            v.ip = w;\n          }\n          function Je(d, v, w, k, I, N) {\n            var z, Q, oe = N.stack, se = d && oe.pop(), oe = oe.pop(), ye = N.rp0, ye = N.z0[ye], Se = N.z1[oe], be = N.minDis, de = N.fv, Ie = N.dpv, ke = z = Ie.distance(Se, ye, !0, !0), Ae = 0 <= ke ? 1 : -1;\n            ke = Math.abs(ke), d && (Q = N.cvt[se], k && Math.abs(ke - Q) < N.cvCutIn && (ke = Q)), w && ke < be && (ke = be), k && (ke = N.round(ke)), de.setRelative(Se, ye, Ae * ke, Ie), de.touch(Se), h.DEBUG && console.log(N.step, (d ? \"MIRP[\" : \"MDRP[\") + (v ? \"M\" : \"m\") + (w ? \">\" : \"_\") + (k ? \"R\" : \"_\") + (I === 0 ? \"Gr\" : I === 1 ? \"Bl\" : I === 2 ? \"Wh\" : \"\") + \"]\", d ? se + \"(\" + N.cvt[se] + \",\" + Q + \")\" : \"\", oe, \"(d =\", z, \"->\", Ae * ke, \")\"), N.rp1 = N.rp0, N.rp2 = oe, v && (N.rp0 = oe);\n          }\n          Xr.prototype.exec = function(d, v) {\n            if (typeof v != \"number\")\n              throw new Error(\"Point size is not a number!\");\n            if (!(2 < this._errorState)) {\n              var w = this.font, k = this._prepState;\n              if (!k || k.ppem !== v) {\n                var I = this._fpgmState;\n                if (!I) {\n                  nr.prototype = Pn, (I = this._fpgmState = new nr(\"fpgm\", w.tables.fpgm)).funcs = [], I.font = w, h.DEBUG && (console.log(\"---EXEC FPGM---\"), I.step = -1);\n                  try {\n                    lr(I);\n                  } catch (oe) {\n                    return console.log(\"Hinting error in FPGM:\" + oe), void (this._errorState = 3);\n                  }\n                }\n                nr.prototype = I, (k = this._prepState = new nr(\"prep\", w.tables.prep)).ppem = v;\n                var N = w.tables.cvt;\n                if (N)\n                  for (var z = k.cvt = new Array(N.length), Q = v / w.unitsPerEm, se = 0; se < N.length; se++)\n                    z[se] = N[se] * Q;\n                else\n                  k.cvt = [];\n                h.DEBUG && (console.log(\"---EXEC PREP---\"), k.step = -1);\n                try {\n                  lr(k);\n                } catch (oe) {\n                  this._errorState < 2 && console.log(\"Hinting error in PREP:\" + oe), this._errorState = 2;\n                }\n              }\n              if (!(1 < this._errorState))\n                try {\n                  return Ln(d, k);\n                } catch (oe) {\n                  this._errorState < 1 && (console.log(\"Hinting error:\" + oe), console.log(\"Note: further hinting errors are silenced\")), this._errorState = 1;\n                }\n            }\n          };\n          var Ln = function(d, v) {\n            var w = v.ppem / v.font.unitsPerEm, k = w, I = d.components;\n            if (nr.prototype = v, I) {\n              for (var N = v.font, z = [], Q = [], se = 0; se < I.length; se++) {\n                var oe = I[se], ye = N.glyphs.get(oe.glyphIndex), Se = new nr(\"glyf\", ye.instructions);\n                h.DEBUG && (console.log(\"---EXEC COMP \" + se + \"---\"), Se.step = -1), fn(ye, Se, w, k);\n                for (var be = Math.round(oe.dx * w), de = Math.round(oe.dy * k), Ie = Se.gZone, ke = Se.contours, Ae = 0; Ae < Ie.length; Ae++) {\n                  var Te = Ie[Ae];\n                  Te.xTouched = Te.yTouched = !1, Te.xo = Te.x = Te.x + be, Te.yo = Te.y = Te.y + de;\n                }\n                var Ee = z.length;\n                z.push.apply(z, Ie);\n                for (var $e = 0; $e < ke.length; $e++)\n                  Q.push(ke[$e] + Ee);\n              }\n              d.instructions && !Se.inhibitGridFit && ((Se = new nr(\"glyf\", d.instructions)).gZone = Se.z0 = Se.z1 = Se.z2 = z, Se.contours = Q, z.push(new rr(0, 0), new rr(Math.round(d.advanceWidth * w), 0)), h.DEBUG && (console.log(\"---EXEC COMPOSITE---\"), Se.step = -1), lr(Se), z.length -= 2);\n            } else\n              Se = new nr(\"glyf\", d.instructions), h.DEBUG && (console.log(\"---EXEC GLYPH---\"), Se.step = -1), fn(d, Se, w, k), z = Se.gZone;\n            return z;\n          }, fn = function(d, v, w, k) {\n            for (var I, N, z, Q = d.points || [], se = Q.length, oe = v.gZone = v.z0 = v.z1 = v.z2 = [], ye = v.contours = [], Se = 0; Se < se; Se++)\n              I = Q[Se], oe[Se] = new rr(I.x * w, I.y * k, I.lastPointOfContour, I.onCurve);\n            for (var be = 0; be < se; be++)\n              I = oe[be], N || (N = I, ye.push(be)), I.lastPointOfContour ? ((I.nextPointOnContour = N).prevPointOnContour = I, N = void 0) : (z = oe[be + 1], (I.nextPointOnContour = z).prevPointOnContour = I);\n            if (!v.inhibitGridFit) {\n              if (h.DEBUG) {\n                console.log(\"PROCESSING GLYPH\", v.stack);\n                for (var de = 0; de < se; de++)\n                  console.log(de, oe[de].x, oe[de].y);\n              }\n              if (oe.push(new rr(0, 0), new rr(Math.round(d.advanceWidth * w), 0)), lr(v), oe.length -= 2, h.DEBUG) {\n                console.log(\"FINISHED GLYPH\", v.stack);\n                for (var Ie = 0; Ie < se; Ie++)\n                  console.log(Ie, oe[Ie].x, oe[Ie].y);\n              }\n            }\n          }, lr = function(d) {\n            var v = d.prog;\n            if (v) {\n              var w, k = v.length;\n              for (d.ip = 0; d.ip < k; d.ip++) {\n                if (h.DEBUG && d.step++, !(w = Rn[v[d.ip]]))\n                  throw new Error(\"unknown instruction: 0x\" + Number(v[d.ip]).toString(16));\n                w(d);\n              }\n            }\n          }, Rn = [Kr.bind(void 0, tr), Kr.bind(void 0, er), Jr.bind(void 0, tr), Jr.bind(void 0, er), $r.bind(void 0, tr), $r.bind(void 0, er), en.bind(void 0, 0), en.bind(void 0, 1), tn.bind(void 0, 0), tn.bind(void 0, 1), function(d) {\n            var v = (w = d.stack).pop(), w = w.pop();\n            h.DEBUG && console.log(d.step, \"SPVFS[]\", v, w), d.pv = d.dpv = dr(w, v);\n          }, function(d) {\n            var v = (w = d.stack).pop(), w = w.pop();\n            h.DEBUG && console.log(d.step, \"SPVFS[]\", v, w), d.fv = dr(w, v);\n          }, function(d) {\n            var v = d.stack, w = d.pv;\n            h.DEBUG && console.log(d.step, \"GPV[]\"), v.push(16384 * w.x), v.push(16384 * w.y);\n          }, function(d) {\n            var v = d.stack, w = d.fv;\n            h.DEBUG && console.log(d.step, \"GFV[]\"), v.push(16384 * w.x), v.push(16384 * w.y);\n          }, function(d) {\n            d.fv = d.pv, h.DEBUG && console.log(d.step, \"SFVTPV[]\");\n          }, function(v) {\n            var w = (z = v.stack).pop(), k = z.pop(), I = z.pop(), N = z.pop(), z = z.pop(), se = v.z0, ye = v.z1, Q = se[w], se = se[k], oe = ye[I], ye = ye[N], v = v.z2[z], w = (h.DEBUG && console.log(\"ISECT[], \", w, k, I, N, z), Q.x), k = Q.y, I = se.x, N = se.y, z = oe.x, Q = oe.y, se = ye.x, oe = ye.y, ye = (w - I) * (Q - oe) - (k - N) * (z - se), Se = w * N - k * I, be = z * oe - Q * se;\n            v.x = (Se * (z - se) - be * (w - I)) / ye, v.y = (Se * (Q - oe) - be * (k - N)) / ye;\n          }, function(d) {\n            d.rp0 = d.stack.pop(), h.DEBUG && console.log(d.step, \"SRP0[]\", d.rp0);\n          }, function(d) {\n            d.rp1 = d.stack.pop(), h.DEBUG && console.log(d.step, \"SRP1[]\", d.rp1);\n          }, function(d) {\n            d.rp2 = d.stack.pop(), h.DEBUG && console.log(d.step, \"SRP2[]\", d.rp2);\n          }, function(d) {\n            var v = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"SZP0[]\", v), d.zp0 = v) {\n              case 0:\n                d.tZone || br(d), d.z0 = d.tZone;\n                break;\n              case 1:\n                d.z0 = d.gZone;\n                break;\n              default:\n                throw new Error(\"Invalid zone pointer\");\n            }\n          }, function(d) {\n            var v = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"SZP1[]\", v), d.zp1 = v) {\n              case 0:\n                d.tZone || br(d), d.z1 = d.tZone;\n                break;\n              case 1:\n                d.z1 = d.gZone;\n                break;\n              default:\n                throw new Error(\"Invalid zone pointer\");\n            }\n          }, function(d) {\n            var v = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"SZP2[]\", v), d.zp2 = v) {\n              case 0:\n                d.tZone || br(d), d.z2 = d.tZone;\n                break;\n              case 1:\n                d.z2 = d.gZone;\n                break;\n              default:\n                throw new Error(\"Invalid zone pointer\");\n            }\n          }, function(d) {\n            var v = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"SZPS[]\", v), d.zp0 = d.zp1 = d.zp2 = v) {\n              case 0:\n                d.tZone || br(d), d.z0 = d.z1 = d.z2 = d.tZone;\n                break;\n              case 1:\n                d.z0 = d.z1 = d.z2 = d.gZone;\n                break;\n              default:\n                throw new Error(\"Invalid zone pointer\");\n            }\n          }, function(d) {\n            d.loop = d.stack.pop(), h.DEBUG && console.log(d.step, \"SLOOP[]\", d.loop);\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"RTG[]\"), d.round = Yr;\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"RTHG[]\"), d.round = Cn;\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SMD[]\", v), d.minDis = v / 64;\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"ELSE[]\"), Qr(d, !1);\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"JMPR[]\", v), d.ip += v - 1;\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SCVTCI[]\", v), d.cvCutIn = v / 64;\n          }, void 0, void 0, function(d) {\n            var v = d.stack;\n            h.DEBUG && console.log(d.step, \"DUP[]\"), v.push(v[v.length - 1]);\n          }, Mr, function(d) {\n            h.DEBUG && console.log(d.step, \"CLEAR[]\"), d.stack.length = 0;\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"SWAP[]\"), v.push(w), v.push(k);\n          }, function(d) {\n            var v = d.stack;\n            h.DEBUG && console.log(d.step, \"DEPTH[]\"), v.push(v.length);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"CINDEX[]\", w), v.push(v[v.length - w]);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"MINDEX[]\", w), v.push(v.splice(v.length - w, 1)[0]);\n          }, void 0, void 0, void 0, function(d) {\n            var v = (k = d.stack).pop(), w = k.pop(), k = (h.DEBUG && console.log(d.step, \"LOOPCALL[]\", v, w), d.ip), I = d.prog;\n            d.prog = d.funcs[v];\n            for (var N = 0; N < w; N++)\n              lr(d), h.DEBUG && console.log(++d.step, N + 1 < w ? \"next loopcall\" : \"done loopcall\", N);\n            d.ip = k, d.prog = I;\n          }, function(d) {\n            var v = d.stack.pop(), w = (h.DEBUG && console.log(d.step, \"CALL[]\", v), d.ip), k = d.prog;\n            d.prog = d.funcs[v], lr(d), d.ip = w, d.prog = k, h.DEBUG && console.log(++d.step, \"returning from\", v);\n          }, function(d) {\n            if (d.env !== \"fpgm\")\n              throw new Error(\"FDEF not allowed here\");\n            var k = d.stack, v = d.prog, w = d.ip, k = k.pop(), I = w;\n            for (h.DEBUG && console.log(d.step, \"FDEF[]\", k); v[++w] !== 45; )\n              ;\n            d.ip = w, d.funcs[k] = v.slice(I + 1, w);\n          }, void 0, rn.bind(void 0, 0), rn.bind(void 0, 1), nn.bind(void 0, tr), nn.bind(void 0, er), on.bind(void 0, 0), on.bind(void 0, 1), sn.bind(void 0, 0), sn.bind(void 0, 1), an.bind(void 0, 0), an.bind(void 0, 1), function(d) {\n            for (var v = d.stack, w = d.loop, k = d.fv, I = v.pop() / 64, N = d.z2; w--; ) {\n              var z = v.pop(), Q = N[z];\n              h.DEBUG && console.log(d.step, (1 < d.loop ? \"loop \" + (d.loop - w) + \": \" : \"\") + \"SHPIX[]\", z, I), k.setRelative(Q, Q, I), k.touch(Q);\n            }\n            d.loop = 1;\n          }, function(d) {\n            for (var v = d.stack, w = d.rp1, k = d.rp2, I = d.loop, N = d.z0[w], z = d.z1[k], Q = d.fv, se = d.dpv, oe = d.z2; I--; ) {\n              var ye = v.pop(), Se = oe[ye];\n              h.DEBUG && console.log(d.step, (1 < d.loop ? \"loop \" + (d.loop - I) + \": \" : \"\") + \"IP[]\", ye, w, \"<->\", k), Q.interpolate(Se, N, z, se), Q.touch(Se);\n            }\n            d.loop = 1;\n          }, ln.bind(void 0, 0), ln.bind(void 0, 1), function(d) {\n            for (var v = d.stack, w = d.rp0, k = d.z0[w], I = d.loop, N = d.fv, z = d.pv, Q = d.z1; I--; ) {\n              var se = v.pop(), oe = Q[se];\n              h.DEBUG && console.log(d.step, (1 < d.loop ? \"loop \" + (d.loop - I) + \": \" : \"\") + \"ALIGNRP[]\", se), N.setRelative(oe, k, 0, z), N.touch(oe);\n            }\n            d.loop = 1;\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"RTDG[]\"), d.round = kn;\n          }, un.bind(void 0, 0), un.bind(void 0, 1), function(d) {\n            var v = d.prog, w = d.ip, k = d.stack, I = v[++w];\n            h.DEBUG && console.log(d.step, \"NPUSHB[]\", I);\n            for (var N = 0; N < I; N++)\n              k.push(v[++w]);\n            d.ip = w;\n          }, function(d) {\n            var v = d.ip, w = d.prog, k = d.stack, I = w[++v];\n            h.DEBUG && console.log(d.step, \"NPUSHW[]\", I);\n            for (var N = 0; N < I; N++) {\n              var z = w[++v] << 8 | w[++v];\n              32768 & z && (z = -(1 + (65535 ^ z))), k.push(z);\n            }\n            d.ip = v;\n          }, function(d) {\n            var k = d.stack, v = (v = d.store) || (d.store = []), w = k.pop(), k = k.pop();\n            h.DEBUG && console.log(d.step, \"WS\", w, k), v[k] = w;\n          }, function(I) {\n            var v = I.stack, w = I.store, k = v.pop(), I = (h.DEBUG && console.log(I.step, \"RS\", k), w && w[k] || 0);\n            v.push(I);\n          }, function(d) {\n            var v = (w = d.stack).pop(), w = w.pop();\n            h.DEBUG && console.log(d.step, \"WCVTP\", v, w), d.cvt[w] = v / 64;\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"RCVT\", w), v.push(64 * d.cvt[w]);\n          }, cn.bind(void 0, 0), cn.bind(void 0, 1), void 0, dn.bind(void 0, 0), dn.bind(void 0, 1), function(d) {\n            h.DEBUG && console.log(d.step, \"MPPEM[]\"), d.stack.push(d.ppem);\n          }, void 0, function(d) {\n            h.DEBUG && console.log(d.step, \"FLIPON[]\"), d.autoFlip = !0;\n          }, void 0, void 0, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"LT[]\", w, k), v.push(k < w ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"LTEQ[]\", w, k), v.push(k <= w ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"GT[]\", w, k), v.push(w < k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"GTEQ[]\", w, k), v.push(w <= k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"EQ[]\", w, k), v.push(w === k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"NEQ[]\", w, k), v.push(w !== k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"ODD[]\", w), v.push(Math.trunc(w) % 2 ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"EVEN[]\", w), v.push(Math.trunc(w) % 2 ? 0 : 1);\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"IF[]\", v), v || (Qr(d, !0), h.DEBUG && console.log(d.step, \"EIF[]\"));\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"EIF[]\");\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"AND[]\", w, k), v.push(w && k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"OR[]\", w, k), v.push(w || k ? 1 : 0);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"NOT[]\", w), v.push(w ? 0 : 1);\n          }, kr.bind(void 0, 1), function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SDB[]\", v), d.deltaBase = v;\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SDS[]\", v), d.deltaShift = Math.pow(0.5, v);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"ADD[]\", w, k), v.push(k + w);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"SUB[]\", w, k), v.push(k - w);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"DIV[]\", w, k), v.push(64 * k / w);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"MUL[]\", w, k), v.push(k * w / 64);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"ABS[]\", w), v.push(Math.abs(w));\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"NEG[]\", w), v.push(-w);\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"FLOOR[]\", w), v.push(64 * Math.floor(w / 64));\n          }, function(d) {\n            var v = d.stack, w = v.pop();\n            h.DEBUG && console.log(d.step, \"CEILING[]\", w), v.push(64 * Math.ceil(w / 64));\n          }, jr.bind(void 0, 0), jr.bind(void 0, 1), jr.bind(void 0, 2), jr.bind(void 0, 3), void 0, void 0, void 0, void 0, function(d) {\n            var v = (w = d.stack).pop(), w = w.pop();\n            h.DEBUG && console.log(d.step, \"WCVTF[]\", v, w), d.cvt[w] = v * d.ppem / d.font.unitsPerEm;\n          }, kr.bind(void 0, 2), kr.bind(void 0, 3), Cr.bind(void 0, 1), Cr.bind(void 0, 2), Cr.bind(void 0, 3), function(d) {\n            var v, w = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"SROUND[]\", w), d.round = Zr, 192 & w) {\n              case 0:\n                v = 0.5;\n                break;\n              case 64:\n                v = 1;\n                break;\n              case 128:\n                v = 2;\n                break;\n              default:\n                throw new Error(\"invalid SROUND value\");\n            }\n            switch (d.srPeriod = v, 48 & w) {\n              case 0:\n                d.srPhase = 0;\n                break;\n              case 16:\n                d.srPhase = 0.25 * v;\n                break;\n              case 32:\n                d.srPhase = 0.5 * v;\n                break;\n              case 48:\n                d.srPhase = 0.75 * v;\n                break;\n              default:\n                throw new Error(\"invalid SROUND value\");\n            }\n            d.srThreshold = (w &= 15) === 0 ? 0 : (w / 8 - 0.5) * v;\n          }, function(d) {\n            var v, w = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"S45ROUND[]\", w), d.round = Zr, 192 & w) {\n              case 0:\n                v = Math.sqrt(2) / 2;\n                break;\n              case 64:\n                v = Math.sqrt(2);\n                break;\n              case 128:\n                v = 2 * Math.sqrt(2);\n                break;\n              default:\n                throw new Error(\"invalid S45ROUND value\");\n            }\n            switch (d.srPeriod = v, 48 & w) {\n              case 0:\n                d.srPhase = 0;\n                break;\n              case 16:\n                d.srPhase = 0.25 * v;\n                break;\n              case 32:\n                d.srPhase = 0.5 * v;\n                break;\n              case 48:\n                d.srPhase = 0.75 * v;\n                break;\n              default:\n                throw new Error(\"invalid S45ROUND value\");\n            }\n            d.srThreshold = (w &= 15) === 0 ? 0 : (w / 8 - 0.5) * v;\n          }, void 0, void 0, function(d) {\n            h.DEBUG && console.log(d.step, \"ROFF[]\"), d.round = Mn;\n          }, void 0, function(d) {\n            h.DEBUG && console.log(d.step, \"RUTG[]\"), d.round = On;\n          }, function(d) {\n            h.DEBUG && console.log(d.step, \"RDTG[]\"), d.round = An;\n          }, Mr, Mr, void 0, void 0, void 0, void 0, void 0, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SCANCTRL[]\", v);\n          }, hn.bind(void 0, 0), hn.bind(void 0, 1), function(d) {\n            var v = d.stack, w = v.pop(), k = 0;\n            h.DEBUG && console.log(d.step, \"GETINFO[]\", w), 1 & w && (k = 35), 32 & w && (k |= 4096), v.push(k);\n          }, void 0, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop(), I = v.pop();\n            h.DEBUG && console.log(d.step, \"ROLL[]\"), v.push(k), v.push(w), v.push(I);\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"MAX[]\", w, k), v.push(Math.max(k, w));\n          }, function(d) {\n            var v = d.stack, w = v.pop(), k = v.pop();\n            h.DEBUG && console.log(d.step, \"MIN[]\", w, k), v.push(Math.min(k, w));\n          }, function(d) {\n            var v = d.stack.pop();\n            h.DEBUG && console.log(d.step, \"SCANTYPE[]\", v);\n          }, function(d) {\n            var v = d.stack.pop(), w = d.stack.pop();\n            switch (h.DEBUG && console.log(d.step, \"INSTCTRL[]\", v, w), v) {\n              case 1:\n                return void (d.inhibitGridFit = !!w);\n              case 2:\n                return void (d.ignoreCvt = !!w);\n              default:\n                throw new Error(\"invalid INSTCTRL[] selector\");\n            }\n          }, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, or.bind(void 0, 1), or.bind(void 0, 2), or.bind(void 0, 3), or.bind(void 0, 4), or.bind(void 0, 5), or.bind(void 0, 6), or.bind(void 0, 7), or.bind(void 0, 8), sr.bind(void 0, 1), sr.bind(void 0, 2), sr.bind(void 0, 3), sr.bind(void 0, 4), sr.bind(void 0, 5), sr.bind(void 0, 6), sr.bind(void 0, 7), sr.bind(void 0, 8), Je.bind(void 0, 0, 0, 0, 0, 0), Je.bind(void 0, 0, 0, 0, 0, 1), Je.bind(void 0, 0, 0, 0, 0, 2), Je.bind(void 0, 0, 0, 0, 0, 3), Je.bind(void 0, 0, 0, 0, 1, 0), Je.bind(void 0, 0, 0, 0, 1, 1), Je.bind(void 0, 0, 0, 0, 1, 2), Je.bind(void 0, 0, 0, 0, 1, 3), Je.bind(void 0, 0, 0, 1, 0, 0), Je.bind(void 0, 0, 0, 1, 0, 1), Je.bind(void 0, 0, 0, 1, 0, 2), Je.bind(void 0, 0, 0, 1, 0, 3), Je.bind(void 0, 0, 0, 1, 1, 0), Je.bind(void 0, 0, 0, 1, 1, 1), Je.bind(void 0, 0, 0, 1, 1, 2), Je.bind(void 0, 0, 0, 1, 1, 3), Je.bind(void 0, 0, 1, 0, 0, 0), Je.bind(void 0, 0, 1, 0, 0, 1), Je.bind(void 0, 0, 1, 0, 0, 2), Je.bind(void 0, 0, 1, 0, 0, 3), Je.bind(void 0, 0, 1, 0, 1, 0), Je.bind(void 0, 0, 1, 0, 1, 1), Je.bind(void 0, 0, 1, 0, 1, 2), Je.bind(void 0, 0, 1, 0, 1, 3), Je.bind(void 0, 0, 1, 1, 0, 0), Je.bind(void 0, 0, 1, 1, 0, 1), Je.bind(void 0, 0, 1, 1, 0, 2), Je.bind(void 0, 0, 1, 1, 0, 3), Je.bind(void 0, 0, 1, 1, 1, 0), Je.bind(void 0, 0, 1, 1, 1, 1), Je.bind(void 0, 0, 1, 1, 1, 2), Je.bind(void 0, 0, 1, 1, 1, 3), Je.bind(void 0, 1, 0, 0, 0, 0), Je.bind(void 0, 1, 0, 0, 0, 1), Je.bind(void 0, 1, 0, 0, 0, 2), Je.bind(void 0, 1, 0, 0, 0, 3), Je.bind(void 0, 1, 0, 0, 1, 0), Je.bind(void 0, 1, 0, 0, 1, 1), Je.bind(void 0, 1, 0, 0, 1, 2), Je.bind(void 0, 1, 0, 0, 1, 3), Je.bind(void 0, 1, 0, 1, 0, 0), Je.bind(void 0, 1, 0, 1, 0, 1), Je.bind(void 0, 1, 0, 1, 0, 2), Je.bind(void 0, 1, 0, 1, 0, 3), Je.bind(void 0, 1, 0, 1, 1, 0), Je.bind(void 0, 1, 0, 1, 1, 1), Je.bind(void 0, 1, 0, 1, 1, 2), Je.bind(void 0, 1, 0, 1, 1, 3), Je.bind(void 0, 1, 1, 0, 0, 0), Je.bind(void 0, 1, 1, 0, 0, 1), Je.bind(void 0, 1, 1, 0, 0, 2), Je.bind(void 0, 1, 1, 0, 0, 3), Je.bind(void 0, 1, 1, 0, 1, 0), Je.bind(void 0, 1, 1, 0, 1, 1), Je.bind(void 0, 1, 1, 0, 1, 2), Je.bind(void 0, 1, 1, 0, 1, 3), Je.bind(void 0, 1, 1, 1, 0, 0), Je.bind(void 0, 1, 1, 1, 0, 1), Je.bind(void 0, 1, 1, 1, 0, 2), Je.bind(void 0, 1, 1, 1, 0, 3), Je.bind(void 0, 1, 1, 1, 1, 0), Je.bind(void 0, 1, 1, 1, 1, 1), Je.bind(void 0, 1, 1, 1, 1, 2), Je.bind(void 0, 1, 1, 1, 1, 3)], In = Array.from || function(d) {\n            return d.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?|[^\\uD800-\\uDFFF]|./g) || [];\n          };\n          function _t(d) {\n            (d = d || {}).empty || (ir(d.familyName, \"When creating a new Font object, familyName is required.\"), ir(d.styleName, \"When creating a new Font object, styleName is required.\"), ir(d.unitsPerEm, \"When creating a new Font object, unitsPerEm is required.\"), ir(d.ascender, \"When creating a new Font object, ascender is required.\"), ir(d.descender, \"When creating a new Font object, descender is required.\"), ir(d.descender < 0, \"Descender should be negative (e.g. -512).\"), this.names = { fontFamily: { en: d.familyName || \" \" }, fontSubfamily: { en: d.styleName || \" \" }, fullName: { en: d.fullName || d.familyName + \" \" + d.styleName }, postScriptName: { en: d.postScriptName || (d.familyName + d.styleName).replace(/\\s/g, \"\") }, designer: { en: d.designer || \" \" }, designerURL: { en: d.designerURL || \" \" }, manufacturer: { en: d.manufacturer || \" \" }, manufacturerURL: { en: d.manufacturerURL || \" \" }, license: { en: d.license || \" \" }, licenseURL: { en: d.licenseURL || \" \" }, version: { en: d.version || \"Version 0.1\" }, description: { en: d.description || \" \" }, copyright: { en: d.copyright || \" \" }, trademark: { en: d.trademark || \" \" } }, this.unitsPerEm = d.unitsPerEm || 1e3, this.ascender = d.ascender, this.descender = d.descender, this.createdTimestamp = d.createdTimestamp, this.tables = { os2: { usWeightClass: d.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: d.widthClass || this.usWidthClasses.MEDIUM, fsSelection: d.fsSelection || this.fsSelectionValues.REGULAR } }), this.supported = !0, this.glyphs = new Ke.GlyphSet(this, d.glyphs || []), this.encoding = new je(this), this.position = new vr(this), this.substitution = new $t(this), this.tables = this.tables || {}, Object.defineProperty(this, \"hinting\", { get: function() {\n              return this._hinting || (this.outlinesFormat === \"truetype\" ? this._hinting = new Xr(this) : void 0);\n            } });\n          }\n          function pn(d, v) {\n            var w, k = JSON.stringify(d), I = 256;\n            for (w in v) {\n              var N = parseInt(w);\n              if (N && !(N < 256)) {\n                if (JSON.stringify(v[w]) === k)\n                  return N;\n                I <= N && (I = N + 1);\n              }\n            }\n            return v[I] = d, I;\n          }\n          _t.prototype.hasChar = function(d) {\n            return this.encoding.charToGlyphIndex(d) !== null;\n          }, _t.prototype.charToGlyphIndex = function(d) {\n            return this.encoding.charToGlyphIndex(d);\n          }, _t.prototype.charToGlyph = function(d) {\n            return d = this.charToGlyphIndex(d), this.glyphs.get(d) || this.glyphs.get(0);\n          }, _t.prototype.stringToGlyphs = function(d, v) {\n            v = v || this.defaultRenderOptions;\n            for (var w = In(d), k = [], I = 0; I < w.length; I += 1) {\n              var N = w[I];\n              k.push(this.charToGlyphIndex(N));\n            }\n            var z = k.length;\n            if (v.features) {\n              var d = v.script || this.substitution.getDefaultScriptName(), Q = [];\n              v.features.liga && (Q = Q.concat(this.substitution.getFeature(\"liga\", d, v.language))), v.features.rlig && (Q = Q.concat(this.substitution.getFeature(\"rlig\", d, v.language)));\n              for (var se = 0; se < z; se += 1)\n                for (var oe = 0; oe < Q.length; oe++) {\n                  for (var ye = Q[oe], Se = ye.sub, be = Se.length, de = 0; de < be && Se[de] === k[se + de]; )\n                    de++;\n                  de === be && (k.splice(se, be, ye.by), z = z - be + 1);\n                }\n            }\n            for (var Ie = new Array(z), ke = this.glyphs.get(0), Ae = 0; Ae < z; Ae += 1)\n              Ie[Ae] = this.glyphs.get(k[Ae]) || ke;\n            return Ie;\n          }, _t.prototype.nameToGlyphIndex = function(d) {\n            return this.glyphNames.nameToGlyphIndex(d);\n          }, _t.prototype.nameToGlyph = function(d) {\n            return d = this.nameToGlyphIndex(d), this.glyphs.get(d) || this.glyphs.get(0);\n          }, _t.prototype.glyphIndexToName = function(d) {\n            return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(d) : \"\";\n          }, _t.prototype.getKerningValue = function(d, v) {\n            d = d.index || d, v = v.index || v;\n            var w = this.position.defaultKerningTables;\n            return w ? this.position.getKerningValue(w, d, v) : this.kerningPairs[d + \",\" + v] || 0;\n          }, _t.prototype.defaultRenderOptions = { kerning: !0, features: { liga: !0, rlig: !0 } }, _t.prototype.forEachGlyph = function(d, v, w, k, I, N) {\n            v = v !== void 0 ? v : 0, w = w !== void 0 ? w : 0, I = I || this.defaultRenderOptions;\n            var z, Q = 1 / this.unitsPerEm * (k = k !== void 0 ? k : 72), se = this.stringToGlyphs(d, I);\n            I.kerning && (d = I.script || this.position.getDefaultScriptName(), z = this.position.getKerningTables(d, I.language));\n            for (var oe = 0; oe < se.length; oe += 1) {\n              var ye = se[oe];\n              N.call(this, ye, v, w, k, I), ye.advanceWidth && (v += ye.advanceWidth * Q), I.kerning && oe < se.length - 1 && (v += (z ? this.position.getKerningValue(z, ye.index, se[oe + 1].index) : this.getKerningValue(ye, se[oe + 1])) * Q), I.letterSpacing ? v += I.letterSpacing * k : I.tracking && (v += I.tracking / 1e3 * k);\n            }\n            return v;\n          }, _t.prototype.getPath = function(d, v, w, k, I) {\n            var N = new X();\n            return this.forEachGlyph(d, v, w, k, I, function(z, Q, se, oe) {\n              z = z.getPath(Q, se, oe, I, this), N.extend(z);\n            }), N;\n          }, _t.prototype.getPaths = function(d, v, w, k, I) {\n            var N = [];\n            return this.forEachGlyph(d, v, w, k, I, function(z, Q, se, oe) {\n              z = z.getPath(Q, se, oe, I, this), N.push(z);\n            }), N;\n          }, _t.prototype.getAdvanceWidth = function(d, v, w) {\n            return this.forEachGlyph(d, 0, 0, v, w, function() {\n            });\n          }, _t.prototype.draw = function(d, v, w, k, I, N) {\n            this.getPath(v, w, k, I, N).draw(d);\n          }, _t.prototype.drawPoints = function(d, v, w, k, I, N) {\n            this.forEachGlyph(v, w, k, I, N, function(z, Q, se, oe) {\n              z.drawPoints(d, Q, se, oe);\n            });\n          }, _t.prototype.drawMetrics = function(d, v, w, k, I, N) {\n            this.forEachGlyph(v, w, k, I, N, function(z, Q, se, oe) {\n              z.drawMetrics(d, Q, se, oe);\n            });\n          }, _t.prototype.getEnglishName = function(d) {\n            if (d = this.names[d], d)\n              return d.en;\n          }, _t.prototype.validate = function() {\n            var d = this;\n            function v(w) {\n              w = d.getEnglishName(w), w && w.trim().length;\n            }\n            v(\"fontFamily\"), v(\"weightName\"), v(\"manufacturer\"), v(\"copyright\"), v(\"version\"), this.unitsPerEm;\n          }, _t.prototype.toTables = function() {\n            return Sn.fontToTable(this);\n          }, _t.prototype.toBuffer = function() {\n            return console.warn(\"Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\"), this.toArrayBuffer();\n          }, _t.prototype.toArrayBuffer = function() {\n            for (var d = this.toTables().encode(), v = new ArrayBuffer(d.length), w = new Uint8Array(v), k = 0; k < d.length; k++)\n              w[k] = d[k];\n            return v;\n          }, _t.prototype.download = function(d) {\n            var v = this.getEnglishName(\"fontFamily\"), w = this.getEnglishName(\"fontSubfamily\"), k = (d = d || v.replace(/\\s/g, \"\") + \"-\" + w + \".otf\", this.toArrayBuffer());\n            typeof window < \"u\" ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, k.byteLength, function(I) {\n              I.root.getFile(d, { create: !0 }, function(N) {\n                N.createWriter(function(z) {\n                  var Q = new DataView(k), Q = new Blob([Q], { type: \"font/opentype\" });\n                  z.write(Q), z.addEventListener(\"writeend\", function() {\n                    location.href = N.toURL();\n                  }, !1);\n                });\n              });\n            }, function(I) {\n              throw new Error(I.name + \": \" + I.message);\n            })) : (v = t(\"fs\"), w = function(I) {\n              for (var N = new m(I.byteLength), z = new Uint8Array(I), Q = 0; Q < N.length; ++Q)\n                N[Q] = z[Q];\n              return N;\n            }(k), v.writeFileSync(d, w));\n          }, _t.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }, _t.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }, _t.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };\n          var Dn = { make: function(d, v) {\n            var w = new Me.Table(\"fvar\", [{ name: \"version\", type: \"ULONG\", value: 65536 }, { name: \"offsetToData\", type: \"USHORT\", value: 0 }, { name: \"countSizePairs\", type: \"USHORT\", value: 2 }, { name: \"axisCount\", type: \"USHORT\", value: d.axes.length }, { name: \"axisSize\", type: \"USHORT\", value: 20 }, { name: \"instanceCount\", type: \"USHORT\", value: d.instances.length }, { name: \"instanceSize\", type: \"USHORT\", value: 4 + 4 * d.axes.length }]);\n            w.offsetToData = w.sizeOf();\n            for (var k, I, N, z = 0; z < d.axes.length; z++)\n              w.fields = w.fields.concat((k = z, I = d.axes[z], N = v, N = pn(I.name, v), [{ name: \"tag_\" + k, type: \"TAG\", value: I.tag }, { name: \"minValue_\" + k, type: \"FIXED\", value: I.minValue << 16 }, { name: \"defaultValue_\" + k, type: \"FIXED\", value: I.defaultValue << 16 }, { name: \"maxValue_\" + k, type: \"FIXED\", value: I.maxValue << 16 }, { name: \"flags_\" + k, type: \"USHORT\", value: 0 }, { name: \"nameID_\" + k, type: \"USHORT\", value: N }]));\n            for (var Q = 0; Q < d.instances.length; Q++)\n              w.fields = w.fields.concat(function(se, oe, ye, Se) {\n                for (var be = [{ name: \"nameID_\" + se, type: \"USHORT\", value: pn(oe.name, Se) }, { name: \"flags_\" + se, type: \"USHORT\", value: 0 }], de = 0; de < ye.length; ++de) {\n                  var Ie = ye[de].tag;\n                  be.push({ name: \"axis_\" + se + \" \" + Ie, type: \"FIXED\", value: oe.coordinates[Ie] << 16 });\n                }\n                return be;\n              }(Q, d.instances[Q], d.axes, v));\n            return w;\n          }, parse: function(d, v, w) {\n            for (var k, I, N, z, Q = new we.Parser(d, v), se = Q.parseULong(), oe = (O.argument(se === 65536, \"Unsupported fvar table version.\"), Q.parseOffset16()), ye = (Q.skip(\"uShort\", 1), Q.parseUShort()), Se = Q.parseUShort(), be = Q.parseUShort(), de = Q.parseUShort(), Ie = [], ke = 0; ke < ye; ke++)\n              Ie.push((k = d, I = v + oe + ke * Se, N = w, z = {}, k = new we.Parser(k, I), z.tag = k.parseTag(), z.minValue = k.parseFixed(), z.defaultValue = k.parseFixed(), z.maxValue = k.parseFixed(), k.skip(\"uShort\", 1), z.name = N[k.parseUShort()] || {}, z));\n            for (var Ae = [], Te = v + oe + ye * Se, Ee = 0; Ee < be; Ee++)\n              Ae.push(function($e, lt, et, tt) {\n                var dt = {}, wt = new we.Parser($e, lt);\n                dt.name = tt[wt.parseUShort()] || {}, wt.skip(\"uShort\", 1), dt.coordinates = {};\n                for (var Ot = 0; Ot < et.length; ++Ot)\n                  dt.coordinates[et[Ot].tag] = wt.parseFixed();\n                return dt;\n              }(d, Te + Ee * de, Ie, w));\n            return { axes: Ie, instances: Ae };\n          } }, Zt = new Array(10);\n          Zt[1] = function() {\n            var d = this.offset + this.relativeOffset, v = this.parseUShort();\n            return v === 1 ? { posFormat: 1, coverage: this.parsePointer(ve.coverage), value: this.parseValueRecord() } : v === 2 ? { posFormat: 2, coverage: this.parsePointer(ve.coverage), values: this.parseValueRecordList() } : void O.assert(!1, \"0x\" + d.toString(16) + \": GPOS lookup type 1 format must be 1 or 2.\");\n          }, Zt[2] = function() {\n            var d, v, w, k, N = this.offset + this.relativeOffset, I = this.parseUShort(), N = (O.assert(I === 1 || I === 2, \"0x\" + N.toString(16) + \": GPOS lookup type 2 format must be 1 or 2.\"), this.parsePointer(ve.coverage)), z = this.parseUShort(), Q = this.parseUShort();\n            return I === 1 ? { posFormat: I, coverage: N, valueFormat1: z, valueFormat2: Q, pairSets: this.parseList(ve.pointer(ve.list(function() {\n              return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(z), value2: this.parseValueRecord(Q) };\n            }))) } : I === 2 ? (d = this.parsePointer(ve.classDef), v = this.parsePointer(ve.classDef), w = this.parseUShort(), k = this.parseUShort(), { posFormat: I, coverage: N, valueFormat1: z, valueFormat2: Q, classDef1: d, classDef2: v, class1Count: w, class2Count: k, classRecords: this.parseList(w, ve.list(k, function() {\n              return { value1: this.parseValueRecord(z), value2: this.parseValueRecord(Q) };\n            })) }) : void 0;\n          }, Zt[3] = function() {\n            return { error: \"GPOS Lookup 3 not supported\" };\n          }, Zt[4] = function() {\n            return { error: \"GPOS Lookup 4 not supported\" };\n          }, Zt[5] = function() {\n            return { error: \"GPOS Lookup 5 not supported\" };\n          }, Zt[6] = function() {\n            return { error: \"GPOS Lookup 6 not supported\" };\n          }, Zt[7] = function() {\n            return { error: \"GPOS Lookup 7 not supported\" };\n          }, Zt[8] = function() {\n            return { error: \"GPOS Lookup 8 not supported\" };\n          }, Zt[9] = function() {\n            return { error: \"GPOS Lookup 9 not supported\" };\n          };\n          var Fn = new Array(10), Un = { parse: function(d, v) {\n            return v = (d = new ve(d, v = v || 0)).parseVersion(1), O.argument(v === 1 || v === 1.1, \"Unsupported GPOS table version \" + v), v === 1 ? { version: v, scripts: d.parseScriptList(), features: d.parseFeatureList(), lookups: d.parseLookupList(Zt) } : { version: v, scripts: d.parseScriptList(), features: d.parseFeatureList(), lookups: d.parseLookupList(Zt), variations: d.parseFeatureVariationsList() };\n          }, make: function(d) {\n            return new Me.Table(\"GPOS\", [{ name: \"version\", type: \"ULONG\", value: 65536 }, { name: \"scripts\", type: \"TABLE\", value: new Me.ScriptList(d.scripts) }, { name: \"features\", type: \"TABLE\", value: new Me.FeatureList(d.features) }, { name: \"lookups\", type: \"TABLE\", value: new Me.LookupList(d.lookups, Fn) }]);\n          } }, Nn = { parse: function(d, v) {\n            if (d = new we.Parser(d, v), (v = d.parseUShort()) === 0) {\n              var w = d, k = {}, Se = (w.skip(\"uShort\"), w.parseUShort()), I = (O.argument(Se === 0, \"Unsupported kern sub-table version.\"), w.skip(\"uShort\", 2), w.parseUShort());\n              w.skip(\"uShort\", 3);\n              for (var N = 0; N < I; N += 1) {\n                var z = w.parseUShort(), Q = w.parseUShort(), se = w.parseShort();\n                k[z + \",\" + Q] = se;\n              }\n              return k;\n            }\n            if (v !== 1)\n              throw new Error(\"Unsupported kern table version (\" + v + \").\");\n            var oe = d, ye = {}, Se = (oe.skip(\"uShort\"), 1 < oe.parseULong() && console.warn(\"Only the first kern subtable is supported.\"), oe.skip(\"uLong\"), 255 & oe.parseUShort());\n            if (oe.skip(\"uShort\"), Se == 0) {\n              var be = oe.parseUShort();\n              oe.skip(\"uShort\", 3);\n              for (var de = 0; de < be; de += 1) {\n                var Ie = oe.parseUShort(), ke = oe.parseUShort(), Ae = oe.parseShort();\n                ye[Ie + \",\" + ke] = Ae;\n              }\n            }\n            return ye;\n          } }, Bn = { parse: function(d, v, w, k) {\n            for (var I = new we.Parser(d, v), N = k ? I.parseUShort : I.parseULong, z = [], Q = 0; Q < w + 1; Q += 1) {\n              var se = N.call(I);\n              k && (se *= 2), z.push(se);\n            }\n            return z;\n          } };\n          function Gn(d, v) {\n            t(\"fs\").readFile(d, function(w, k) {\n              if (w)\n                return v(w.message);\n              v(null, zr(k));\n            });\n          }\n          function Vn(d, v) {\n            var w = new XMLHttpRequest();\n            w.open(\"get\", d, !0), w.responseType = \"arraybuffer\", w.onload = function() {\n              return w.response ? v(null, w.response) : v(\"Font could not be loaded: \" + w.statusText);\n            }, w.onerror = function() {\n              v(\"Font could not be loaded\");\n            }, w.send();\n          }\n          function mn(d, v) {\n            for (var w = [], k = 12, I = 0; I < v; I += 1) {\n              var N = we.getTag(d, k), z = we.getULong(d, k + 4), Q = we.getULong(d, k + 8), se = we.getULong(d, k + 12);\n              w.push({ tag: N, checksum: z, offset: Q, length: se, compression: !1 }), k += 16;\n            }\n            return w;\n          }\n          function Lt(w, v) {\n            if (v.compression !== \"WOFF\")\n              return { data: w, offset: v.offset };\n            var w = new Uint8Array(w.buffer, v.offset + 2, v.compressedLength - 2), k = new Uint8Array(v.length);\n            if (G(w, k), k.byteLength !== v.length)\n              throw new Error(\"Decompression error: \" + v.tag + \" decompressed length doesn't match recorded length\");\n            return { data: new DataView(k.buffer, 0), offset: 0 };\n          }\n          function Or(Ee) {\n            var v, w, k, I, N, z, Q, se, oe, ye, Se, be, de, Ie, ke = new _t({ empty: !0 }), Ae = new DataView(Ee, 0), Te = [], Ee = we.getTag(Ae, 0);\n            if (Ee === \"\\0\u0001\\0\\0\" || Ee === \"true\" || Ee === \"typ1\")\n              ke.outlinesFormat = \"truetype\", Te = mn(Ae, k = we.getUShort(Ae, 4));\n            else if (Ee === \"OTTO\")\n              ke.outlinesFormat = \"cff\", Te = mn(Ae, k = we.getUShort(Ae, 4));\n            else {\n              if (Ee !== \"wOFF\")\n                throw new Error(\"Unsupported OpenType signature \" + Ee);\n              var $e = we.getTag(Ae, 4);\n              if ($e === \"\\0\u0001\\0\\0\")\n                ke.outlinesFormat = \"truetype\";\n              else {\n                if ($e !== \"OTTO\")\n                  throw new Error(\"Unsupported OpenType flavor \" + Ee);\n                ke.outlinesFormat = \"cff\";\n              }\n              Te = function(St, vt) {\n                for (var qt = [], kt = 44, zt = 0; zt < vt; zt += 1) {\n                  var Tt = we.getTag(St, kt), Gt = we.getULong(St, kt + 4), fr = we.getULong(St, kt + 8), ur = we.getULong(St, kt + 12), yn = void 0, yn = fr < ur && \"WOFF\";\n                  qt.push({ tag: Tt, offset: Gt, compression: yn, compressedLength: fr, length: ur }), kt += 20;\n                }\n                return qt;\n              }(Ae, k = we.getUShort(Ae, 12));\n            }\n            for (var lt = 0; lt < k; lt += 1) {\n              var et = Te[lt], tt = void 0;\n              switch (et.tag) {\n                case \"cmap\":\n                  tt = Lt(Ae, et), ke.tables.cmap = Z.parse(tt.data, tt.offset), ke.encoding = new Ce(ke.tables.cmap);\n                  break;\n                case \"cvt \":\n                  tt = Lt(Ae, et), Ie = new we.Parser(tt.data, tt.offset), ke.tables.cvt = Ie.parseShortList(et.length / 2);\n                  break;\n                case \"fvar\":\n                  N = et;\n                  break;\n                case \"fpgm\":\n                  tt = Lt(Ae, et), Ie = new we.Parser(tt.data, tt.offset), ke.tables.fpgm = Ie.parseByteList(et.length);\n                  break;\n                case \"head\":\n                  tt = Lt(Ae, et), ke.tables.head = pt.parse(tt.data, tt.offset), ke.unitsPerEm = ke.tables.head.unitsPerEm, v = ke.tables.head.indexToLocFormat;\n                  break;\n                case \"hhea\":\n                  tt = Lt(Ae, et), ke.tables.hhea = ie.parse(tt.data, tt.offset), ke.ascender = ke.tables.hhea.ascender, ke.descender = ke.tables.hhea.descender, ke.numberOfHMetrics = ke.tables.hhea.numberOfHMetrics;\n                  break;\n                case \"hmtx\":\n                  oe = et;\n                  break;\n                case \"ltag\":\n                  tt = Lt(Ae, et), w = Ge.parse(tt.data, tt.offset);\n                  break;\n                case \"maxp\":\n                  tt = Lt(Ae, et), ke.tables.maxp = Le.parse(tt.data, tt.offset), ke.numGlyphs = ke.tables.maxp.numGlyphs;\n                  break;\n                case \"name\":\n                  be = et;\n                  break;\n                case \"OS/2\":\n                  tt = Lt(Ae, et), ke.tables.os2 = Bt.parse(tt.data, tt.offset);\n                  break;\n                case \"post\":\n                  tt = Lt(Ae, et), ke.tables.post = Lr.parse(tt.data, tt.offset), ke.glyphNames = new Ne(ke.tables.post);\n                  break;\n                case \"prep\":\n                  tt = Lt(Ae, et), Ie = new we.Parser(tt.data, tt.offset), ke.tables.prep = Ie.parseByteList(et.length);\n                  break;\n                case \"glyf\":\n                  z = et;\n                  break;\n                case \"loca\":\n                  Se = et;\n                  break;\n                case \"CFF \":\n                  I = et;\n                  break;\n                case \"kern\":\n                  ye = et;\n                  break;\n                case \"GPOS\":\n                  Q = et;\n                  break;\n                case \"GSUB\":\n                  se = et;\n                  break;\n                case \"meta\":\n                  de = et;\n              }\n            }\n            if ($e = Lt(Ae, be), ke.tables.name = Xt.parse($e.data, $e.offset, w), ke.names = ke.tables.name, z && Se)\n              Ee = v === 0, $e = Lt(Ae, Se), $e = Bn.parse($e.data, $e.offset, ke.numGlyphs, Ee), Ee = Lt(Ae, z), ke.glyphs = qr.parse(Ee.data, Ee.offset, $e, ke);\n            else {\n              if (!I)\n                throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n              Ee = Lt(Ae, I), ft.parse(Ee.data, Ee.offset, ke);\n            }\n            for (var $e = Lt(Ae, oe), dt = (Oe.parse($e.data, $e.offset, ke.numberOfHMetrics, ke.numGlyphs, ke.glyphs), ke), wt = dt.tables.cmap.glyphIndexMap, Ot = Object.keys(wt), Rt = 0; Rt < Ot.length; Rt += 1) {\n              var Ht, Wt = Ot[Rt], Qt = wt[Wt];\n              (Ht = dt.glyphs.get(Qt)).addUnicode(parseInt(Wt));\n            }\n            for (var xt = 0; xt < dt.glyphs.length; xt += 1)\n              Ht = dt.glyphs.get(xt), dt.cffEncoding ? dt.isCIDFont ? Ht.name = \"gid\" + xt : Ht.name = dt.cffEncoding.charset[xt] : dt.glyphNames.names && (Ht.name = dt.glyphNames.glyphIndexToName(xt));\n            return ye ? (Ee = Lt(Ae, ye), ke.kerningPairs = Nn.parse(Ee.data, Ee.offset)) : ke.kerningPairs = {}, Q && ($e = Lt(Ae, Q), ke.tables.gpos = Un.parse($e.data, $e.offset), ke.position.init()), se && (Ee = Lt(Ae, se), ke.tables.gsub = Rr.parse(Ee.data, Ee.offset)), N && ($e = Lt(Ae, N), ke.tables.fvar = Dn.parse($e.data, $e.offset, ke.names)), de && (Ee = Lt(Ae, de), ke.tables.meta = Ir.parse(Ee.data, Ee.offset), ke.metas = ke.tables.meta), ke;\n          }\n          h.Font = _t, h.Glyph = We, h.Path = X, h.BoundingBox = W, h._parse = we, h.parse = Or, h.load = function(d, v) {\n            (typeof window > \"u\" ? Gn : Vn)(d, function(w, k) {\n              if (w)\n                return v(w);\n              var I;\n              try {\n                I = Or(k);\n              } catch (N) {\n                return v(N, null);\n              }\n              return v(null, I);\n            });\n          }, h.loadSync = function(d) {\n            return Or(zr(t(\"fs\").readFileSync(d)));\n          }, Object.defineProperty(h, \"__esModule\", { value: !0 });\n        }, u(typeof C == \"object\" && H !== void 0 ? C : y.opentype = {});\n      }).call(this, t(\"buffer\").Buffer);\n    }, { buffer: 4, fs: 2 }], 255: [function(t, H, C) {\n      (function(m) {\n        function y(g, f) {\n          for (var r = 0, s = g.length - 1; 0 <= s; s--) {\n            var o = g[s];\n            o === \".\" ? g.splice(s, 1) : o === \"..\" ? (g.splice(s, 1), r++) : r && (g.splice(s, 1), r--);\n          }\n          if (f)\n            for (; r--; )\n              g.unshift(\"..\");\n          return g;\n        }\n        function u(g, f) {\n          if (g.filter)\n            return g.filter(f);\n          for (var r = [], s = 0; s < g.length; s++)\n            f(g[s], s, g) && r.push(g[s]);\n          return r;\n        }\n        C.resolve = function() {\n          for (var g = \"\", f = !1, r = arguments.length - 1; -1 <= r && !f; r--) {\n            var s = 0 <= r ? arguments[r] : m.cwd();\n            if (typeof s != \"string\")\n              throw new TypeError(\"Arguments to path.resolve must be strings\");\n            s && (g = s + \"/\" + g, f = s.charAt(0) === \"/\");\n          }\n          return (f ? \"/\" : \"\") + (g = y(u(g.split(\"/\"), function(o) {\n            return !!o;\n          }), !f).join(\"/\")) || \".\";\n        }, C.normalize = function(g) {\n          var f = C.isAbsolute(g), r = h(g, -1) === \"/\";\n          return (g = (g = y(u(g.split(\"/\"), function(s) {\n            return !!s;\n          }), !f).join(\"/\")) || f ? g : \".\") && r && (g += \"/\"), (f ? \"/\" : \"\") + g;\n        }, C.isAbsolute = function(g) {\n          return g.charAt(0) === \"/\";\n        }, C.join = function() {\n          var g = Array.prototype.slice.call(arguments, 0);\n          return C.normalize(u(g, function(f, r) {\n            if (typeof f != \"string\")\n              throw new TypeError(\"Arguments to path.join must be strings\");\n            return f;\n          }).join(\"/\"));\n        }, C.relative = function(g, f) {\n          function r(c) {\n            for (var p = 0; p < c.length && c[p] === \"\"; p++)\n              ;\n            for (var j = c.length - 1; 0 <= j && c[j] === \"\"; j--)\n              ;\n            return j < p ? [] : c.slice(p, j - p + 1);\n          }\n          g = C.resolve(g).substr(1), f = C.resolve(f).substr(1);\n          for (var s = r(g.split(\"/\")), o = r(f.split(\"/\")), i = Math.min(s.length, o.length), l = i, n = 0; n < i; n++)\n            if (s[n] !== o[n]) {\n              l = n;\n              break;\n            }\n          for (var a = [], n = l; n < s.length; n++)\n            a.push(\"..\");\n          return (a = a.concat(o.slice(l))).join(\"/\");\n        }, C.sep = \"/\", C.delimiter = \":\", C.dirname = function(g) {\n          if (typeof g != \"string\" && (g += \"\"), g.length === 0)\n            return \".\";\n          for (var f = g.charCodeAt(0) === 47, r = -1, s = !0, o = g.length - 1; 1 <= o; --o)\n            if (g.charCodeAt(o) === 47) {\n              if (!s) {\n                r = o;\n                break;\n              }\n            } else\n              s = !1;\n          return r === -1 ? f ? \"/\" : \".\" : f && r === 1 ? \"/\" : g.slice(0, r);\n        }, C.basename = function(g, f) {\n          return g = function(r) {\n            typeof r != \"string\" && (r += \"\");\n            for (var s = 0, o = -1, i = !0, l = r.length - 1; 0 <= l; --l)\n              if (r.charCodeAt(l) === 47) {\n                if (!i) {\n                  s = l + 1;\n                  break;\n                }\n              } else\n                o === -1 && (i = !1, o = l + 1);\n            return o === -1 ? \"\" : r.slice(s, o);\n          }(g), g = f && g.substr(-1 * f.length) === f ? g.substr(0, g.length - f.length) : g;\n        }, C.extname = function(g) {\n          typeof g != \"string\" && (g += \"\");\n          for (var f = -1, r = 0, s = -1, o = !0, i = 0, l = g.length - 1; 0 <= l; --l) {\n            var n = g.charCodeAt(l);\n            if (n === 47) {\n              if (o)\n                continue;\n              r = l + 1;\n              break;\n            }\n            s === -1 && (o = !1, s = l + 1), n === 46 ? f === -1 ? f = l : i !== 1 && (i = 1) : f !== -1 && (i = -1);\n          }\n          return f === -1 || s === -1 || i === 0 || i === 1 && f === s - 1 && f === r + 1 ? \"\" : g.slice(f, s);\n        };\n        var h =  true ? function(g, f, r) {\n          return g.substr(f, r);\n        } : 0;\n      }).call(this, t(\"_process\"));\n    }, { _process: 256 }], 256: [function(t, u, C) {\n      var m, y, u = u.exports = {};\n      function h() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function g() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      try {\n        m = typeof setTimeout == \"function\" ? setTimeout : h;\n      } catch {\n        m = h;\n      }\n      try {\n        y = typeof clearTimeout == \"function\" ? clearTimeout : g;\n      } catch {\n        y = g;\n      }\n      function f(p) {\n        if (m === setTimeout)\n          return setTimeout(p, 0);\n        if ((m === h || !m) && setTimeout)\n          return (m = setTimeout)(p, 0);\n        try {\n          return m(p, 0);\n        } catch {\n          try {\n            return m.call(null, p, 0);\n          } catch {\n            return m.call(this, p, 0);\n          }\n        }\n      }\n      var r, s = [], o = !1, i = -1;\n      function l() {\n        o && r && (o = !1, r.length ? s = r.concat(s) : i = -1, s.length && n());\n      }\n      function n() {\n        if (!o) {\n          for (var p = f(l), j = (o = !0, s.length); j; ) {\n            for (r = s, s = []; ++i < j; )\n              r && r[i].run();\n            i = -1, j = s.length;\n          }\n          r = null, o = !1, function(T) {\n            if (y === clearTimeout)\n              return clearTimeout(T);\n            if ((y === g || !y) && clearTimeout)\n              return (y = clearTimeout)(T);\n            try {\n              y(T);\n            } catch {\n              try {\n                return y.call(null, T);\n              } catch {\n                return y.call(this, T);\n              }\n            }\n          }(p);\n        }\n      }\n      function a(p, j) {\n        this.fun = p, this.array = j;\n      }\n      function c() {\n      }\n      u.nextTick = function(p) {\n        var j = new Array(arguments.length - 1);\n        if (1 < arguments.length)\n          for (var T = 1; T < arguments.length; T++)\n            j[T - 1] = arguments[T];\n        s.push(new a(p, j)), s.length !== 1 || o || f(n);\n      }, a.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      }, u.title = \"browser\", u.browser = !0, u.env = {}, u.argv = [], u.version = \"\", u.versions = {}, u.on = c, u.addListener = c, u.once = c, u.off = c, u.removeListener = c, u.removeAllListeners = c, u.emit = c, u.prependListener = c, u.prependOnceListener = c, u.listeners = function(p) {\n        return [];\n      }, u.binding = function(p) {\n        throw new Error(\"process.binding is not supported\");\n      }, u.cwd = function() {\n        return \"/\";\n      }, u.chdir = function(p) {\n        throw new Error(\"process.chdir is not supported\");\n      }, u.umask = function() {\n        return 0;\n      };\n    }, {}], 257: [function(t, H, C) {\n      H = function(m) {\n        var y, u = Object.prototype, h = u.hasOwnProperty, _ = typeof Symbol == \"function\" ? Symbol : {}, g = _.iterator || \"@@iterator\", f = _.asyncIterator || \"@@asyncIterator\", r = _.toStringTag || \"@@toStringTag\";\n        function s(V, D, U, B) {\n          var X, ne, b, O, D = D && D.prototype instanceof p ? D : p, D = Object.create(D.prototype), B = new R(B || []);\n          return D._invoke = (X = V, ne = U, b = B, O = i, function(Y, J) {\n            if (O === n)\n              throw new Error(\"Generator is already running\");\n            if (O === a) {\n              if (Y === \"throw\")\n                throw J;\n              return F();\n            }\n            for (b.method = Y, b.arg = J; ; ) {\n              var te = b.delegate;\n              if (te && (te = function ce(re, ue) {\n                var le = re.iterator[ue.method];\n                if (le === y) {\n                  if (ue.delegate = null, ue.method === \"throw\") {\n                    if (re.iterator.return && (ue.method = \"return\", ue.arg = y, ce(re, ue), ue.method === \"throw\"))\n                      return c;\n                    ue.method = \"throw\", ue.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n                  }\n                  return c;\n                }\n                if (le = o(le, re.iterator, ue.arg), le.type === \"throw\")\n                  return ue.method = \"throw\", ue.arg = le.arg, ue.delegate = null, c;\n                if (le = le.arg, !le)\n                  return ue.method = \"throw\", ue.arg = new TypeError(\"iterator result is not an object\"), ue.delegate = null, c;\n                {\n                  if (!le.done)\n                    return le;\n                  ue[re.resultName] = le.value, ue.next = re.nextLoc, ue.method !== \"return\" && (ue.method = \"next\", ue.arg = y);\n                }\n                return ue.delegate = null, c;\n              }(te, b), te)) {\n                if (te === c)\n                  continue;\n                return te;\n              }\n              if (b.method === \"next\")\n                b.sent = b._sent = b.arg;\n              else if (b.method === \"throw\") {\n                if (O === i)\n                  throw O = a, b.arg;\n                b.dispatchException(b.arg);\n              } else\n                b.method === \"return\" && b.abrupt(\"return\", b.arg);\n              if (O = n, te = o(X, ne, b), te.type === \"normal\") {\n                if (O = b.done ? a : l, te.arg !== c)\n                  return { value: te.arg, done: b.done };\n              } else\n                te.type === \"throw\" && (O = a, b.method = \"throw\", b.arg = te.arg);\n            }\n          }), D;\n        }\n        function o(V, G, U) {\n          try {\n            return { type: \"normal\", arg: V.call(G, U) };\n          } catch (W) {\n            return { type: \"throw\", arg: W };\n          }\n        }\n        m.wrap = s;\n        var i = \"suspendedStart\", l = \"suspendedYield\", n = \"executing\", a = \"completed\", c = {};\n        function p() {\n        }\n        function j() {\n        }\n        function T() {\n        }\n        var _ = {}, S = (_[g] = function() {\n          return this;\n        }, Object.getPrototypeOf), S = S && S(S(L([]))), E = (S && S !== u && h.call(S, g) && (_ = S), T.prototype = p.prototype = Object.create(_));\n        function A(V) {\n          [\"next\", \"throw\", \"return\"].forEach(function(G) {\n            V[G] = function(U) {\n              return this._invoke(G, U);\n            };\n          });\n        }\n        function x(V) {\n          var G;\n          this._invoke = function(U, W) {\n            function X() {\n              return new Promise(function(ne, b) {\n                (function O(ce, B, Y, J) {\n                  var te, ce = o(V[ce], V, B);\n                  if (ce.type !== \"throw\")\n                    return (B = (te = ce.arg).value) && typeof B == \"object\" && h.call(B, \"__await\") ? Promise.resolve(B.__await).then(function(re) {\n                      O(\"next\", re, Y, J);\n                    }, function(re) {\n                      O(\"throw\", re, Y, J);\n                    }) : Promise.resolve(B).then(function(re) {\n                      te.value = re, Y(te);\n                    }, function(re) {\n                      return O(\"throw\", re, Y, J);\n                    });\n                  J(ce.arg);\n                })(U, W, ne, b);\n              });\n            }\n            return G = G ? G.then(X, X) : X();\n          };\n        }\n        function P(V) {\n          var G = { tryLoc: V[0] };\n          1 in V && (G.catchLoc = V[1]), 2 in V && (G.finallyLoc = V[2], G.afterLoc = V[3]), this.tryEntries.push(G);\n        }\n        function M(V) {\n          var G = V.completion || {};\n          G.type = \"normal\", delete G.arg, V.completion = G;\n        }\n        function R(V) {\n          this.tryEntries = [{ tryLoc: \"root\" }], V.forEach(P, this), this.reset(!0);\n        }\n        function L(V) {\n          if (V) {\n            var G, U = V[g];\n            if (U)\n              return U.call(V);\n            if (typeof V.next == \"function\")\n              return V;\n            if (!isNaN(V.length))\n              return G = -1, (U = function W() {\n                for (; ++G < V.length; )\n                  if (h.call(V, G))\n                    return W.value = V[G], W.done = !1, W;\n                return W.value = y, W.done = !0, W;\n              }).next = U;\n          }\n          return { next: F };\n        }\n        function F() {\n          return { value: y, done: !0 };\n        }\n        return (j.prototype = E.constructor = T).constructor = j, T[r] = j.displayName = \"GeneratorFunction\", m.isGeneratorFunction = function(V) {\n          return V = typeof V == \"function\" && V.constructor, !!V && (V === j || (V.displayName || V.name) === \"GeneratorFunction\");\n        }, m.mark = function(V) {\n          return Object.setPrototypeOf ? Object.setPrototypeOf(V, T) : (V.__proto__ = T, r in V || (V[r] = \"GeneratorFunction\")), V.prototype = Object.create(E), V;\n        }, m.awrap = function(V) {\n          return { __await: V };\n        }, A(x.prototype), x.prototype[f] = function() {\n          return this;\n        }, m.AsyncIterator = x, m.async = function(V, G, U, W) {\n          var X = new x(s(V, G, U, W));\n          return m.isGeneratorFunction(G) ? X : X.next().then(function(ne) {\n            return ne.done ? ne.value : X.next();\n          });\n        }, A(E), E[r] = \"Generator\", E[g] = function() {\n          return this;\n        }, E.toString = function() {\n          return \"[object Generator]\";\n        }, m.keys = function(V) {\n          var G, U = [];\n          for (G in V)\n            U.push(G);\n          return U.reverse(), function W() {\n            for (; U.length; ) {\n              var X = U.pop();\n              if (X in V)\n                return W.value = X, W.done = !1, W;\n            }\n            return W.done = !0, W;\n          };\n        }, m.values = L, R.prototype = { constructor: R, reset: function(V) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = y, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = y, this.tryEntries.forEach(M), !V)\n            for (var G in this)\n              G.charAt(0) === \"t\" && h.call(this, G) && !isNaN(+G.slice(1)) && (this[G] = y);\n        }, stop: function() {\n          this.done = !0;\n          var V = this.tryEntries[0].completion;\n          if (V.type === \"throw\")\n            throw V.arg;\n          return this.rval;\n        }, dispatchException: function(V) {\n          if (this.done)\n            throw V;\n          var G = this;\n          function U(D, B) {\n            return ne.type = \"throw\", ne.arg = V, G.next = D, B && (G.method = \"next\", G.arg = y), !!B;\n          }\n          for (var W = this.tryEntries.length - 1; 0 <= W; --W) {\n            var X = this.tryEntries[W], ne = X.completion;\n            if (X.tryLoc === \"root\")\n              return U(\"end\");\n            if (X.tryLoc <= this.prev) {\n              var b = h.call(X, \"catchLoc\"), O = h.call(X, \"finallyLoc\");\n              if (b && O) {\n                if (this.prev < X.catchLoc)\n                  return U(X.catchLoc, !0);\n                if (this.prev < X.finallyLoc)\n                  return U(X.finallyLoc);\n              } else if (b) {\n                if (this.prev < X.catchLoc)\n                  return U(X.catchLoc, !0);\n              } else {\n                if (!O)\n                  throw new Error(\"try statement without catch or finally\");\n                if (this.prev < X.finallyLoc)\n                  return U(X.finallyLoc);\n              }\n            }\n          }\n        }, abrupt: function(V, G) {\n          for (var U = this.tryEntries.length - 1; 0 <= U; --U) {\n            var W = this.tryEntries[U];\n            if (W.tryLoc <= this.prev && h.call(W, \"finallyLoc\") && this.prev < W.finallyLoc) {\n              var X = W;\n              break;\n            }\n          }\n          var ne = (X = X && (V === \"break\" || V === \"continue\") && X.tryLoc <= G && G <= X.finallyLoc ? null : X) ? X.completion : {};\n          return ne.type = V, ne.arg = G, X ? (this.method = \"next\", this.next = X.finallyLoc, c) : this.complete(ne);\n        }, complete: function(V, G) {\n          if (V.type === \"throw\")\n            throw V.arg;\n          return V.type === \"break\" || V.type === \"continue\" ? this.next = V.arg : V.type === \"return\" ? (this.rval = this.arg = V.arg, this.method = \"return\", this.next = \"end\") : V.type === \"normal\" && G && (this.next = G), c;\n        }, finish: function(V) {\n          for (var G = this.tryEntries.length - 1; 0 <= G; --G) {\n            var U = this.tryEntries[G];\n            if (U.finallyLoc === V)\n              return this.complete(U.completion, U.afterLoc), M(U), c;\n          }\n        }, catch: function(V) {\n          for (var G = this.tryEntries.length - 1; 0 <= G; --G) {\n            var U, W, X = this.tryEntries[G];\n            if (X.tryLoc === V)\n              return (U = X.completion).type === \"throw\" && (W = U.arg, M(X)), W;\n          }\n          throw new Error(\"illegal catch attempt\");\n        }, delegateYield: function(V, G, U) {\n          return this.delegate = { iterator: L(V), resultName: G, nextLoc: U }, this.method === \"next\" && (this.arg = y), c;\n        } }, m;\n      }(typeof H == \"object\" ? H.exports : {});\n      try {\n        regeneratorRuntime = H;\n      } catch {\n        Function(\"r\", \"regeneratorRuntime = r\")(H);\n      }\n    }, {}], 258: [function(t, H, C) {\n      (function(m) {\n        var y, u, h, g, f, r, s, o, i, l;\n        function n(M) {\n          if (typeof M != \"string\" && (M = String(M)), /[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(M))\n            throw new TypeError(\"Invalid character in header field name\");\n          return M.toLowerCase();\n        }\n        function a(M) {\n          return M = typeof M != \"string\" ? String(M) : M;\n        }\n        function c(M) {\n          var R = { next: function() {\n            var L = M.shift();\n            return { done: L === void 0, value: L };\n          } };\n          return u && (R[Symbol.iterator] = function() {\n            return R;\n          }), R;\n        }\n        function p(M) {\n          this.map = {}, M instanceof p ? M.forEach(function(R, L) {\n            this.append(L, R);\n          }, this) : Array.isArray(M) ? M.forEach(function(R) {\n            this.append(R[0], R[1]);\n          }, this) : M && Object.getOwnPropertyNames(M).forEach(function(R) {\n            this.append(R, M[R]);\n          }, this);\n        }\n        function j(M) {\n          if (M.bodyUsed)\n            return Promise.reject(new TypeError(\"Already read\"));\n          M.bodyUsed = !0;\n        }\n        function T(M) {\n          return new Promise(function(R, L) {\n            M.onload = function() {\n              R(M.result);\n            }, M.onerror = function() {\n              L(M.error);\n            };\n          });\n        }\n        function _(M) {\n          var R = new FileReader(), L = T(R);\n          return R.readAsArrayBuffer(M), L;\n        }\n        function S(M) {\n          var R;\n          return M.slice ? M.slice(0) : ((R = new Uint8Array(M.byteLength)).set(new Uint8Array(M)), R.buffer);\n        }\n        function E() {\n          return this.bodyUsed = !1, this._initBody = function(M) {\n            if (this._bodyInit = M)\n              if (typeof M == \"string\")\n                this._bodyText = M;\n              else if (h && Blob.prototype.isPrototypeOf(M))\n                this._bodyBlob = M;\n              else if (g && FormData.prototype.isPrototypeOf(M))\n                this._bodyFormData = M;\n              else if (y && URLSearchParams.prototype.isPrototypeOf(M))\n                this._bodyText = M.toString();\n              else if (f && h && s(M))\n                this._bodyArrayBuffer = S(M.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);\n              else {\n                if (!f || !ArrayBuffer.prototype.isPrototypeOf(M) && !o(M))\n                  throw new Error(\"unsupported BodyInit type\");\n                this._bodyArrayBuffer = S(M);\n              }\n            else\n              this._bodyText = \"\";\n            this.headers.get(\"content-type\") || (typeof M == \"string\" ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : y && URLSearchParams.prototype.isPrototypeOf(M) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n          }, h && (this.blob = function() {\n            var M = j(this);\n            if (M)\n              return M;\n            if (this._bodyBlob)\n              return Promise.resolve(this._bodyBlob);\n            if (this._bodyArrayBuffer)\n              return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n            if (this._bodyFormData)\n              throw new Error(\"could not read FormData body as blob\");\n            return Promise.resolve(new Blob([this._bodyText]));\n          }, this.arrayBuffer = function() {\n            return this._bodyArrayBuffer ? j(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(_);\n          }), this.text = function() {\n            var M, R, L = j(this);\n            if (L)\n              return L;\n            if (this._bodyBlob)\n              return L = this._bodyBlob, M = new FileReader(), R = T(M), M.readAsText(L), R;\n            if (this._bodyArrayBuffer)\n              return Promise.resolve(function(F) {\n                for (var V = new Uint8Array(F), G = new Array(V.length), U = 0; U < V.length; U++)\n                  G[U] = String.fromCharCode(V[U]);\n                return G.join(\"\");\n              }(this._bodyArrayBuffer));\n            if (this._bodyFormData)\n              throw new Error(\"could not read FormData body as text\");\n            return Promise.resolve(this._bodyText);\n          }, g && (this.formData = function() {\n            return this.text().then(x);\n          }), this.json = function() {\n            return this.text().then(JSON.parse);\n          }, this;\n        }\n        function A(M, R) {\n          var L, F = (R = R || {}).body;\n          if (M instanceof A) {\n            if (M.bodyUsed)\n              throw new TypeError(\"Already read\");\n            this.url = M.url, this.credentials = M.credentials, R.headers || (this.headers = new p(M.headers)), this.method = M.method, this.mode = M.mode, F || M._bodyInit == null || (F = M._bodyInit, M.bodyUsed = !0);\n          } else\n            this.url = String(M);\n          if (this.credentials = R.credentials || this.credentials || \"omit\", !R.headers && this.headers || (this.headers = new p(R.headers)), this.method = (M = R.method || this.method || \"GET\", L = M.toUpperCase(), -1 < i.indexOf(L) ? L : M), this.mode = R.mode || this.mode || null, this.referrer = null, (this.method === \"GET\" || this.method === \"HEAD\") && F)\n            throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n          this._initBody(F);\n        }\n        function x(M) {\n          var R = new FormData();\n          return M.trim().split(\"&\").forEach(function(L) {\n            var F;\n            L && (F = (L = L.split(\"=\")).shift().replace(/\\+/g, \" \"), L = L.join(\"=\").replace(/\\+/g, \" \"), R.append(decodeURIComponent(F), decodeURIComponent(L)));\n          }), R;\n        }\n        function P(M, R) {\n          R = R || {}, this.type = \"default\", this.status = R.status === void 0 ? 200 : R.status, this.ok = 200 <= this.status && this.status < 300, this.statusText = \"statusText\" in R ? R.statusText : \"OK\", this.headers = new p(R.headers), this.url = R.url || \"\", this._initBody(M);\n        }\n        m.fetch || (y = \"URLSearchParams\" in m, u = \"Symbol\" in m && \"iterator\" in Symbol, h = \"FileReader\" in m && \"Blob\" in m && function() {\n          try {\n            return new Blob(), !0;\n          } catch {\n            return !1;\n          }\n        }(), g = \"FormData\" in m, (f = \"ArrayBuffer\" in m) && (r = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"], s = function(M) {\n          return M && DataView.prototype.isPrototypeOf(M);\n        }, o = ArrayBuffer.isView || function(M) {\n          return M && -1 < r.indexOf(Object.prototype.toString.call(M));\n        }), p.prototype.append = function(M, R) {\n          M = n(M), R = a(R);\n          var L = this.map[M];\n          this.map[M] = L ? L + \",\" + R : R;\n        }, p.prototype.delete = function(M) {\n          delete this.map[n(M)];\n        }, p.prototype.get = function(M) {\n          return M = n(M), this.has(M) ? this.map[M] : null;\n        }, p.prototype.has = function(M) {\n          return this.map.hasOwnProperty(n(M));\n        }, p.prototype.set = function(M, R) {\n          this.map[n(M)] = a(R);\n        }, p.prototype.forEach = function(M, R) {\n          for (var L in this.map)\n            this.map.hasOwnProperty(L) && M.call(R, this.map[L], L, this);\n        }, p.prototype.keys = function() {\n          var M = [];\n          return this.forEach(function(R, L) {\n            M.push(L);\n          }), c(M);\n        }, p.prototype.values = function() {\n          var M = [];\n          return this.forEach(function(R) {\n            M.push(R);\n          }), c(M);\n        }, p.prototype.entries = function() {\n          var M = [];\n          return this.forEach(function(R, L) {\n            M.push([L, R]);\n          }), c(M);\n        }, u && (p.prototype[Symbol.iterator] = p.prototype.entries), i = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"], A.prototype.clone = function() {\n          return new A(this, { body: this._bodyInit });\n        }, E.call(A.prototype), E.call(P.prototype), P.prototype.clone = function() {\n          return new P(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new p(this.headers), url: this.url });\n        }, P.error = function() {\n          var M = new P(null, { status: 0, statusText: \"\" });\n          return M.type = \"error\", M;\n        }, l = [301, 302, 303, 307, 308], P.redirect = function(M, R) {\n          if (l.indexOf(R) === -1)\n            throw new RangeError(\"Invalid status code\");\n          return new P(null, { status: R, headers: { location: M } });\n        }, m.Headers = p, m.Request = A, m.Response = P, m.fetch = function(M, R) {\n          return new Promise(function(L, F) {\n            var V = new A(M, R), G = new XMLHttpRequest();\n            G.onload = function() {\n              var U, W = { status: G.status, statusText: G.statusText, headers: (W = G.getAllResponseHeaders() || \"\", U = new p(), W.replace(/\\r?\\n[\\t ]+/g, \" \").split(/\\r?\\n/).forEach(function(b) {\n                var b = b.split(\":\"), O = b.shift().trim();\n                O && (b = b.join(\":\").trim(), U.append(O, b));\n              }), U) }, X = (W.url = \"responseURL\" in G ? G.responseURL : W.headers.get(\"X-Request-URL\"), \"response\" in G ? G.response : G.responseText);\n              L(new P(X, W));\n            }, G.onerror = function() {\n              F(new TypeError(\"Network request failed\"));\n            }, G.ontimeout = function() {\n              F(new TypeError(\"Network request failed\"));\n            }, G.open(V.method, V.url, !0), V.credentials === \"include\" ? G.withCredentials = !0 : V.credentials === \"omit\" && (G.withCredentials = !1), \"responseType\" in G && h && (G.responseType = \"blob\"), V.headers.forEach(function(U, W) {\n              G.setRequestHeader(W, U);\n            }), G.send(V._bodyInit === void 0 ? null : V._bodyInit);\n          });\n        }, m.fetch.polyfill = !0);\n      })(typeof self < \"u\" ? self : this);\n    }, {}], 259: [function(t, H, C) {\n      t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.split\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m, y = h(t(\"../core/main\")), u = h(t(\"../color/color_conversion\"));\n      function h(r) {\n        return r && r.__esModule ? r : { default: r };\n      }\n      var g = [{ h: 0, s: 0, b: 0.8275, name: \"gray\" }, { h: 0, s: 0, b: 0.8627, name: \"gray\" }, { h: 0, s: 0, b: 0.7529, name: \"gray\" }, { h: 0.0167, s: 0.1176, b: 1, name: \"light pink\" }], f = [{ h: 0, s: 0, b: 0, name: \"black\" }, { h: 0, s: 0, b: 0.5, name: \"gray\" }, { h: 0, s: 0, b: 1, name: \"white\" }, { h: 0, s: 0.5, b: 0.5, name: \"dark maroon\" }, { h: 0, s: 0.5, b: 1, name: \"salmon pink\" }, { h: 0, s: 1, b: 0, name: \"black\" }, { h: 0, s: 1, b: 0.5, name: \"dark red\" }, { h: 0, s: 1, b: 1, name: \"red\" }, { h: 5, s: 0, b: 1, name: \"very light peach\" }, { h: 5, s: 0.5, b: 0.5, name: \"brown\" }, { h: 5, s: 0.5, b: 1, name: \"peach\" }, { h: 5, s: 1, b: 0.5, name: \"brick red\" }, { h: 5, s: 1, b: 1, name: \"crimson\" }, { h: 10, s: 0, b: 1, name: \"light peach\" }, { h: 10, s: 0.5, b: 0.5, name: \"brown\" }, { h: 10, s: 0.5, b: 1, name: \"light orange\" }, { h: 10, s: 1, b: 0.5, name: \"brown\" }, { h: 10, s: 1, b: 1, name: \"orange\" }, { h: 15, s: 0, b: 1, name: \"very light yellow\" }, { h: 15, s: 0.5, b: 0.5, name: \"olive green\" }, { h: 15, s: 0.5, b: 1, name: \"light yellow\" }, { h: 15, s: 1, b: 0, name: \"dark olive green\" }, { h: 15, s: 1, b: 0.5, name: \"olive green\" }, { h: 15, s: 1, b: 1, name: \"yellow\" }, { h: 20, s: 0, b: 1, name: \"very light yellow\" }, { h: 20, s: 0.5, b: 0.5, name: \"olive green\" }, { h: 20, s: 0.5, b: 1, name: \"light yellow green\" }, { h: 20, s: 1, b: 0, name: \"dark olive green\" }, { h: 20, s: 1, b: 0.5, name: \"dark yellow green\" }, { h: 20, s: 1, b: 1, name: \"yellow green\" }, { h: 25, s: 0.5, b: 0.5, name: \"dark yellow green\" }, { h: 25, s: 0.5, b: 1, name: \"light green\" }, { h: 25, s: 1, b: 0.5, name: \"dark green\" }, { h: 25, s: 1, b: 1, name: \"green\" }, { h: 30, s: 0.5, b: 1, name: \"light green\" }, { h: 30, s: 1, b: 0.5, name: \"dark green\" }, { h: 30, s: 1, b: 1, name: \"green\" }, { h: 35, s: 0, b: 0.5, name: \"light green\" }, { h: 35, s: 0, b: 1, name: \"very light green\" }, { h: 35, s: 0.5, b: 0.5, name: \"dark green\" }, { h: 35, s: 0.5, b: 1, name: \"light green\" }, { h: 35, s: 1, b: 0, name: \"very dark green\" }, { h: 35, s: 1, b: 0.5, name: \"dark green\" }, { h: 35, s: 1, b: 1, name: \"green\" }, { h: 40, s: 0, b: 1, name: \"very light green\" }, { h: 40, s: 0.5, b: 0.5, name: \"dark green\" }, { h: 40, s: 0.5, b: 1, name: \"light green\" }, { h: 40, s: 1, b: 0.5, name: \"dark green\" }, { h: 40, s: 1, b: 1, name: \"green\" }, { h: 45, s: 0.5, b: 1, name: \"light turquoise\" }, { h: 45, s: 1, b: 0.5, name: \"dark turquoise\" }, { h: 45, s: 1, b: 1, name: \"turquoise\" }, { h: 50, s: 0, b: 1, name: \"light sky blue\" }, { h: 50, s: 0.5, b: 0.5, name: \"dark cyan\" }, { h: 50, s: 0.5, b: 1, name: \"light cyan\" }, { h: 50, s: 1, b: 0.5, name: \"dark cyan\" }, { h: 50, s: 1, b: 1, name: \"cyan\" }, { h: 55, s: 0, b: 1, name: \"light sky blue\" }, { h: 55, s: 0.5, b: 1, name: \"light sky blue\" }, { h: 55, s: 1, b: 0.5, name: \"dark blue\" }, { h: 55, s: 1, b: 1, name: \"sky blue\" }, { h: 60, s: 0, b: 0.5, name: \"gray\" }, { h: 60, s: 0, b: 1, name: \"very light blue\" }, { h: 60, s: 0.5, b: 0.5, name: \"blue\" }, { h: 60, s: 0.5, b: 1, name: \"light blue\" }, { h: 60, s: 1, b: 0.5, name: \"navy blue\" }, { h: 60, s: 1, b: 1, name: \"blue\" }, { h: 65, s: 0, b: 1, name: \"lavender\" }, { h: 65, s: 0.5, b: 0.5, name: \"navy blue\" }, { h: 65, s: 0.5, b: 1, name: \"light purple\" }, { h: 65, s: 1, b: 0.5, name: \"dark navy blue\" }, { h: 65, s: 1, b: 1, name: \"blue\" }, { h: 70, s: 0, b: 1, name: \"lavender\" }, { h: 70, s: 0.5, b: 0.5, name: \"navy blue\" }, { h: 70, s: 0.5, b: 1, name: \"lavender blue\" }, { h: 70, s: 1, b: 0.5, name: \"dark navy blue\" }, { h: 70, s: 1, b: 1, name: \"blue\" }, { h: 75, s: 0.5, b: 1, name: \"lavender\" }, { h: 75, s: 1, b: 0.5, name: \"dark purple\" }, { h: 75, s: 1, b: 1, name: \"purple\" }, { h: 80, s: 0.5, b: 1, name: \"pinkish purple\" }, { h: 80, s: 1, b: 0.5, name: \"dark purple\" }, { h: 80, s: 1, b: 1, name: \"purple\" }, { h: 85, s: 0, b: 1, name: \"light pink\" }, { h: 85, s: 0.5, b: 0.5, name: \"purple\" }, { h: 85, s: 0.5, b: 1, name: \"light fuchsia\" }, { h: 85, s: 1, b: 0.5, name: \"dark fuchsia\" }, { h: 85, s: 1, b: 1, name: \"fuchsia\" }, { h: 90, s: 0.5, b: 0.5, name: \"dark fuchsia\" }, { h: 90, s: 0.5, b: 1, name: \"hot pink\" }, { h: 90, s: 1, b: 0.5, name: \"dark fuchsia\" }, { h: 90, s: 1, b: 1, name: \"fuchsia\" }, { h: 95, s: 0, b: 1, name: \"pink\" }, { h: 95, s: 0.5, b: 1, name: \"light pink\" }, { h: 95, s: 1, b: 0.5, name: \"dark magenta\" }, { h: 95, s: 1, b: 1, name: \"magenta\" }];\n      y.default.prototype._rgbColorName = function(i) {\n        var s, o, i = u.default._rgbaToHSBA(i), l = [(m = i)[0], i[1], i[2]];\n        l[0] !== 0 && (l[0] = Math.round(100 * l[0]), (i = l[0].toString().split(\"\"))[o = i.length - 1] = parseInt(i[o]), i[o] < 2.5 ? i[o] = 0 : 2.5 <= i[o] && i[o] < 7.5 && (i[o] = 5), i.length === 2 ? (i[0] = parseInt(i[0]), 7.5 <= i[o] && (i[o] = 0, i[0] = i[0] + 1), l[0] = 10 * i[0] + i[1]) : 7.5 <= i[o] ? l[0] = 10 : l[0] = i[o]), l[2] = l[2] / 255;\n        for (var n = l.length - 1; 1 <= n; n--)\n          l[n] <= 0.25 ? l[n] = 0 : 0.25 < l[n] && l[n] < 0.75 ? l[n] = 0.5 : l[n] = 1;\n        if (l[0] === 0 && l[1] === 0 && l[2] === 1) {\n          for (var a = 2; 0 <= a; a--)\n            m[a] = Math.round(1e4 * m[a]) / 1e4;\n          for (var c = 0; c < g.length; c++) {\n            if (g[c].h === m[0] && g[c].s === m[1] && g[c].b === m[2]) {\n              s = g[c].name;\n              break;\n            }\n            s = \"white\";\n          }\n        } else\n          for (var p = 0; p < f.length; p++)\n            if (f[p].h === l[0] && f[p].s === l[1] && f[p].b === l[2]) {\n              s = f[p].name;\n              break;\n            }\n        return s;\n      }, t = y.default, C.default = t;\n    }, { \"../color/color_conversion\": 265, \"../core/main\": 280, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.split\": 203 }], 260: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.ends-with\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.ends-with\"), t(\"core-js/modules/es.string.replace\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, y = \"_Description\", u = \"_fallbackDesc\", h = \"_fallbackTable\", g = \"_Label\", f = \"_labelDesc\", r = \"_labelTable\";\n      function s(o) {\n        if (o === \"label\" || o === \"fallback\")\n          throw new Error(\"description should not be LABEL or FALLBACK\");\n        return o.endsWith(\".\") || o.endsWith(\";\") || o.endsWith(\",\") || o.endsWith(\"?\") || o.endsWith(\"!\") || (o += \".\"), o;\n      }\n      m.default.prototype.describe = function(o, i) {\n        var l;\n        m.default._validateParameters(\"describe\", arguments), typeof o == \"string\" && (l = this.canvas.id, o = s(o), this.dummyDOM || (this.dummyDOM = document.getElementById(l).parentNode), this.descriptions || (this.descriptions = {}), this.descriptions.fallback ? this.descriptions.fallback.innerHTML !== o && (this.descriptions.fallback.innerHTML = o) : this._describeHTML(\"fallback\", o), i === this.LABEL && (this.descriptions.label ? this.descriptions.label.innerHTML !== o && (this.descriptions.label.innerHTML = o) : this._describeHTML(\"label\", o)));\n      }, m.default.prototype.describeElement = function(o, i, l) {\n        var n, a;\n        m.default._validateParameters(\"describeElement\", arguments), typeof i == \"string\" && typeof o == \"string\" && (n = this.canvas.id, i = s(i), a = function(c) {\n          if (c === \"label\" || c === \"fallback\")\n            throw new Error(\"element name should not be LABEL or FALLBACK\");\n          return c.endsWith(\".\") || c.endsWith(\";\") || c.endsWith(\",\") ? c = c.replace(/.$/, \":\") : c.endsWith(\":\") || (c += \":\"), c;\n        }(o), o = o.replace(/[^a-zA-Z0-9]/g, \"\"), a = '<th scope=\"row\">'.concat(a, \"</th><td>\").concat(i, \"</td>\"), this.dummyDOM || (this.dummyDOM = document.getElementById(n).parentNode), this.descriptions ? this.descriptions.fallbackElements || (this.descriptions.fallbackElements = {}) : this.descriptions = { fallbackElements: {} }, this.descriptions.fallbackElements[o] ? this.descriptions.fallbackElements[o].innerHTML !== a && (this.descriptions.fallbackElements[o].innerHTML = a) : this._describeElementHTML(\"fallback\", o, a), l === this.LABEL && (this.descriptions.labelElements || (this.descriptions.labelElements = {}), this.descriptions.labelElements[o] ? this.descriptions.labelElements[o].innerHTML !== a && (this.descriptions.labelElements[o].innerHTML = a) : this._describeElementHTML(\"label\", o, a)));\n      }, m.default.prototype._describeHTML = function(o, i) {\n        var l, n = this.canvas.id;\n        o === \"fallback\" ? (this.dummyDOM.querySelector(\"#\".concat(n + y)) ? this.dummyDOM.querySelector(\"#\" + n + h).insertAdjacentHTML(\"beforebegin\", '<p id=\"'.concat(n + u, '\"></p>')) : (l = '<div id=\"'.concat(n).concat(y, '\" role=\"region\" aria-label=\"Canvas Description\"><p id=\"').concat(n).concat(u, '\"></p></div>'), this.dummyDOM.querySelector(\"#\".concat(n, \"accessibleOutput\")) ? this.dummyDOM.querySelector(\"#\".concat(n, \"accessibleOutput\")).insertAdjacentHTML(\"beforebegin\", l) : this.dummyDOM.querySelector(\"#\".concat(n)).innerHTML = l), this.descriptions.fallback = this.dummyDOM.querySelector(\"#\".concat(n).concat(u)), this.descriptions.fallback.innerHTML = i) : o === \"label\" && (this.dummyDOM.querySelector(\"#\".concat(n + g)) ? this.dummyDOM.querySelector(\"#\".concat(n + r)) && this.dummyDOM.querySelector(\"#\".concat(n + r)).insertAdjacentHTML(\"beforebegin\", '<p id=\"'.concat(n).concat(f, '\"></p>')) : (l = '<div id=\"'.concat(n).concat(g, '\" class=\"p5Label\"><p id=\"').concat(n).concat(f, '\"></p></div>'), this.dummyDOM.querySelector(\"#\".concat(n, \"accessibleOutputLabel\")) ? this.dummyDOM.querySelector(\"#\".concat(n, \"accessibleOutputLabel\")).insertAdjacentHTML(\"beforebegin\", l) : this.dummyDOM.querySelector(\"#\" + n).insertAdjacentHTML(\"afterend\", l)), this.descriptions.label = this.dummyDOM.querySelector(\"#\" + n + f), this.descriptions.label.innerHTML = i);\n      }, m.default.prototype._describeElementHTML = function(o, i, l) {\n        var n, a = this.canvas.id;\n        o === \"fallback\" ? (this.dummyDOM.querySelector(\"#\".concat(a + y)) ? this.dummyDOM.querySelector(\"#\" + a + h) || this.dummyDOM.querySelector(\"#\" + a + u).insertAdjacentHTML(\"afterend\", '<table id=\"'.concat(a).concat(h, '\"><caption>Canvas elements and their descriptions</caption></table>')) : (n = '<div id=\"'.concat(a).concat(y, '\" role=\"region\" aria-label=\"Canvas Description\"><table id=\"').concat(a).concat(h, '\"><caption>Canvas elements and their descriptions</caption></table></div>'), this.dummyDOM.querySelector(\"#\".concat(a, \"accessibleOutput\")) ? this.dummyDOM.querySelector(\"#\".concat(a, \"accessibleOutput\")).insertAdjacentHTML(\"beforebegin\", n) : this.dummyDOM.querySelector(\"#\" + a).innerHTML = n), (n = document.createElement(\"tr\")).id = a + \"_fte_\" + i, this.dummyDOM.querySelector(\"#\" + a + h).appendChild(n), this.descriptions.fallbackElements[i] = this.dummyDOM.querySelector(\"#\".concat(a).concat(\"_fte_\").concat(i)), this.descriptions.fallbackElements[i].innerHTML = l) : o === \"label\" && (this.dummyDOM.querySelector(\"#\".concat(a + g)) ? this.dummyDOM.querySelector(\"#\".concat(a + r)) || this.dummyDOM.querySelector(\"#\" + a + f).insertAdjacentHTML(\"afterend\", '<table id=\"'.concat(a + r, '\"></table>')) : (n = '<div id=\"'.concat(a).concat(g, '\" class=\"p5Label\"><table id=\"').concat(a).concat(r, '\"></table></div>'), this.dummyDOM.querySelector(\"#\".concat(a, \"accessibleOutputLabel\")) ? this.dummyDOM.querySelector(\"#\".concat(a, \"accessibleOutputLabel\")).insertAdjacentHTML(\"beforebegin\", n) : this.dummyDOM.querySelector(\"#\" + a).insertAdjacentHTML(\"afterend\", n)), (o = document.createElement(\"tr\")).id = a + \"_lte_\" + i, this.dummyDOM.querySelector(\"#\" + a + r).appendChild(o), this.descriptions.labelElements[i] = this.dummyDOM.querySelector(\"#\".concat(a).concat(\"_lte_\").concat(i)), this.descriptions.labelElements[i].innerHTML = l);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.ends-with\": 195, \"core-js/modules/es.string.replace\": 201 }], 261: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.string.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.prototype._updateGridOutput = function(m) {\n        var y, u, h, g;\n        this.dummyDOM.querySelector(\"#\".concat(m, \"_summary\")) && (y = this._accessibleOutputs[m], h = function(f, r, s, o) {\n          return r = \"\".concat(r, \" canvas, \").concat(s, \" by \").concat(o, \" pixels, contains \").concat(f[0]), r = (f[0] === 1 ? \"\".concat(r, \" shape: \") : \"\".concat(r, \" shapes: \")).concat(f[1]), r;\n        }((u = function(f, r) {\n          var s, o = \"\", i = \"\", l = 0;\n          for (s in r) {\n            var n, a = 0;\n            for (n in r[s]) {\n              var c = '<li id=\"'.concat(f, \"shape\").concat(l, '\">').concat(r[s][n].color, \" \").concat(s, \",\");\n              s === \"line\" ? c += \" location = \".concat(r[s][n].pos, \", length = \").concat(r[s][n].length, \" pixels\") : (c += \" location = \".concat(r[s][n].pos), s !== \"point\" && (c += \", area = \".concat(r[s][n].area, \" %\")), c += \"</li>\"), o += c, a++, l++;\n            }\n            i = 1 < a ? \"\".concat(i, \" \").concat(a, \" \").concat(s, \"s\") : \"\".concat(i, \" \").concat(a, \" \").concat(s);\n          }\n          return { numShapes: [l, i], details: o };\n        }(m, this.ingredients.shapes)).numShapes, this.ingredients.colors.background, this.width, this.height), g = function(f, r) {\n          var s, o, i = 0, l = \"\", n = Array.from(Array(10), function() {\n            return Array(10);\n          });\n          for (s in r)\n            for (var a in r[s]) {\n              var c = void 0;\n              c = s !== \"line\" ? '<a href=\"#'.concat(f, \"shape\").concat(i, '\">').concat(r[s][a].color, \" \").concat(s, \"</a>\") : '<a href=\"#'.concat(f, \"shape\").concat(i, '\">').concat(r[s][a].color, \" \").concat(s, \" midpoint</a>\"), n[r[s][a].loc.locY][r[s][a].loc.locX] ? n[r[s][a].loc.locY][r[s][a].loc.locX] = n[r[s][a].loc.locY][r[s][a].loc.locX] + \"  \" + c : n[r[s][a].loc.locY][r[s][a].loc.locX] = c, i++;\n            }\n          for (o in n) {\n            var p, j = \"<tr>\";\n            for (p in n[o])\n              j += \"<td>\", n[o][p] !== void 0 && (j += n[o][p]), j += \"</td>\";\n            l = l + j + \"</tr>\";\n          }\n          return l;\n        }(m, this.ingredients.shapes), h !== y.summary.innerHTML && (y.summary.innerHTML = h), g !== y.map.innerHTML && (y.map.innerHTML = g), u.details !== y.shapeDetails.innerHTML && (y.shapeDetails.innerHTML = u.details), this._accessibleOutputs[m] = y);\n      }, t = t.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.string.iterator\": 197 }], 262: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.number.to-fixed\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(h) {\n        return function(g) {\n          if (Array.isArray(g)) {\n            for (var f = 0, r = new Array(g.length); f < g.length; f++)\n              r[f] = g[f];\n            return r;\n          }\n        }(h) || function(g) {\n          if (Symbol.iterator in Object(g) || Object.prototype.toString.call(g) === \"[object Arguments]\")\n            return Array.from(g);\n        }(h) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function u(h, g, f) {\n        return g = Math.floor(h[0] / g * 10), h = Math.floor(h[1] / f * 10), g === 10 && (g -= 1), h === 10 && (h -= 1), { locX: g, locY: h };\n      }\n      m.default.prototype.textOutput = function(h) {\n        m.default._validateParameters(\"textOutput\", arguments), this._accessibleOutputs.text || (this._accessibleOutputs.text = !0, this._createOutput(\"textOutput\", \"Fallback\"), h === this.LABEL && (this._accessibleOutputs.textLabel = !0, this._createOutput(\"textOutput\", \"Label\")));\n      }, m.default.prototype.gridOutput = function(h) {\n        m.default._validateParameters(\"gridOutput\", arguments), this._accessibleOutputs.grid || (this._accessibleOutputs.grid = !0, this._createOutput(\"gridOutput\", \"Fallback\"), h === this.LABEL && (this._accessibleOutputs.gridLabel = !0, this._createOutput(\"gridOutput\", \"Label\")));\n      }, m.default.prototype._addAccsOutput = function() {\n        return this._accessibleOutputs || (this._accessibleOutputs = { text: !1, grid: !1, textLabel: !1, gridLabel: !1 }), this._accessibleOutputs.grid || this._accessibleOutputs.text;\n      }, m.default.prototype._createOutput = function(h, g) {\n        var f, r, s, o = this.canvas.id, i = (this.ingredients || (this.ingredients = { shapes: {}, colors: { background: \"white\", fill: \"white\", stroke: \"black\" }, pShapes: \"\", pBackground: \"\" }), this.dummyDOM || (this.dummyDOM = document.getElementById(o).parentNode), \"\");\n        g === \"Fallback\" ? (f = o + h, this.dummyDOM.querySelector(\"#\".concat(r = o + \"accessibleOutput\")) || (this.dummyDOM.querySelector(\"#\".concat(o, \"_Description\")) ? this.dummyDOM.querySelector(\"#\".concat(o, \"_Description\")).insertAdjacentHTML(\"afterend\", '<div id=\"'.concat(r, '\" role=\"region\" aria-label=\"Canvas Outputs\"></div>')) : this.dummyDOM.querySelector(\"#\".concat(o)).innerHTML = '<div id=\"'.concat(r, '\" role=\"region\" aria-label=\"Canvas Outputs\"></div>'))) : g === \"Label\" && (f = o + h + (i = g), this.dummyDOM.querySelector(\"#\".concat(r = o + \"accessibleOutput\" + g)) || (this.dummyDOM.querySelector(\"#\".concat(o, \"_Label\")) ? this.dummyDOM.querySelector(\"#\".concat(o, \"_Label\")) : this.dummyDOM.querySelector(\"#\".concat(o))).insertAdjacentHTML(\"afterend\", '<div id=\"'.concat(r, '\"></div>'))), this._accessibleOutputs[f] = {}, h === \"textOutput\" ? (i = \"#\".concat(o, \"gridOutput\").concat(i), s = '<div id=\"'.concat(f, '\">Text Output<div id=\"').concat(f, 'Summary\" aria-label=\"text output summary\"><p id=\"').concat(f, '_summary\"></p><ul id=\"').concat(f, '_list\"></ul></div><table id=\"').concat(f, '_shapeDetails\" summary=\"text output shape details\"></table></div>'), this.dummyDOM.querySelector(i) ? this.dummyDOM.querySelector(i).insertAdjacentHTML(\"beforebegin\", s) : this.dummyDOM.querySelector(\"#\".concat(r)).innerHTML = s, this._accessibleOutputs[f].list = this.dummyDOM.querySelector(\"#\".concat(f, \"_list\"))) : h === \"gridOutput\" && (i = \"#\".concat(o, \"textOutput\").concat(i), s = '<div id=\"'.concat(f, '\">Grid Output<p id=\"').concat(f, '_summary\" aria-label=\"grid output summary\"><table id=\"').concat(f, '_map\" summary=\"grid output content\"></table><ul id=\"').concat(f, '_shapeDetails\" aria-label=\"grid output shape details\"></ul></div>'), this.dummyDOM.querySelector(i) ? this.dummyDOM.querySelector(i).insertAdjacentHTML(\"afterend\", s) : this.dummyDOM.querySelector(\"#\".concat(r)).innerHTML = s, this._accessibleOutputs[f].map = this.dummyDOM.querySelector(\"#\".concat(f, \"_map\"))), this._accessibleOutputs[f].shapeDetails = this.dummyDOM.querySelector(\"#\".concat(f, \"_shapeDetails\")), this._accessibleOutputs[f].summary = this.dummyDOM.querySelector(\"#\".concat(f, \"_summary\"));\n      }, m.default.prototype._updateAccsOutput = function() {\n        var h = this.canvas.id;\n        JSON.stringify(this.ingredients.shapes) === this.ingredients.pShapes && this.ingredients.colors.background === this.ingredients.pBackground || (this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this._accessibleOutputs.text && this._updateTextOutput(h + \"textOutput\"), this._accessibleOutputs.grid && this._updateGridOutput(h + \"gridOutput\"), this._accessibleOutputs.textLabel && this._updateTextOutput(h + \"textOutputLabel\"), this._accessibleOutputs.gridLabel && this._updateGridOutput(h + \"gridOutputLabel\"));\n      }, m.default.prototype._accsBackground = function(h) {\n        this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this.ingredients.pBackground = this.ingredients.colors.background, this.ingredients.shapes = {}, this.ingredients.colors.backgroundRGBA !== h && (this.ingredients.colors.backgroundRGBA = h, this.ingredients.colors.background = this._rgbColorName(h));\n      }, m.default.prototype._accsCanvasColors = function(h, g) {\n        h === \"fill\" ? this.ingredients.colors.fillRGBA !== g && (this.ingredients.colors.fillRGBA = g, this.ingredients.colors.fill = this._rgbColorName(g)) : h === \"stroke\" && this.ingredients.colors.strokeRGBA !== g && (this.ingredients.colors.strokeRGBA = g, this.ingredients.colors.stroke = this._rgbColorName(g));\n      }, m.default.prototype._accsOutput = function(h, g) {\n        h === \"ellipse\" && g[2] === g[3] ? h = \"circle\" : h === \"rectangle\" && g[2] === g[3] && (h = \"square\");\n        var f, r, s = {}, o = !0, i = function(n, a) {\n          var c;\n          return n = n === \"rectangle\" || n === \"ellipse\" || n === \"arc\" || n === \"circle\" || n === \"square\" ? (c = Math.round(a[0] + a[2] / 2), Math.round(a[1] + a[3] / 2)) : n === \"triangle\" ? (c = (a[0] + a[2] + a[4]) / 3, (a[1] + a[3] + a[5]) / 3) : n === \"quadrilateral\" ? (c = (a[0] + a[2] + a[4] + a[6]) / 4, (a[1] + a[3] + a[5] + a[7]) / 4) : n === \"line\" ? (c = (a[0] + a[2]) / 2, (a[1] + a[3]) / 2) : (c = a[0], a[1]), [c, n];\n        }(h, g);\n        if (h === \"line\" ? (s.color = this.ingredients.colors.stroke, s.length = Math.round(this.dist(g[0], g[1], g[2], g[3])), f = this._getPos(g[0], [1]), r = this._getPos(g[2], [3]), s.loc = u(i, this.width, this.height), s.pos = f === r ? \"at \".concat(f) : \"from \".concat(f, \" to \").concat(r)) : (h === \"point\" ? s.color = this.ingredients.colors.stroke : (s.color = this.ingredients.colors.fill, s.area = this._getArea(h, g)), s.pos = this._getPos.apply(this, y(i)), s.loc = u(i, this.width, this.height)), this.ingredients.shapes[h]) {\n          if (this.ingredients.shapes[h] !== [s]) {\n            for (var l in this.ingredients.shapes[h])\n              JSON.stringify(this.ingredients.shapes[h][l]) === JSON.stringify(s) && (o = !1);\n            o === !0 && this.ingredients.shapes[h].push(s);\n          }\n        } else\n          this.ingredients.shapes[h] = [s];\n      }, m.default.prototype._getPos = function(r, f) {\n        var r = new DOMPointReadOnly(r, f), f = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform(), r = r.matrixTransform(f), f = r.x, r = r.y, s = this.width * this._pixelDensity, o = this.height * this._pixelDensity;\n        return f < 0.4 * s ? r < 0.4 * o ? \"top left\" : 0.6 * o < r ? \"bottom left\" : \"mid left\" : 0.6 * s < f ? r < 0.4 * o ? \"top right\" : 0.6 * o < r ? \"bottom right\" : \"mid right\" : r < 0.4 * o ? \"top middle\" : 0.6 * o < r ? \"bottom middle\" : \"middle\";\n      }, m.default.prototype._getArea = function(h, g) {\n        var f, r, s = 0, o = (h === \"arc\" ? (s = (f = ((g[5] - g[4]) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI)) * g[2] * g[3] / 8, g[6] !== \"open\" && g[6] !== \"chord\" || (r = g[0], a = g[1], o = g[0] + g[2] / 2 * Math.cos(g[4]).toFixed(2), c = g[1] + g[3] / 2 * Math.sin(g[4]).toFixed(2), l = g[0] + g[2] / 2 * Math.cos(g[5]).toFixed(2), i = g[1] + g[3] / 2 * Math.sin(g[5]).toFixed(2), r = Math.abs(r * (c - i) + o * (i - a) + l * (a - c)) / 2, f > Math.PI ? s += r : s -= r)) : h === \"ellipse\" || h === \"circle\" ? s = 3.14 * g[2] / 2 * g[3] / 2 : h === \"line\" || h === \"point\" ? s = 0 : h === \"quadrilateral\" ? s = Math.abs((g[6] + g[0]) * (g[7] - g[1]) + (g[0] + g[2]) * (g[1] - g[3]) + (g[2] + g[4]) * (g[3] - g[5]) + (g[4] + g[6]) * (g[5] - g[7])) / 2 : h === \"rectangle\" || h === \"square\" ? s = g[2] * g[3] : h === \"triangle\" && (s = Math.abs(g[0] * (g[3] - g[5]) + g[2] * (g[5] - g[1]) + g[4] * (g[1] - g[3])) / 2), this.width * this._pixelDensity), i = this.height * this._pixelDensity, l = [new DOMPoint(0, 0), new DOMPoint(o, 0), new DOMPoint(o, i), new DOMPoint(0, i)], n = (this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform()).inverse(), a = l.map(function(p) {\n          return p.matrixTransform(n);\n        }), c = Math.abs((a[3].x + a[0].x) * (a[3].y - a[0].y) + (a[0].x + a[1].x) * (a[0].y - a[1].y) + (a[1].x + a[2].x) * (a[1].y - a[2].y) + (a[2].x + a[3].x) * (a[2].y - a[3].y)) / 2;\n        return Math.round(100 * s / c);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.number.to-fixed\": 180, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 263: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.concat\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.prototype._updateTextOutput = function(m) {\n        var y, u, h, g;\n        this.dummyDOM.querySelector(\"#\".concat(m, \"_summary\")) && (y = this._accessibleOutputs[m], h = function(f, r, s, o) {\n          return s = \"Your output is a, \".concat(s, \" by \").concat(o, \" pixels, \").concat(r, \" canvas containing the following\"), s = f === 1 ? \"\".concat(s, \" shape:\") : \"\".concat(s, \" \").concat(f, \" shapes:\"), s;\n        }((u = function(f, r) {\n          var s, o = \"\", i = 0;\n          for (s in r)\n            for (var l in r[s]) {\n              var n = '<li><a href=\"#'.concat(f, \"shape\").concat(i, '\">').concat(r[s][l].color, \" \").concat(s, \"</a>\");\n              s === \"line\" ? n += \", \".concat(r[s][l].pos, \", \").concat(r[s][l].length, \" pixels long.</li>\") : (n += \", at \".concat(r[s][l].pos), s !== \"point\" && (n += \", covering \".concat(r[s][l].area, \"% of the canvas\")), n += \".</li>\"), o += n, i++;\n            }\n          return { numShapes: i, listShapes: o };\n        }(m, this.ingredients.shapes)).numShapes, this.ingredients.colors.background, this.width, this.height), g = function(f, r) {\n          var s, o = \"\", i = 0;\n          for (s in r)\n            for (var l in r[s]) {\n              var n = '<tr id=\"'.concat(f, \"shape\").concat(i, '\"><th>').concat(r[s][l].color, \" \").concat(s, \"</th>\");\n              s === \"line\" ? n += \"<td>location = \".concat(r[s][l].pos, \"</td><td>length = \").concat(r[s][l].length, \" pixels</td></tr>\") : (n += \"<td>location = \".concat(r[s][l].pos, \"</td>\"), s !== \"point\" && (n += \"<td> area = \".concat(r[s][l].area, \"%</td>\")), n += \"</tr>\"), o += n, i++;\n            }\n          return o;\n        }(m, this.ingredients.shapes), h !== y.summary.innerHTML && (y.summary.innerHTML = h), u.listShapes !== y.list.innerHTML && (y.list.innerHTML = u.listShapes), g !== y.shapeDetails.innerHTML && (y.shapeDetails.innerHTML = g), this._accessibleOutputs[m] = y);\n      }, t = t.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152 }], 264: [function(t, H, C) {\n      var m = (m = t(\"./core/main\")) && m.__esModule ? m : { default: m };\n      t(\"./core/constants\"), t(\"./core/environment\"), t(\"./core/friendly_errors/stacktrace\"), t(\"./core/friendly_errors/validate_params\"), t(\"./core/friendly_errors/file_errors\"), t(\"./core/friendly_errors/fes_core\"), t(\"./core/friendly_errors/sketch_reader\"), t(\"./core/helpers\"), t(\"./core/legacy\"), t(\"./core/preload\"), t(\"./core/p5.Element\"), t(\"./core/p5.Graphics\"), t(\"./core/p5.Renderer\"), t(\"./core/p5.Renderer2D\"), t(\"./core/rendering\"), t(\"./core/shim\"), t(\"./core/structure\"), t(\"./core/transform\"), t(\"./core/shape/2d_primitives\"), t(\"./core/shape/attributes\"), t(\"./core/shape/curves\"), t(\"./core/shape/vertex\"), t(\"./accessibility/outputs\"), t(\"./accessibility/textOutput\"), t(\"./accessibility/gridOutput\"), t(\"./accessibility/color_namer\"), t(\"./color/color_conversion\"), t(\"./color/creating_reading\"), t(\"./color/p5.Color\"), t(\"./color/setting\"), t(\"./data/p5.TypedDict\"), t(\"./data/local_storage.js\"), t(\"./dom/dom\"), t(\"./accessibility/describe\"), t(\"./events/acceleration\"), t(\"./events/keyboard\"), t(\"./events/mouse\"), t(\"./events/touch\"), t(\"./image/filters\"), t(\"./image/image\"), t(\"./image/loading_displaying\"), t(\"./image/p5.Image\"), t(\"./image/pixels\"), t(\"./io/files\"), t(\"./io/p5.Table\"), t(\"./io/p5.TableRow\"), t(\"./io/p5.XML\"), t(\"./math/calculation\"), t(\"./math/math\"), t(\"./math/noise\"), t(\"./math/p5.Vector\"), t(\"./math/random\"), t(\"./math/trigonometry\"), t(\"./typography/attributes\"), t(\"./typography/loading_displaying\"), t(\"./typography/p5.Font\"), t(\"./utilities/array_functions\"), t(\"./utilities/conversion\"), t(\"./utilities/string_functions\"), t(\"./utilities/time_date\"), t(\"./webgl/3d_primitives\"), t(\"./webgl/interaction\"), t(\"./webgl/light\"), t(\"./webgl/loading\"), t(\"./webgl/material\"), t(\"./webgl/p5.Camera\"), t(\"./webgl/p5.DataArray\"), t(\"./webgl/p5.Geometry\"), t(\"./webgl/p5.Matrix\"), t(\"./webgl/p5.RendererGL.Immediate\"), t(\"./webgl/p5.RendererGL\"), t(\"./webgl/p5.RendererGL.Retained\"), t(\"./webgl/p5.Framebuffer\"), t(\"./webgl/p5.Shader\"), t(\"./webgl/p5.RenderBuffer\"), t(\"./webgl/p5.Texture\"), t(\"./webgl/text\"), t(\"./core/init\"), H.exports = m.default;\n    }, { \"./accessibility/color_namer\": 259, \"./accessibility/describe\": 260, \"./accessibility/gridOutput\": 261, \"./accessibility/outputs\": 262, \"./accessibility/textOutput\": 263, \"./color/color_conversion\": 265, \"./color/creating_reading\": 266, \"./color/p5.Color\": 267, \"./color/setting\": 268, \"./core/constants\": 269, \"./core/environment\": 270, \"./core/friendly_errors/fes_core\": 271, \"./core/friendly_errors/file_errors\": 272, \"./core/friendly_errors/sketch_reader\": 273, \"./core/friendly_errors/stacktrace\": 274, \"./core/friendly_errors/validate_params\": 275, \"./core/helpers\": 276, \"./core/init\": 277, \"./core/legacy\": 279, \"./core/main\": 280, \"./core/p5.Element\": 281, \"./core/p5.Graphics\": 282, \"./core/p5.Renderer\": 283, \"./core/p5.Renderer2D\": 284, \"./core/preload\": 285, \"./core/rendering\": 286, \"./core/shape/2d_primitives\": 287, \"./core/shape/attributes\": 288, \"./core/shape/curves\": 289, \"./core/shape/vertex\": 290, \"./core/shim\": 291, \"./core/structure\": 292, \"./core/transform\": 293, \"./data/local_storage.js\": 294, \"./data/p5.TypedDict\": 295, \"./dom/dom\": 296, \"./events/acceleration\": 297, \"./events/keyboard\": 298, \"./events/mouse\": 299, \"./events/touch\": 300, \"./image/filters\": 301, \"./image/image\": 302, \"./image/loading_displaying\": 303, \"./image/p5.Image\": 304, \"./image/pixels\": 305, \"./io/files\": 306, \"./io/p5.Table\": 307, \"./io/p5.TableRow\": 308, \"./io/p5.XML\": 309, \"./math/calculation\": 310, \"./math/math\": 311, \"./math/noise\": 312, \"./math/p5.Vector\": 313, \"./math/random\": 314, \"./math/trigonometry\": 315, \"./typography/attributes\": 316, \"./typography/loading_displaying\": 317, \"./typography/p5.Font\": 318, \"./utilities/array_functions\": 319, \"./utilities/conversion\": 320, \"./utilities/string_functions\": 321, \"./utilities/time_date\": 322, \"./webgl/3d_primitives\": 323, \"./webgl/interaction\": 325, \"./webgl/light\": 326, \"./webgl/loading\": 327, \"./webgl/material\": 328, \"./webgl/p5.Camera\": 329, \"./webgl/p5.DataArray\": 330, \"./webgl/p5.Framebuffer\": 331, \"./webgl/p5.Geometry\": 332, \"./webgl/p5.Matrix\": 333, \"./webgl/p5.RenderBuffer\": 334, \"./webgl/p5.RendererGL\": 337, \"./webgl/p5.RendererGL.Immediate\": 335, \"./webgl/p5.RendererGL.Retained\": 336, \"./webgl/p5.Shader\": 338, \"./webgl/p5.Texture\": 339, \"./webgl/text\": 340 }], 265: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.ColorConversion = { _hsbaToHSLA: function(m) {\n        var y = m[0], u = m[1], h = m[2], g = (2 - u) * h / 2;\n        return g != 0 && (g == 1 ? u = 0 : g < 0.5 ? u /= 2 - u : u = u * h / (2 - 2 * g)), [y, u, g, m[3]];\n      }, _hsbaToRGBA: function(m) {\n        var y, u, h, g, f, r = 6 * m[0], s = m[1], o = m[2];\n        return s === 0 ? [o, o, o, m[3]] : (u = o * (1 - s), h = o * (1 - s * (r - (y = Math.floor(r)))), s = o * (1 - s * (1 + y - r)), r = y === 1 ? (g = h, f = o, u) : y === 2 ? (g = u, f = o, s) : y === 3 ? (g = u, f = h, o) : y === 4 ? (g = s, f = u, o) : y === 5 ? (g = o, f = u, h) : (g = o, f = s, u), [g, f, r, m[3]]);\n      }, _hslaToHSBA: function(m) {\n        var y = m[0], u = m[1], h = m[2], g = h < 0.5 ? (1 + u) * h : h + u - h * u;\n        return [y, u = 2 * (g - h) / g, g, m[3]];\n      }, _hslaToRGBA: function(m) {\n        var y, u = 6 * m[0], h = m[1], g = m[2];\n        return h === 0 ? [g, g, g, m[3]] : [(y = function(f, r, s) {\n          return f < 0 ? f += 6 : 6 <= f && (f -= 6), f < 1 ? r + (s - r) * f : f < 3 ? s : f < 4 ? r + (s - r) * (4 - f) : r;\n        })(2 + u, h = 2 * g - (g = g < 0.5 ? (1 + h) * g : g + h - g * h), g), y(u, h, g), y(u - 2, h, g), m[3]];\n      }, _rgbaToHSBA: function(m) {\n        var y, u, h = m[0], g = m[1], f = m[2], r = Math.max(h, g, f), s = r - Math.min(h, g, f);\n        return s == 0 ? u = y = 0 : (u = s / r, h === r ? y = (g - f) / s : g === r ? y = 2 + (f - h) / s : f === r && (y = 4 + (h - g) / s), y < 0 ? y += 6 : 6 <= y && (y -= 6)), [y / 6, u, r, m[3]];\n      }, _rgbaToHSLA: function(m) {\n        var y, u, h = m[0], g = m[1], f = m[2], r = Math.max(h, g, f), o = Math.min(h, g, f), s = r + o, o = r - o;\n        return o == 0 ? u = y = 0 : (u = s < 1 ? o / s : o / (2 - s), h === r ? y = (g - f) / o : g === r ? y = 2 + (f - h) / o : f === r && (y = 4 + (h - g) / o), y < 0 ? y += 6 : 6 <= y && (y -= 6)), [y / 6, u, s / 2, m[3]];\n      } }, t = t.default.ColorConversion, C.default = t;\n    }, { \"../core/main\": 280 }], 266: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.map\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, h = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\"));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      t(\"./p5.Color\"), t(\"../core/friendly_errors/validate_params\"), t(\"../core/friendly_errors/file_errors\"), t(\"../core/friendly_errors/fes_core\"), u.default.prototype.alpha = function(r) {\n        return u.default._validateParameters(\"alpha\", arguments), this.color(r)._getAlpha();\n      }, u.default.prototype.blue = function(r) {\n        return u.default._validateParameters(\"blue\", arguments), this.color(r)._getBlue();\n      }, u.default.prototype.brightness = function(r) {\n        return u.default._validateParameters(\"brightness\", arguments), this.color(r)._getBrightness();\n      }, u.default.prototype.color = function() {\n        for (var r, s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n          o[i] = arguments[i];\n        return u.default._validateParameters(\"color\", o), o[0] instanceof u.default.Color ? o[0] : (r = Array.isArray(o[0]) ? o[0] : o, new u.default.Color(this, r));\n      }, u.default.prototype.green = function(r) {\n        return u.default._validateParameters(\"green\", arguments), this.color(r)._getGreen();\n      }, u.default.prototype.hue = function(r) {\n        return u.default._validateParameters(\"hue\", arguments), this.color(r)._getHue();\n      }, u.default.prototype.lerpColor = function(r, s, o) {\n        u.default._validateParameters(\"lerpColor\", arguments);\n        var i, l, n, a = this._colorMode, c = this._colorMaxes;\n        if (a === h.RGB)\n          l = r.levels.map(function(p) {\n            return p / 255;\n          }), n = s.levels.map(function(p) {\n            return p / 255;\n          });\n        else if (a === h.HSB)\n          r._getBrightness(), s._getBrightness(), l = r.hsba, n = s.hsba;\n        else {\n          if (a !== h.HSL)\n            throw new Error(\"\".concat(a, \" cannot be used for interpolation.\"));\n          r._getLightness(), s._getLightness(), l = r.hsla, n = s.hsla;\n        }\n        return o = Math.max(Math.min(o, 1), 0), this.lerp === void 0 && (this.lerp = function(p, j, T) {\n          return T * (j - p) + p;\n        }), a === h.RGB ? i = this.lerp(l[0], n[0], o) : (0.5 < Math.abs(l[0] - n[0]) && (l[0] > n[0] ? n[0] += 1 : l[0] += 1), 1 <= (i = this.lerp(l[0], n[0], o)) && --i), r = this.lerp(l[1], n[1], o), s = this.lerp(l[2], n[2], o), l = this.lerp(l[3], n[3], o), i *= c[a][0], r *= c[a][1], s *= c[a][2], l *= c[a][3], this.color(i, r, s, l);\n      }, u.default.prototype.lightness = function(r) {\n        return u.default._validateParameters(\"lightness\", arguments), this.color(r)._getLightness();\n      }, u.default.prototype.red = function(r) {\n        return u.default._validateParameters(\"red\", arguments), this.color(r)._getRed();\n      }, u.default.prototype.saturation = function(r) {\n        return u.default._validateParameters(\"saturation\", arguments), this.color(r)._getSaturation();\n      };\n      var f = u.default;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/friendly_errors/fes_core\": 271, \"../core/friendly_errors/file_errors\": 272, \"../core/friendly_errors/validate_params\": 275, \"../core/main\": 280, \"./p5.Color\": 267, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 267: [function(i, H, C) {\n      function m(p) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(j) {\n          return typeof j;\n        } : function(j) {\n          return j && typeof Symbol == \"function\" && j.constructor === Symbol && j !== Symbol.prototype ? \"symbol\" : typeof j;\n        })(p);\n      }\n      function y(p) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(j) {\n          return m(j);\n        } : function(j) {\n          return j && typeof Symbol == \"function\" && j.constructor === Symbol && j !== Symbol.prototype ? \"symbol\" : m(j);\n        })(p);\n      }\n      i(\"core-js/modules/es.symbol\"), i(\"core-js/modules/es.symbol.description\"), i(\"core-js/modules/es.symbol.iterator\"), i(\"core-js/modules/es.array.includes\"), i(\"core-js/modules/es.array.iterator\"), i(\"core-js/modules/es.array.join\"), i(\"core-js/modules/es.array.map\"), i(\"core-js/modules/es.array.slice\"), i(\"core-js/modules/es.object.get-own-property-descriptor\"), i(\"core-js/modules/es.object.to-string\"), i(\"core-js/modules/es.regexp.constructor\"), i(\"core-js/modules/es.regexp.exec\"), i(\"core-js/modules/es.regexp.to-string\"), i(\"core-js/modules/es.string.includes\"), i(\"core-js/modules/es.string.iterator\"), i(\"core-js/modules/es.string.trim\"), i(\"core-js/modules/es.weak-map\"), i(\"core-js/modules/web.dom-collections.iterator\"), i(\"core-js/modules/es.array.includes\"), i(\"core-js/modules/es.array.join\"), i(\"core-js/modules/es.array.map\"), i(\"core-js/modules/es.array.slice\"), i(\"core-js/modules/es.object.to-string\"), i(\"core-js/modules/es.regexp.constructor\"), i(\"core-js/modules/es.regexp.exec\"), i(\"core-js/modules/es.regexp.to-string\"), i(\"core-js/modules/es.string.includes\"), i(\"core-js/modules/es.string.trim\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = r(i(\"../core/main\")), h = function(p) {\n        if (p && p.__esModule)\n          return p;\n        if (p === null || y(p) !== \"object\" && typeof p != \"function\")\n          return { default: p };\n        var j = f();\n        if (j && j.has(p))\n          return j.get(p);\n        var T, _ = {}, S = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (T in p) {\n          var E;\n          Object.prototype.hasOwnProperty.call(p, T) && ((E = S ? Object.getOwnPropertyDescriptor(p, T) : null) && (E.get || E.set) ? Object.defineProperty(_, T, E) : _[T] = p[T]);\n        }\n        return _.default = p, j && j.set(p, _), _;\n      }(i(\"../core/constants\")), g = r(i(\"./color_conversion\"));\n      function f() {\n        var p;\n        return typeof WeakMap != \"function\" ? null : (p = /* @__PURE__ */ new WeakMap(), f = function() {\n          return p;\n        }, p);\n      }\n      function r(p) {\n        return p && p.__esModule ? p : { default: p };\n      }\n      function s(p, j) {\n        for (var T = 0; T < j.length; T++) {\n          var _ = j[T];\n          _.enumerable = _.enumerable || !1, _.configurable = !0, \"value\" in _ && (_.writable = !0), Object.defineProperty(p, _.key, _);\n        }\n      }\n      var o = { aliceblue: \"#f0f8ff\", antiquewhite: \"#faebd7\", aqua: \"#00ffff\", aquamarine: \"#7fffd4\", azure: \"#f0ffff\", beige: \"#f5f5dc\", bisque: \"#ffe4c4\", black: \"#000000\", blanchedalmond: \"#ffebcd\", blue: \"#0000ff\", blueviolet: \"#8a2be2\", brown: \"#a52a2a\", burlywood: \"#deb887\", cadetblue: \"#5f9ea0\", chartreuse: \"#7fff00\", chocolate: \"#d2691e\", coral: \"#ff7f50\", cornflowerblue: \"#6495ed\", cornsilk: \"#fff8dc\", crimson: \"#dc143c\", cyan: \"#00ffff\", darkblue: \"#00008b\", darkcyan: \"#008b8b\", darkgoldenrod: \"#b8860b\", darkgray: \"#a9a9a9\", darkgreen: \"#006400\", darkgrey: \"#a9a9a9\", darkkhaki: \"#bdb76b\", darkmagenta: \"#8b008b\", darkolivegreen: \"#556b2f\", darkorange: \"#ff8c00\", darkorchid: \"#9932cc\", darkred: \"#8b0000\", darksalmon: \"#e9967a\", darkseagreen: \"#8fbc8f\", darkslateblue: \"#483d8b\", darkslategray: \"#2f4f4f\", darkslategrey: \"#2f4f4f\", darkturquoise: \"#00ced1\", darkviolet: \"#9400d3\", deeppink: \"#ff1493\", deepskyblue: \"#00bfff\", dimgray: \"#696969\", dimgrey: \"#696969\", dodgerblue: \"#1e90ff\", firebrick: \"#b22222\", floralwhite: \"#fffaf0\", forestgreen: \"#228b22\", fuchsia: \"#ff00ff\", gainsboro: \"#dcdcdc\", ghostwhite: \"#f8f8ff\", gold: \"#ffd700\", goldenrod: \"#daa520\", gray: \"#808080\", green: \"#008000\", greenyellow: \"#adff2f\", grey: \"#808080\", honeydew: \"#f0fff0\", hotpink: \"#ff69b4\", indianred: \"#cd5c5c\", indigo: \"#4b0082\", ivory: \"#fffff0\", khaki: \"#f0e68c\", lavender: \"#e6e6fa\", lavenderblush: \"#fff0f5\", lawngreen: \"#7cfc00\", lemonchiffon: \"#fffacd\", lightblue: \"#add8e6\", lightcoral: \"#f08080\", lightcyan: \"#e0ffff\", lightgoldenrodyellow: \"#fafad2\", lightgray: \"#d3d3d3\", lightgreen: \"#90ee90\", lightgrey: \"#d3d3d3\", lightpink: \"#ffb6c1\", lightsalmon: \"#ffa07a\", lightseagreen: \"#20b2aa\", lightskyblue: \"#87cefa\", lightslategray: \"#778899\", lightslategrey: \"#778899\", lightsteelblue: \"#b0c4de\", lightyellow: \"#ffffe0\", lime: \"#00ff00\", limegreen: \"#32cd32\", linen: \"#faf0e6\", magenta: \"#ff00ff\", maroon: \"#800000\", mediumaquamarine: \"#66cdaa\", mediumblue: \"#0000cd\", mediumorchid: \"#ba55d3\", mediumpurple: \"#9370db\", mediumseagreen: \"#3cb371\", mediumslateblue: \"#7b68ee\", mediumspringgreen: \"#00fa9a\", mediumturquoise: \"#48d1cc\", mediumvioletred: \"#c71585\", midnightblue: \"#191970\", mintcream: \"#f5fffa\", mistyrose: \"#ffe4e1\", moccasin: \"#ffe4b5\", navajowhite: \"#ffdead\", navy: \"#000080\", oldlace: \"#fdf5e6\", olive: \"#808000\", olivedrab: \"#6b8e23\", orange: \"#ffa500\", orangered: \"#ff4500\", orchid: \"#da70d6\", palegoldenrod: \"#eee8aa\", palegreen: \"#98fb98\", paleturquoise: \"#afeeee\", palevioletred: \"#db7093\", papayawhip: \"#ffefd5\", peachpuff: \"#ffdab9\", peru: \"#cd853f\", pink: \"#ffc0cb\", plum: \"#dda0dd\", powderblue: \"#b0e0e6\", purple: \"#800080\", rebeccapurple: \"#663399\", red: \"#ff0000\", rosybrown: \"#bc8f8f\", royalblue: \"#4169e1\", saddlebrown: \"#8b4513\", salmon: \"#fa8072\", sandybrown: \"#f4a460\", seagreen: \"#2e8b57\", seashell: \"#fff5ee\", sienna: \"#a0522d\", silver: \"#c0c0c0\", skyblue: \"#87ceeb\", slateblue: \"#6a5acd\", slategray: \"#708090\", slategrey: \"#708090\", snow: \"#fffafa\", springgreen: \"#00ff7f\", steelblue: \"#4682b4\", tan: \"#d2b48c\", teal: \"#008080\", thistle: \"#d8bfd8\", tomato: \"#ff6347\", turquoise: \"#40e0d0\", violet: \"#ee82ee\", wheat: \"#f5deb3\", white: \"#ffffff\", whitesmoke: \"#f5f5f5\", yellow: \"#ffff00\", yellowgreen: \"#9acd32\" }, i = /\\s*/, c = /(\\d{1,3})/, l = /((?:\\d+(?:\\.\\d+)?)|(?:\\.\\d+))/, n = new RegExp(\"\".concat(l.source, \"%\")), a = { HEX3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i, HEX4: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i, HEX6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i, HEX8: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i, RGB: new RegExp([\"^rgb\\\\(\", c.source, \",\", c.source, \",\", c.source, \"\\\\)$\"].join(i.source), \"i\"), RGB_PERCENT: new RegExp([\"^rgb\\\\(\", n.source, \",\", n.source, \",\", n.source, \"\\\\)$\"].join(i.source), \"i\"), RGBA: new RegExp([\"^rgba\\\\(\", c.source, \",\", c.source, \",\", c.source, \",\", l.source, \"\\\\)$\"].join(i.source), \"i\"), RGBA_PERCENT: new RegExp([\"^rgba\\\\(\", n.source, \",\", n.source, \",\", n.source, \",\", l.source, \"\\\\)$\"].join(i.source), \"i\"), HSL: new RegExp([\"^hsl\\\\(\", c.source, \",\", n.source, \",\", n.source, \"\\\\)$\"].join(i.source), \"i\"), HSLA: new RegExp([\"^hsla\\\\(\", c.source, \",\", n.source, \",\", n.source, \",\", l.source, \"\\\\)$\"].join(i.source), \"i\"), HSB: new RegExp([\"^hsb\\\\(\", c.source, \",\", n.source, \",\", n.source, \"\\\\)$\"].join(i.source), \"i\"), HSBA: new RegExp([\"^hsba\\\\(\", c.source, \",\", n.source, \",\", n.source, \",\", l.source, \"\\\\)$\"].join(i.source), \"i\") }, c = (u.default.Color = function() {\n        function p(S, E) {\n          if (!(this instanceof p))\n            throw new TypeError(\"Cannot call a class as a function\");\n          if (this._storeModeAndMaxes(S._colorMode, S._colorMaxes), ![h.RGB, h.HSL, h.HSB].includes(this.mode))\n            throw new Error(\"\".concat(this.mode, \" is an invalid colorMode.\"));\n          this._array = p._parseInputs.apply(this, E), this._calculateLevels();\n        }\n        var j, T, _;\n        return j = p, _ = [{ key: \"_parseInputs\", value: function(S, E, A, x) {\n          var P, M = arguments.length, R = this.mode, L = this.maxes[R], F = [];\n          if (3 <= M) {\n            for (F[0] = S / L[0], F[1] = E / L[1], F[2] = A / L[2], F[3] = typeof x == \"number\" ? x / L[3] : 1, P = F.length - 1; 0 <= P; --P) {\n              var V = F[P];\n              V < 0 ? F[P] = 0 : 1 < V && (F[P] = 1);\n            }\n            return R === h.HSL ? g.default._hslaToRGBA(F) : R === h.HSB ? g.default._hsbaToRGBA(F) : F;\n          }\n          if (M === 1 && typeof S == \"string\") {\n            if (A = S.trim().toLowerCase(), o[A])\n              return p._parseInputs.call(this, o[A]);\n            if (a.HEX3.test(A))\n              return (F = a.HEX3.exec(A).slice(1).map(function(G) {\n                return parseInt(G + G, 16) / 255;\n              }))[3] = 1, F;\n            if (a.HEX6.test(A))\n              return (F = a.HEX6.exec(A).slice(1).map(function(G) {\n                return parseInt(G, 16) / 255;\n              }))[3] = 1, F;\n            if (a.HEX4.test(A))\n              return F = a.HEX4.exec(A).slice(1).map(function(G) {\n                return parseInt(G + G, 16) / 255;\n              });\n            if (a.HEX8.test(A))\n              return F = a.HEX8.exec(A).slice(1).map(function(G) {\n                return parseInt(G, 16) / 255;\n              });\n            if (a.RGB.test(A))\n              return (F = a.RGB.exec(A).slice(1).map(function(G) {\n                return G / 255;\n              }))[3] = 1, F;\n            if (a.RGB_PERCENT.test(A))\n              return (F = a.RGB_PERCENT.exec(A).slice(1).map(function(G) {\n                return parseFloat(G) / 100;\n              }))[3] = 1, F;\n            if (a.RGBA.test(A))\n              return F = a.RGBA.exec(A).slice(1).map(function(G, U) {\n                return U === 3 ? parseFloat(G) : G / 255;\n              });\n            if (a.RGBA_PERCENT.test(A))\n              return F = a.RGBA_PERCENT.exec(A).slice(1).map(function(G, U) {\n                return U === 3 ? parseFloat(G) : parseFloat(G) / 100;\n              });\n            if (a.HSL.test(A) ? (F = a.HSL.exec(A).slice(1).map(function(G, U) {\n              return U === 0 ? parseInt(G, 10) / 360 : parseInt(G, 10) / 100;\n            }))[3] = 1 : a.HSLA.test(A) && (F = a.HSLA.exec(A).slice(1).map(function(G, U) {\n              return U === 0 ? parseInt(G, 10) / 360 : U === 3 ? parseFloat(G) : parseInt(G, 10) / 100;\n            })), (F = F.map(function(G) {\n              return Math.max(Math.min(G, 1), 0);\n            })).length)\n              return g.default._hslaToRGBA(F);\n            if (a.HSB.test(A) ? (F = a.HSB.exec(A).slice(1).map(function(G, U) {\n              return U === 0 ? parseInt(G, 10) / 360 : parseInt(G, 10) / 100;\n            }))[3] = 1 : a.HSBA.test(A) && (F = a.HSBA.exec(A).slice(1).map(function(G, U) {\n              return U === 0 ? parseInt(G, 10) / 360 : U === 3 ? parseFloat(G) : parseInt(G, 10) / 100;\n            })), F.length) {\n              for (P = F.length - 1; 0 <= P; --P)\n                F[P] = Math.max(Math.min(F[P], 1), 0);\n              return g.default._hsbaToRGBA(F);\n            }\n            F = [1, 1, 1, 1];\n          } else {\n            if (M !== 1 && M !== 2 || typeof S != \"number\")\n              throw new Error(\"\".concat(arguments, \"is not a valid color representation.\"));\n            F[0] = S / L[2], F[1] = S / L[2], F[2] = S / L[2], F[3] = typeof E == \"number\" ? E / L[3] : 1, F = F.map(function(G) {\n              return Math.max(Math.min(G, 1), 0);\n            });\n          }\n          return F;\n        } }], (T = [{ key: \"toString\", value: function(S) {\n          var E = this.levels, A = this._array, x = A[3];\n          switch (S) {\n            case \"#rrggbb\":\n              return \"#\".concat(E[0] < 16 ? \"0\".concat(E[0].toString(16)) : E[0].toString(16), E[1] < 16 ? \"0\".concat(E[1].toString(16)) : E[1].toString(16), E[2] < 16 ? \"0\".concat(E[2].toString(16)) : E[2].toString(16));\n            case \"#rrggbbaa\":\n              return \"#\".concat(E[0] < 16 ? \"0\".concat(E[0].toString(16)) : E[0].toString(16), E[1] < 16 ? \"0\".concat(E[1].toString(16)) : E[1].toString(16), E[2] < 16 ? \"0\".concat(E[2].toString(16)) : E[2].toString(16), E[3] < 16 ? \"0\".concat(E[3].toString(16)) : E[3].toString(16));\n            case \"#rgb\":\n              return \"#\".concat(Math.round(15 * A[0]).toString(16), Math.round(15 * A[1]).toString(16), Math.round(15 * A[2]).toString(16));\n            case \"#rgba\":\n              return \"#\".concat(Math.round(15 * A[0]).toString(16), Math.round(15 * A[1]).toString(16), Math.round(15 * A[2]).toString(16), Math.round(15 * A[3]).toString(16));\n            case \"rgb\":\n              return \"rgb(\".concat(E[0], \", \", E[1], \", \", E[2], \")\");\n            case \"rgb%\":\n              return \"rgb(\".concat((100 * A[0]).toPrecision(3), \"%, \", (100 * A[1]).toPrecision(3), \"%, \", (100 * A[2]).toPrecision(3), \"%)\");\n            case \"rgba%\":\n              return \"rgba(\".concat((100 * A[0]).toPrecision(3), \"%, \", (100 * A[1]).toPrecision(3), \"%, \", (100 * A[2]).toPrecision(3), \"%, \", (100 * A[3]).toPrecision(3), \"%)\");\n            case \"hsb\":\n            case \"hsv\":\n              return this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), \"hsb(\".concat(this.hsba[0] * this.maxes[h.HSB][0], \", \", this.hsba[1] * this.maxes[h.HSB][1], \", \", this.hsba[2] * this.maxes[h.HSB][2], \")\");\n            case \"hsb%\":\n            case \"hsv%\":\n              return this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), \"hsb(\".concat((100 * this.hsba[0]).toPrecision(3), \"%, \", (100 * this.hsba[1]).toPrecision(3), \"%, \", (100 * this.hsba[2]).toPrecision(3), \"%)\");\n            case \"hsba\":\n            case \"hsva\":\n              return this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), \"hsba(\".concat(this.hsba[0] * this.maxes[h.HSB][0], \", \", this.hsba[1] * this.maxes[h.HSB][1], \", \", this.hsba[2] * this.maxes[h.HSB][2], \", \", x, \")\");\n            case \"hsba%\":\n            case \"hsva%\":\n              return this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), \"hsba(\".concat((100 * this.hsba[0]).toPrecision(3), \"%, \", (100 * this.hsba[1]).toPrecision(3), \"%, \", (100 * this.hsba[2]).toPrecision(3), \"%, \", (100 * x).toPrecision(3), \"%)\");\n            case \"hsl\":\n              return this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), \"hsl(\".concat(this.hsla[0] * this.maxes[h.HSL][0], \", \", this.hsla[1] * this.maxes[h.HSL][1], \", \", this.hsla[2] * this.maxes[h.HSL][2], \")\");\n            case \"hsl%\":\n              return this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), \"hsl(\".concat((100 * this.hsla[0]).toPrecision(3), \"%, \", (100 * this.hsla[1]).toPrecision(3), \"%, \", (100 * this.hsla[2]).toPrecision(3), \"%)\");\n            case \"hsla\":\n              return this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), \"hsla(\".concat(this.hsla[0] * this.maxes[h.HSL][0], \", \", this.hsla[1] * this.maxes[h.HSL][1], \", \", this.hsla[2] * this.maxes[h.HSL][2], \", \", x, \")\");\n            case \"hsla%\":\n              return this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), \"hsl(\".concat((100 * this.hsla[0]).toPrecision(3), \"%, \", (100 * this.hsla[1]).toPrecision(3), \"%, \", (100 * this.hsla[2]).toPrecision(3), \"%, \", (100 * x).toPrecision(3), \"%)\");\n            default:\n              return \"rgba(\".concat(E[0], \",\", E[1], \",\", E[2], \",\", x, \")\");\n          }\n        } }, { key: \"setRed\", value: function(S) {\n          this._array[0] = S / this.maxes[h.RGB][0], this._calculateLevels();\n        } }, { key: \"setGreen\", value: function(S) {\n          this._array[1] = S / this.maxes[h.RGB][1], this._calculateLevels();\n        } }, { key: \"setBlue\", value: function(S) {\n          this._array[2] = S / this.maxes[h.RGB][2], this._calculateLevels();\n        } }, { key: \"setAlpha\", value: function(S) {\n          this._array[3] = S / this.maxes[this.mode][3], this._calculateLevels();\n        } }, { key: \"_calculateLevels\", value: function() {\n          for (var S = this._array, E = this.levels = new Array(S.length), A = S.length - 1; 0 <= A; --A)\n            E[A] = Math.round(255 * S[A]);\n          this.hsla = null, this.hsba = null;\n        } }, { key: \"_getAlpha\", value: function() {\n          return this._array[3] * this.maxes[this.mode][3];\n        } }, { key: \"_storeModeAndMaxes\", value: function(S, E) {\n          this.mode = S, this.maxes = E;\n        } }, { key: \"_getMode\", value: function() {\n          return this.mode;\n        } }, { key: \"_getMaxes\", value: function() {\n          return this.maxes;\n        } }, { key: \"_getBlue\", value: function() {\n          return this._array[2] * this.maxes[h.RGB][2];\n        } }, { key: \"_getBrightness\", value: function() {\n          return this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), this.hsba[2] * this.maxes[h.HSB][2];\n        } }, { key: \"_getGreen\", value: function() {\n          return this._array[1] * this.maxes[h.RGB][1];\n        } }, { key: \"_getHue\", value: function() {\n          return this.mode === h.HSB ? (this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), this.hsba[0] * this.maxes[h.HSB][0]) : (this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), this.hsla[0] * this.maxes[h.HSL][0]);\n        } }, { key: \"_getLightness\", value: function() {\n          return this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), this.hsla[2] * this.maxes[h.HSL][2];\n        } }, { key: \"_getRed\", value: function() {\n          return this._array[0] * this.maxes[h.RGB][0];\n        } }, { key: \"_getSaturation\", value: function() {\n          return this.mode === h.HSB ? (this.hsba || (this.hsba = g.default._rgbaToHSBA(this._array)), this.hsba[1] * this.maxes[h.HSB][1]) : (this.hsla || (this.hsla = g.default._rgbaToHSLA(this._array)), this.hsla[1] * this.maxes[h.HSL][1]);\n        } }]) && s(j.prototype, T), _ && s(j, _), p;\n      }(), u.default.Color);\n      C.default = c;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./color_conversion\": 265, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.constructor\": 191, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 268: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.fill\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, h = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\"));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      t(\"./p5.Color\"), u.default.prototype.beginClip = function() {\n        this._renderer.beginClip(0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {});\n      }, u.default.prototype.endClip = function() {\n        this._renderer.endClip();\n      }, u.default.prototype.clip = function(r, s) {\n        this._renderer.beginClip(s), r(), this._renderer.endClip(s);\n      }, u.default.prototype.background = function() {\n        var r;\n        return (r = this._renderer).background.apply(r, arguments), this;\n      }, u.default.prototype.clear = function() {\n        return this._renderer.clear((arguments.length <= 0 ? void 0 : arguments[0]) || 0, (arguments.length <= 1 ? void 0 : arguments[1]) || 0, (arguments.length <= 2 ? void 0 : arguments[2]) || 0, (arguments.length <= 3 ? void 0 : arguments[3]) || 0), this;\n      }, u.default.prototype.colorMode = function(r, s, o, i, l) {\n        return u.default._validateParameters(\"colorMode\", arguments), r !== h.RGB && r !== h.HSB && r !== h.HSL || (this._colorMode = r, r = this._colorMaxes[r], arguments.length === 2 ? (r[0] = s, r[1] = s, r[2] = s, r[3] = s) : arguments.length === 4 ? (r[0] = s, r[1] = o, r[2] = i) : arguments.length === 5 && (r[0] = s, r[1] = o, r[2] = i, r[3] = l)), this;\n      }, u.default.prototype.fill = function() {\n        var r;\n        return this._renderer._setProperty(\"_fillSet\", !0), this._renderer._setProperty(\"_doFill\", !0), (r = this._renderer).fill.apply(r, arguments), this;\n      }, u.default.prototype.noFill = function() {\n        return this._renderer._setProperty(\"_doFill\", !1), this;\n      }, u.default.prototype.noStroke = function() {\n        return this._renderer._setProperty(\"_doStroke\", !1), this;\n      }, u.default.prototype.stroke = function() {\n        var r;\n        return this._renderer._setProperty(\"_strokeSet\", !0), this._renderer._setProperty(\"_doStroke\", !0), (r = this._renderer).stroke.apply(r, arguments), this;\n      }, u.default.prototype.erase = function() {\n        return this._renderer.erase(0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 255, 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 255), this;\n      }, u.default.prototype.noErase = function() {\n        return this._renderer.noErase(), this;\n      };\n      var f = u.default;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.Color\": 267, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 269: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.QUADRATIC = C.LINEAR = C._CTX_MIDDLE = C._DEFAULT_LEADMULT = C._DEFAULT_TEXT_FILL = C.WORD = C.CHAR = C.BOLDITALIC = C.BOLD = C.ITALIC = C.NORMAL = C.BLUR = C.ERODE = C.DILATE = C.POSTERIZE = C.INVERT = C.OPAQUE = C.GRAY = C.THRESHOLD = C.BURN = C.DODGE = C.SOFT_LIGHT = C.HARD_LIGHT = C.OVERLAY = C.REPLACE = C.SCREEN = C.MULTIPLY = C.EXCLUSION = C.SUBTRACT = C.DIFFERENCE = C.LIGHTEST = C.DARKEST = C.ADD = C.REMOVE = C.BLEND = C.UP_ARROW = C.TAB = C.SHIFT = C.RIGHT_ARROW = C.RETURN = C.OPTION = C.LEFT_ARROW = C.ESCAPE = C.ENTER = C.DOWN_ARROW = C.DELETE = C.CONTROL = C.BACKSPACE = C.ALT = C.AUTO = C.HSL = C.HSB = C.RGB = C.MITER = C.BEVEL = C.ROUND = C.SQUARE = C.PROJECT = C.PIE = C.CHORD = C.OPEN = C.CLOSE = C.TESS = C.QUAD_STRIP = C.QUADS = C.TRIANGLE_STRIP = C.TRIANGLE_FAN = C.TRIANGLES = C.LINE_LOOP = C.LINE_STRIP = C.LINES = C.POINTS = C.BASELINE = C.BOTTOM = C.TOP = C.CENTER = C.LEFT = C.RIGHT = C.RADIUS = C.CORNERS = C.CORNER = C.RAD_TO_DEG = C.DEG_TO_RAD = C.RADIANS = C.DEGREES = C.TWO_PI = C.TAU = C.QUARTER_PI = C.PI = C.HALF_PI = C.WAIT = C.TEXT = C.MOVE = C.HAND = C.CROSS = C.ARROW = C.WEBGL2 = C.WEBGL = C.P2D = C.VERSION = void 0, C.RGBA = C.HALF_FLOAT = C.FLOAT = C.UNSIGNED_INT = C.UNSIGNED_BYTE = C.COVER = C.CONTAIN = C.FALLBACK = C.LABEL = C.AXES = C.GRID = C._DEFAULT_FILL = C._DEFAULT_STROKE = C.PORTRAIT = C.LANDSCAPE = C.SMOOTH = C.FLAT = C.MIRROR = C.CLAMP = C.REPEAT = C.NEAREST = C.IMAGE = C.IMMEDIATE = C.TEXTURE = C.FILL = C.STROKE = C.CURVE = C.BEZIER = void 0;\n      var m = Math.PI, y = (C.VERSION = \"1.9.4\", C.P2D = \"p2d\", C.WEBGL = \"webgl\", C.WEBGL2 = \"webgl2\", C.ARROW = \"default\", C.CROSS = \"crosshair\", C.HAND = \"pointer\", C.MOVE = \"move\", C.TEXT = \"text\", C.WAIT = \"wait\", m / 2), y = (C.HALF_PI = y, m), y = (C.PI = y, m / 4), y = (C.QUARTER_PI = y, 2 * m), y = (C.TAU = y, 2 * m), y = (C.TWO_PI = y, C.DEGREES = \"degrees\", C.RADIANS = \"radians\", m / 180), y = (C.DEG_TO_RAD = y, 180 / m);\n      C.RAD_TO_DEG = y, C.CORNER = \"corner\", C.CORNERS = \"corners\", C.RADIUS = \"radius\", C.RIGHT = \"right\", C.LEFT = \"left\", C.CENTER = \"center\", C.TOP = \"top\", C.BOTTOM = \"bottom\", C.BASELINE = \"alphabetic\", C.POINTS = 0, C.LINES = 1, C.LINE_STRIP = 3, C.LINE_LOOP = 2, C.TRIANGLES = 4, C.TRIANGLE_FAN = 6, C.TRIANGLE_STRIP = 5, C.QUADS = \"quads\", C.QUAD_STRIP = \"quad_strip\", C.TESS = \"tess\", C.CLOSE = \"close\", C.OPEN = \"open\", C.CHORD = \"chord\", C.PIE = \"pie\", C.PROJECT = \"square\", C.SQUARE = \"butt\", C.ROUND = \"round\", C.BEVEL = \"bevel\", C.MITER = \"miter\", C.RGB = \"rgb\", C.HSB = \"hsb\", C.HSL = \"hsl\", C.AUTO = \"auto\", C.ALT = 18, C.BACKSPACE = 8, C.CONTROL = 17, C.DELETE = 46, C.DOWN_ARROW = 40, C.ENTER = 13, C.ESCAPE = 27, C.LEFT_ARROW = 37, C.OPTION = 18, C.RETURN = 13, C.RIGHT_ARROW = 39, C.SHIFT = 16, C.TAB = 9, C.UP_ARROW = 38, C.BLEND = \"source-over\", C.REMOVE = \"destination-out\", C.ADD = \"lighter\", C.DARKEST = \"darken\", C.LIGHTEST = \"lighten\", C.DIFFERENCE = \"difference\", C.SUBTRACT = \"subtract\", C.EXCLUSION = \"exclusion\", C.MULTIPLY = \"multiply\", C.SCREEN = \"screen\", C.REPLACE = \"copy\", C.OVERLAY = \"overlay\", C.HARD_LIGHT = \"hard-light\", C.SOFT_LIGHT = \"soft-light\", C.DODGE = \"color-dodge\", C.BURN = \"color-burn\", C.THRESHOLD = \"threshold\", C.GRAY = \"gray\", C.OPAQUE = \"opaque\", C.INVERT = \"invert\", C.POSTERIZE = \"posterize\", C.DILATE = \"dilate\", C.ERODE = \"erode\", C.BLUR = \"blur\", C.NORMAL = \"normal\", C.ITALIC = \"italic\", C.BOLD = \"bold\", C.BOLDITALIC = \"bold italic\", C.CHAR = \"CHAR\", C.WORD = \"WORD\", C._DEFAULT_TEXT_FILL = \"#000000\", C._DEFAULT_LEADMULT = 1.25, C._CTX_MIDDLE = \"middle\", C.LINEAR = \"linear\", C.QUADRATIC = \"quadratic\", C.BEZIER = \"bezier\", C.CURVE = \"curve\", C.STROKE = \"stroke\", C.FILL = \"fill\", C.TEXTURE = \"texture\", C.IMMEDIATE = \"immediate\", C.IMAGE = \"image\", C.NEAREST = \"nearest\", C.REPEAT = \"repeat\", C.CLAMP = \"clamp\", C.MIRROR = \"mirror\", C.FLAT = \"flat\", C.SMOOTH = \"smooth\", C.LANDSCAPE = \"landscape\", C.PORTRAIT = \"portrait\", C._DEFAULT_STROKE = \"#000000\", C._DEFAULT_FILL = \"#FFFFFF\", C.GRID = \"grid\", C.AXES = \"axes\", C.LABEL = \"label\", C.FALLBACK = \"fallback\", C.CONTAIN = \"contain\", C.COVER = \"cover\", C.UNSIGNED_BYTE = \"unsigned-byte\", C.UNSIGNED_INT = \"unsigned-int\", C.FLOAT = \"float\", C.HALF_FLOAT = \"half-float\", C.RGBA = \"rgba\";\n    }, {}], 270: [function(t, H, C) {\n      function m(l) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(n) {\n          return typeof n;\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : typeof n;\n        })(l);\n      }\n      function y(l) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(n) {\n          return m(n);\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : m(n);\n        })(l);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.search\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.search\"), t(\"core-js/modules/es.string.split\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (h = t(\"./main\")) && h.__esModule ? h : { default: h }, h = function(l) {\n        if (l && l.__esModule)\n          return l;\n        if (l === null || y(l) !== \"object\" && typeof l != \"function\")\n          return { default: l };\n        var n = g();\n        if (n && n.has(l))\n          return n.get(l);\n        var a, c = {}, p = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (a in l) {\n          var j;\n          Object.prototype.hasOwnProperty.call(l, a) && ((j = p ? Object.getOwnPropertyDescriptor(l, a) : null) && (j.get || j.set) ? Object.defineProperty(c, a, j) : c[a] = l[a]);\n        }\n        return c.default = l, n && n.set(l, c), c;\n      }(t(\"./constants\"));\n      function g() {\n        var l;\n        return typeof WeakMap != \"function\" ? null : (l = /* @__PURE__ */ new WeakMap(), g = function() {\n          return l;\n        }, l);\n      }\n      var f = [h.ARROW, h.CROSS, h.HAND, h.MOVE, h.TEXT, h.WAIT], r = (u.default.prototype._frameRate = 0, u.default.prototype._lastFrameTime = window.performance.now(), u.default.prototype._targetFrameRate = 60, window.print), s = !1;\n      function o() {\n        return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;\n      }\n      function i() {\n        return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;\n      }\n      u.default.prototype.print = function() {\n        var l;\n        arguments.length ? (l = console).log.apply(l, arguments) : s || (r(), window.confirm(\"You just tried to print the webpage. Do you want to prevent this from running again?\") && (s = !0));\n      }, u.default.prototype.frameCount = 0, u.default.prototype.deltaTime = 0, u.default.prototype.focused = document.hasFocus(), u.default.prototype.cursor = function(l, n, a) {\n        var c, p = \"auto\", j = this._curElement.elt;\n        f.includes(l) ? p = l : typeof l == \"string\" && (c = \"\", n && a && typeof n == \"number\" && typeof a == \"number\" && (c = \"\".concat(n, \" \").concat(a)), p = l.substring(0, 7) === \"http://\" || l.substring(0, 8) === \"https://\" || /\\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(l) ? \"url(\".concat(l, \") \").concat(c, \", auto\") : l), j.style.cursor = p;\n      }, u.default.prototype.frameRate = function(l) {\n        return u.default._validateParameters(\"frameRate\", arguments), typeof l != \"number\" || l < 0 ? this._frameRate : (this._setProperty(\"_targetFrameRate\", l), l === 0 && this._setProperty(\"_frameRate\", l), this);\n      }, u.default.prototype.getFrameRate = function() {\n        return this.frameRate();\n      }, u.default.prototype.setFrameRate = function(l) {\n        return this.frameRate(l);\n      }, u.default.prototype.getTargetFrameRate = function() {\n        return this._targetFrameRate;\n      }, u.default.prototype.noCursor = function() {\n        this._curElement.elt.style.cursor = \"none\";\n      }, u.default.prototype.webglVersion = h.P2D, u.default.prototype.displayWidth = screen.width, u.default.prototype.displayHeight = screen.height, u.default.prototype.windowWidth = o(), u.default.prototype.windowHeight = i(), u.default.prototype._onresize = function(l) {\n        this._setProperty(\"windowWidth\", o()), this._setProperty(\"windowHeight\", i());\n        var n = this._isGlobal ? window : this;\n        typeof n.windowResized != \"function\" || (n = n.windowResized(l)) === void 0 || n || l.preventDefault();\n      }, u.default.prototype.width = 0, u.default.prototype.height = 0, u.default.prototype.fullscreen = function(l) {\n        if (u.default._validateParameters(\"fullscreen\", arguments), l === void 0)\n          return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n        if (l) {\n          if (l = document.documentElement, !(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled))\n            throw new Error(\"Fullscreen not enabled in this browser.\");\n          l.requestFullscreen ? l.requestFullscreen() : l.mozRequestFullScreen ? l.mozRequestFullScreen() : l.webkitRequestFullscreen ? l.webkitRequestFullscreen() : l.msRequestFullscreen && l.msRequestFullscreen();\n        } else\n          document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();\n      }, u.default.prototype.pixelDensity = function(l) {\n        var n;\n        return u.default._validateParameters(\"pixelDensity\", arguments), typeof l == \"number\" ? (l !== this._pixelDensity && (this._pixelDensity = this._maxAllowedPixelDimensions = l), (n = this).resizeCanvas(this.width, this.height, !0)) : n = this._pixelDensity, n;\n      }, u.default.prototype.displayDensity = function() {\n        return window.devicePixelRatio;\n      }, u.default.prototype.getURL = function() {\n        return location.href;\n      }, u.default.prototype.getURLPath = function() {\n        return location.pathname.split(\"/\").filter(function(l) {\n          return l !== \"\";\n        });\n      }, u.default.prototype.getURLParams = function() {\n        for (var l, n = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim, a = {}; (l = n.exec(location.search)) != null; )\n          l.index === n.lastIndex && n.lastIndex++, a[l[1]] = l[2];\n        return a;\n      }, t = u.default, C.default = t;\n    }, { \"./constants\": 269, \"./main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.search\": 202, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 271: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-own-property-names\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.starts-with\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-own-property-names\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.starts-with\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (f = t(\"../main\")) && f.__esModule ? f : { default: f };\n      t(\"../internationalization\");\n      function y(r, s) {\n        s = s || console.log.bind(console), u || g(), u.some(function(o) {\n          var i;\n          if (r.message && r.message.match(\"\\\\W?\".concat(o.name, \"\\\\W\")) !== null)\n            return i = o.type === \"function\" ? \"\".concat(o.name, \"()\") : o.name, s(\"Did you just try to use p5.js's \".concat(i, \" \").concat(o.type, `? If so, you may want to move it into your sketch's setup() function.\n\nFor more details, see: `).concat(h)), !0;\n        });\n      }\n      var u = null, g = null, h = (m.default._friendlyError = m.default._checkForUserDefinedFunctions = m.default._fesErrorMonitor = function() {\n      }, u = null, \"https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup\"), g = function() {\n        function r(o) {\n          return Object.getOwnPropertyNames(o).filter(function(i) {\n            return i[0] !== \"_\" && !(i in s) && (s[i] = !0);\n          }).map(function(i) {\n            var l = typeof o[i] == \"function\" ? \"function\" : i === i.toUpperCase() ? \"constant\" : \"variable\";\n            return { name: i, type: l };\n          });\n        }\n        var s = {};\n        (u = [].concat(r(m.default.prototype), r(t(\"../constants\")))).sort(function(o, i) {\n          return i.name.length - o.name.length;\n        });\n      }, f = (m.default.prototype._helpForMisusedAtTopLevelCode = y, document.readyState !== \"complete\" && (window.addEventListener(\"error\", y, !1), window.addEventListener(\"load\", function() {\n        window.removeEventListener(\"error\", y, !1);\n      })), m.default);\n      C.default = f;\n    }, { \"../constants\": 269, \"../internationalization\": 278, \"../main\": 280, \"./browser_errors\": void 0, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.some\": 169, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.get-own-property-names\": 184, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.constructor\": 191, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.starts-with\": 204, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 272: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (m = t(\"../main\")) && m.__esModule ? m : { default: m };\n      t(\"../internationalization\"), m.default._friendlyFileLoadError = function() {\n      }, t = m.default, C.default = t;\n    }, { \"../internationalization\": 278, \"../main\": 280 }], 273: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      function y(s) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.for-each\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = f(t(\"../main\"));\n      t(\"../internationalization\"), g(t(\"../constants\"));\n      function h() {\n        var s;\n        return typeof WeakMap != \"function\" ? null : (s = /* @__PURE__ */ new WeakMap(), h = function() {\n          return s;\n        }, s);\n      }\n      function g(s) {\n        if (s && s.__esModule)\n          return s;\n        if (s === null || y(s) !== \"object\" && typeof s != \"function\")\n          return { default: s };\n        var o = h();\n        if (o && o.has(s))\n          return o.get(s);\n        var i, l, n = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (i in s)\n          Object.prototype.hasOwnProperty.call(s, i) && ((l = a ? Object.getOwnPropertyDescriptor(s, i) : null) && (l.get || l.set) ? Object.defineProperty(n, i, l) : n[i] = s[i]);\n        return n.default = s, o && o.set(s, n), n;\n      }\n      function f(s) {\n        return s && s.__esModule ? s : { default: s };\n      }\n      u.default._fesCodeReader = function() {\n      };\n      var r = u.default;\n      C.default = r;\n    }, { \"../constants\": 269, \"../internationalization\": 278, \"../main\": 280, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.constructor\": 191, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 274: [function(t, H, C) {\n      t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../main\")) && t.__esModule ? t : { default: t };\n      function m() {\n        var y = /(^|@)\\S+:\\d+/, u = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m, h = /^(eval@)?(\\[native code])?$/;\n        return { parse: function(g) {\n          return g.stacktrace !== void 0 || g[\"opera#sourceloc\"] !== void 0 ? this.parseOpera(g) : g.stack && g.stack.match(u) ? this.parseV8OrIE(g) : g.stack ? this.parseFFOrSafari(g) : void 0;\n        }, extractLocation: function(g) {\n          return g.indexOf(\":\") === -1 ? [g] : [(g = /(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(g.replace(/[()]/g, \"\")))[1], g[2] || void 0, g[3] || void 0];\n        }, parseV8OrIE: function(g) {\n          return g.stack.split(`\n`).filter(function(f) {\n            return !!f.match(u);\n          }, this).map(function(f) {\n            var r = (f = -1 < f.indexOf(\"(eval \") ? f.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(\\),.*$)/g, \"\") : f).replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\"), s = r.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/), r = (r = s ? r.replace(s[0], \"\") : r).split(/\\s+/).slice(1), s = this.extractLocation(s ? s[1] : r.pop());\n            return { functionName: r.join(\" \") || void 0, fileName: -1 < [\"eval\", \"<anonymous>\"].indexOf(s[0]) ? void 0 : s[0], lineNumber: s[1], columnNumber: s[2], source: f };\n          }, this);\n        }, parseFFOrSafari: function(g) {\n          return g.stack.split(`\n`).filter(function(f) {\n            return !f.match(h);\n          }, this).map(function(f) {\n            var r, s;\n            return (f = -1 < f.indexOf(\" > eval\") ? f.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\") : f).indexOf(\"@\") === -1 && f.indexOf(\":\") === -1 ? { functionName: f } : { functionName: (s = f.match(r = /((.*\".+\"[^@]*)?[^@]*)(?:@)/)) && s[1] ? s[1] : void 0, fileName: (s = this.extractLocation(f.replace(r, \"\")))[0], lineNumber: s[1], columnNumber: s[2], source: f };\n          }, this);\n        }, parseOpera: function(g) {\n          return !g.stacktrace || -1 < g.message.indexOf(`\n`) && g.message.split(`\n`).length > g.stacktrace.split(`\n`).length ? this.parseOpera9(g) : g.stack ? this.parseOpera11(g) : this.parseOpera10(g);\n        }, parseOpera9: function(g) {\n          for (var f = /Line (\\d+).*script (?:in )?(\\S+)/i, r = g.message.split(`\n`), s = [], o = 2, i = r.length; o < i; o += 2) {\n            var l = f.exec(r[o]);\n            l && s.push({ fileName: l[2], lineNumber: l[1], source: r[o] });\n          }\n          return s;\n        }, parseOpera10: function(g) {\n          for (var f = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i, r = g.stacktrace.split(`\n`), s = [], o = 0, i = r.length; o < i; o += 2) {\n            var l = f.exec(r[o]);\n            l && s.push({ functionName: l[3] || void 0, fileName: l[2], lineNumber: l[1], source: r[o] });\n          }\n          return s;\n        }, parseOpera11: function(g) {\n          return g.stack.split(`\n`).filter(function(f) {\n            return !!f.match(y) && !f.match(/^Error created at/);\n          }, this).map(function(f) {\n            var r, o = f.split(\"@\"), s = this.extractLocation(o.pop()), o = o.shift() || \"\";\n            return { functionName: o.replace(/<anonymous function(: (\\w+))?>/, \"$2\").replace(/\\([^)]*\\)/g, \"\") || void 0, args: (r = o.match(/\\(([^)]*)\\)/) ? o.replace(/^[^(]+\\(([^)]*)\\)$/, \"$1\") : r) === void 0 || r === \"[arguments not available]\" ? void 0 : r.split(\",\"), fileName: s[0], lineNumber: s[1], columnNumber: s[2], source: f };\n          }, this);\n        } };\n      }\n      t.default._getErrorStackParser = function() {\n        return new m();\n      }, t = t.default, C.default = t;\n    }, { \"../main\": 280, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203 }], 275: [function(t, H, C) {\n      function m(g) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(f) {\n          return typeof f;\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : typeof f;\n        })(g);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.map\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (y = t(\"../main\")) && y.__esModule ? y : { default: y };\n      (function(g) {\n        if (!(g && g.__esModule) && !(g === null || h(g) !== \"object\" && typeof g != \"function\")) {\n          var f = u();\n          if (f && f.has(g))\n            return f.get(g);\n          var r, s = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (r in g) {\n            var i;\n            Object.prototype.hasOwnProperty.call(g, r) && ((i = o ? Object.getOwnPropertyDescriptor(g, r) : null) && (i.get || i.set) ? Object.defineProperty(s, r, i) : s[r] = g[r]);\n          }\n          s.default = g, f && f.set(g, s);\n        }\n      })(t(\"../constants\")), t(\"../internationalization\");\n      function u() {\n        var g;\n        return typeof WeakMap != \"function\" ? null : (g = /* @__PURE__ */ new WeakMap(), u = function() {\n          return g;\n        }, g);\n      }\n      function h(g) {\n        return (h = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(f) {\n          return m(f);\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : m(f);\n        })(g);\n      }\n      y.default._validateParameters = y.default._clearValidateParamsCache = function() {\n      }, t = y.default, C.default = t;\n    }, { \"../../../docs/parameterData.json\": void 0, \"../constants\": 269, \"../internationalization\": 278, \"../main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.last-index-of\": 166, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.map\": 174, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.set\": 194, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 276: [function(t, H, C) {\n      function m(g) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(f) {\n          return typeof f;\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : typeof f;\n        })(g);\n      }\n      function y(g) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(f) {\n          return m(f);\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : m(f);\n        })(g);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = function(g) {\n        if (g && g.__esModule)\n          return g;\n        if (g === null || y(g) !== \"object\" && typeof g != \"function\")\n          return { default: g };\n        var f = h();\n        if (f && f.has(g))\n          return f.get(g);\n        var r, s = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (r in g) {\n          var i;\n          Object.prototype.hasOwnProperty.call(g, r) && ((i = o ? Object.getOwnPropertyDescriptor(g, r) : null) && (i.get || i.set) ? Object.defineProperty(s, r, i) : s[r] = g[r]);\n        }\n        return s.default = g, f && f.set(g, s), s;\n      }(t(\"./constants\"));\n      function h() {\n        var g;\n        return typeof WeakMap != \"function\" ? null : (g = /* @__PURE__ */ new WeakMap(), h = function() {\n          return g;\n        }, g);\n      }\n      C.default = { modeAdjust: function(g, f, r, s, o) {\n        return o === u.CORNER ? { x: g, y: f, w: r, h: s } : o === u.CORNERS ? { x: g, y: f, w: r - g, h: s - f } : o === u.RADIUS ? { x: g - r, y: f - s, w: 2 * r, h: 2 * s } : o === u.CENTER ? { x: g - 0.5 * r, y: f - 0.5 * s, w: r, h: s } : void 0;\n      } };\n    }, { \"./constants\": 269, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 277: [function(t, H, C) {\n      t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\");\n      var m = (y = t(\"../core/main\")) && y.__esModule ? y : { default: y };\n      t(\"./internationalization\");\n      var y = Promise.resolve();\n      Promise.all([new Promise(function(u, h) {\n        document.readyState === \"complete\" ? u() : window.addEventListener(\"load\", u, !1);\n      }), y]).then(function() {\n        window._setupDone !== void 0 ? console.warn(\"p5.js seems to have been imported multiple times. Please remove the duplicate import\") : window.mocha || (window.setup && typeof window.setup == \"function\" || window.draw && typeof window.draw == \"function\") && !m.default.instance && new m.default();\n      });\n    }, { \"../core/main\": 280, \"./internationalization\": 278, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/web.dom-collections.iterator\": 243 }], 278: [function(t, H, C) {\n      t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.setTranslatorLanguage = C.currentTranslatorLanguage = C.availableTranslatorLanguages = C.initialize = C.translator = void 0;\n      var m, y, u = g(t(\"i18next\")), h = g(t(\"i18next-browser-languagedetector\"));\n      function g(s) {\n        return s && s.__esModule ? s : { default: s };\n      }\n      function f(s, o) {\n        for (var i = 0; i < o.length; i++) {\n          var l = o[i];\n          l.enumerable = l.enumerable || !1, l.configurable = !0, \"value\" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);\n        }\n      }\n      var r = function() {\n        function s(l, n) {\n          if (!(this instanceof s))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.init(l, n);\n        }\n        var o, i;\n        return o = s, (i = [{ key: \"fetchWithTimeout\", value: function(l, n) {\n          var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 2e3;\n          return Promise.race([fetch(l, n), new Promise(function(c, p) {\n            return setTimeout(function() {\n              return p(new Error(\"timeout\"));\n            }, a);\n          })]);\n        } }, { key: \"init\", value: function(l) {\n          var n = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};\n          this.services = l, this.options = n;\n        } }, { key: \"read\", value: function(l, n, a) {\n          var c = this.options.loadPath;\n          l === this.options.fallback ? a(null, m[l][n]) : y.includes(l) ? (c = this.services.interpolator.interpolate(c, { lng: l, ns: n }), this.loadUrl(c, a)) : a(\"Not found\", !1);\n        } }, { key: \"loadUrl\", value: function(l, n) {\n          this.fetchWithTimeout(l).then(function(a) {\n            if (a.ok)\n              return a.json();\n            throw new Error(\"failed loading \".concat(l));\n          }, function() {\n            throw new Error(\"failed loading \".concat(l));\n          }).then(function(a) {\n            return n(null, a);\n          }).catch(n);\n        } }]) && f(o.prototype, i), s;\n      }();\n      r.type = \"backend\", C.translator = function(s, o) {\n        console.debug(\"p5.js translator called before translations were loaded\"), u.default.t(s, o);\n      }, C.initialize = function() {\n        return u.default.use(h.default).use(r).init({ fallbackLng: \"en\", nestingPrefix: \"$tr(\", nestingSuffix: \")\", defaultNS: \"translation\", returnEmptyString: !1, interpolation: { escapeValue: !1 }, detection: { checkWhitelist: !1, order: [\"querystring\", \"navigator\", \"htmlTag\", \"path\", \"subdomain\"], caches: [] }, backend: { fallback: \"en\", loadPath: \"https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json\" }, partialBundledLanguages: !0, resources: m }).then(function(s) {\n          C.translator = s;\n        }, function(s) {\n          return console.debug(\"Translations failed to load (\".concat(s, \")\"));\n        });\n      }, C.availableTranslatorLanguages = function() {\n        return u.default.languages;\n      }, C.currentTranslatorLanguage = function(s) {\n        return u.default.language;\n      }, C.setTranslatorLanguage = function(s) {\n        return u.default.changeLanguage(s || void 0, function(o) {\n          return console.debug(\"Translations failed to load (\".concat(o, \")\"));\n        });\n      };\n    }, { \"../../translations\": void 0, \"../../translations/dev\": void 0, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.split\": 203, \"core-js/modules/web.dom-collections.iterator\": 243, i18next: 3, \"i18next-browser-languagedetector\": 3 }], 279: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"./main\")) && t.__esModule ? t : { default: t }, t.default.prototype.pushStyle = function() {\n        throw new Error(\"pushStyle() not used, see push()\");\n      }, t.default.prototype.popStyle = function() {\n        throw new Error(\"popStyle() not used, see pop()\");\n      }, t.default.prototype.popMatrix = function() {\n        throw new Error(\"popMatrix() not used, see pop()\");\n      }, t.default.prototype.pushMatrix = function() {\n        throw new Error(\"pushMatrix() not used, see push()\");\n      }, t = t.default, C.default = t;\n    }, { \"./main\": 280 }], 280: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      function y(s) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.get-own-property-names\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.get-own-property-names\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t(\"./shim\");\n      var u = function(s) {\n        if (s && s.__esModule)\n          return s;\n        if (s === null || y(s) !== \"object\" && typeof s != \"function\")\n          return { default: s };\n        var o = h();\n        if (o && o.has(s))\n          return o.get(s);\n        var i, l = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (i in s) {\n          var a;\n          Object.prototype.hasOwnProperty.call(s, i) && ((a = n ? Object.getOwnPropertyDescriptor(s, i) : null) && (a.get || a.set) ? Object.defineProperty(l, i, a) : l[i] = s[i]);\n        }\n        return l.default = s, o && o.set(s, l), l;\n      }(t(\"./constants\"));\n      function h() {\n        var s;\n        return typeof WeakMap != \"function\" ? null : (s = /* @__PURE__ */ new WeakMap(), h = function() {\n          return s;\n        }, s);\n      }\n      function g(s, o) {\n        for (var i = 0; i < o.length; i++) {\n          var l = o[i];\n          l.enumerable = l.enumerable || !1, l.configurable = !0, \"value\" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);\n        }\n      }\n      var f, r = function() {\n        function s(l, c) {\n          var a = this;\n          if (!(this instanceof s))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this._setupDone = !1, this._preloadDone = !1, this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1, this._maxAllowedPixelDimensions = 0, this._userNode = c, this._curElement = null, this._elements = [], this._glAttributes = null, this._requestAnimId = 0, this._preloadCount = 0, this._isGlobal = !1, this._loop = !0, this._startListener = null, this._initializeInstanceVariables(), this._defaultCanvasSize = { width: 100, height: 100 }, this._events = { mousemove: null, mousedown: null, mouseup: null, dragend: null, dragover: null, click: null, dblclick: null, mouseover: null, mouseout: null, keydown: null, keyup: null, keypress: null, touchstart: null, touchmove: null, touchend: null, resize: null, blur: null }, this._millisStart = -1, this._recording = !1, this.touchstart = !1, this.touchend = !1, this._lcg_random_state = null, this._gaussian_previous = !1, this._events.wheel = null, this._loadingScreenId = \"p5_loading\", this._registeredMethods = {};\n          var c = Object.getOwnPropertyNames(s.prototype._registeredMethods), p = !0, j = !1, T = void 0;\n          try {\n            for (var _, S = c[Symbol.iterator](); !(p = (_ = S.next()).done); p = !0) {\n              var E = _.value;\n              this._registeredMethods[E] = s.prototype._registeredMethods[E].slice();\n            }\n          } catch (G) {\n            j = !0, T = G;\n          } finally {\n            try {\n              p || S.return == null || S.return();\n            } finally {\n              if (j)\n                throw T;\n            }\n          }\n          window.DeviceOrientationEvent && (this._events.deviceorientation = null), window.DeviceMotionEvent && !window._isNodeWebkit && (this._events.devicemotion = null), s.prototype.callRegisteredHooksFor = function(G) {\n            var U = this || s.prototype, W = this._isGlobal ? window : this;\n            if (U._registeredMethods.hasOwnProperty(G)) {\n              var U = U._registeredMethods[G], X = !0, G = !1, ne = void 0;\n              try {\n                for (var b, O = U[Symbol.iterator](); !(X = (b = O.next()).done); X = !0) {\n                  var D = b.value;\n                  typeof D == \"function\" && D.call(W);\n                }\n              } catch (J) {\n                G = !0, ne = J;\n              } finally {\n                try {\n                  X || O.return == null || O.return();\n                } finally {\n                  if (G)\n                    throw ne;\n                }\n              }\n            }\n          }, this._start = function() {\n            a._userNode && typeof a._userNode == \"string\" && (a._userNode = document.getElementById(a._userNode));\n            var G = a._isGlobal ? window : a;\n            if (G.preload) {\n              a.callRegisteredHooksFor(\"beforePreload\");\n              var U, W = document.getElementById(a._loadingScreenId), X = (W || ((W = document.createElement(\"div\")).innerHTML = \"Loading...\", W.style.position = \"absolute\", W.id = a._loadingScreenId, (a._userNode || document.body).appendChild(W)), a._preloadMethods);\n              for (U in X) {\n                X[U] = X[U] || s;\n                var ne = X[U];\n                ne !== s.prototype && ne !== s || (a._isGlobal && (window[U] = a._wrapPreload(a, U)), ne = a), a._registeredPreloadMethods[U] = ne[U], ne[U] = a._wrapPreload(ne, U);\n              }\n              G.preload(), a._runIfPreloadsAreDone();\n            } else\n              a._setup(), a._recording || a._draw();\n          }, this._runIfPreloadsAreDone = function() {\n            var G, U = this._isGlobal ? window : this;\n            U._preloadCount === 0 && ((G = document.getElementById(U._loadingScreenId)) && G.parentNode.removeChild(G), this.callRegisteredHooksFor(\"afterPreload\"), this._setupDone || (this._lastTargetFrameTime = window.performance.now(), this._lastRealFrameTime = window.performance.now(), U._setup(), this._recording || U._draw()));\n          }, this._decrementPreload = function() {\n            var G = this._isGlobal ? window : this;\n            G._preloadDone || typeof G.preload != \"function\" || (G._setProperty(\"_preloadCount\", G._preloadCount - 1), G._runIfPreloadsAreDone());\n          }, this._wrapPreload = function(G, U) {\n            var W = this;\n            return function() {\n              W._incrementPreload();\n              for (var X = arguments.length, ne = new Array(X), b = 0; b < X; b++)\n                ne[b] = arguments[b];\n              return W._registeredPreloadMethods[U].apply(G, ne);\n            };\n          }, this._incrementPreload = function() {\n            var G = this._isGlobal ? window : this;\n            G._preloadDone || G._setProperty(\"_preloadCount\", G._preloadCount + 1);\n          }, this._setup = function() {\n            a.callRegisteredHooksFor(\"beforeSetup\"), a.createCanvas(a._defaultCanvasSize.width, a._defaultCanvasSize.height, \"p2d\");\n            var G = a._isGlobal ? window : a;\n            if (typeof G.preload == \"function\")\n              for (var U in a._preloadMethods)\n                G[U] = a._preloadMethods[U][U], G[U] && a && (G[U] = G[U].bind(a));\n            a._millisStart = window.performance.now(), G._preloadDone = !0, typeof G.setup == \"function\" && G.setup();\n            var W = document.getElementsByTagName(\"canvas\"), X = !0, ne = !1, b = void 0;\n            try {\n              for (var O, D = W[Symbol.iterator](); !(X = (O = D.next()).done); X = !0) {\n                var B = O.value;\n                B.dataset.hidden === \"true\" && (B.style.visibility = \"\", delete B.dataset.hidden);\n              }\n            } catch (Y) {\n              ne = !0, b = Y;\n            } finally {\n              try {\n                X || D.return == null || D.return();\n              } finally {\n                if (ne)\n                  throw b;\n              }\n            }\n            a._lastTargetFrameTime = window.performance.now(), a._lastRealFrameTime = window.performance.now(), a._setupDone = !0, (a._accessibleOutputs.grid || a._accessibleOutputs.text) && a._updateAccsOutput(), a.callRegisteredHooksFor(\"afterSetup\");\n          }, this._draw = function() {\n            var G = window.performance.now(), U = G - a._lastTargetFrameTime, W = 1e3 / a._targetFrameRate;\n            (!a._loop || W - 5 <= U) && (a.deltaTime = G - a._lastRealFrameTime, a._setProperty(\"deltaTime\", a.deltaTime), a._frameRate = 1e3 / a.deltaTime, a.redraw(), a._lastTargetFrameTime = Math.max(a._lastTargetFrameTime + W, G), a._lastRealFrameTime = G, a._updateMouseCoords !== void 0 && (a._updateMouseCoords(), a._setProperty(\"movedX\", 0), a._setProperty(\"movedY\", 0))), a._loop && (a._requestAnimId = window.requestAnimationFrame(a._draw));\n          }, this._setProperty = function(G, U) {\n            a[G] = U, a._isGlobal && (window[G] = U);\n          }, this.remove = function() {\n            a._startListener && window.removeEventListener(\"load\", a._startListener, !1);\n            var G = document.getElementById(a._loadingScreenId);\n            if (G && (G.parentNode.removeChild(G), a._incrementPreload()), a._curElement) {\n              for (var U in a._loop = !1, a._requestAnimId && window.cancelAnimationFrame(a._requestAnimId), a._events)\n                window.removeEventListener(U, a._events[U]);\n              var W = !0, G = !1, X = void 0;\n              try {\n                for (var ne, b = a._elements[Symbol.iterator](); !(W = (ne = b.next()).done); W = !0) {\n                  var O, D = ne.value;\n                  for (O in D.elt && D.elt.parentNode && D.elt.parentNode.removeChild(D.elt), D._events)\n                    D.elt.removeEventListener(O, D._events[O]);\n                }\n              } catch (ce) {\n                G = !0, X = ce;\n              } finally {\n                try {\n                  W || b.return == null || b.return();\n                } finally {\n                  if (G)\n                    throw X;\n                }\n              }\n              var B = a;\n              a._registeredMethods.remove.forEach(function(ce) {\n                ce !== void 0 && ce.call(B);\n              });\n            }\n            if (a._isGlobal) {\n              for (var Y in s.prototype)\n                try {\n                  delete window[Y];\n                } catch {\n                  window[Y] = void 0;\n                }\n              for (var J in a)\n                if (a.hasOwnProperty(J))\n                  try {\n                    delete window[J];\n                  } catch {\n                    window[J] = void 0;\n                  }\n              s.instance = null;\n            }\n          }, this._registeredMethods.init.forEach(function(G) {\n            G !== void 0 && G.call(this);\n          }, this), this._setupPromisePreloads();\n          var A, x, P = this._createFriendlyGlobalFunctionBinder();\n          if (l)\n            l(this), s._checkForUserDefinedFunctions(this);\n          else {\n            for (var M in this._isGlobal = !0, s.instance = this, s.prototype)\n              typeof s.prototype[M] == \"function\" ? (A = M.substring(2), this._events.hasOwnProperty(A) || (Math.hasOwnProperty(M) && Math[M] === s.prototype[M] ? P(M, s.prototype[M]) : P(M, s.prototype[M].bind(this)))) : P(M, s.prototype[M]);\n            for (var R in this)\n              this.hasOwnProperty(R) && P(R, this[R]);\n          }\n          for (x in this._events) {\n            var L = this[\"_on\".concat(x)];\n            L && (L = L.bind(this), window.addEventListener(x, L, { passive: !1 }), this._events[x] = L);\n          }\n          function F() {\n            a._setProperty(\"focused\", !0);\n          }\n          function V() {\n            a._setProperty(\"focused\", !1);\n          }\n          window.addEventListener(\"focus\", F), window.addEventListener(\"blur\", V), this.registerMethod(\"remove\", function() {\n            window.removeEventListener(\"focus\", F), window.removeEventListener(\"blur\", V);\n          }), document.readyState === \"complete\" ? this._start() : (this._startListener = this._start.bind(this), window.addEventListener(\"load\", this._startListener, !1));\n        }\n        var o, i;\n        return o = s, (i = [{ key: \"_initializeInstanceVariables\", value: function() {\n          this._accessibleOutputs = { text: !1, grid: !1, textLabel: !1, gridLabel: !1 }, this._styles = [], this._bezierDetail = 20, this._curveDetail = 20, this._colorMode = u.RGB, this._colorMaxes = { rgb: [255, 255, 255, 255], hsb: [360, 100, 100, 1], hsl: [360, 100, 100, 1] }, this._downKeys = {};\n        } }, { key: \"registerPreloadMethod\", value: function(l, n) {\n          s.prototype._preloadMethods.hasOwnProperty(l) || (s.prototype._preloadMethods[l] = n);\n        } }, { key: \"registerMethod\", value: function(l, n) {\n          var a = this || s.prototype;\n          a._registeredMethods.hasOwnProperty(l) || (a._registeredMethods[l] = []), a._registeredMethods[l].push(n);\n        } }, { key: \"unregisterMethod\", value: function(l, n) {\n          var a = this || s.prototype;\n          if (a._registeredMethods.hasOwnProperty(l)) {\n            for (var c = a._registeredMethods[l], p = [], j = 0; j < c.length; j++)\n              c[j] === n && p.push(j);\n            for (var T = p.length - 1; 0 <= T; T--)\n              c.splice(p[T], 1);\n          }\n        } }, { key: \"_createFriendlyGlobalFunctionBinder\", value: function() {\n          var l = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}, n = l.globalObject || window;\n          return l.log || console.log.bind(console), function(a, c) {\n            s.disableFriendlyErrors, n[a] = c;\n          };\n        } }]) && g(o.prototype, i), s;\n      }();\n      for (f in r.instance = null, r.disableFriendlyErrors = !1, u)\n        r.prototype[f] = u[f];\n      r.VERSION = u.VERSION, r.prototype._preloadMethods = { loadJSON: r.prototype, loadImage: r.prototype, loadStrings: r.prototype, loadXML: r.prototype, loadBytes: r.prototype, loadTable: r.prototype, loadFont: r.prototype, loadModel: r.prototype, loadShader: r.prototype }, r.prototype._registeredMethods = { init: [], pre: [], post: [], remove: [] }, r.prototype._registeredPreloadMethods = {}, C.default = r;\n    }, { \"./constants\": 269, \"./shim\": 291, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-own-property-names\": 184, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 281: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"./main\")) && t.__esModule ? t : { default: t };\n      function y(u, h) {\n        for (var g = 0; g < h.length; g++) {\n          var f = h[g];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);\n        }\n      }\n      m.default.Element = function() {\n        function u(r, s) {\n          if (!(this instanceof u))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.elt = r, this._pInst = this._pixelsState = s, this._events = {}, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight;\n        }\n        var h, g, f;\n        return h = u, f = [{ key: \"_adjustListener\", value: function(r, s, o) {\n          return s === !1 ? m.default.Element._detachListener(r, o) : m.default.Element._attachListener(r, s, o), this;\n        } }, { key: \"_attachListener\", value: function(r, s, o) {\n          o._events[r] && m.default.Element._detachListener(r, o), s = s.bind(o), o.elt.addEventListener(r, s, !1), o._events[r] = s;\n        } }, { key: \"_detachListener\", value: function(r, s) {\n          var o = s._events[r];\n          s.elt.removeEventListener(r, o, !1), s._events[r] = null;\n        } }], (g = [{ key: \"parent\", value: function(r) {\n          return r === void 0 ? this.elt.parentNode : (typeof r == \"string\" ? (r[0] === \"#\" && (r = r.substring(1)), r = document.getElementById(r)) : r instanceof m.default.Element && (r = r.elt), r.appendChild(this.elt), this);\n        } }, { key: \"id\", value: function(r) {\n          return r === void 0 ? this.elt.id : (this.elt.id = r, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight, this);\n        } }, { key: \"class\", value: function(r) {\n          return r === void 0 ? this.elt.className : (this.elt.className = r, this);\n        } }, { key: \"mousePressed\", value: function(r) {\n          return m.default.Element._adjustListener(\"mousedown\", function(s) {\n            return this._pInst._setProperty(\"mouseIsPressed\", !0), this._pInst._setMouseButton(s), r.call(this, s);\n          }, this), this;\n        } }, { key: \"doubleClicked\", value: function(r) {\n          return m.default.Element._adjustListener(\"dblclick\", r, this), this;\n        } }, { key: \"mouseWheel\", value: function(r) {\n          return m.default.Element._adjustListener(\"wheel\", r, this), this;\n        } }, { key: \"mouseReleased\", value: function(r) {\n          return m.default.Element._adjustListener(\"mouseup\", r, this), this;\n        } }, { key: \"mouseClicked\", value: function(r) {\n          return m.default.Element._adjustListener(\"click\", r, this), this;\n        } }, { key: \"mouseMoved\", value: function(r) {\n          return m.default.Element._adjustListener(\"mousemove\", r, this), this;\n        } }, { key: \"mouseOver\", value: function(r) {\n          return m.default.Element._adjustListener(\"mouseover\", r, this), this;\n        } }, { key: \"mouseOut\", value: function(r) {\n          return m.default.Element._adjustListener(\"mouseout\", r, this), this;\n        } }, { key: \"touchStarted\", value: function(r) {\n          return m.default.Element._adjustListener(\"touchstart\", r, this), this;\n        } }, { key: \"touchMoved\", value: function(r) {\n          return m.default.Element._adjustListener(\"touchmove\", r, this), this;\n        } }, { key: \"touchEnded\", value: function(r) {\n          return m.default.Element._adjustListener(\"touchend\", r, this), this;\n        } }, { key: \"dragOver\", value: function(r) {\n          return m.default.Element._adjustListener(\"dragover\", r, this), this;\n        } }, { key: \"dragLeave\", value: function(r) {\n          return m.default.Element._adjustListener(\"dragleave\", r, this), this;\n        } }, { key: \"_setProperty\", value: function(r, s) {\n          this[r] = s;\n        } }]) && y(h.prototype, g), f && y(h, f), u;\n      }(), t = m.default.Element, C.default = t;\n    }, { \"./main\": 280 }], 282: [function(t, H, C) {\n      function m(a) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(c) {\n          return typeof c;\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : typeof c;\n        })(a);\n      }\n      function y(a) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(c) {\n          return m(c);\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : m(c);\n        })(a);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.get-prototype-of\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (n = t(\"./main\")) && n.__esModule ? n : { default: n }, h = function(a) {\n        if (a && a.__esModule)\n          return a;\n        if (a === null || y(a) !== \"object\" && typeof a != \"function\")\n          return { default: a };\n        var c = g();\n        if (c && c.has(a))\n          return c.get(a);\n        var p, j = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (p in a) {\n          var _;\n          Object.prototype.hasOwnProperty.call(a, p) && ((_ = T ? Object.getOwnPropertyDescriptor(a, p) : null) && (_.get || _.set) ? Object.defineProperty(j, p, _) : j[p] = a[p]);\n        }\n        return j.default = a, c && c.set(a, j), j;\n      }(t(\"./constants\"));\n      function g() {\n        var a;\n        return typeof WeakMap != \"function\" ? null : (a = /* @__PURE__ */ new WeakMap(), g = function() {\n          return a;\n        }, a);\n      }\n      function f(a, c) {\n        for (var p = 0; p < c.length; p++) {\n          var j = c[p];\n          j.enumerable = j.enumerable || !1, j.configurable = !0, \"value\" in j && (j.writable = !0), Object.defineProperty(a, j.key, j);\n        }\n      }\n      function r(a, c) {\n        return (r = Object.setPrototypeOf || function(p, j) {\n          return p.__proto__ = j, p;\n        })(a, c);\n      }\n      function s(a) {\n        return function() {\n          var c, p = l(a);\n          return o(this, function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (c = l(this).constructor, Reflect.construct(p, arguments, c)) : p.apply(this, arguments));\n        };\n      }\n      function o(a, c) {\n        return !c || y(c) !== \"object\" && typeof c != \"function\" ? i(a) : c;\n      }\n      function i(a) {\n        if (a === void 0)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return a;\n      }\n      function l(a) {\n        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(c) {\n          return c.__proto__ || Object.getPrototypeOf(c);\n        })(a);\n      }\n      u.default.Graphics = function(a) {\n        var c = j;\n        if (typeof a != \"function\" && a !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        c.prototype = Object.create(a && a.prototype, { constructor: { value: c, writable: !0, configurable: !0 } }), a && r(c, a);\n        var p = s(j);\n        function j(T, _, R, E, A) {\n          var x;\n          if (!(this instanceof j))\n            throw new TypeError(\"Cannot call a class as a function\");\n          M = A || document.createElement(\"canvas\"), (x = p.call(this, M, E)).canvas = M;\n          var P, M = R || h.P2D, R = E._userNode || document.body;\n          for (P in A || R.appendChild(x.canvas), u.default.prototype)\n            x[P] || (typeof u.default.prototype[P] == \"function\" ? x[P] = u.default.prototype[P].bind(i(x)) : x[P] = u.default.prototype[P]);\n          return u.default.prototype._initializeInstanceVariables.apply(i(x)), x.width = T, x.height = _, x._pixelDensity = E._pixelDensity, M === h.WEBGL ? (x._renderer = new u.default.RendererGL(x.canvas, i(x), !1), T = (A = x._renderer._adjustDimensions(T, _)).adjustedWidth, _ = A.adjustedHeight) : x._renderer = new u.default.Renderer2D(x.canvas, i(x), !1), E._elements.push(i(x)), Object.defineProperty(i(x), \"deltaTime\", { get: function() {\n            return this._pInst.deltaTime;\n          } }), x._renderer.resize(T, _), x._renderer._applyDefaults(), o(x, i(x));\n        }\n        return c = j, (a = [{ key: \"reset\", value: function() {\n          this._renderer.resetMatrix(), this._renderer.isP3D && this._renderer._update();\n        } }, { key: \"remove\", value: function() {\n          this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);\n          var T, _ = this._pInst._elements.indexOf(this);\n          for (T in _ !== -1 && this._pInst._elements.splice(_, 1), this._events)\n            this.elt.removeEventListener(T, this._events[T]);\n        } }, { key: \"createFramebuffer\", value: function(T) {\n          return new u.default.Framebuffer(this, T);\n        } }]) && f(c.prototype, a), j;\n      }(u.default.Element);\n      var n = u.default.Graphics;\n      C.default = n;\n    }, { \"./constants\": 269, \"./main\": 280, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 283: [function(t, H, C) {\n      function m(a) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(c) {\n          return typeof c;\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : typeof c;\n        })(a);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (l = t(\"./main\")) && l.__esModule ? l : { default: l }, u = function(a) {\n        if (a && a.__esModule)\n          return a;\n        if (a === null || g(a) !== \"object\" && typeof a != \"function\")\n          return { default: a };\n        var c = h();\n        if (c && c.has(a))\n          return c.get(a);\n        var p, j = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (p in a) {\n          var _;\n          Object.prototype.hasOwnProperty.call(a, p) && ((_ = T ? Object.getOwnPropertyDescriptor(a, p) : null) && (_.get || _.set) ? Object.defineProperty(j, p, _) : j[p] = a[p]);\n        }\n        return j.default = a, c && c.set(a, j), j;\n      }(t(\"../core/constants\"));\n      function h() {\n        var a;\n        return typeof WeakMap != \"function\" ? null : (a = /* @__PURE__ */ new WeakMap(), h = function() {\n          return a;\n        }, a);\n      }\n      function g(a) {\n        return (g = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(c) {\n          return m(c);\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : m(c);\n        })(a);\n      }\n      function f(a, c) {\n        for (var p = 0; p < c.length; p++) {\n          var j = c[p];\n          j.enumerable = j.enumerable || !1, j.configurable = !0, \"value\" in j && (j.writable = !0), Object.defineProperty(a, j.key, j);\n        }\n      }\n      function r(a, c) {\n        return (r = Object.setPrototypeOf || function(p, j) {\n          return p.__proto__ = j, p;\n        })(a, c);\n      }\n      function s(a) {\n        return function() {\n          var c, p, j = i(a);\n          return c = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (c = i(this).constructor, Reflect.construct(j, arguments, c)) : j.apply(this, arguments), j = this, !(p = c) || g(p) !== \"object\" && typeof p != \"function\" ? o(j) : p;\n        };\n      }\n      function o(a) {\n        if (a === void 0)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return a;\n      }\n      function i(a) {\n        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(c) {\n          return c.__proto__ || Object.getPrototypeOf(c);\n        })(a);\n      }\n      var l = function(a) {\n        var c = j;\n        if (typeof a != \"function\" && a !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        c.prototype = Object.create(a && a.prototype, { constructor: { value: c, writable: !0, configurable: !0 } }), a && r(c, a);\n        var p = s(j);\n        function j(T, _, S) {\n          var E;\n          if (this instanceof j)\n            return (E = p.call(this, T, _)).canvas = T, E._pixelsState = _, S ? (E._isMainCanvas = !0, E._pInst._setProperty(\"_curElement\", o(E)), E._pInst._setProperty(\"canvas\", E.canvas), E._pInst._setProperty(\"width\", E.width), E._pInst._setProperty(\"height\", E.height)) : (E.canvas.style.display = \"none\", E._styles = []), E._clipping = !1, E._clipInvert = !1, E._textSize = 12, E._textLeading = 15, E._textFont = \"sans-serif\", E._textStyle = u.NORMAL, E._textAscent = null, E._textDescent = null, E._textAlign = u.LEFT, E._textBaseline = u.BASELINE, E._textWrap = u.WORD, E._rectMode = u.CORNER, E._ellipseMode = u.CENTER, E._curveTightness = 0, E._imageMode = u.CORNER, E._tint = null, E._doStroke = !0, E._doFill = !0, E._strokeSet = !1, E._fillSet = !1, E._leadingSet = !1, E._pushPopDepth = 0, E;\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n        return c = j, (a = [{ key: \"push\", value: function() {\n          return this._pushPopDepth++, { properties: { _doStroke: this._doStroke, _strokeSet: this._strokeSet, _doFill: this._doFill, _fillSet: this._fillSet, _tint: this._tint, _imageMode: this._imageMode, _rectMode: this._rectMode, _ellipseMode: this._ellipseMode, _textFont: this._textFont, _textLeading: this._textLeading, _leadingSet: this._leadingSet, _textSize: this._textSize, _textAlign: this._textAlign, _textBaseline: this._textBaseline, _textStyle: this._textStyle, _textWrap: this._textWrap } };\n        } }, { key: \"pop\", value: function(T) {\n          this._pushPopDepth--, T.properties && Object.assign(this, T.properties);\n        } }, { key: \"beginClip\", value: function() {\n          var T = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {};\n          if (this._clipping)\n            throw new Error(\"It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?\");\n          this._clipping = !0, this._clipInvert = T.invert;\n        } }, { key: \"endClip\", value: function() {\n          if (!this._clipping)\n            throw new Error(\"It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?\");\n          this._clipping = !1;\n        } }, { key: \"resize\", value: function(T, _) {\n          this.width = T, this.height = _, this.elt.width = T * this._pInst._pixelDensity, this.elt.height = _ * this._pInst._pixelDensity, this.elt.style.width = \"\".concat(T, \"px\"), this.elt.style.height = \"\".concat(_, \"px\"), this._isMainCanvas && (this._pInst._setProperty(\"width\", this.width), this._pInst._setProperty(\"height\", this.height));\n        } }, { key: \"get\", value: function(T, _, S, E) {\n          var A = this._pixelsState, x = A._pixelDensity, P = this.canvas;\n          if (T === void 0 && _ === void 0)\n            T = _ = 0, S = A.width, E = A.height;\n          else if (T *= x, _ *= x, S === void 0 && E === void 0)\n            return T < 0 || _ < 0 || T >= P.width || _ >= P.height ? [0, 0, 0, 0] : this._getPixel(T, _);\n          return A = new y.default.Image(S * x, E * x), A.pixelDensity(x), A.canvas.getContext(\"2d\").drawImage(P, T, _, S * x, E * x, 0, 0, S * x, E * x), A;\n        } }, { key: \"textLeading\", value: function(T) {\n          return typeof T == \"number\" ? (this._setProperty(\"_leadingSet\", !0), this._setProperty(\"_textLeading\", T), this._pInst) : this._textLeading;\n        } }, { key: \"textStyle\", value: function(T) {\n          return T ? (T !== u.NORMAL && T !== u.ITALIC && T !== u.BOLD && T !== u.BOLDITALIC || this._setProperty(\"_textStyle\", T), this._applyTextProperties()) : this._textStyle;\n        } }, { key: \"textAscent\", value: function() {\n          return this._textAscent === null && this._updateTextMetrics(), this._textAscent;\n        } }, { key: \"textDescent\", value: function() {\n          return this._textDescent === null && this._updateTextMetrics(), this._textDescent;\n        } }, { key: \"textAlign\", value: function(T, _) {\n          return T !== void 0 ? (this._setProperty(\"_textAlign\", T), _ !== void 0 && this._setProperty(\"_textBaseline\", _), this._applyTextProperties()) : { horizontal: this._textAlign, vertical: this._textBaseline };\n        } }, { key: \"textWrap\", value: function(T) {\n          return this._setProperty(\"_textWrap\", T), this._textWrap;\n        } }, { key: \"text\", value: function(T, _, S, E, A) {\n          var x, P, M, R, L = this._pInst, F = this._textWrap, V = Number.MAX_VALUE, G = S;\n          if ((this._doFill || this._doStroke) && T !== void 0) {\n            if (x = (T = (T = typeof T != \"string\" ? T.toString() : T).replace(/(\\t)/g, \"  \")).split(`\n`), E !== void 0) {\n              switch (this._rectMode === u.CENTER && (_ -= E / 2), this._textAlign) {\n                case u.CENTER:\n                  _ += E / 2;\n                  break;\n                case u.RIGHT:\n                  _ += E;\n              }\n              if (A !== void 0) {\n                this._rectMode === u.CENTER && (S -= A / 2, G -= A / 2);\n                var T = S, U = L.textAscent();\n                switch (this._textBaseline) {\n                  case u.BOTTOM:\n                    R = S + A, S = Math.max(R, S), G += U;\n                    break;\n                  case u.CENTER:\n                    R = S + A / 2, S = Math.max(R, S), G += U / 2;\n                }\n                V = S + A - U, this._textBaseline === u.CENTER && (V = T + A - U / 2);\n              } else\n                this._textBaseline !== u.BOTTOM && this._textBaseline !== u.CENTER || (G = S - (T = L.textSize() * this._textLeading) / 2, V = S + T / 2);\n              if (F === u.WORD) {\n                for (var W = [], X = 0; X < x.length; X++) {\n                  for (var ne = \"\", b = x[X].split(\" \"), O = 0; O < b.length; O++)\n                    P = \"\".concat(ne + b[O]) + \" \", ne = E < (M = this.textWidth(P)) && 0 < ne.length ? (W.push(ne), \"\".concat(b[O]) + \" \") : P;\n                  W.push(ne);\n                }\n                var D = 0;\n                this._textBaseline === u.CENTER ? D = (W.length - 1) * L.textLeading() / 2 : this._textBaseline === u.BOTTOM && (D = (W.length - 1) * L.textLeading());\n                for (var B = 0; B < x.length; B++) {\n                  ne = \"\", b = x[B].split(\" \");\n                  for (var Y = 0; Y < b.length; Y++)\n                    P = \"\".concat(ne + b[Y]) + \" \", E < (M = this.textWidth(P)) && 0 < ne.length ? (this._renderText(L, ne.trim(), _, S - D, V, G), ne = \"\".concat(b[Y]) + \" \", S += L.textLeading()) : ne = P;\n                  this._renderText(L, ne.trim(), _, S - D, V, G), S += L.textLeading();\n                }\n              } else {\n                for (var J = [], te = 0; te < x.length; te++)\n                  for (var ce = x[te].split(ne = \"\"), re = 0; re < ce.length; re++)\n                    P = \"\".concat(ne + ce[re]), (M = this.textWidth(P)) <= E ? ne += ce[re] : E < M && 0 < ne.length && (J.push(ne), ne = \"\".concat(ce[re]));\n                J.push(ne);\n                var ue = 0;\n                this._textBaseline === u.CENTER ? ue = (J.length - 1) * L.textLeading() / 2 : this._textBaseline === u.BOTTOM && (ue = (J.length - 1) * L.textLeading());\n                for (var le = 0; le < x.length; le++) {\n                  ce = x[le].split(ne = \"\");\n                  for (var K = 0; K < ce.length; K++)\n                    P = \"\".concat(ne + ce[K]), (M = this.textWidth(P)) <= E ? ne += ce[K] : E < M && 0 < ne.length && (this._renderText(L, ne.trim(), _, S - ue, V, G), S += L.textLeading(), ne = \"\".concat(ce[K]));\n                }\n                this._renderText(L, ne.trim(), _, S - ue, V, G), S += L.textLeading();\n              }\n            } else {\n              var ae = 0;\n              this._textBaseline === u.CENTER ? ae = (x.length - 1) * L.textLeading() / 2 : this._textBaseline === u.BOTTOM && (ae = (x.length - 1) * L.textLeading());\n              for (var he = 0; he < x.length; he++)\n                this._renderText(L, x[he], _, S - ae, V, G - ae), S += L.textLeading();\n            }\n            return L;\n          }\n        } }, { key: \"_applyDefaults\", value: function() {\n          return this;\n        } }, { key: \"_isOpenType\", value: function() {\n          var T = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : this._textFont;\n          return g(T) === \"object\" && T.font && T.font.supported;\n        } }, { key: \"_updateTextMetrics\", value: function() {\n          var T, _, S, E, A, x;\n          return this._isOpenType() ? (this._setProperty(\"_textAscent\", this._textFont._textAscent()), this._setProperty(\"_textDescent\", this._textFont._textDescent())) : ((T = document.createElement(\"span\")).style.fontFamily = this._textFont, T.style.fontSize = \"\".concat(this._textSize, \"px\"), T.innerHTML = \"ABCjgq|\", (x = document.createElement(\"div\")).style.display = \"inline-block\", x.style.width = \"1px\", x.style.height = \"0px\", E = ((_ = document.createElement(\"div\")).appendChild(T), _.appendChild(x), _.style.height = \"0px\", _.style.overflow = \"hidden\", document.body.appendChild(_), x.style.verticalAlign = \"baseline\", n(x)), A = n(T), S = E[1] - A[1], E = (x.style.verticalAlign = \"bottom\", n(x)), A = n(T), x = E[1] - A[1] - S, document.body.removeChild(_), this._setProperty(\"_textAscent\", S), this._setProperty(\"_textDescent\", x)), this;\n        } }]) && f(c.prototype, a), j;\n      }(y.default.Element);\n      function n(a) {\n        var c = 0, p = 0;\n        if (a.offsetParent)\n          for (; c += a.offsetLeft, p += a.offsetTop, a = a.offsetParent; )\n            ;\n        else\n          c += a.offsetLeft, p += a.offsetTop;\n        return [c, p];\n      }\n      l.prototype.textSize = function(a) {\n        return typeof a == \"number\" ? (this._setProperty(\"_textSize\", a), this._leadingSet || this._setProperty(\"_textLeading\", a * u._DEFAULT_LEADMULT), this._applyTextProperties()) : this._textSize;\n      }, y.default.Renderer = l, t = y.default.Renderer, C.default = t;\n    }, { \"../core/constants\": 269, \"./main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 284: [function(a, H, C) {\n      function m(c) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(p) {\n          return typeof p;\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : typeof p;\n        })(c);\n      }\n      function y(c) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(p) {\n          return m(p);\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : m(p);\n        })(c);\n      }\n      a(\"core-js/modules/es.symbol\"), a(\"core-js/modules/es.symbol.description\"), a(\"core-js/modules/es.symbol.iterator\"), a(\"core-js/modules/es.array.concat\"), a(\"core-js/modules/es.array.fill\"), a(\"core-js/modules/es.array.for-each\"), a(\"core-js/modules/es.array.iterator\"), a(\"core-js/modules/es.array.join\"), a(\"core-js/modules/es.array.slice\"), a(\"core-js/modules/es.function.name\"), a(\"core-js/modules/es.number.to-fixed\"), a(\"core-js/modules/es.object.get-own-property-descriptor\"), a(\"core-js/modules/es.object.get-prototype-of\"), a(\"core-js/modules/es.object.to-string\"), a(\"core-js/modules/es.reflect.construct\"), a(\"core-js/modules/es.reflect.get\"), a(\"core-js/modules/es.regexp.exec\"), a(\"core-js/modules/es.regexp.to-string\"), a(\"core-js/modules/es.string.iterator\"), a(\"core-js/modules/es.weak-map\"), a(\"core-js/modules/web.dom-collections.iterator\"), a(\"core-js/modules/es.array.concat\"), a(\"core-js/modules/es.array.fill\"), a(\"core-js/modules/es.array.for-each\"), a(\"core-js/modules/es.array.join\"), a(\"core-js/modules/es.array.slice\"), a(\"core-js/modules/es.function.name\"), a(\"core-js/modules/es.number.to-fixed\"), a(\"core-js/modules/es.object.get-prototype-of\"), a(\"core-js/modules/es.object.to-string\"), a(\"core-js/modules/es.regexp.exec\"), a(\"core-js/modules/es.regexp.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (n = a(\"./main\")) && n.__esModule ? n : { default: n }, h = function(c) {\n        if (c && c.__esModule)\n          return c;\n        if (c === null || y(c) !== \"object\" && typeof c != \"function\")\n          return { default: c };\n        var p = g();\n        if (p && p.has(c))\n          return p.get(c);\n        var j, T = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (j in c) {\n          var S;\n          Object.prototype.hasOwnProperty.call(c, j) && ((S = _ ? Object.getOwnPropertyDescriptor(c, j) : null) && (S.get || S.set) ? Object.defineProperty(T, j, S) : T[j] = c[j]);\n        }\n        return T.default = c, p && p.set(c, T), T;\n      }(a(\"./constants\"));\n      function g() {\n        var c;\n        return typeof WeakMap != \"function\" ? null : (c = /* @__PURE__ */ new WeakMap(), g = function() {\n          return c;\n        }, c);\n      }\n      function f(c, p) {\n        for (var j = 0; j < p.length; j++) {\n          var T = p[j];\n          T.enumerable = T.enumerable || !1, T.configurable = !0, \"value\" in T && (T.writable = !0), Object.defineProperty(c, T.key, T);\n        }\n      }\n      function r(c, p, j) {\n        return (r = typeof Reflect < \"u\" && Reflect.get ? Reflect.get : function(E, _, S) {\n          var E = function(A, x) {\n            for (; !Object.prototype.hasOwnProperty.call(A, x) && (A = i(A)) !== null; )\n              ;\n            return A;\n          }(E, _);\n          if (E)\n            return (E = Object.getOwnPropertyDescriptor(E, _)).get ? E.get.call(S) : E.value;\n        })(c, p, j || c);\n      }\n      function s(c, p) {\n        return (s = Object.setPrototypeOf || function(j, T) {\n          return j.__proto__ = T, j;\n        })(c, p);\n      }\n      function o(c) {\n        return function() {\n          var p, j = i(c), j = (p = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (p = i(this).constructor, Reflect.construct(j, arguments, p)) : j.apply(this, arguments), this);\n          if (!p || y(p) !== \"object\" && typeof p != \"function\") {\n            if (j !== void 0)\n              return j;\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n          return p;\n        };\n      }\n      function i(c) {\n        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(p) {\n          return p.__proto__ || Object.getPrototypeOf(p);\n        })(c);\n      }\n      a(\"./p5.Renderer\");\n      var l = \"rgba(0,0,0,0)\", n = function(c) {\n        var p = T;\n        if (typeof c != \"function\" && c !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        p.prototype = Object.create(c && c.prototype, { constructor: { value: p, writable: !0, configurable: !0 } }), c && s(p, c);\n        var j = o(T);\n        function T(_, S, E) {\n          if (this instanceof T)\n            return (_ = j.call(this, _, S, E)).drawingContext = _.canvas.getContext(\"2d\"), _._pInst._setProperty(\"drawingContext\", _.drawingContext), _;\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n        return p = T, (c = [{ key: \"getFilterGraphicsLayer\", value: function() {\n          var _;\n          return this.filterGraphicsLayer || (_ = (this._pInst instanceof u.default.Graphics ? this._pInst : this)._pInst, this.filterGraphicsLayer = new u.default.Graphics(this.width, this.height, h.WEBGL, _)), this.filterGraphicsLayer.width === this.width && this.filterGraphicsLayer.height === this.height || this.filterGraphicsLayer.resizeCanvas(this.width, this.height), this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity() && this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity()), this.filterGraphicsLayer;\n        } }, { key: \"_applyDefaults\", value: function() {\n          this._cachedFillStyle = this._cachedStrokeStyle = void 0, this._cachedBlendMode = h.BLEND, this._setFill(h._DEFAULT_FILL), this._setStroke(h._DEFAULT_STROKE), this.drawingContext.lineCap = h.ROUND, this.drawingContext.font = \"normal 12px sans-serif\";\n        } }, { key: \"resize\", value: function(_, S) {\n          r(i(T.prototype), \"resize\", this).call(this, _, S), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);\n        } }, { key: \"background\", value: function() {\n          var _, S;\n          this.drawingContext.save(), this.resetMatrix(), (arguments.length <= 0 ? void 0 : arguments[0]) instanceof u.default.Image ? 0 <= (arguments.length <= 1 ? void 0 : arguments[1]) ? (_ = arguments.length <= 0 ? void 0 : arguments[0], this.drawingContext.globalAlpha = (arguments.length <= 1 ? void 0 : arguments[1]) / 255, this._pInst.image(_, 0, 0, this.width, this.height)) : this._pInst.image(arguments.length <= 0 ? void 0 : arguments[0], 0, 0, this.width, this.height) : (_ = this._getFill(), S = (S = this._pInst).color.apply(S, arguments), this._pInst._addAccsOutput() && this._pInst._accsBackground(S.levels), S = S.toString(), this._setFill(S), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.fillRect(0, 0, this.width, this.height), this._setFill(_), this._isErasing && this._pInst.erase()), this.drawingContext.restore();\n        } }, { key: \"clear\", value: function() {\n          this.drawingContext.save(), this.resetMatrix(), this.drawingContext.clearRect(0, 0, this.width, this.height), this.drawingContext.restore();\n        } }, { key: \"fill\", value: function() {\n          var _ = (_ = this._pInst).color.apply(_, arguments);\n          this._setFill(_.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors(\"fill\", _.levels);\n        } }, { key: \"stroke\", value: function() {\n          var _ = (_ = this._pInst).color.apply(_, arguments);\n          this._setStroke(_.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors(\"stroke\", _.levels);\n        } }, { key: \"erase\", value: function(_, S) {\n          this._isErasing || (this._cachedFillStyle = this.drawingContext.fillStyle, _ = this._pInst.color(255, _).toString(), this.drawingContext.fillStyle = _, this._cachedStrokeStyle = this.drawingContext.strokeStyle, _ = this._pInst.color(255, S).toString(), this.drawingContext.strokeStyle = _, S = this._cachedBlendMode, this.blendMode(h.REMOVE), this._cachedBlendMode = S, this._isErasing = !0);\n        } }, { key: \"noErase\", value: function() {\n          this._isErasing && (this.drawingContext.fillStyle = this._cachedFillStyle, this.drawingContext.strokeStyle = this._cachedStrokeStyle, this.blendMode(this._cachedBlendMode), this._isErasing = !1);\n        } }, { key: \"beginClip\", value: function() {\n          var _ = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}, _ = (r(i(T.prototype), \"beginClip\", this).call(this, _), this._cachedFillStyle = this.drawingContext.fillStyle, this._pInst.color(255, 0).toString()), _ = (this.drawingContext.fillStyle = _, this._cachedStrokeStyle = this.drawingContext.strokeStyle, this._pInst.color(255, 0).toString()), _ = (this.drawingContext.strokeStyle = _, this._cachedBlendMode);\n          this.blendMode(h.BLEND), this._cachedBlendMode = _, this.drawingContext.beginPath(), this._clipInvert && (this.drawingContext.moveTo(-2 * this.width, -2 * this.height), this.drawingContext.lineTo(-2 * this.width, 2 * this.height), this.drawingContext.lineTo(2 * this.width, 2 * this.height), this.drawingContext.lineTo(2 * this.width, -2 * this.height), this.drawingContext.closePath());\n        } }, { key: \"endClip\", value: function() {\n          this._doFillStrokeClose(), this.drawingContext.clip(), r(i(T.prototype), \"endClip\", this).call(this), this.drawingContext.fillStyle = this._cachedFillStyle, this.drawingContext.strokeStyle = this._cachedStrokeStyle, this.blendMode(this._cachedBlendMode);\n        } }, { key: \"image\", value: function(_, S, E, A, x, P, M, R, L) {\n          _.gifProperties && _._animateGif(this._pInst);\n          try {\n            u.default.MediaElement && _ instanceof u.default.MediaElement && _._ensureCanvas();\n            var F = (F = this._tint && _.canvas ? this._getTintedImageCanvas(_) : F) || _.canvas || _.elt, V = 1;\n            _.width && 0 < _.width && (V = F.width / _.width), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.drawImage(F, V * S, V * E, V * A, V * x, P, M, R, L), this._isErasing && this._pInst.erase();\n          } catch (G) {\n            if (G.name !== \"NS_ERROR_NOT_AVAILABLE\")\n              throw G;\n          }\n        } }, { key: \"_getTintedImageCanvas\", value: function(_) {\n          if (!_.canvas)\n            return _;\n          _.tintCanvas || (_.tintCanvas = document.createElement(\"canvas\")), _.tintCanvas.width !== _.canvas.width && (_.tintCanvas.width = _.canvas.width), _.tintCanvas.height !== _.canvas.height && (_.tintCanvas.height = _.canvas.height);\n          var S = _.tintCanvas.getContext(\"2d\");\n          return S.save(), S.clearRect(0, 0, _.canvas.width, _.canvas.height), (this._tint[0] < 255 || this._tint[1] < 255 || this._tint[2] < 255) && (S.drawImage(_.canvas, 0, 0), S.globalCompositeOperation = \"luminosity\", S.drawImage(_.canvas, 0, 0), S.globalCompositeOperation = \"color\", S.drawImage(_.canvas, 0, 0), S.globalCompositeOperation = \"multiply\", S.fillStyle = \"rgb(\".concat(this._tint.slice(0, 3).join(\", \"), \")\"), S.fillRect(0, 0, _.canvas.width, _.canvas.height), S.globalCompositeOperation = \"destination-in\"), S.globalAlpha = this._tint[3] / 255, S.drawImage(_.canvas, 0, 0), S.restore(), _.tintCanvas;\n        } }, { key: \"blendMode\", value: function(_) {\n          if (_ === h.SUBTRACT)\n            console.warn(\"blendMode(SUBTRACT) only works in WEBGL mode.\");\n          else {\n            if (_ !== h.BLEND && _ !== h.REMOVE && _ !== h.DARKEST && _ !== h.LIGHTEST && _ !== h.DIFFERENCE && _ !== h.MULTIPLY && _ !== h.EXCLUSION && _ !== h.SCREEN && _ !== h.REPLACE && _ !== h.OVERLAY && _ !== h.HARD_LIGHT && _ !== h.SOFT_LIGHT && _ !== h.DODGE && _ !== h.BURN && _ !== h.ADD)\n              throw new Error(\"Mode \".concat(_, \" not recognized.\"));\n            this._cachedBlendMode = _, this.drawingContext.globalCompositeOperation = _;\n          }\n        } }, { key: \"blend\", value: function() {\n          for (var _ = this.drawingContext.globalCompositeOperation, S = arguments.length, E = new Array(S), A = 0; A < S; A++)\n            E[A] = arguments[A];\n          var x = E[E.length - 1], P = Array.prototype.slice.call(E, 0, E.length - 1);\n          this.drawingContext.globalCompositeOperation = x, u.default.prototype.copy.apply(this, P), this.drawingContext.globalCompositeOperation = _;\n        } }, { key: \"_getPixel\", value: function(_, S) {\n          return _ = this.drawingContext.getImageData(_, S, 1, 1).data, [_[0], _[1], _[2], _[3]];\n        } }, { key: \"loadPixels\", value: function() {\n          var _ = this._pixelsState, S = _._pixelDensity, E = this.width * S, S = this.height * S, E = this.drawingContext.getImageData(0, 0, E, S);\n          _._setProperty(\"imageData\", E), _._setProperty(\"pixels\", E.data);\n        } }, { key: \"set\", value: function(_, S, E) {\n          _ = Math.floor(_), S = Math.floor(S);\n          var A = this._pixelsState;\n          if (E instanceof u.default.Image)\n            this.drawingContext.save(), this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(A._pixelDensity, A._pixelDensity), this.drawingContext.clearRect(_, S, E.width, E.height), this.drawingContext.drawImage(E.canvas, _, S), this.drawingContext.restore();\n          else {\n            var x = 0, P = 0, M = 0, R = 0, L = 4 * (S * A._pixelDensity * (this.width * A._pixelDensity) + _ * A._pixelDensity);\n            if (A.imageData || A.loadPixels(), typeof E == \"number\")\n              L < A.pixels.length && (M = P = x = E, R = 255);\n            else if (Array.isArray(E)) {\n              if (E.length < 4)\n                throw new Error(\"pixel array must be of the form [R, G, B, A]\");\n              L < A.pixels.length && (x = E[0], P = E[1], M = E[2], R = E[3]);\n            } else\n              E instanceof u.default.Color && L < A.pixels.length && (x = E.levels[0], P = E.levels[1], M = E.levels[2], R = E.levels[3]);\n            for (var F = 0; F < A._pixelDensity; F++)\n              for (var V = 0; V < A._pixelDensity; V++)\n                L = 4 * ((S * A._pixelDensity + V) * this.width * A._pixelDensity + (_ * A._pixelDensity + F)), A.pixels[L] = x, A.pixels[L + 1] = P, A.pixels[L + 2] = M, A.pixels[L + 3] = R;\n          }\n        } }, { key: \"updatePixels\", value: function(_, S, E, A) {\n          var x = this._pixelsState, P = x._pixelDensity;\n          _ === void 0 && S === void 0 && E === void 0 && A === void 0 && (S = _ = 0, E = this.width, A = this.height), _ *= P, S *= P, E *= P, A *= P, this.gifProperties && (this.gifProperties.frames[this.gifProperties.displayIndex].image = x.imageData), this.drawingContext.putImageData(x.imageData, _, S, 0, 0, E, A);\n        } }, { key: \"_acuteArcToBezier\", value: function(_, S) {\n          var P = S / 2, E = Math.cos(P), R = Math.sin(P), A = 1 / Math.tan(P), P = _ + P, x = Math.cos(P), P = Math.sin(P), M = (4 - E) / 3, R = R + (E - M) * A;\n          return { ax: Math.cos(_).toFixed(7), ay: Math.sin(_).toFixed(7), bx: (M * x + R * P).toFixed(7), by: (M * P - R * x).toFixed(7), cx: (M * x - R * P).toFixed(7), cy: (M * P + R * x).toFixed(7), dx: Math.cos(_ + S).toFixed(7), dy: Math.sin(_ + S).toFixed(7) };\n        } }, { key: \"arc\", value: function(_, S, E, A, x, P, M) {\n          var R, L = this.drawingContext, F = E / 2, V = A / 2, G = [];\n          for (_ += F, S += V; 1e-5 <= P - x; )\n            R = Math.min(P - x, h.HALF_PI), G.push(this._acuteArcToBezier(x, R)), x += R;\n          return this._doFill && (this._clipping || L.beginPath(), G.forEach(function(U, W) {\n            W === 0 && L.moveTo(_ + U.ax * F, S + U.ay * V), L.bezierCurveTo(_ + U.bx * F, S + U.by * V, _ + U.cx * F, S + U.cy * V, _ + U.dx * F, S + U.dy * V);\n          }), M !== h.PIE && M != null || L.lineTo(_, S), L.closePath(), this._clipping || L.fill()), this._doStroke && (this._clipping || L.beginPath(), G.forEach(function(U, W) {\n            W === 0 && L.moveTo(_ + U.ax * F, S + U.ay * V), L.bezierCurveTo(_ + U.bx * F, S + U.by * V, _ + U.cx * F, S + U.cy * V, _ + U.dx * F, S + U.dy * V);\n          }), M === h.PIE ? (L.lineTo(_, S), L.closePath()) : M === h.CHORD && L.closePath(), this._clipping || L.stroke()), this;\n        } }, { key: \"ellipse\", value: function(R) {\n          var S = this.drawingContext, E = this._doFill, A = this._doStroke, x = parseFloat(R[0]), P = parseFloat(R[1]), M = parseFloat(R[2]), R = parseFloat(R[3]);\n          if (E && !A) {\n            if (this._getFill() === l)\n              return this;\n          } else if (!E && A && this._getStroke() === l)\n            return this;\n          x += M / 2, P += R / 2, M /= 2, R /= 2, this._clipping || S.beginPath(), S.ellipse(x, P, M, R, 0, 0, 2 * Math.PI), !this._clipping && E && S.fill(), !this._clipping && A && S.stroke();\n        } }, { key: \"line\", value: function(_, S, E, A) {\n          var x = this.drawingContext;\n          return this._doStroke && this._getStroke() !== l && (this._clipping || x.beginPath(), x.moveTo(_, S), x.lineTo(E, A), x.stroke()), this;\n        } }, { key: \"point\", value: function(_, S) {\n          var E, A, x = this.drawingContext;\n          return !this._doStroke || this._getStroke() === l ? this : (E = this._getStroke(), A = this._getFill(), this._clipping || this._setFill(E), this._clipping || x.beginPath(), x.arc(_, S, x.lineWidth / 2, 0, h.TWO_PI, !1), void (this._clipping || (x.fill(), this._setFill(A))));\n        } }, { key: \"quad\", value: function(_, S, E, A, x, P, M, R) {\n          var L = this.drawingContext, F = this._doFill, V = this._doStroke;\n          if (F && !V) {\n            if (this._getFill() === l)\n              return this;\n          } else if (!F && V && this._getStroke() === l)\n            return this;\n          return this._clipping || L.beginPath(), L.moveTo(_, S), L.lineTo(E, A), L.lineTo(x, P), L.lineTo(M, R), L.closePath(), !this._clipping && F && L.fill(), !this._clipping && V && L.stroke(), this;\n        } }, { key: \"rect\", value: function(V) {\n          var S, E, A = V[0], x = V[1], P = V[2], M = V[3], R = V[4], L = V[5], F = V[6], V = V[7], G = this.drawingContext, U = this._doFill, W = this._doStroke;\n          if (U && !W) {\n            if (this._getFill() === l)\n              return this;\n          } else if (!U && W && this._getStroke() === l)\n            return this;\n          return this._clipping || G.beginPath(), R === void 0 ? G.rect(A, x, P, M) : (L === void 0 && (L = R), F === void 0 && (F = L), V === void 0 && (V = F), W = (U = Math.abs(P)) / 2, E = (S = Math.abs(M)) / 2, S < 2 * (R = U < 2 * R ? W : R) && (R = E), S < 2 * (L = U < 2 * L ? W : L) && (L = E), S < 2 * (F = U < 2 * F ? W : F) && (F = E), S < 2 * (V = U < 2 * V ? W : V) && (V = E), this._clipping || G.beginPath(), G.moveTo(A + R, x), G.arcTo(A + P, x, A + P, x + M, L), G.arcTo(A + P, x + M, A, x + M, F), G.arcTo(A, x + M, A, x, V), G.arcTo(A, x, A + P, x, R), G.closePath()), !this._clipping && this._doFill && G.fill(), !this._clipping && this._doStroke && G.stroke(), this;\n        } }, { key: \"triangle\", value: function(F) {\n          var S = this.drawingContext, E = this._doFill, A = this._doStroke, x = F[0], P = F[1], M = F[2], R = F[3], L = F[4], F = F[5];\n          if (E && !A) {\n            if (this._getFill() === l)\n              return this;\n          } else if (!E && A && this._getStroke() === l)\n            return this;\n          this._clipping || S.beginPath(), S.moveTo(x, P), S.lineTo(M, R), S.lineTo(L, F), S.closePath(), !this._clipping && E && S.fill(), !this._clipping && A && S.stroke();\n        } }, { key: \"endShape\", value: function(_, S, E, A, x, P, M) {\n          if (S.length !== 0 && (this._doStroke || this._doFill)) {\n            var R, L, F, V = _ === h.CLOSE, G = (V && !P && S.push(S[0]), S.length);\n            if (E && M === null) {\n              if (3 < G) {\n                var U = [], W = 1 - this._curveTightness;\n                for (this._clipping || this.drawingContext.beginPath(), this.drawingContext.moveTo(S[1][0], S[1][1]), L = 1; L + 2 < G; L++)\n                  R = S[L], U[0] = [R[0], R[1]], U[1] = [R[0] + (W * S[L + 1][0] - W * S[L - 1][0]) / 6, R[1] + (W * S[L + 1][1] - W * S[L - 1][1]) / 6], U[2] = [S[L + 1][0] + (W * S[L][0] - W * S[L + 2][0]) / 6, S[L + 1][1] + (W * S[L][1] - W * S[L + 2][1]) / 6], U[3] = [S[L + 1][0], S[L + 1][1]], this.drawingContext.bezierCurveTo(U[1][0], U[1][1], U[2][0], U[2][1], U[3][0], U[3][1]);\n                V && this.drawingContext.lineTo(S[L + 1][0], S[L + 1][1]), this._doFillStrokeClose(V);\n              }\n            } else if (A && M === null) {\n              for (this._clipping || this.drawingContext.beginPath(), L = 0; L < G; L++)\n                S[L].isVert ? S[L].moveTo ? this.drawingContext.moveTo(S[L][0], S[L][1]) : this.drawingContext.lineTo(S[L][0], S[L][1]) : this.drawingContext.bezierCurveTo(S[L][0], S[L][1], S[L][2], S[L][3], S[L][4], S[L][5]);\n              this._doFillStrokeClose(V);\n            } else if (x && M === null) {\n              for (this._clipping || this.drawingContext.beginPath(), L = 0; L < G; L++)\n                S[L].isVert ? S[L].moveTo ? this.drawingContext.moveTo(S[L][0], S[L][1]) : this.drawingContext.lineTo(S[L][0], S[L][1]) : this.drawingContext.quadraticCurveTo(S[L][0], S[L][1], S[L][2], S[L][3]);\n              this._doFillStrokeClose(V);\n            } else if (M === h.POINTS)\n              for (L = 0; L < G; L++)\n                R = S[L], this._doStroke && this._pInst.stroke(R[6]), this._pInst.point(R[0], R[1]);\n            else if (M === h.LINES)\n              for (L = 0; L + 1 < G; L += 2)\n                R = S[L], this._doStroke && this._pInst.stroke(S[L + 1][6]), this._pInst.line(R[0], R[1], S[L + 1][0], S[L + 1][1]);\n            else if (M === h.TRIANGLES)\n              for (L = 0; L + 2 < G; L += 3)\n                R = S[L], this._clipping || this.drawingContext.beginPath(), this.drawingContext.moveTo(R[0], R[1]), this.drawingContext.lineTo(S[L + 1][0], S[L + 1][1]), this.drawingContext.lineTo(S[L + 2][0], S[L + 2][1]), this.drawingContext.closePath(), !this._clipping && this._doFill && (this._pInst.fill(S[L + 2][5]), this.drawingContext.fill()), !this._clipping && this._doStroke && (this._pInst.stroke(S[L + 2][6]), this.drawingContext.stroke());\n            else if (M === h.TRIANGLE_STRIP)\n              for (L = 0; L + 1 < G; L++)\n                R = S[L], this._clipping || this.drawingContext.beginPath(), this.drawingContext.moveTo(S[L + 1][0], S[L + 1][1]), this.drawingContext.lineTo(R[0], R[1]), !this._clipping && this._doStroke && this._pInst.stroke(S[L + 1][6]), !this._clipping && this._doFill && this._pInst.fill(S[L + 1][5]), L + 2 < G && (this.drawingContext.lineTo(S[L + 2][0], S[L + 2][1]), !this._clipping && this._doStroke && this._pInst.stroke(S[L + 2][6]), !this._clipping && this._doFill && this._pInst.fill(S[L + 2][5])), this._doFillStrokeClose(V);\n            else if (M === h.TRIANGLE_FAN) {\n              if (2 < G) {\n                for (this._clipping || this.drawingContext.beginPath(), L = 2; L < G; L++)\n                  R = S[L], this.drawingContext.moveTo(S[0][0], S[0][1]), this.drawingContext.lineTo(S[L - 1][0], S[L - 1][1]), this.drawingContext.lineTo(R[0], R[1]), this.drawingContext.lineTo(S[0][0], S[0][1]), L < G - 1 && (this._doFill && R[5] !== S[L + 1][5] || this._doStroke && R[6] !== S[L + 1][6]) && (!this._clipping && this._doFill && (this._pInst.fill(R[5]), this.drawingContext.fill(), this._pInst.fill(S[L + 1][5])), !this._clipping && this._doStroke && (this._pInst.stroke(R[6]), this.drawingContext.stroke(), this._pInst.stroke(S[L + 1][6])), this.drawingContext.closePath(), this._clipping || this.drawingContext.beginPath());\n                this._doFillStrokeClose(V);\n              }\n            } else if (M === h.QUADS)\n              for (L = 0; L + 3 < G; L += 4) {\n                for (R = S[L], this._clipping || this.drawingContext.beginPath(), this.drawingContext.moveTo(R[0], R[1]), F = 1; F < 4; F++)\n                  this.drawingContext.lineTo(S[L + F][0], S[L + F][1]);\n                this.drawingContext.lineTo(R[0], R[1]), !this._clipping && this._doFill && this._pInst.fill(S[L + 3][5]), !this._clipping && this._doStroke && this._pInst.stroke(S[L + 3][6]), this._doFillStrokeClose(V);\n              }\n            else if (M === h.QUAD_STRIP) {\n              if (3 < G)\n                for (L = 0; L + 1 < G; L += 2)\n                  R = S[L], this._clipping || this.drawingContext.beginPath(), L + 3 < G ? (this.drawingContext.moveTo(S[L + 2][0], S[L + 2][1]), this.drawingContext.lineTo(R[0], R[1]), this.drawingContext.lineTo(S[L + 1][0], S[L + 1][1]), this.drawingContext.lineTo(S[L + 3][0], S[L + 3][1]), !this._clipping && this._doFill && this._pInst.fill(S[L + 3][5]), !this._clipping && this._doStroke && this._pInst.stroke(S[L + 3][6])) : (this.drawingContext.moveTo(R[0], R[1]), this.drawingContext.lineTo(S[L + 1][0], S[L + 1][1])), this._doFillStrokeClose(V);\n            } else {\n              for (this._clipping || this.drawingContext.beginPath(), this.drawingContext.moveTo(S[0][0], S[0][1]), L = 1; L < G; L++)\n                (R = S[L]).isVert && (R.moveTo ? (V && this.drawingContext.closePath(), this.drawingContext.moveTo(R[0], R[1])) : this.drawingContext.lineTo(R[0], R[1]));\n              this._doFillStrokeClose(V);\n            }\n            P = x = A = E = !1, V && S.pop();\n          }\n          return this;\n        } }, { key: \"strokeCap\", value: function(_) {\n          return _ !== h.ROUND && _ !== h.SQUARE && _ !== h.PROJECT || (this.drawingContext.lineCap = _), this;\n        } }, { key: \"strokeJoin\", value: function(_) {\n          return _ !== h.ROUND && _ !== h.BEVEL && _ !== h.MITER || (this.drawingContext.lineJoin = _), this;\n        } }, { key: \"strokeWeight\", value: function(_) {\n          return this.drawingContext.lineWidth = _ === void 0 || _ === 0 ? 1e-4 : _, this;\n        } }, { key: \"_getFill\", value: function() {\n          return this._cachedFillStyle || (this._cachedFillStyle = this.drawingContext.fillStyle), this._cachedFillStyle;\n        } }, { key: \"_setFill\", value: function(_) {\n          _ !== this._cachedFillStyle && (this.drawingContext.fillStyle = _, this._cachedFillStyle = _);\n        } }, { key: \"_getStroke\", value: function() {\n          return this._cachedStrokeStyle || (this._cachedStrokeStyle = this.drawingContext.strokeStyle), this._cachedStrokeStyle;\n        } }, { key: \"_setStroke\", value: function(_) {\n          _ !== this._cachedStrokeStyle && (this.drawingContext.strokeStyle = _, this._cachedStrokeStyle = _);\n        } }, { key: \"bezier\", value: function(_, S, E, A, x, P, M, R) {\n          return this._pInst.beginShape(), this._pInst.vertex(_, S), this._pInst.bezierVertex(E, A, x, P, M, R), this._pInst.endShape(), this;\n        } }, { key: \"curve\", value: function(_, S, E, A, x, P, M, R) {\n          return this._pInst.beginShape(), this._pInst.curveVertex(_, S), this._pInst.curveVertex(E, A), this._pInst.curveVertex(x, P), this._pInst.curveVertex(M, R), this._pInst.endShape(), this;\n        } }, { key: \"_doFillStrokeClose\", value: function(_) {\n          _ && this.drawingContext.closePath(), !this._clipping && this._doFill && this.drawingContext.fill(), !this._clipping && this._doStroke && this.drawingContext.stroke();\n        } }, { key: \"applyMatrix\", value: function(_, S, E, A, x, P) {\n          this.drawingContext.transform(_, S, E, A, x, P);\n        } }, { key: \"resetMatrix\", value: function() {\n          return this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), this;\n        } }, { key: \"rotate\", value: function(_) {\n          this.drawingContext.rotate(_);\n        } }, { key: \"scale\", value: function(_, S) {\n          return this.drawingContext.scale(_, S), this;\n        } }, { key: \"translate\", value: function(_, S) {\n          return _ instanceof u.default.Vector && (S = _.y, _ = _.x), this.drawingContext.translate(_, S), this;\n        } }, { key: \"_renderText\", value: function(_, S, E, A, x, P) {\n          if (!(A < P || x <= A))\n            return _.push(), this._isOpenType() ? this._textFont._renderPath(S, E, A, { renderer: this }) : (this._doStroke && this._strokeSet && this.drawingContext.strokeText(S, E, A), !this._clipping && this._doFill && (this._fillSet || this._setFill(h._DEFAULT_TEXT_FILL), this.drawingContext.fillText(S, E, A))), _.pop(), _;\n        } }, { key: \"textWidth\", value: function(_) {\n          return this._isOpenType() ? this._textFont._textWidth(_, this._textSize) : this.drawingContext.measureText(_).width;\n        } }, { key: \"_applyTextProperties\", value: function() {\n          var _ = this._pInst, S = (this._setProperty(\"_textAscent\", null), this._setProperty(\"_textDescent\", null), S = this._textFont, this._isOpenType() && (S = this._textFont.font.familyName, this._setProperty(\"_textStyle\", this._textFont.font.styleName)), S || \"sans-serif\");\n          return /\\s/.exec(S) && (S = '\"'.concat(S, '\"')), this.drawingContext.font = \"\".concat(this._textStyle || \"normal\", \" \").concat(this._textSize || 12, \"px \").concat(S), this.drawingContext.textAlign = this._textAlign, this._textBaseline === h.CENTER ? this.drawingContext.textBaseline = h._CTX_MIDDLE : this.drawingContext.textBaseline = this._textBaseline, _;\n        } }, { key: \"push\", value: function() {\n          return this.drawingContext.save(), r(i(T.prototype), \"push\", this).call(this);\n        } }, { key: \"pop\", value: function(_) {\n          this.drawingContext.restore(), this._cachedFillStyle = this.drawingContext.fillStyle, this._cachedStrokeStyle = this.drawingContext.strokeStyle, r(i(T.prototype), \"pop\", this).call(this, _);\n        } }]) && f(p.prototype, c), T;\n      }(u.default.Renderer), a = (n.prototype.text = function(c, p, j, E, _) {\n        E !== void 0 && this.drawingContext.textBaseline === h.BASELINE && (S = !0, this.drawingContext.textBaseline = h.TOP);\n        var S, E = u.default.Renderer.prototype.text.apply(this, arguments);\n        return S && (this.drawingContext.textBaseline = h.BASELINE), E;\n      }, u.default.Renderer2D = n, u.default.Renderer2D);\n      C.default = a;\n    }, { \"./constants\": 269, \"./main\": 280, \"./p5.Renderer\": 283, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.number.to-fixed\": 180, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.reflect.get\": 190, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 285: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\");\n      var m = (t = t(\"./main\")) && t.__esModule ? t : { default: t };\n      m.default.prototype._promisePreloads = [];\n      function y() {\n        return {};\n      }\n      var u = !(m.default.prototype.registerPromisePreload = function(h) {\n        m.default.prototype._promisePreloads.push(h);\n      });\n      m.default.prototype._setupPromisePreloads = function() {\n        var h = !0, g = !1, f = void 0;\n        try {\n          for (var r, s = this._promisePreloads[Symbol.iterator](); !(h = (r = s.next()).done); h = !0) {\n            var o = r.value, i = this, l = o.method, n = o.addCallbacks, a = o.legacyPreloadSetup, c = o.target || this, p = c[l].bind(c);\n            if (c === m.default.prototype) {\n              if (u)\n                continue;\n              i = null, p = c[l];\n            }\n            c[l] = this._wrapPromisePreload(i, p, n), a && (c[a.method] = this._legacyPreloadGenerator(i, a, c[l]));\n          }\n        } catch (j) {\n          g = !0, f = j;\n        } finally {\n          try {\n            h || s.return == null || s.return();\n          } finally {\n            if (g)\n              throw f;\n          }\n        }\n        u = !0;\n      }, m.default.prototype._wrapPromisePreload = function(h, g, f) {\n        var r = function() {\n          for (var s = this, o = (this._incrementPreload(), null), i = null, l = arguments.length, n = new Array(l), a = 0; a < l; a++)\n            n[a] = arguments[a];\n          if (f)\n            for (var c = n.length - 1; 0 <= c && !i && typeof n[c] == \"function\"; c--)\n              i = o, o = n.pop();\n          var p = Promise.resolve(g.apply(this, n));\n          return o && p.then(o), i && p.catch(i), p.then(function() {\n            return s._decrementPreload();\n          }), p;\n        };\n        return r = h ? r.bind(h) : r;\n      }, m.default.prototype._legacyPreloadGenerator = function(h, s, f) {\n        var r = s.createBaseObject || y, s = function() {\n          var o = this;\n          this._incrementPreload();\n          for (var i = arguments.length, l = new Array(i), n = 0; n < i; n++)\n            l[n] = arguments[n];\n          var a = r.apply(this, l);\n          return f.apply(this, l).then(function(c) {\n            Object.assign(a, c), o._decrementPreload();\n          }), a;\n        };\n        return s = h ? s.bind(h) : s;\n      };\n    }, { \"./main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 286: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (r = t(\"./main\")) && r.__esModule ? r : { default: r }, u = function(s) {\n        if (s && s.__esModule)\n          return s;\n        if (s === null || g(s) !== \"object\" && typeof s != \"function\")\n          return { default: s };\n        var o = h();\n        if (o && o.has(s))\n          return o.get(s);\n        var i, l = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (i in s) {\n          var a;\n          Object.prototype.hasOwnProperty.call(s, i) && ((a = n ? Object.getOwnPropertyDescriptor(s, i) : null) && (a.get || a.set) ? Object.defineProperty(l, i, a) : l[i] = s[i]);\n        }\n        return l.default = s, o && o.set(s, l), l;\n      }(t(\"./constants\"));\n      function h() {\n        var s;\n        return typeof WeakMap != \"function\" ? null : (s = /* @__PURE__ */ new WeakMap(), h = function() {\n          return s;\n        }, s);\n      }\n      function g(s) {\n        return (g = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"./p5.Graphics\"), t(\"./p5.Renderer2D\"), t(\"../webgl/p5.RendererGL\");\n      var f = \"defaultCanvas0\", r = (y.default.prototype.createCanvas = function(s, o, i, l) {\n        var n, a, c;\n        if (y.default._validateParameters(\"createCanvas\", arguments), arguments[2] instanceof HTMLCanvasElement ? (i = u.P2D, l = arguments[2]) : n = i || u.P2D, l)\n          (c = document.getElementById(f)) && c.parentNode.removeChild(c), c = l, this._defaultGraphicsCreated = !1;\n        else {\n          if (n === u.WEBGL)\n            (c = document.getElementById(f)) && (c.parentNode.removeChild(c), a = this._renderer, this._elements = this._elements.filter(function(j) {\n              return j !== a;\n            })), (c = document.createElement(\"canvas\")).id = f, c.classList.add(\"p5Canvas\");\n          else if (this._defaultGraphicsCreated)\n            c = this.canvas;\n          else {\n            c = l || document.createElement(\"canvas\");\n            for (var p = 0; document.getElementById(\"defaultCanvas\".concat(p)); )\n              p++;\n            f = \"defaultCanvas\".concat(p), c.id = f, c.classList.add(\"p5Canvas\");\n          }\n          this._setupDone || (c.dataset.hidden = !0, c.style.visibility = \"hidden\"), (this._userNode || (document.getElementsByTagName(\"main\").length === 0 && (i = document.createElement(\"main\"), document.body.appendChild(i)), document.getElementsByTagName(\"main\")[0])).appendChild(c);\n        }\n        return n === u.WEBGL ? (this._setProperty(\"_renderer\", new y.default.RendererGL(c, this, !0)), this._elements.push(this._renderer), s = (l = this._renderer._adjustDimensions(s, o)).adjustedWidth, o = l.adjustedHeight) : this._defaultGraphicsCreated || (this._setProperty(\"_renderer\", new y.default.Renderer2D(c, this, !0)), this._defaultGraphicsCreated = !0, this._elements.push(this._renderer)), this._renderer.resize(s, o), this._renderer._applyDefaults(), this._renderer;\n      }, y.default.prototype.resizeCanvas = function(s, o, i) {\n        if (y.default._validateParameters(\"resizeCanvas\", arguments), this._renderer) {\n          var l, n, a, c = {};\n          for (l in this.drawingContext) {\n            var p = this.drawingContext[l];\n            g(p) !== \"object\" && typeof p != \"function\" && (c[l] = p);\n          }\n          for (a in this._renderer instanceof y.default.RendererGL && (s = (n = this._renderer._adjustDimensions(s, o)).adjustedWidth, o = n.adjustedHeight), this.width = s, this.height = o, this._renderer.resize(s, o), c)\n            try {\n              this.drawingContext[a] = c[a];\n            } catch {\n            }\n          i || this.redraw();\n        }\n        this._addAccsOutput() && this._updateAccsOutput();\n      }, y.default.prototype.noCanvas = function() {\n        this.canvas && this.canvas.parentNode.removeChild(this.canvas);\n      }, y.default.prototype.createGraphics = function(s, o) {\n        for (var i = arguments.length, l = new Array(2 < i ? i - 2 : 0), n = 2; n < i; n++)\n          l[n - 2] = arguments[n];\n        return l[0] instanceof HTMLCanvasElement && (l[1] = l[0], l[0] = u.P2D), y.default._validateParameters(\"createGraphics\", arguments), new y.default.Graphics(s, o, l[0], this, l[1]);\n      }, y.default.prototype.createFramebuffer = function(s) {\n        return new y.default.Framebuffer(this, s);\n      }, y.default.prototype.clearDepth = function(s) {\n        this._assert3d(\"clearDepth\"), this._renderer.clearDepth(s);\n      }, y.default.prototype.blendMode = function(s) {\n        y.default._validateParameters(\"blendMode\", arguments), s === u.NORMAL && (console.warn(\"NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead.\"), s = u.BLEND), this._renderer.blendMode(s);\n      }, y.default);\n      C.default = r;\n    }, { \"../webgl/p5.RendererGL\": 337, \"./constants\": 269, \"./main\": 280, \"./p5.Graphics\": 282, \"./p5.Renderer2D\": 284, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 287: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      function y(o) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.slice\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = r(t(\"../main\")), h = function(o) {\n        if (o && o.__esModule)\n          return o;\n        if (o === null || y(o) !== \"object\" && typeof o != \"function\")\n          return { default: o };\n        var i = f();\n        if (i && i.has(o))\n          return i.get(o);\n        var l, n = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (l in o) {\n          var c;\n          Object.prototype.hasOwnProperty.call(o, l) && ((c = a ? Object.getOwnPropertyDescriptor(o, l) : null) && (c.get || c.set) ? Object.defineProperty(n, l, c) : n[l] = o[l]);\n        }\n        return n.default = o, i && i.set(o, n), n;\n      }(t(\"../constants\")), g = r(t(\"../helpers\"));\n      function f() {\n        var o;\n        return typeof WeakMap != \"function\" ? null : (o = /* @__PURE__ */ new WeakMap(), f = function() {\n          return o;\n        }, o);\n      }\n      function r(o) {\n        return o && o.__esModule ? o : { default: o };\n      }\n      function s(o) {\n        return function(i) {\n          if (Array.isArray(i)) {\n            for (var l = 0, n = new Array(i.length); l < i.length; l++)\n              n[l] = i[l];\n            return n;\n          }\n        }(o) || function(i) {\n          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === \"[object Arguments]\")\n            return Array.from(i);\n        }(o) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      t(\"../friendly_errors/fes_core\"), t(\"../friendly_errors/file_errors\"), t(\"../friendly_errors/validate_params\"), u.default.prototype._normalizeArcAngles = function(o, i, l, n, a) {\n        var c;\n        return o -= h.TWO_PI * Math.floor(o / h.TWO_PI), i -= h.TWO_PI * Math.floor(i / h.TWO_PI), c = Math.min(Math.abs(o - i), h.TWO_PI - Math.abs(o - i)), a && (o = o <= h.HALF_PI ? Math.atan(l / n * Math.tan(o)) : o > h.HALF_PI && o <= 3 * h.HALF_PI ? Math.atan(l / n * Math.tan(o)) + h.PI : Math.atan(l / n * Math.tan(o)) + h.TWO_PI, i = i <= h.HALF_PI ? Math.atan(l / n * Math.tan(i)) : i > h.HALF_PI && i <= 3 * h.HALF_PI ? Math.atan(l / n * Math.tan(i)) + h.PI : Math.atan(l / n * Math.tan(i)) + h.TWO_PI), i < o && (i += h.TWO_PI), { start: o, stop: i, correspondToSamePoint: c < 1e-5 };\n      }, u.default.prototype.arc = function(o, i, l, n, a, c, p, j) {\n        return u.default._validateParameters(\"arc\", arguments), (this._renderer._doStroke || this._renderer._doFill) && a !== c && (a = this._toRadians(a), c = this._toRadians(c), l = Math.abs(l), n = Math.abs(n), o = g.default.modeAdjust(o, i, l, n, this._renderer._ellipseMode), (i = this._normalizeArcAngles(a, c, o.w, o.h, !0)).correspondToSamePoint ? this._renderer.ellipse([o.x, o.y, o.w, o.h, j]) : (this._renderer.arc(o.x, o.y, o.w, o.h, i.start, i.stop, p, j), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"arc\", [o.x, o.y, o.w, o.h, i.start, i.stop, p]))), this;\n      }, u.default.prototype.ellipse = function(o, i, l, n, a) {\n        return u.default._validateParameters(\"ellipse\", arguments), this._renderEllipse.apply(this, arguments);\n      }, u.default.prototype.circle = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        u.default._validateParameters(\"circle\", i);\n        var n = i.slice(0, 2);\n        return n.push(i[2], i[2]), this._renderEllipse.apply(this, s(n));\n      }, u.default.prototype._renderEllipse = function(o, i, l, n, a) {\n        return (this._renderer._doStroke || this._renderer._doFill) && (l < 0 && (l = Math.abs(l)), n === void 0 ? n = l : n < 0 && (n = Math.abs(n)), o = g.default.modeAdjust(o, i, l, n, this._renderer._ellipseMode), this._renderer.ellipse([o.x, o.y, o.w, o.h, a]), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"ellipse\", [o.x, o.y, o.w, o.h])), this;\n      }, u.default.prototype.line = function() {\n        for (var o, i = arguments.length, l = new Array(i), n = 0; n < i; n++)\n          l[n] = arguments[n];\n        return u.default._validateParameters(\"line\", l), this._renderer._doStroke && (o = this._renderer).line.apply(o, l), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"line\", l), this;\n      }, u.default.prototype.point = function() {\n        for (var o, i = arguments.length, l = new Array(i), n = 0; n < i; n++)\n          l[n] = arguments[n];\n        return u.default._validateParameters(\"point\", l), this._renderer._doStroke && (l.length === 1 && l[0] instanceof u.default.Vector ? this._renderer.point.call(this._renderer, l[0].x, l[0].y, l[0].z) : ((o = this._renderer).point.apply(o, l), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"point\", l))), this;\n      }, u.default.prototype.quad = function() {\n        for (var o, i = arguments.length, l = new Array(i), n = 0; n < i; n++)\n          l[n] = arguments[n];\n        return u.default._validateParameters(\"quad\", l), (this._renderer._doStroke || this._renderer._doFill) && (this._renderer.isP3D && l.length < 12 ? this._renderer.quad.call(this._renderer, l[0], l[1], 0, l[2], l[3], 0, l[4], l[5], 0, l[6], l[7], 0, l[8], l[9]) : ((o = this._renderer).quad.apply(o, l), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"quadrilateral\", l))), this;\n      }, u.default.prototype.rect = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        return u.default._validateParameters(\"rect\", i), this._renderRect.apply(this, i);\n      }, u.default.prototype.square = function(o, i, l, n, a, c, p) {\n        return u.default._validateParameters(\"square\", arguments), this._renderRect.call(this, o, i, l, l, n, a, c, p);\n      }, u.default.prototype._renderRect = function() {\n        if (this._renderer._doStroke || this._renderer._doFill) {\n          arguments.length === 3 && (arguments[3] = arguments[2]);\n          for (var o = g.default.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer._rectMode), i = [o.x, o.y, o.w, o.h], l = 4; l < arguments.length; l++)\n            i[l] = arguments[l];\n          this._renderer.rect(i), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"rectangle\", [o.x, o.y, o.w, o.h]);\n        }\n        return this;\n      }, u.default.prototype.triangle = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        return u.default._validateParameters(\"triangle\", i), (this._renderer._doStroke || this._renderer._doFill) && this._renderer.triangle(i), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput(\"triangle\", i), this;\n      }, t = u.default, C.default = t;\n    }, { \"../constants\": 269, \"../friendly_errors/fes_core\": 271, \"../friendly_errors/file_errors\": 272, \"../friendly_errors/validate_params\": 275, \"../helpers\": 276, \"../main\": 280, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 288: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../main\")) && f.__esModule ? f : { default: f }, h = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../constants\"));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      u.default.prototype.ellipseMode = function(r) {\n        return u.default._validateParameters(\"ellipseMode\", arguments), r !== h.CORNER && r !== h.CORNERS && r !== h.RADIUS && r !== h.CENTER || (this._renderer._ellipseMode = r), this;\n      }, u.default.prototype.noSmooth = function() {\n        return this._renderer.isP3D ? this.setAttributes(\"antialias\", !1) : \"imageSmoothingEnabled\" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = !1), this;\n      }, u.default.prototype.rectMode = function(r) {\n        return u.default._validateParameters(\"rectMode\", arguments), r !== h.CORNER && r !== h.CORNERS && r !== h.RADIUS && r !== h.CENTER || (this._renderer._rectMode = r), this;\n      }, u.default.prototype.smooth = function() {\n        return this.setAttributes(\"antialias\", !0), this._renderer.isP3D || \"imageSmoothingEnabled\" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = !0), this;\n      }, u.default.prototype.strokeCap = function(r) {\n        return u.default._validateParameters(\"strokeCap\", arguments), r !== h.ROUND && r !== h.SQUARE && r !== h.PROJECT || this._renderer.strokeCap(r), this;\n      }, u.default.prototype.strokeJoin = function(r) {\n        return u.default._validateParameters(\"strokeJoin\", arguments), r !== h.ROUND && r !== h.BEVEL && r !== h.MITER || this._renderer.strokeJoin(r), this;\n      }, u.default.prototype.strokeWeight = function(r) {\n        return u.default._validateParameters(\"strokeWeight\", arguments), this._renderer.strokeWeight(r), this;\n      };\n      var f = u.default;\n      C.default = f;\n    }, { \"../constants\": 269, \"../main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 289: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (y = t(\"../main\")) && y.__esModule ? y : { default: y };\n      t(\"../friendly_errors/fes_core\"), t(\"../friendly_errors/file_errors\"), t(\"../friendly_errors/validate_params\"), m.default.prototype.bezier = function() {\n        for (var u, h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"bezier\", g), (this._renderer._doStroke || this._renderer._doFill) && (u = this._renderer).bezier.apply(u, g), this;\n      }, m.default.prototype.bezierDetail = function(u) {\n        return m.default._validateParameters(\"bezierDetail\", arguments), this._bezierDetail = u, this;\n      }, m.default.prototype.bezierPoint = function(u, h, g, f, r) {\n        m.default._validateParameters(\"bezierPoint\", arguments);\n        var s = 1 - r;\n        return Math.pow(s, 3) * u + 3 * Math.pow(s, 2) * r * h + 3 * s * Math.pow(r, 2) * g + Math.pow(r, 3) * f;\n      }, m.default.prototype.bezierTangent = function(u, h, g, f, r) {\n        m.default._validateParameters(\"bezierTangent\", arguments);\n        var s = 1 - r;\n        return 3 * f * Math.pow(r, 2) - 3 * g * Math.pow(r, 2) + 6 * g * s * r - 6 * h * s * r + 3 * h * Math.pow(s, 2) - 3 * u * Math.pow(s, 2);\n      }, m.default.prototype.curve = function() {\n        for (var u, h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"curve\", g), this._renderer._doStroke && (u = this._renderer).curve.apply(u, g), this;\n      }, m.default.prototype.curveDetail = function(u) {\n        return m.default._validateParameters(\"curveDetail\", arguments), this._curveDetail = u < 3 ? 3 : u, this;\n      }, m.default.prototype.curveTightness = function(u) {\n        return m.default._validateParameters(\"curveTightness\", arguments), this._renderer._curveTightness = u, this;\n      }, m.default.prototype.curvePoint = function(u, h, g, f, r) {\n        m.default._validateParameters(\"curvePoint\", arguments);\n        var s = this._renderer._curveTightness, o = r * r * r, i = r * r;\n        return u * ((s - 1) / 2 * o + (1 - s) * i + (s - 1) / 2 * r) + h * ((s + 3) / 2 * o + (-5 - s) / 2 * i + 1) + g * ((-3 - s) / 2 * o + (s + 2) * i + (1 - s) / 2 * r) + f * ((1 - s) / 2 * o + (s - 1) / 2 * i);\n      }, m.default.prototype.curveTangent = function(u, h, g, f, i) {\n        m.default._validateParameters(\"curveTangent\", arguments);\n        var s = this._renderer._curveTightness, o = i * i * 3, i = 2 * i;\n        return u * ((s - 1) / 2 * o + (1 - s) * i + (s - 1) / 2) + h * ((s + 3) / 2 * o + (-5 - s) / 2 * i) + g * ((-3 - s) / 2 * o + (s + 2) * i + (1 - s) / 2) + f * ((1 - s) / 2 * o + (s - 1) / 2 * i);\n      };\n      var y = m.default;\n      C.default = y;\n    }, { \"../friendly_errors/fes_core\": 271, \"../friendly_errors/file_errors\": 272, \"../friendly_errors/validate_params\": 275, \"../main\": 280 }], 290: [function(t, H, C) {\n      function m(p) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(j) {\n          return typeof j;\n        } : function(j) {\n          return j && typeof Symbol == \"function\" && j.constructor === Symbol && j !== Symbol.prototype ? \"symbol\" : typeof j;\n        })(p);\n      }\n      function y(p) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(j) {\n          return m(j);\n        } : function(j) {\n          return j && typeof Symbol == \"function\" && j.constructor === Symbol && j !== Symbol.prototype ? \"symbol\" : m(j);\n        })(p);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.slice\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (c = t(\"../main\")) && c.__esModule ? c : { default: c }, h = function(p) {\n        if (p && p.__esModule)\n          return p;\n        if (p === null || y(p) !== \"object\" && typeof p != \"function\")\n          return { default: p };\n        var j = g();\n        if (j && j.has(p))\n          return j.get(p);\n        var T, _ = {}, S = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (T in p) {\n          var E;\n          Object.prototype.hasOwnProperty.call(p, T) && ((E = S ? Object.getOwnPropertyDescriptor(p, T) : null) && (E.get || E.set) ? Object.defineProperty(_, T, E) : _[T] = p[T]);\n        }\n        return _.default = p, j && j.set(p, _), _;\n      }(t(\"../constants\"));\n      function g() {\n        var p;\n        return typeof WeakMap != \"function\" ? null : (p = /* @__PURE__ */ new WeakMap(), g = function() {\n          return p;\n        }, p);\n      }\n      var f = null, r = [], s = [], o = !1, i = !1, l = !1, n = !1, a = !0, c = (u.default.prototype.beginContour = function() {\n        return this._renderer.isP3D ? this._renderer.beginContour() : (s = [], n = !0), this;\n      }, u.default.prototype.beginShape = function(p) {\n        var j;\n        return u.default._validateParameters(\"beginShape\", arguments), this._renderer.isP3D ? (j = this._renderer).beginShape.apply(j, arguments) : (f = p === h.POINTS || p === h.LINES || p === h.TRIANGLES || p === h.TRIANGLE_FAN || p === h.TRIANGLE_STRIP || p === h.QUADS || p === h.QUAD_STRIP ? p : null, r = [], s = []), this;\n      }, u.default.prototype.bezierVertex = function() {\n        for (var p, j = arguments.length, T = new Array(j), _ = 0; _ < j; _++)\n          T[_] = arguments[_];\n        if (u.default._validateParameters(\"bezierVertex\", T), this._renderer.isP3D)\n          (p = this._renderer).bezierVertex.apply(p, T);\n        else if (r.length === 0)\n          u.default._friendlyError(\"vertex() must be used once before calling bezierVertex()\", \"bezierVertex\");\n        else {\n          o = !0;\n          for (var S = [], E = 0; E < T.length; E++)\n            S[E] = T[E];\n          S.isVert = !1, (n ? s : r).push(S);\n        }\n        return this;\n      }, u.default.prototype.curveVertex = function() {\n        for (var p, j = arguments.length, T = new Array(j), _ = 0; _ < j; _++)\n          T[_] = arguments[_];\n        return u.default._validateParameters(\"curveVertex\", T), this._renderer.isP3D ? (p = this._renderer).curveVertex.apply(p, T) : (i = !0, this.vertex(T[0], T[1])), this;\n      }, u.default.prototype.endContour = function() {\n        if (!this._renderer.isP3D) {\n          var p = s[0].slice();\n          p.isVert = s[0].isVert, p.moveTo = !1, s.push(p), a && (r.push(r[0]), a = !1);\n          for (var j = 0; j < s.length; j++)\n            r.push(s[j]);\n        }\n        return this;\n      }, u.default.prototype.endShape = function(p) {\n        var j = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (u.default._validateParameters(\"endShape\", arguments), j < 1 && (console.log(\"🌸 p5.js says: You can not have less than one instance\"), j = 1), this._renderer.isP3D)\n          this._renderer.endShape(p, i, o, l, n, f, j);\n        else {\n          if (j !== 1 && console.log(\"🌸 p5.js says: Instancing is only supported in WebGL2 mode\"), r.length === 0)\n            return this;\n          if (!this._renderer._doStroke && !this._renderer._doFill)\n            return this;\n          j = p === h.CLOSE, j && !n && r.push(r[0]), this._renderer.endShape(p, r, i, o, l, n, f), a = !(n = l = o = i = !1), j && r.pop();\n        }\n        return this;\n      }, u.default.prototype.quadraticVertex = function() {\n        for (var p, j = arguments.length, T = new Array(j), _ = 0; _ < j; _++)\n          T[_] = arguments[_];\n        if (u.default._validateParameters(\"quadraticVertex\", T), this._renderer.isP3D)\n          (p = this._renderer).quadraticVertex.apply(p, T);\n        else {\n          if (this._contourInited)\n            return (p = {}).x = T[0], p.y = T[1], p.x3 = T[2], p.y3 = T[3], p.type = h.QUADRATIC, this._contourVertices.push(p), this;\n          if (0 < r.length) {\n            l = !0;\n            for (var S = [], E = 0; E < T.length; E++)\n              S[E] = T[E];\n            S.isVert = !1, (n ? s : r).push(S);\n          } else\n            u.default._friendlyError(\"vertex() must be used once before calling quadraticVertex()\", \"quadraticVertex\");\n        }\n        return this;\n      }, u.default.prototype.vertex = function(p, j, T, _, S) {\n        var E;\n        return this._renderer.isP3D ? (E = this._renderer).vertex.apply(E, arguments) : ((E = []).isVert = !0, E[0] = p, E[1] = j, E[2] = 0, E[3] = 0, E[4] = 0, E[5] = this._renderer._getFill(), E[6] = this._renderer._getStroke(), T && (E.moveTo = T), (n ? (s.length === 0 && (E.moveTo = !0), s) : r).push(E)), this;\n      }, u.default.prototype.normal = function(p, j, T) {\n        var _;\n        return this._assert3d(\"normal\"), u.default._validateParameters(\"normal\", arguments), (_ = this._renderer).normal.apply(_, arguments), this;\n      }, u.default);\n      C.default = c;\n    }, { \"../constants\": 269, \"../main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 291: [function(t, H, C) {\n    }, {}], 292: [function(t, H, C) {\n      t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.assign\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"./main\")) && t.__esModule ? t : { default: t }, t.default.prototype.noLoop = function() {\n        this._loop = !1;\n      }, t.default.prototype.loop = function() {\n        this._loop || (this._loop = !0, this._setupDone && this._draw());\n      }, t.default.prototype.isLooping = function() {\n        return this._loop;\n      }, t.default.prototype.push = function() {\n        this._styles.push({ props: { _colorMode: this._colorMode }, renderer: this._renderer.push() });\n      }, t.default.prototype.pop = function() {\n        var m = this._styles.pop();\n        m ? (this._renderer.pop(m.renderer), Object.assign(this, m.props)) : console.warn(\"pop() was called without matching push()\");\n      }, t.default.prototype.redraw = function(m) {\n        if (!this._inUserDraw && this._setupDone) {\n          var y = parseInt(m), u = ((isNaN(y) || y < 1) && (y = 1), this._isGlobal ? window : this);\n          if (typeof u.draw == \"function\") {\n            u.setup === void 0 && u.scale(u._pixelDensity, u._pixelDensity);\n            for (var h = 0; h < y; h++) {\n              u.resetMatrix(), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._updateAccsOutput(), u._renderer.isP3D && u._renderer._update(), u._setProperty(\"frameCount\", u.frameCount + 1), this.callRegisteredHooksFor(\"pre\"), this._inUserDraw = !0;\n              try {\n                u.draw();\n              } finally {\n                this._inUserDraw = !1;\n              }\n              this.callRegisteredHooksFor(\"post\");\n            }\n          }\n        }\n      }, t = t.default, C.default = t;\n    }, { \"./main\": 280, \"core-js/modules/es.object.assign\": 181 }], 293: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"./main\")) && t.__esModule ? t : { default: t };\n      function y(u) {\n        return function(h) {\n          if (Array.isArray(h)) {\n            for (var g = 0, f = new Array(h.length); g < h.length; g++)\n              f[g] = h[g];\n            return f;\n          }\n        }(u) || function(h) {\n          if (Symbol.iterator in Object(h) || Object.prototype.toString.call(h) === \"[object Arguments]\")\n            return Array.from(h);\n        }(u) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      m.default.prototype.applyMatrix = function() {\n        var u = (arguments.length <= 0 ? void 0 : arguments[0]) instanceof Object.getPrototypeOf(Uint8Array);\n        return Array.isArray(arguments.length <= 0 ? void 0 : arguments[0]) || u ? (u = this._renderer).applyMatrix.apply(u, y(arguments.length <= 0 ? void 0 : arguments[0])) : (u = this._renderer).applyMatrix.apply(u, arguments), this;\n      }, m.default.prototype.resetMatrix = function() {\n        return this._renderer.resetMatrix(), this;\n      }, m.default.prototype.rotate = function(u, h) {\n        return m.default._validateParameters(\"rotate\", arguments), this._renderer.rotate(this._toRadians(u), h), this;\n      }, m.default.prototype.rotateX = function(u) {\n        return this._assert3d(\"rotateX\"), m.default._validateParameters(\"rotateX\", arguments), this._renderer.rotateX(this._toRadians(u)), this;\n      }, m.default.prototype.rotateY = function(u) {\n        return this._assert3d(\"rotateY\"), m.default._validateParameters(\"rotateY\", arguments), this._renderer.rotateY(this._toRadians(u)), this;\n      }, m.default.prototype.rotateZ = function(u) {\n        return this._assert3d(\"rotateZ\"), m.default._validateParameters(\"rotateZ\", arguments), this._renderer.rotateZ(this._toRadians(u)), this;\n      }, m.default.prototype.scale = function(u, h, g) {\n        var f;\n        return m.default._validateParameters(\"scale\", arguments), u instanceof m.default.Vector ? (u = (f = u).x, h = f.y, g = f.z) : Array.isArray(u) && (u = (f = u)[0], h = f[1], g = f[2] || 1), isNaN(h) ? h = g = u : isNaN(g) && (g = 1), this._renderer.scale(u, h, g), this;\n      }, m.default.prototype.shearX = function(u) {\n        return m.default._validateParameters(\"shearX\", arguments), u = this._toRadians(u), this._renderer.applyMatrix(1, 0, Math.tan(u), 1, 0, 0), this;\n      }, m.default.prototype.shearY = function(u) {\n        return m.default._validateParameters(\"shearY\", arguments), u = this._toRadians(u), this._renderer.applyMatrix(1, Math.tan(u), 0, 1, 0, 0), this;\n      }, m.default.prototype.translate = function(u, h, g) {\n        return m.default._validateParameters(\"translate\", arguments), this._renderer.isP3D ? this._renderer.translate(u, h, g) : this._renderer.translate(u, h), this;\n      }, t = m.default, C.default = t;\n    }, { \"./main\": 280, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/web.dom-collections.iterator\": 243 }], 294: [function(t, H, C) {\n      function m(g) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(f) {\n          return typeof f;\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : typeof f;\n        })(g);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.ends-with\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.ends-with\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\");\n      var y = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function u(g) {\n        return function(f) {\n          if (Array.isArray(f)) {\n            for (var r = 0, s = new Array(f.length); r < f.length; r++)\n              s[r] = f[r];\n            return s;\n          }\n        }(g) || function(f) {\n          if (Symbol.iterator in Object(f) || Object.prototype.toString.call(f) === \"[object Arguments]\")\n            return Array.from(f);\n        }(g) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function h(g) {\n        return (h = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(f) {\n          return m(f);\n        } : function(f) {\n          return f && typeof Symbol == \"function\" && f.constructor === Symbol && f !== Symbol.prototype ? \"symbol\" : m(f);\n        })(g);\n      }\n      y.default.prototype.storeItem = function(g, f) {\n        typeof g != \"string\" && console.log(\"The argument that you passed to storeItem() - \".concat(g, \" is not a string.\")), g.endsWith(\"p5TypeID\") && console.log(\"The argument that you passed to storeItem() - \".concat(g, \" must not end with 'p5TypeID'.\")), f === void 0 && console.log(\"You cannot store undefined variables using storeItem().\");\n        var r = h(f);\n        switch (r) {\n          case \"number\":\n          case \"boolean\":\n            f = f.toString();\n            break;\n          case \"object\":\n            f instanceof y.default.Color ? r = \"p5.Color\" : f instanceof y.default.Vector && (r = \"p5.Vector\", f = [f.x, f.y, f.z]), f = JSON.stringify(f);\n        }\n        localStorage.setItem(g, f), g = \"\".concat(g, \"p5TypeID\"), localStorage.setItem(g, r);\n      }, y.default.prototype.getItem = function(g) {\n        var f = localStorage.getItem(g), r = localStorage.getItem(\"\".concat(g, \"p5TypeID\"));\n        if (r === void 0)\n          console.log(\"Unable to determine type of item stored under \".concat(g, \"in local storage. Did you save the item with something other than setItem()?\"));\n        else if (f !== null)\n          switch (r) {\n            case \"number\":\n              f = parseFloat(f);\n              break;\n            case \"boolean\":\n              f = f === \"true\";\n              break;\n            case \"object\":\n              f = JSON.parse(f);\n              break;\n            case \"p5.Color\":\n              f = JSON.parse(f), f = this.color.apply(this, u(f.levels));\n              break;\n            case \"p5.Vector\":\n              f = JSON.parse(f), f = this.createVector.apply(this, u(f));\n          }\n        return f;\n      }, y.default.prototype.clearStorage = function() {\n        var g = this;\n        Object.keys(localStorage).forEach(function(f) {\n          f.endsWith(\"p5TypeID\") && g.removeItem(f.replace(\"p5TypeID\", \"\"));\n        });\n      }, y.default.prototype.removeItem = function(g) {\n        typeof g != \"string\" && console.log(\"The argument that you passed to removeItem() - \".concat(g, \" is not a string.\")), localStorage.removeItem(g), localStorage.removeItem(\"\".concat(g, \"p5TypeID\"));\n      };\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.ends-with\": 195, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 295: [function(t, H, C) {\n      function m(l) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(n) {\n          return typeof n;\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : typeof n;\n        })(l);\n      }\n      function y(l) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(n) {\n          return m(n);\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : m(n);\n        })(l);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.object.keys\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function h(l, n) {\n        if (typeof n != \"function\" && n !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        l.prototype = Object.create(n && n.prototype, { constructor: { value: l, writable: !0, configurable: !0 } }), n && g(l, n);\n      }\n      function g(l, n) {\n        return (g = Object.setPrototypeOf || function(a, c) {\n          return a.__proto__ = c, a;\n        })(l, n);\n      }\n      function f(l) {\n        return function() {\n          var n, a = r(l), a = (n = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (n = r(this).constructor, Reflect.construct(a, arguments, n)) : a.apply(this, arguments), this);\n          if (!n || y(n) !== \"object\" && typeof n != \"function\") {\n            if (a !== void 0)\n              return a;\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n          return n;\n        };\n      }\n      function r(l) {\n        return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {\n          return n.__proto__ || Object.getPrototypeOf(n);\n        })(l);\n      }\n      function s(l, n) {\n        if (!(l instanceof n))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function o(l, n) {\n        for (var a = 0; a < n.length; a++) {\n          var c = n[a];\n          c.enumerable = c.enumerable || !1, c.configurable = !0, \"value\" in c && (c.writable = !0), Object.defineProperty(l, c.key, c);\n        }\n      }\n      function i(l, n, a) {\n        n && o(l.prototype, n);\n      }\n      u.default.prototype.createStringDict = function(l, n) {\n        return u.default._validateParameters(\"createStringDict\", arguments), new u.default.StringDict(l, n);\n      }, u.default.prototype.createNumberDict = function(l, n) {\n        return u.default._validateParameters(\"createNumberDict\", arguments), new u.default.NumberDict(l, n);\n      }, u.default.TypedDict = function() {\n        function l(n, a) {\n          return s(this, l), n instanceof Object ? this.data = n : (this.data = {}, this.data[n] = a), this;\n        }\n        return i(l, [{ key: \"size\", value: function() {\n          return Object.keys(this.data).length;\n        } }, { key: \"hasKey\", value: function(n) {\n          return this.data.hasOwnProperty(n);\n        } }, { key: \"get\", value: function(n) {\n          if (this.data.hasOwnProperty(n))\n            return this.data[n];\n          console.log(\"\".concat(n, \" does not exist in this Dictionary\"));\n        } }, { key: \"set\", value: function(n, a) {\n          this._validate(a) ? this.data[n] = a : console.log(\"Those values dont work for this dictionary type.\");\n        } }, { key: \"_addObj\", value: function(n) {\n          for (var a in n)\n            this.set(a, n[a]);\n        } }, { key: \"create\", value: function(n, a) {\n          n instanceof Object && a === void 0 ? this._addObj(n) : n !== void 0 ? this.set(n, a) : console.log(\"In order to create a new Dictionary entry you must pass an object or a key, value pair\");\n        } }, { key: \"clear\", value: function() {\n          this.data = {};\n        } }, { key: \"remove\", value: function(n) {\n          if (!this.data.hasOwnProperty(n))\n            throw new Error(\"\".concat(n, \" does not exist in this Dictionary\"));\n          delete this.data[n];\n        } }, { key: \"print\", value: function() {\n          for (var n in this.data)\n            console.log(\"key:\".concat(n, \" value:\").concat(this.data[n]));\n        } }, { key: \"saveTable\", value: function(n) {\n          var a, c = \"\";\n          for (a in this.data)\n            c += \"\".concat(a, \",\").concat(this.data[a], `\n`);\n          var p = new Blob([c], { type: \"text/csv\" });\n          u.default.prototype.downloadFile(p, n || \"mycsv\", \"csv\");\n        } }, { key: \"saveJSON\", value: function(n, a) {\n          u.default.prototype.saveJSON(this.data, n, a);\n        } }, { key: \"_validate\", value: function(n) {\n          return !0;\n        } }]), l;\n      }(), u.default.StringDict = function() {\n        h(n, u.default.TypedDict);\n        var l = f(n);\n        function n() {\n          s(this, n);\n          for (var a = arguments.length, c = new Array(a), p = 0; p < a; p++)\n            c[p] = arguments[p];\n          return l.call.apply(l, [this].concat(c));\n        }\n        return i(n, [{ key: \"_validate\", value: function(a) {\n          return typeof a == \"string\";\n        } }]), n;\n      }(), u.default.NumberDict = function() {\n        h(n, u.default.TypedDict);\n        var l = f(n);\n        function n() {\n          s(this, n);\n          for (var a = arguments.length, c = new Array(a), p = 0; p < a; p++)\n            c[p] = arguments[p];\n          return l.call.apply(l, [this].concat(c));\n        }\n        return i(n, [{ key: \"_validate\", value: function(a) {\n          return typeof a == \"number\";\n        } }, { key: \"add\", value: function(a, c) {\n          this.data.hasOwnProperty(a) ? this.data[a] += c : console.log(\"The key - \".concat(a, \" does not exist in this dictionary.\"));\n        } }, { key: \"sub\", value: function(a, c) {\n          this.add(a, -c);\n        } }, { key: \"mult\", value: function(a, c) {\n          this.data.hasOwnProperty(a) ? this.data[a] *= c : console.log(\"The key - \".concat(a, \" does not exist in this dictionary.\"));\n        } }, { key: \"div\", value: function(a, c) {\n          this.data.hasOwnProperty(a) ? this.data[a] /= c : console.log(\"The key - \".concat(a, \" does not exist in this dictionary.\"));\n        } }, { key: \"_valueTest\", value: function(a) {\n          if (Object.keys(this.data).length === 0)\n            throw new Error(\"Unable to search for a minimum or maximum value on an empty NumberDict\");\n          if (Object.keys(this.data).length === 1)\n            return this.data[Object.keys(this.data)[0]];\n          var c, p = this.data[Object.keys(this.data)[0]];\n          for (c in this.data)\n            this.data[c] * a < p * a && (p = this.data[c]);\n          return p;\n        } }, { key: \"minValue\", value: function() {\n          return this._valueTest(1);\n        } }, { key: \"maxValue\", value: function() {\n          return this._valueTest(-1);\n        } }, { key: \"_keyTest\", value: function(a) {\n          if (Object.keys(this.data).length === 0)\n            throw new Error(\"Unable to use minValue on an empty NumberDict\");\n          if (Object.keys(this.data).length === 1)\n            return Object.keys(this.data)[0];\n          for (var c = Object.keys(this.data)[0], p = 1; p < Object.keys(this.data).length; p++)\n            Object.keys(this.data)[p] * a < c * a && (c = Object.keys(this.data)[p]);\n          return c;\n        } }, { key: \"minKey\", value: function() {\n          return this._keyTest(1);\n        } }, { key: \"maxKey\", value: function() {\n          return this._keyTest(-1);\n        } }]), n;\n      }(), t = u.default.TypedDict, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 296: [function(t, H, C) {\n      function m(c) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(p) {\n          return typeof p;\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : typeof p;\n        })(c);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/web.url\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/web.url\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function u(c, p) {\n        for (var j = 0; j < p.length; j++) {\n          var T = p[j];\n          T.enumerable = T.enumerable || !1, T.configurable = !0, \"value\" in T && (T.writable = !0), Object.defineProperty(c, T.key, T);\n        }\n      }\n      function h(c, p, j) {\n        p && u(c.prototype, p), j && u(c, j);\n      }\n      function g(c, p) {\n        return (g = Object.setPrototypeOf || function(j, T) {\n          return j.__proto__ = T, j;\n        })(c, p);\n      }\n      function f(c) {\n        return function() {\n          var p, j, T = s(c);\n          return p = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (p = s(this).constructor, Reflect.construct(T, arguments, p)) : T.apply(this, arguments), T = this, !(j = p) || i(j) !== \"object\" && typeof j != \"function\" ? r(T) : j;\n        };\n      }\n      function r(c) {\n        if (c === void 0)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return c;\n      }\n      function s(c) {\n        return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function(p) {\n          return p.__proto__ || Object.getPrototypeOf(p);\n        })(c);\n      }\n      function o(c, p) {\n        if (!(c instanceof p))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function i(c) {\n        return (i = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(p) {\n          return m(p);\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : m(p);\n        })(c);\n      }\n      function l(c, p, j) {\n        return (p._userNode || document.body).appendChild(c), j = new (j ? y.default.MediaElement : y.default.Element)(c, p), p._elements.push(j), j;\n      }\n      function n(c, E, j, T) {\n        var _ = document.createElement(E), S = (typeof (j = j || \"\") == \"string\" && (j = [j]), !0), E = !1, A = void 0;\n        try {\n          for (var x, P = j[Symbol.iterator](); !(S = (x = P.next()).done); S = !0) {\n            var M = x.value, R = document.createElement(\"source\");\n            R.setAttribute(\"src\", M), _.appendChild(R);\n          }\n        } catch (F) {\n          E = !0, A = F;\n        } finally {\n          try {\n            S || P.return == null || P.return();\n          } finally {\n            if (E)\n              throw A;\n          }\n        }\n        typeof T == \"function\" && _.addEventListener(\"canplaythrough\", function F() {\n          T(), _.removeEventListener(\"canplaythrough\", F);\n        });\n        var L = l(_, c, !0);\n        return L.loadedmetadata = !1, _.addEventListener(\"loadedmetadata\", function() {\n          L.width = _.videoWidth, L.height = _.videoHeight, L.elt.width === 0 && (L.elt.width = _.videoWidth), L.elt.height === 0 && (L.elt.height = _.videoHeight), L.presetPlaybackRate && (L.elt.playbackRate = L.presetPlaybackRate, delete L.presetPlaybackRate), L.loadedmetadata = !0;\n        }), L;\n      }\n      y.default.prototype.select = function(c, p) {\n        return y.default._validateParameters(\"select\", arguments), p = this._getContainer(p).querySelector(c), p ? this._wrapElement(p) : null;\n      }, y.default.prototype.selectAll = function(c, p) {\n        y.default._validateParameters(\"selectAll\", arguments);\n        var j = [], T = this._getContainer(p).querySelectorAll(c);\n        if (T)\n          for (var _ = 0; _ < T.length; _++) {\n            var S = this._wrapElement(T[_]);\n            j.push(S);\n          }\n        return j;\n      }, y.default.prototype._getContainer = function(c) {\n        var p = document;\n        return typeof c == \"string\" ? p = document.querySelector(c) || document : c instanceof y.default.Element ? p = c.elt : c instanceof HTMLElement && (p = c), p;\n      }, y.default.prototype._wrapElement = function(c) {\n        var p, j = Array.prototype.slice.call(c.children);\n        return c.tagName === \"INPUT\" && c.type === \"checkbox\" ? ((p = new y.default.Element(c, this)).checked = function() {\n          return arguments.length === 0 ? this.elt.checked : (this.elt.checked = !(arguments.length <= 0 || !arguments[0]), this);\n        }, p) : c.tagName === \"VIDEO\" || c.tagName === \"AUDIO\" ? new y.default.MediaElement(c, this) : c.tagName === \"SELECT\" ? this.createSelect(new y.default.Element(c, this)) : 0 < j.length && j.every(function(T) {\n          return T.tagName === \"INPUT\" || T.tagName === \"LABEL\";\n        }) ? this.createRadio(new y.default.Element(c, this)) : new y.default.Element(c, this);\n      }, y.default.prototype.removeElements = function(c) {\n        y.default._validateParameters(\"removeElements\", arguments), this._elements.filter(function(p) {\n          return !(p.elt instanceof HTMLCanvasElement);\n        }).map(function(p) {\n          return p.remove();\n        });\n      }, y.default.Element.prototype.changed = function(c) {\n        return y.default.Element._adjustListener(\"change\", c, this), this;\n      }, y.default.Element.prototype.input = function(c) {\n        return y.default.Element._adjustListener(\"input\", c, this), this;\n      }, y.default.prototype.createDiv = function() {\n        var c = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : \"\", p = document.createElement(\"div\");\n        return p.innerHTML = c, l(p, this);\n      }, y.default.prototype.createP = function() {\n        var c = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : \"\", p = document.createElement(\"p\");\n        return p.innerHTML = c, l(p, this);\n      }, y.default.prototype.createSpan = function() {\n        var c = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : \"\", p = document.createElement(\"span\");\n        return p.innerHTML = c, l(p, this);\n      }, y.default.prototype.createImg = function() {\n        y.default._validateParameters(\"createImg\", arguments);\n        var c, p = document.createElement(\"img\"), j = arguments;\n        return 1 < j.length && typeof j[1] == \"string\" && (p.alt = j[1]), 2 < j.length && typeof j[2] == \"string\" && (p.crossOrigin = j[2]), p.src = j[0], c = l(p, this), p.addEventListener(\"load\", function() {\n          c.width = p.offsetWidth || p.width, c.height = p.offsetHeight || p.height;\n          var T = j[j.length - 1];\n          typeof T == \"function\" && T(c);\n        }), c;\n      }, y.default.prototype.createA = function(c, p, j) {\n        y.default._validateParameters(\"createA\", arguments);\n        var T = document.createElement(\"a\");\n        return T.href = c, T.innerHTML = p, j && (T.target = j), l(T, this);\n      }, y.default.prototype.createSlider = function(c, p, j, T) {\n        y.default._validateParameters(\"createSlider\", arguments);\n        var _ = document.createElement(\"input\");\n        return _.type = \"range\", _.min = c, _.max = p, T === 0 ? _.step = 1e-18 : T && (_.step = T), typeof j == \"number\" && (_.value = j), l(_, this);\n      }, y.default.prototype.createButton = function(c, p) {\n        y.default._validateParameters(\"createButton\", arguments);\n        var j = document.createElement(\"button\");\n        return j.innerHTML = c, p && (j.value = p), l(j, this);\n      }, y.default.prototype.createCheckbox = function() {\n        for (var c = arguments.length, p = new Array(c), j = 0; j < c; j++)\n          p[j] = arguments[j];\n        y.default._validateParameters(\"createCheckbox\", p);\n        var T = document.createElement(\"div\"), _ = document.createElement(\"input\"), S = (_.type = \"checkbox\", document.createElement(\"label\")), E = (S.appendChild(_), T.appendChild(S), l(T, this));\n        return E.checked = function() {\n          var A = E.elt.firstElementChild.getElementsByTagName(\"input\")[0];\n          if (A) {\n            if (arguments.length === 0)\n              return A.checked;\n            A.checked = !(arguments.length <= 0 || !arguments[0]);\n          }\n          return E;\n        }, this.value = function(A) {\n          return E.value = A, this;\n        }, p[0] && (E.value(p[0]), (T = document.createElement(\"span\")).innerHTML = p[0], S.appendChild(T)), p[1] && (_.checked = !0), E;\n      }, y.default.prototype.createSelect = function() {\n        for (var c, p = arguments.length, j = new Array(p), T = 0; T < p; T++)\n          j[T] = arguments[T];\n        y.default._validateParameters(\"createSelect\", j);\n        var _, S = j[0];\n        return S instanceof y.default.Element && S.elt instanceof HTMLSelectElement ? this.elt = (c = S).elt : S instanceof HTMLSelectElement ? (c = l(S, this), this.elt = S) : (_ = document.createElement(\"select\"), S && typeof S == \"boolean\" && _.setAttribute(\"multiple\", \"true\"), c = l(_, this), this.elt = _), c.option = function(E, A) {\n          var x;\n          if (E !== void 0) {\n            for (var P, M = 0; M < this.elt.length; M += 1)\n              if (this.elt[M].textContent === E) {\n                x = M;\n                break;\n              }\n            x !== void 0 ? A === !1 ? this.elt.remove(x) : this.elt[x].value = A : ((P = document.createElement(\"option\")).textContent = E, P.value = A === void 0 ? E : A, this.elt.appendChild(P), this._pInst._elements.push(P));\n          }\n        }, c.selected = function(E) {\n          if (E !== void 0) {\n            for (var A = 0; A < this.elt.length; A += 1)\n              this.elt[A].value.toString() === E.toString() && (this.elt.selectedIndex = A);\n            return this;\n          }\n          if (this.elt.getAttribute(\"multiple\")) {\n            var x = [], P = !0, M = !1, R = void 0;\n            try {\n              for (var L, F = this.elt.selectedOptions[Symbol.iterator](); !(P = (L = F.next()).done); P = !0) {\n                var V = L.value;\n                x.push(V.value);\n              }\n            } catch (G) {\n              M = !0, R = G;\n            } finally {\n              try {\n                P || F.return == null || F.return();\n              } finally {\n                if (M)\n                  throw R;\n              }\n            }\n            return x;\n          }\n          return this.elt.value;\n        }, c.disable = function(E) {\n          if (typeof E == \"string\")\n            for (var A = 0; A < this.elt.length; A++)\n              this.elt[A].value.toString() === E && (this.elt[A].disabled = !0, this.elt[A].selected = !1);\n          else\n            this.elt.disabled = !0;\n          return this;\n        }, c.enable = function(E) {\n          if (typeof E == \"string\")\n            for (var A = 0; A < this.elt.length; A++)\n              this.elt[A].value.toString() === E && (this.elt[A].disabled = !1, this.elt[A].selected = !1);\n          else {\n            this.elt.disabled = !1;\n            for (var x = 0; x < this.elt.length; x++)\n              this.elt[x].disabled = !1, this.elt[x].selected = !1;\n          }\n          return this;\n        }, c;\n      }, y.default.prototype.createRadio = function() {\n        function c(E) {\n          return E instanceof HTMLInputElement && E.type === \"radio\";\n        }\n        function p(E) {\n          return E instanceof HTMLLabelElement;\n        }\n        var j, T, _, S = arguments.length <= 0 ? void 0 : arguments[0];\n        return S instanceof y.default.Element && (S.elt instanceof HTMLDivElement || S.elt instanceof HTMLSpanElement) ? (j = S, this.elt = S.elt) : S instanceof HTMLDivElement || S instanceof HTMLSpanElement ? (j = l(S, this), T = this.elt = S, typeof (arguments.length <= 1 ? void 0 : arguments[1]) == \"string\" && (_ = arguments.length <= 1 ? void 0 : arguments[1])) : (typeof S == \"string\" && (_ = S), T = document.createElement(\"div\"), j = l(T, this), this.elt = T), j._name = _ || \"radioOption\", j._getOptionsArray = function() {\n          return Array.from(this.elt.children).filter(function(E) {\n            return c(E) || p(E) && c(E.firstElementChild);\n          }).map(function(E) {\n            return c(E) ? E : E.firstElementChild;\n          });\n        }, j.option = function(E, A) {\n          var x, P, M, R = !0, L = !1, F = void 0;\n          try {\n            for (var V, G = j._getOptionsArray()[Symbol.iterator](); !(R = (V = G.next()).done); R = !0) {\n              var U = V.value;\n              if (U.value === E) {\n                x = U;\n                break;\n              }\n            }\n          } catch (W) {\n            L = !0, F = W;\n          } finally {\n            try {\n              R || G.return == null || G.return();\n            } finally {\n              if (L)\n                throw F;\n            }\n          }\n          return x === void 0 && ((x = document.createElement(\"input\")).setAttribute(\"type\", \"radio\"), x.setAttribute(\"value\", E)), x.setAttribute(\"name\", j._name), p(x.parentElement) ? P = x.parentElement : (P = document.createElement(\"label\")).insertAdjacentElement(\"afterbegin\", x), P.lastElementChild instanceof HTMLSpanElement ? M = P.lastElementChild : (M = document.createElement(\"span\"), x.insertAdjacentElement(\"afterend\", M)), M.innerHTML = A === void 0 ? E : A, this.elt.appendChild(P), x;\n        }, j.remove = function(E) {\n          var A = !0, x = !1, P = void 0;\n          try {\n            for (var M, R = j._getOptionsArray()[Symbol.iterator](); !(A = (M = R.next()).done); A = !0) {\n              var L = M.value;\n              if (L.value === E)\n                return void (p(L.parentElement) ? L.parentElement : L).remove();\n            }\n          } catch (F) {\n            x = !0, P = F;\n          } finally {\n            try {\n              A || R.return == null || R.return();\n            } finally {\n              if (x)\n                throw P;\n            }\n          }\n        }, j.value = function() {\n          var E = \"\", A = !0, x = !1, P = void 0;\n          try {\n            for (var M, R = j._getOptionsArray()[Symbol.iterator](); !(A = (M = R.next()).done); A = !0) {\n              var L = M.value;\n              if (L.checked) {\n                E = L.value;\n                break;\n              }\n            }\n          } catch (F) {\n            x = !0, P = F;\n          } finally {\n            try {\n              A || R.return == null || R.return();\n            } finally {\n              if (x)\n                throw P;\n            }\n          }\n          return E;\n        }, j.selected = function(E) {\n          var A = null;\n          if (E === void 0) {\n            var x = !0, P = !1, M = void 0;\n            try {\n              for (var R, L = j._getOptionsArray()[Symbol.iterator](); !(x = (R = L.next()).done); x = !0) {\n                var F = R.value;\n                if (F.checked) {\n                  A = F;\n                  break;\n                }\n              }\n            } catch (X) {\n              P = !0, M = X;\n            } finally {\n              try {\n                x || L.return == null || L.return();\n              } finally {\n                if (P)\n                  throw M;\n              }\n            }\n          } else {\n            j._getOptionsArray().forEach(function(b) {\n              b.checked = !1, b.removeAttribute(\"checked\");\n            });\n            var V = !0, P = !1, M = void 0;\n            try {\n              for (var G, U = j._getOptionsArray()[Symbol.iterator](); !(V = (G = U.next()).done); V = !0) {\n                var W = G.value;\n                W.value === E && (W.setAttribute(\"checked\", !0), W.checked = !0, A = W);\n              }\n            } catch (b) {\n              P = !0, M = b;\n            } finally {\n              try {\n                V || U.return == null || U.return();\n              } finally {\n                if (P)\n                  throw M;\n              }\n            }\n          }\n          return A;\n        }, j.disable = function() {\n          var E = !(0 < arguments.length && arguments[0] !== void 0) || arguments[0], A = !0, x = !1, P = void 0;\n          try {\n            for (var M, R = j._getOptionsArray()[Symbol.iterator](); !(A = (M = R.next()).done); A = !0)\n              M.value.setAttribute(\"disabled\", E);\n          } catch (L) {\n            x = !0, P = L;\n          } finally {\n            try {\n              A || R.return == null || R.return();\n            } finally {\n              if (x)\n                throw P;\n            }\n          }\n        }, j;\n      }, y.default.prototype.createColorPicker = function(c) {\n        y.default._validateParameters(\"createColorPicker\", arguments);\n        var p = document.createElement(\"input\");\n        return p.type = \"color\", c ? c instanceof y.default.Color ? p.value = c.toString(\"#rrggbb\") : (y.default.prototype._colorMode = \"rgb\", y.default.prototype._colorMaxes = { rgb: [255, 255, 255, 255], hsb: [360, 100, 100, 1], hsl: [360, 100, 100, 1] }, p.value = y.default.prototype.color(c).toString(\"#rrggbb\")) : p.value = \"#000000\", (p = l(p, this)).color = function() {\n          return c && (c.mode && (y.default.prototype._colorMode = c.mode), c.maxes && (y.default.prototype._colorMaxes = c.maxes)), y.default.prototype.color(this.elt.value);\n        }, p;\n      }, y.default.prototype.createInput = function() {\n        var c = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : \"\", p = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : \"text\", j = (y.default._validateParameters(\"createInput\", arguments), document.createElement(\"input\"));\n        return j.setAttribute(\"value\", c), j.setAttribute(\"type\", p), l(j, this);\n      }, y.default.prototype.createFileInput = function(c) {\n        var p, j = 1 < arguments.length && arguments[1] !== void 0 && arguments[1];\n        if (y.default._validateParameters(\"createFileInput\", arguments), window.File && window.FileReader && window.FileList && window.Blob)\n          return (p = document.createElement(\"input\")).setAttribute(\"type\", \"file\"), j && p.setAttribute(\"multiple\", !0), p.addEventListener(\"change\", function(T) {\n            var _ = !0, S = !1, E = void 0;\n            try {\n              for (var A, x = T.target.files[Symbol.iterator](); !(_ = (A = x.next()).done); _ = !0) {\n                var P = A.value;\n                y.default.File._load(P, c);\n              }\n            } catch (M) {\n              S = !0, E = M;\n            } finally {\n              try {\n                _ || x.return == null || x.return();\n              } finally {\n                if (S)\n                  throw E;\n              }\n            }\n          }, !1), l(p, this);\n        console.log(\"The File APIs are not fully supported in this browser. Cannot create element.\");\n      }, y.default.prototype.createVideo = function(c, p) {\n        return y.default._validateParameters(\"createVideo\", arguments), n(this, \"video\", c, p);\n      }, y.default.prototype.createAudio = function(c, p) {\n        return y.default._validateParameters(\"createAudio\", arguments), n(this, \"audio\", c, p);\n      }, y.default.prototype.VIDEO = \"video\", y.default.prototype.AUDIO = \"audio\", navigator.mediaDevices === void 0 && (navigator.mediaDevices = {}), navigator.mediaDevices.getUserMedia === void 0 && (navigator.mediaDevices.getUserMedia = function(c) {\n        var p = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n        return p ? new Promise(function(j, T) {\n          p.call(navigator, c, j, T);\n        }) : Promise.reject(new Error(\"getUserMedia is not implemented in this browser\"));\n      }), y.default.prototype.createCapture = function() {\n        for (var c = arguments.length, p = new Array(c), j = 0; j < c; j++)\n          p[j] = arguments[j];\n        if (y.default._validateParameters(\"createCapture\", p), !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n          throw new DOMException(\"getUserMedia not supported in this browser\");\n        for (var T, _ = !0, S = !0, E = !1, A = 0, x = p; A < x.length; A++) {\n          var P = x[A];\n          P === y.default.prototype.VIDEO ? S = !1 : P === y.default.prototype.AUDIO ? _ = !1 : i(P) === \"object\" ? (P.flipped !== void 0 && (E = P.flipped, delete P.flipped), M = Object.assign({}, M, P)) : typeof P == \"function\" && (T = P);\n        }\n        var M = Object.assign({}, { video: _, audio: S }, M), R = document.createElement(\"video\"), L = (R.setAttribute(\"playsinline\", \"\"), navigator.mediaDevices.getUserMedia(M).then(function(F) {\n          try {\n            \"srcObject\" in R ? R.srcObject = F : R.src = window.URL.createObjectURL(F);\n          } catch {\n            R.src = F;\n          }\n        }).catch(function(F) {\n          F.name === \"NotFoundError\" && y.default._friendlyError(\"No webcam found on this device\", \"createCapture\"), F.name === \"NotAllowedError\" && y.default._friendlyError(\"Access to the camera was denied\", \"createCapture\"), console.error(F);\n        }), l(R, this, !0));\n        return L.loadedmetadata = !1, R.addEventListener(\"loadedmetadata\", function() {\n          R.play(), R.width ? (L.width = R.width, L.height = R.height, E && (L.elt.style.transform = \"scaleX(-1)\")) : (L.width = L.elt.width = R.videoWidth, L.height = L.elt.height = R.videoHeight), L.loadedmetadata = !0, T && T(R.srcObject);\n        }), L.flipped = E, L;\n      }, y.default.prototype.createElement = function(c, p) {\n        return y.default._validateParameters(\"createElement\", arguments), c = document.createElement(c), p !== void 0 && (c.innerHTML = p), l(c, this);\n      }, y.default.Element.prototype.addClass = function(c) {\n        return this.elt.className ? this.hasClass(c) || (this.elt.className = this.elt.className + \" \" + c) : this.elt.className = c, this;\n      }, y.default.Element.prototype.removeClass = function(c) {\n        return this.elt.classList.remove(c), this;\n      }, y.default.Element.prototype.hasClass = function(c) {\n        return this.elt.classList.contains(c);\n      }, y.default.Element.prototype.toggleClass = function(c) {\n        return this.elt.classList.contains(c) ? this.elt.classList.remove(c) : this.elt.classList.add(c), this;\n      }, y.default.Element.prototype.child = function(c) {\n        return c === void 0 ? this.elt.childNodes : (typeof c == \"string\" ? (c[0] === \"#\" && (c = c.substring(1)), c = document.getElementById(c)) : c instanceof y.default.Element && (c = c.elt), c instanceof HTMLElement && this.elt.appendChild(c), this);\n      }, y.default.Element.prototype.center = function(c) {\n        var p = this.elt.style.display, j = this.elt.style.display === \"none\", T = this.parent().style.display === \"none\", _ = { x: this.elt.offsetLeft, y: this.elt.offsetTop }, S = (j && this.show(), T && this.parent().show(), this.elt.style.display = \"block\", this.position(0, 0), Math.abs(this.parent().offsetWidth - this.elt.offsetWidth)), E = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);\n        return c === \"both\" || c === void 0 ? this.position(S / 2 + this.parent().offsetLeft, E / 2 + this.parent().offsetTop) : c === \"horizontal\" ? this.position(S / 2 + this.parent().offsetLeft, _.y) : c === \"vertical\" && this.position(_.x, E / 2 + this.parent().offsetTop), this.style(\"display\", p), j && this.hide(), T && this.parent().hide(), this;\n      }, y.default.Element.prototype.html = function() {\n        return arguments.length === 0 ? this.elt.innerHTML : (arguments.length <= 1 || !arguments[1] ? this.elt.innerHTML = arguments.length <= 0 ? void 0 : arguments[0] : this.elt.insertAdjacentHTML(\"beforeend\", arguments.length <= 0 ? void 0 : arguments[0]), this);\n      }, y.default.Element.prototype.position = function() {\n        return arguments.length === 0 ? { x: this.elt.offsetLeft, y: this.elt.offsetTop } : (this.elt.style.position = (arguments.length <= 2 ? void 0 : arguments[2]) !== \"static\" && (arguments.length <= 2 ? void 0 : arguments[2]) !== \"fixed\" && (arguments.length <= 2 ? void 0 : arguments[2]) !== \"relative\" && (arguments.length <= 2 ? void 0 : arguments[2]) !== \"sticky\" && (arguments.length <= 2 ? void 0 : arguments[2]) !== \"initial\" && (arguments.length <= 2 ? void 0 : arguments[2]) !== \"inherit\" ? \"absolute\" : arguments.length <= 2 ? void 0 : arguments[2], this.elt.style.left = (arguments.length <= 0 ? void 0 : arguments[0]) + \"px\", this.elt.style.top = (arguments.length <= 1 ? void 0 : arguments[1]) + \"px\", this.x = arguments.length <= 0 ? void 0 : arguments[0], this.y = arguments.length <= 1 ? void 0 : arguments[1], this);\n      }, y.default.Element.prototype._translate = function() {\n        this.elt.style.position = \"absolute\";\n        var c = \"\";\n        return this.elt.style.transform && (c = (c = this.elt.style.transform.replace(/translate3d\\(.*\\)/g, \"\")).replace(/translate[X-Z]?\\(.*\\)/g, \"\")), arguments.length === 2 ? this.elt.style.transform = \"translate(\" + (arguments.length <= 0 ? void 0 : arguments[0]) + \"px, \" + (arguments.length <= 1 ? void 0 : arguments[1]) + \"px)\" : 2 < arguments.length && (this.elt.style.transform = \"translate3d(\" + (arguments.length <= 0 ? void 0 : arguments[0]) + \"px,\" + (arguments.length <= 1 ? void 0 : arguments[1]) + \"px,\" + (arguments.length <= 2 ? void 0 : arguments[2]) + \"px)\", this.elt.parentElement.style.perspective = arguments.length === 3 ? \"1000px\" : (arguments.length <= 3 ? void 0 : arguments[3]) + \"px\"), this.elt.style.transform += c, this;\n      }, y.default.Element.prototype._rotate = function() {\n        var c = \"\";\n        return this.elt.style.transform && (c = (c = this.elt.style.transform.replace(/rotate3d\\(.*\\)/g, \"\")).replace(/rotate[X-Z]?\\(.*\\)/g, \"\")), arguments.length === 1 ? this.elt.style.transform = \"rotate(\" + (arguments.length <= 0 ? void 0 : arguments[0]) + \"deg)\" : arguments.length === 2 ? this.elt.style.transform = \"rotate(\" + (arguments.length <= 0 ? void 0 : arguments[0]) + \"deg, \" + (arguments.length <= 1 ? void 0 : arguments[1]) + \"deg)\" : arguments.length === 3 && (this.elt.style.transform = \"rotateX(\" + (arguments.length <= 0 ? void 0 : arguments[0]) + \"deg)\", this.elt.style.transform += \"rotateY(\" + (arguments.length <= 1 ? void 0 : arguments[1]) + \"deg)\", this.elt.style.transform += \"rotateZ(\" + (arguments.length <= 2 ? void 0 : arguments[2]) + \"deg)\"), this.elt.style.transform += c, this;\n      }, y.default.Element.prototype.style = function(c, p) {\n        if ((p = p instanceof y.default.Color ? \"rgba(\" + p.levels[0] + \",\" + p.levels[1] + \",\" + p.levels[2] + \",\" + p.levels[3] / 255 + \")\" : p) === void 0) {\n          if (c.indexOf(\":\") === -1)\n            return window.getComputedStyle(this.elt).getPropertyValue(c);\n          for (var j = c.split(\";\"), T = 0; T < j.length; T++) {\n            var _ = j[T].split(\":\");\n            _[0] && _[1] && (this.elt.style[_[0].trim()] = _[1].trim());\n          }\n        } else\n          this.elt.style[c] = p, c !== \"width\" && c !== \"height\" && c !== \"left\" && c !== \"top\" || (p = window.getComputedStyle(this.elt).getPropertyValue(c).replace(/[^\\d.]/g, \"\"), this[c] = Math.round(parseFloat(p, 10)));\n        return this;\n      }, y.default.Element.prototype.attribute = function(c, p) {\n        if (this.elt.firstChild == null || this.elt.firstChild.type !== \"checkbox\" && this.elt.firstChild.type !== \"radio\")\n          return p === void 0 ? this.elt.getAttribute(c) : (this.elt.setAttribute(c, p), this);\n        if (p === void 0)\n          return this.elt.firstChild.getAttribute(c);\n        for (var j = 0; j < this.elt.childNodes.length; j++)\n          this.elt.childNodes[j].setAttribute(c, p);\n      }, y.default.Element.prototype.removeAttribute = function(c) {\n        if (this.elt.firstChild != null && (this.elt.firstChild.type === \"checkbox\" || this.elt.firstChild.type === \"radio\"))\n          for (var p = 0; p < this.elt.childNodes.length; p++)\n            this.elt.childNodes[p].removeAttribute(c);\n        return this.elt.removeAttribute(c), this;\n      }, y.default.Element.prototype.value = function() {\n        return 0 < arguments.length ? (this.elt.value = arguments.length <= 0 ? void 0 : arguments[0], this) : this.elt.type === \"range\" ? parseFloat(this.elt.value) : this.elt.value;\n      }, y.default.Element.prototype.show = function() {\n        return this.elt.style.display = \"block\", this;\n      }, y.default.Element.prototype.hide = function() {\n        return this.elt.style.display = \"none\", this;\n      }, y.default.Element.prototype.size = function(c, p) {\n        if (arguments.length === 0)\n          return { width: this.elt.offsetWidth, height: this.elt.offsetHeight };\n        var j = c, T = p, _ = y.default.prototype.AUTO;\n        if (j !== _ || T !== _) {\n          if (j === _ ? j = p * this.width / this.height : T === _ && (T = c * this.height / this.width), this.elt instanceof HTMLCanvasElement) {\n            var S, E = {}, A = this.elt.getContext(\"2d\");\n            for (S in A)\n              E[S] = A[S];\n            for (S in this.elt.setAttribute(\"width\", j * this._pInst._pixelDensity), this.elt.setAttribute(\"height\", T * this._pInst._pixelDensity), this.elt.style.width = j + \"px\", this.elt.style.height = T + \"px\", this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), E)\n              this.elt.getContext(\"2d\")[S] = E[S];\n          } else\n            this.elt.style.width = j + \"px\", this.elt.style.height = T + \"px\", this.elt.width = j, this.elt.height = T;\n          this.width = j, this.height = T, this._pInst && this._pInst._curElement && this._pInst._curElement.elt === this.elt && (this._pInst._setProperty(\"width\", j), this._pInst._setProperty(\"height\", T));\n        }\n        return this;\n      }, y.default.Element.prototype.remove = function() {\n        this instanceof y.default.MediaElement && (this.stop(), (p = this.elt.srcObject) !== null && p.getTracks().forEach(function(j) {\n          j.stop();\n        }));\n        var c, p = this._pInst._elements.indexOf(this);\n        for (c in p !== -1 && this._pInst._elements.splice(p, 1), this._events)\n          this.elt.removeEventListener(c, this._events[c]);\n        this.elt && this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);\n      }, y.default.Element.prototype.drop = function(c, p) {\n        var j;\n        return window.File && window.FileReader && window.FileList && window.Blob ? (this._dragDisabled || (this._dragDisabled = !0, this.elt.addEventListener(\"dragover\", j = function(T) {\n          T.preventDefault();\n        }), this.elt.addEventListener(\"dragleave\", j)), y.default.Element._attachListener(\"drop\", function(_) {\n          _.preventDefault(), typeof p == \"function\" && p.call(this, _);\n          var _ = _.dataTransfer.files, S = !0, E = !1, A = void 0;\n          try {\n            for (var x, P = _[Symbol.iterator](); !(S = (x = P.next()).done); S = !0) {\n              var M = x.value;\n              y.default.File._load(M, c);\n            }\n          } catch (R) {\n            E = !0, A = R;\n          } finally {\n            try {\n              S || P.return == null || P.return();\n            } finally {\n              if (E)\n                throw A;\n            }\n          }\n        }, this)) : console.log(\"The File APIs are not fully supported in this browser.\"), this;\n      }, y.default.Element.prototype.draggable = function(c) {\n        var p, j = \"ontouchstart\" in window, T = 0, _ = 0, S = 0, E = 0, A = j ? \"touchend\" : \"mouseup\", x = j ? \"touchmove\" : \"mousemove\";\n        function P(R) {\n          var L;\n          R = R || window.event, E = j ? (L = R.changedTouches, T = S - parseInt(L[0].clientX), _ = E - parseInt(L[0].clientY), S = parseInt(L[0].clientX), parseInt(L[0].clientY)) : (T = S - parseInt(R.clientX), _ = E - parseInt(R.clientY), S = parseInt(R.clientX), parseInt(R.clientY)), c.style.left = c.offsetLeft - T + \"px\", c.style.top = c.offsetTop - _ + \"px\";\n        }\n        function M() {\n          document.removeEventListener(A, M, !1), document.removeEventListener(x, P, !1);\n        }\n        return c === void 0 ? p = c = this.elt : c !== this.elt && c.elt !== this.elt && (c = c.elt, p = this.elt), p.addEventListener(j ? \"touchstart\" : \"mousedown\", function(R) {\n          {\n            var L;\n            R = R || window.event, E = j ? (L = R.changedTouches, S = parseInt(L[0].clientX), parseInt(L[0].clientY)) : (S = parseInt(R.clientX), parseInt(R.clientY));\n          }\n          return document.addEventListener(A, M, !1), document.addEventListener(x, P, !1), !1;\n        }, !1), p.style.cursor = \"move\", this;\n      };\n      function a(c, p, j, T) {\n        o(this, a), this.callback = c, this.time = p, this.id = j, this.val = T;\n      }\n      t = function(c) {\n        var p = T;\n        if (typeof c != \"function\" && c !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        p.prototype = Object.create(c && c.prototype, { constructor: { value: p, writable: !0, configurable: !0 } }), c && g(p, c);\n        var j = f(T);\n        function T(_, S) {\n          o(this, T);\n          var E = r(S = j.call(this, _, S));\n          return S.elt.crossOrigin = \"anonymous\", S._prevTime = 0, S._cueIDCounter = 0, S._cues = [], S.pixels = [], S._pixelsState = r(S), S._pixelDensity = 1, S._modified = !1, S._frameOnCanvas = -1, Object.defineProperty(E, \"src\", { get: function() {\n            var A = E.elt.children[0].src, x = E.elt.src === window.location.href ? \"\" : E.elt.src;\n            return A === window.location.href ? x : A;\n          }, set: function(A) {\n            for (var x = 0; x < E.elt.children.length; x++)\n              E.elt.removeChild(E.elt.children[x]);\n            var P = document.createElement(\"source\");\n            P.src = A, _.appendChild(P), E.elt.src = A, E.modified = !0;\n          } }), E._onended = function() {\n          }, E.elt.onended = function() {\n            E._onended(E);\n          }, S;\n        }\n        return h(T, [{ key: \"play\", value: function() {\n          var _;\n          return this.elt.currentTime === this.elt.duration && (this.elt.currentTime = 0), 1 < this.elt.readyState || this.elt.load(), (_ = this.elt.play()) && _.catch && _.catch(function(S) {\n            S.name === \"NotAllowedError\" ? console.error(S) : console.error(\"Media play method encountered an unexpected error\", S);\n          }), this;\n        } }, { key: \"stop\", value: function() {\n          return this.elt.pause(), this.elt.currentTime = 0, this;\n        } }, { key: \"pause\", value: function() {\n          return this.elt.pause(), this;\n        } }, { key: \"loop\", value: function() {\n          return this.elt.setAttribute(\"loop\", !0), this.play(), this;\n        } }, { key: \"noLoop\", value: function() {\n          return this.elt.removeAttribute(\"loop\"), this;\n        } }, { key: \"_setupAutoplayFailDetection\", value: function() {\n          var _ = setTimeout(function() {\n            console.error(e);\n          }, 500);\n          this.elt.addEventListener(\"play\", function() {\n            return clearTimeout(_);\n          }, { passive: !0, once: !0 });\n        } }, { key: \"autoplay\", value: function(_) {\n          var S = this, E = this.elt.getAttribute(\"autoplay\");\n          return this.elt.setAttribute(\"autoplay\", _), _ && !E && (_ = function() {\n            return S._setupAutoplayFailDetection();\n          }, this.elt.readyState === 4 ? _() : this.elt.addEventListener(\"canplay\", _, { passive: !0, once: !0 })), this;\n        } }, { key: \"volume\", value: function(_) {\n          if (_ === void 0)\n            return this.elt.volume;\n          this.elt.volume = _;\n        } }, { key: \"speed\", value: function(_) {\n          if (_ === void 0)\n            return this.presetPlaybackRate || this.elt.playbackRate;\n          this.loadedmetadata ? this.elt.playbackRate = _ : this.presetPlaybackRate = _;\n        } }, { key: \"time\", value: function(_) {\n          return _ === void 0 ? this.elt.currentTime : (this.elt.currentTime = _, this);\n        } }, { key: \"duration\", value: function() {\n          return this.elt.duration;\n        } }, { key: \"_ensureCanvas\", value: function() {\n          this.canvas || (this.canvas = document.createElement(\"canvas\"), this.drawingContext = this.canvas.getContext(\"2d\"), this.setModified(!0));\n          var _ = this._frameOnCanvas !== this._pInst.frameCount;\n          this.loadedmetadata && _ && (this.canvas.width !== this.elt.width && (this.canvas.width = this.elt.width, this.canvas.height = this.elt.height, this.width = this.canvas.width, this.height = this.canvas.height), this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.flipped === !0 && (this.drawingContext.save(), this.drawingContext.scale(-1, 1), this.drawingContext.translate(-this.canvas.width, 0)), this.drawingContext.drawImage(this.elt, 0, 0, this.canvas.width, this.canvas.height), this.flipped === !0 && this.drawingContext.restore(), this.setModified(!0), this._frameOnCanvas = this._pInst.frameCount);\n        } }, { key: \"loadPixels\", value: function() {\n          this._ensureCanvas();\n          for (var _ = arguments.length, S = new Array(_), E = 0; E < _; E++)\n            S[E] = arguments[E];\n          return y.default.Renderer2D.prototype.loadPixels.apply(this, S);\n        } }, { key: \"updatePixels\", value: function(_, S, E, A) {\n          return this.loadedmetadata && (this._ensureCanvas(), y.default.Renderer2D.prototype.updatePixels.call(this, _, S, E, A)), this.setModified(!0), this;\n        } }, { key: \"get\", value: function() {\n          this._ensureCanvas();\n          for (var _ = arguments.length, S = new Array(_), E = 0; E < _; E++)\n            S[E] = arguments[E];\n          return y.default.Renderer2D.prototype.get.apply(this, S);\n        } }, { key: \"_getPixel\", value: function() {\n          this.loadPixels();\n          for (var _ = arguments.length, S = new Array(_), E = 0; E < _; E++)\n            S[E] = arguments[E];\n          return y.default.Renderer2D.prototype._getPixel.apply(this, S);\n        } }, { key: \"set\", value: function(_, S, E) {\n          this.loadedmetadata && (this._ensureCanvas(), y.default.Renderer2D.prototype.set.call(this, _, S, E), this.setModified(!0));\n        } }, { key: \"copy\", value: function() {\n          this._ensureCanvas();\n          for (var _ = arguments.length, S = new Array(_), E = 0; E < _; E++)\n            S[E] = arguments[E];\n          y.default.prototype.copy.apply(this, S);\n        } }, { key: \"mask\", value: function() {\n          this.loadPixels(), this.setModified(!0);\n          for (var _ = arguments.length, S = new Array(_), E = 0; E < _; E++)\n            S[E] = arguments[E];\n          y.default.Image.prototype.mask.apply(this, S);\n        } }, { key: \"isModified\", value: function() {\n          return this._modified;\n        } }, { key: \"setModified\", value: function(_) {\n          this._modified = _;\n        } }, { key: \"onended\", value: function(_) {\n          return this._onended = _, this;\n        } }, { key: \"connect\", value: function(_) {\n          var S, E;\n          if (typeof y.default.prototype.getAudioContext == \"function\")\n            S = y.default.prototype.getAudioContext(), E = y.default.soundOut.input;\n          else\n            try {\n              E = (S = _.context).destination;\n            } catch {\n              throw \"connect() is meant to be used with Web Audio API or p5.sound.js\";\n            }\n          this.audioSourceNode || (this.audioSourceNode = S.createMediaElementSource(this.elt), this.audioSourceNode.connect(E)), _ ? _.input ? this.audioSourceNode.connect(_.input) : this.audioSourceNode.connect(_) : this.audioSourceNode.connect(E);\n        } }, { key: \"disconnect\", value: function() {\n          if (!this.audioSourceNode)\n            throw \"nothing to disconnect\";\n          this.audioSourceNode.disconnect();\n        } }, { key: \"showControls\", value: function() {\n          this.elt.style[\"text-align\"] = \"inherit\", this.elt.controls = !0;\n        } }, { key: \"hideControls\", value: function() {\n          this.elt.controls = !1;\n        } }, { key: \"addCue\", value: function(_, x, E) {\n          var A = this._cueIDCounter++, x = new a(x, _, A, E);\n          return this._cues.push(x), this.elt.ontimeupdate || (this.elt.ontimeupdate = this._onTimeUpdate.bind(this)), A;\n        } }, { key: \"removeCue\", value: function(_) {\n          for (var S = 0; S < this._cues.length; S++)\n            this._cues[S].id === _ && (console.log(_), this._cues.splice(S, 1));\n          this._cues.length === 0 && (this.elt.ontimeupdate = null);\n        } }, { key: \"clearCues\", value: function() {\n          this._cues = [], this.elt.ontimeupdate = null;\n        } }, { key: \"_onTimeUpdate\", value: function() {\n          for (var _ = this.time(), S = 0; S < this._cues.length; S++) {\n            var E = this._cues[S].time, A = this._cues[S].val;\n            this._prevTime < E && E <= _ && this._cues[S].callback(A);\n          }\n          this._prevTime = _;\n        } }]), T;\n      }(y.default.Element), y.default.MediaElement = t, t = function() {\n        function c(p, j) {\n          o(this, c), this.file = p, this._pInst = j, j = p.type.split(\"/\"), this.type = j[0], this.subtype = j[1], this.name = p.name, this.size = p.size, this.data = void 0;\n        }\n        return h(c, null, [{ key: \"_createLoader\", value: function(p, j) {\n          var T = new FileReader();\n          return T.onload = function(_) {\n            var S, E = new y.default.File(p);\n            E.file.type === \"application/json\" ? E.data = JSON.parse(_.target.result) : E.file.type === \"text/xml\" ? (S = new DOMParser().parseFromString(_.target.result, \"text/xml\"), E.data = new y.default.XML(S.documentElement)) : E.data = _.target.result, j(E);\n          }, T;\n        } }, { key: \"_load\", value: function(p, j) {\n          var T;\n          /^text\\//.test(p.type) || p.type === \"application/json\" ? y.default.File._createLoader(p, j).readAsText(p) : /^(video|audio)\\//.test(p.type) ? ((T = new y.default.File(p)).data = URL.createObjectURL(p), j(T)) : y.default.File._createLoader(p, j).readAsDataURL(p);\n        } }]), c;\n      }(), y.default.File = t, t = y.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.every\": 154, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243, \"core-js/modules/web.url\": 245 }], 297: [function(i, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (i = i(\"../core/main\")) && i.__esModule ? i : { default: i };\n      m.default.prototype.deviceOrientation = 1 < window.innerWidth / window.innerHeight ? \"landscape\" : \"portrait\", m.default.prototype.accelerationX = 0, m.default.prototype.accelerationY = 0, m.default.prototype.accelerationZ = 0, m.default.prototype.pAccelerationX = 0, m.default.prototype.pAccelerationY = 0, m.default.prototype.pAccelerationZ = 0, m.default.prototype._updatePAccelerations = function() {\n        this._setProperty(\"pAccelerationX\", this.accelerationX), this._setProperty(\"pAccelerationY\", this.accelerationY), this._setProperty(\"pAccelerationZ\", this.accelerationZ);\n      }, m.default.prototype.rotationX = 0, m.default.prototype.rotationY = 0, m.default.prototype.rotationZ = 0, m.default.prototype.pRotationX = 0, m.default.prototype.pRotationY = 0;\n      var y = m.default.prototype.pRotationZ = 0, u = 0, h = 0, g = \"clockwise\", f = \"clockwise\", r = \"clockwise\", s = (m.default.prototype.pRotateDirectionX = void 0, m.default.prototype.pRotateDirectionY = void 0, m.default.prototype.pRotateDirectionZ = void 0, m.default.prototype._updatePRotations = function() {\n        this._setProperty(\"pRotationX\", this.rotationX), this._setProperty(\"pRotationY\", this.rotationY), this._setProperty(\"pRotationZ\", this.rotationZ);\n      }, m.default.prototype.turnAxis = void 0, 0.5), o = 30, i = (m.default.prototype.setMoveThreshold = function(l) {\n        m.default._validateParameters(\"setMoveThreshold\", arguments), s = l;\n      }, m.default.prototype.setShakeThreshold = function(l) {\n        m.default._validateParameters(\"setShakeThreshold\", arguments), o = l;\n      }, m.default.prototype._ondeviceorientation = function(l) {\n        this._updatePRotations(), this._setProperty(\"rotationX\", this._fromDegrees(l.beta)), this._setProperty(\"rotationY\", this._fromDegrees(l.gamma)), this._setProperty(\"rotationZ\", this._fromDegrees(l.alpha)), this._handleMotion();\n      }, m.default.prototype._ondevicemotion = function(l) {\n        this._updatePAccelerations(), this._setProperty(\"accelerationX\", 2 * l.acceleration.x), this._setProperty(\"accelerationY\", 2 * l.acceleration.y), this._setProperty(\"accelerationZ\", 2 * l.acceleration.z), this._handleMotion();\n      }, m.default.prototype._handleMotion = function() {\n        window.orientation === 90 || window.orientation === -90 ? this._setProperty(\"deviceOrientation\", \"landscape\") : window.orientation === 0 ? this._setProperty(\"deviceOrientation\", \"portrait\") : window.orientation === void 0 && this._setProperty(\"deviceOrientation\", \"undefined\");\n        var l, n, a, c, p, j = this._isGlobal ? window : this;\n        typeof j.deviceMoved == \"function\" && (Math.abs(this.accelerationX - this.pAccelerationX) > s || Math.abs(this.accelerationY - this.pAccelerationY) > s || Math.abs(this.accelerationZ - this.pAccelerationZ) > s) && j.deviceMoved(), typeof j.deviceTurned == \"function\" && (n = this._toDegrees(this.rotationX) + 180, a = this._toDegrees(this.pRotationX) + 180, l = y + 180, 0 < n - a && n - a < 270 || n - a < -270 ? g = \"clockwise\" : (n - a < 0 || 270 < n - a) && (g = \"counter-clockwise\"), g !== this.pRotateDirectionX && (l = n), 90 < Math.abs(n - l) && Math.abs(n - l) < 270 && (l = n, this._setProperty(\"turnAxis\", \"X\"), j.deviceTurned()), this.pRotateDirectionX = g, y = l - 180, a = this._toDegrees(this.rotationY) + 180, n = this._toDegrees(this.pRotationY) + 180, l = u + 180, 0 < a - n && a - n < 270 || a - n < -270 ? f = \"clockwise\" : (a - n < 0 || 270 < a - this.pRotationY) && (f = \"counter-clockwise\"), f !== this.pRotateDirectionY && (l = a), 90 < Math.abs(a - l) && Math.abs(a - l) < 270 && (l = a, this._setProperty(\"turnAxis\", \"Y\"), j.deviceTurned()), this.pRotateDirectionY = f, u = l - 180, 0 < (n = this._toDegrees(this.rotationZ)) - (a = this._toDegrees(this.pRotationZ)) && n - a < 270 || n - a < -270 ? r = \"clockwise\" : (n - a < 0 || 270 < n - a) && (r = \"counter-clockwise\"), r !== this.pRotateDirectionZ && (h = n), 90 < Math.abs(n - h) && Math.abs(n - h) < 270 && (h = n, this._setProperty(\"turnAxis\", \"Z\"), j.deviceTurned()), this.pRotateDirectionZ = r, this._setProperty(\"turnAxis\", void 0)), typeof j.deviceShaken == \"function\" && (this.pAccelerationX !== null && (c = Math.abs(this.accelerationX - this.pAccelerationX), p = Math.abs(this.accelerationY - this.pAccelerationY)), o < c + p && j.deviceShaken());\n      }, m.default);\n      C.default = i;\n    }, { \"../core/main\": 280 }], 298: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      m.default.prototype.isKeyPressed = !1, m.default.prototype.keyIsPressed = !1, m.default.prototype.key = \"\", m.default.prototype.keyCode = 0, m.default.prototype._onkeydown = function(y) {\n        var u;\n        this._downKeys[y.which] || (this._setProperty(\"isKeyPressed\", !0), this._setProperty(\"keyIsPressed\", !0), this._setProperty(\"keyCode\", y.which), this._downKeys[y.which] = !0, this._setProperty(\"key\", y.key || String.fromCharCode(y.which) || y.which), typeof (u = this._isGlobal ? window : this).keyPressed != \"function\" || y.charCode || u.keyPressed(y) === !1 && y.preventDefault());\n      }, m.default.prototype._onkeyup = function(y) {\n        this._downKeys[y.which] = !1, this._areDownKeys() || (this._setProperty(\"isKeyPressed\", !1), this._setProperty(\"keyIsPressed\", !1)), this._setProperty(\"_lastKeyCodeTyped\", null), this._setProperty(\"key\", y.key || String.fromCharCode(y.which) || y.which), this._setProperty(\"keyCode\", y.which);\n        var u = this._isGlobal ? window : this;\n        typeof u.keyReleased == \"function\" && u.keyReleased(y) === !1 && y.preventDefault();\n      }, m.default.prototype._onkeypress = function(y) {\n        var u;\n        y.which !== this._lastKeyCodeTyped && (this._setProperty(\"_lastKeyCodeTyped\", y.which), this._setProperty(\"key\", y.key || String.fromCharCode(y.which) || y.which), typeof (u = this._isGlobal ? window : this).keyTyped == \"function\" && u.keyTyped(y) === !1 && y.preventDefault());\n      }, m.default.prototype._onblur = function(y) {\n        this._downKeys = {};\n      }, m.default.prototype.keyIsDown = function(y) {\n        return m.default._validateParameters(\"keyIsDown\", arguments), this._downKeys[y] || !1;\n      }, m.default.prototype._areDownKeys = function() {\n        for (var y in this._downKeys)\n          if (this._downKeys.hasOwnProperty(y) && this._downKeys[y] === !0)\n            return !0;\n        return !1;\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280 }], 299: [function(t, H, C) {\n      function m(f) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(r) {\n          return typeof r;\n        } : function(r) {\n          return r && typeof Symbol == \"function\" && r.constructor === Symbol && r !== Symbol.prototype ? \"symbol\" : typeof r;\n        })(f);\n      }\n      function y(f) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(r) {\n          return m(r);\n        } : function(r) {\n          return r && typeof Symbol == \"function\" && r.constructor === Symbol && r !== Symbol.prototype ? \"symbol\" : m(r);\n        })(f);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (u = t(\"../core/main\")) && u.__esModule ? u : { default: u }, h = function(f) {\n        if (f && f.__esModule)\n          return f;\n        if (f === null || y(f) !== \"object\" && typeof f != \"function\")\n          return { default: f };\n        var r = g();\n        if (r && r.has(f))\n          return r.get(f);\n        var s, o = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (s in f) {\n          var l;\n          Object.prototype.hasOwnProperty.call(f, s) && ((l = i ? Object.getOwnPropertyDescriptor(f, s) : null) && (l.get || l.set) ? Object.defineProperty(o, s, l) : o[s] = f[s]);\n        }\n        return o.default = f, r && r.set(f, o), o;\n      }(t(\"../core/constants\"));\n      function g() {\n        var f;\n        return typeof WeakMap != \"function\" ? null : (f = /* @__PURE__ */ new WeakMap(), g = function() {\n          return f;\n        }, f);\n      }\n      u.default.prototype.movedX = 0, u.default.prototype.movedY = 0, u.default.prototype._hasMouseInteracted = !1, u.default.prototype.mouseX = 0, u.default.prototype.mouseY = 0, u.default.prototype.pmouseX = 0, u.default.prototype.pmouseY = 0, u.default.prototype.winMouseX = 0, u.default.prototype.winMouseY = 0, u.default.prototype.pwinMouseX = 0, u.default.prototype.pwinMouseY = 0, u.default.prototype.mouseButton = 0, u.default.prototype.mouseIsPressed = !1, u.default.prototype._updateNextMouseCoords = function(f) {\n        var r, s, o, i, l;\n        this._curElement !== null && (!f.touches || 0 < f.touches.length) && (r = this._curElement.elt, s = this.width, o = this.height, (i = f) && !i.clientX && (i.touches ? i = i.touches[0] : i.changedTouches && (i = i.changedTouches[0])), l = r.getBoundingClientRect(), s = r.scrollWidth / s || 1, r = r.scrollHeight / o || 1, o = { x: (i.clientX - l.left) / s, y: (i.clientY - l.top) / r, winX: i.clientX, winY: i.clientY, id: i.identifier }, this._setProperty(\"movedX\", f.movementX), this._setProperty(\"movedY\", f.movementY), this._setProperty(\"mouseX\", o.x), this._setProperty(\"mouseY\", o.y), this._setProperty(\"winMouseX\", o.winX), this._setProperty(\"winMouseY\", o.winY)), this._hasMouseInteracted || (this._updateMouseCoords(), this._setProperty(\"_hasMouseInteracted\", !0));\n      }, u.default.prototype._updateMouseCoords = function() {\n        this._setProperty(\"pmouseX\", this.mouseX), this._setProperty(\"pmouseY\", this.mouseY), this._setProperty(\"pwinMouseX\", this.winMouseX), this._setProperty(\"pwinMouseY\", this.winMouseY), this._setProperty(\"_pmouseWheelDeltaY\", this._mouseWheelDeltaY);\n      }, u.default.prototype._setMouseButton = function(f) {\n        f.button === 1 ? this._setProperty(\"mouseButton\", h.CENTER) : f.button === 2 ? this._setProperty(\"mouseButton\", h.RIGHT) : this._setProperty(\"mouseButton\", h.LEFT);\n      }, u.default.prototype._onmousemove = function(f) {\n        var r = this._isGlobal ? window : this;\n        this._updateNextMouseCoords(f), this.mouseIsPressed ? typeof r.mouseDragged == \"function\" ? r.mouseDragged(f) === !1 && f.preventDefault() : typeof r.touchMoved == \"function\" && r.touchMoved(f) === !1 && f.preventDefault() : typeof r.mouseMoved == \"function\" && r.mouseMoved(f) === !1 && f.preventDefault();\n      }, u.default.prototype._onmousedown = function(f) {\n        var r = this._isGlobal ? window : this;\n        this._setProperty(\"mouseIsPressed\", !0), this._setMouseButton(f), this._updateNextMouseCoords(f), this.touchstart || (typeof r.mousePressed == \"function\" ? r.mousePressed(f) === !1 && f.preventDefault() : typeof r.touchStarted == \"function\" && r.touchStarted(f) === !1 && f.preventDefault(), this.touchstart = !1);\n      }, u.default.prototype._onmouseup = function(f) {\n        var r = this._isGlobal ? window : this;\n        this._setProperty(\"mouseIsPressed\", !1), this.touchend || (typeof r.mouseReleased == \"function\" ? r.mouseReleased(f) === !1 && f.preventDefault() : typeof r.touchEnded == \"function\" && r.touchEnded(f) === !1 && f.preventDefault(), this.touchend = !1);\n      }, u.default.prototype._ondragend = u.default.prototype._onmouseup, u.default.prototype._ondragover = u.default.prototype._onmousemove, u.default.prototype._onclick = function(f) {\n        var r = this._isGlobal ? window : this;\n        typeof r.mouseClicked == \"function\" && r.mouseClicked(f) === !1 && f.preventDefault();\n      }, u.default.prototype._ondblclick = function(f) {\n        var r = this._isGlobal ? window : this;\n        typeof r.doubleClicked == \"function\" && r.doubleClicked(f) === !1 && f.preventDefault();\n      }, u.default.prototype._mouseWheelDeltaY = 0, u.default.prototype._pmouseWheelDeltaY = 0, u.default.prototype._onwheel = function(f) {\n        var r = this._isGlobal ? window : this;\n        this._setProperty(\"_mouseWheelDeltaY\", f.deltaY), typeof r.mouseWheel == \"function\" && (f.delta = f.deltaY, r.mouseWheel(f) === !1 && f.preventDefault());\n      }, u.default.prototype.requestPointerLock = function() {\n        var f = this._curElement.elt;\n        return f.requestPointerLock = f.requestPointerLock || f.mozRequestPointerLock, f.requestPointerLock ? (f.requestPointerLock(), !0) : (console.log(\"requestPointerLock is not implemented in this browser\"), !1);\n      }, u.default.prototype.exitPointerLock = function() {\n        document.exitPointerLock();\n      }, t = u.default, C.default = t;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 300: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.prototype.touches = [], t.default.prototype._updateTouchCoords = function(m) {\n        if (this._curElement !== null) {\n          for (var y = [], u = 0; u < m.touches.length; u++)\n            y[u] = function(l, i, n, r) {\n              var s = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, o = l.getBoundingClientRect(), i = l.scrollWidth / i || 1, l = l.scrollHeight / n || 1, n = r.touches[s] || r.changedTouches[s];\n              return { x: (n.clientX - o.left) / i, y: (n.clientY - o.top) / l, winX: n.clientX, winY: n.clientY, id: n.identifier };\n            }(this._curElement.elt, this.width, this.height, m, u);\n          this._setProperty(\"touches\", y);\n        }\n      }, t.default.prototype._ontouchstart = function(m) {\n        var y = this._isGlobal ? window : this;\n        this._setProperty(\"mouseIsPressed\", !0), this._updateTouchCoords(m), this._updateNextMouseCoords(m), this._updateMouseCoords(), typeof y.touchStarted == \"function\" && (y.touchStarted(m) === !1 && m.preventDefault(), this.touchstart = !0);\n      }, t.default.prototype._ontouchmove = function(m) {\n        var y = this._isGlobal ? window : this;\n        this._updateTouchCoords(m), this._updateNextMouseCoords(m), typeof y.touchMoved == \"function\" ? y.touchMoved(m) === !1 && m.preventDefault() : typeof y.mouseDragged == \"function\" && y.mouseDragged(m) === !1 && m.preventDefault();\n      }, t.default.prototype._ontouchend = function(m) {\n        this._setProperty(\"mouseIsPressed\", !1), this._updateTouchCoords(m), this._updateNextMouseCoords(m);\n        var y = this._isGlobal ? window : this;\n        typeof y.touchEnded == \"function\" && (y.touchEnded(m) === !1 && m.preventDefault(), this.touchend = !0);\n      }, t = t.default, C.default = t;\n    }, { \"../core/main\": 280 }], 301: [function(t, H, C) {\n      t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.int32-array\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.int32-array\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m, y, u, h, g = { _toPixels: function(f) {\n        var r, s;\n        return f instanceof ImageData ? f.data : f.getContext(\"2d\") ? f.getContext(\"2d\").getImageData(0, 0, f.width, f.height).data : f.getContext(\"webgl\") ? (s = (r = f.getContext(\"webgl\")).drawingBufferWidth * r.drawingBufferHeight * 4, s = new Uint8Array(s), r.readPixels(0, 0, f.width, f.height, r.RGBA, r.UNSIGNED_BYTE, s), s) : void 0;\n      }, _getARGB: function(f, r) {\n        return r *= 4, f[3 + r] << 24 & 4278190080 | f[r] << 16 & 16711680 | f[1 + r] << 8 & 65280 | 255 & f[2 + r];\n      }, _setPixels: function(f, r) {\n        for (var s, o = 0, i = f.length; o < i; o++)\n          f[0 + (s = 4 * o)] = (16711680 & r[o]) >>> 16, f[1 + s] = (65280 & r[o]) >>> 8, f[2 + s] = 255 & r[o], f[3 + s] = (4278190080 & r[o]) >>> 24;\n      }, _toImageData: function(f) {\n        return f instanceof ImageData ? f : f.getContext(\"2d\").getImageData(0, 0, f.width, f.height);\n      }, _createImageData: function(f, r) {\n        return g._tmpCanvas = document.createElement(\"canvas\"), g._tmpCtx = g._tmpCanvas.getContext(\"2d\"), this._tmpCtx.createImageData(f, r);\n      }, apply: function(f, l, s) {\n        var o = f.getContext(\"2d\"), i = o.getImageData(0, 0, f.width, f.height), l = l(i, s);\n        l instanceof ImageData ? o.putImageData(l, 0, 0, 0, 0, f.width, f.height) : o.putImageData(i, 0, 0, 0, 0, f.width, f.height);\n      }, threshold: function(f) {\n        for (var r = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0.5, s = g._toPixels(f), o = Math.floor(255 * r), i = 0; i < s.length; i += 4) {\n          var l = void 0, l = o <= 0.2126 * s[i] + 0.7152 * s[i + 1] + 0.0722 * s[i + 2] ? 255 : 0;\n          s[i] = s[i + 1] = s[i + 2] = l;\n        }\n      }, gray: function(f) {\n        for (var r = g._toPixels(f), s = 0; s < r.length; s += 4) {\n          var o = r[s], i = r[s + 1], l = r[s + 2];\n          r[s] = r[s + 1] = r[s + 2] = 0.2126 * o + 0.7152 * i + 0.0722 * l;\n        }\n      }, opaque: function(f) {\n        for (var r = g._toPixels(f), s = 0; s < r.length; s += 4)\n          r[s + 3] = 255;\n        return r;\n      }, invert: function(f) {\n        for (var r = g._toPixels(f), s = 0; s < r.length; s += 4)\n          r[s] = 255 - r[s], r[s + 1] = 255 - r[s + 1], r[s + 2] = 255 - r[s + 2];\n      }, posterize: function(f) {\n        var r = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 4, s = g._toPixels(f);\n        if (r < 2 || 255 < r)\n          throw new Error(\"Level must be greater than 2 and less than 255 for posterize\");\n        for (var o = r - 1, i = 0; i < s.length; i += 4) {\n          var l = s[i], n = s[i + 1], a = s[i + 2];\n          s[i] = 255 * (l * r >> 8) / o, s[i + 1] = 255 * (n * r >> 8) / o, s[i + 2] = 255 * (a * r >> 8) / o;\n        }\n      }, dilate: function(f) {\n        for (var r, s, o, i, l, n, a, c, p, j = g._toPixels(f), T = 0, _ = j.length ? j.length / 4 : 0, S = new Int32Array(_); T < _; )\n          for (s = (r = T) + f.width; T < s; )\n            i = o = g._getARGB(j, T), (p = T - 1) < r && (p = T), s <= (c = T + 1) && (c = T), (l = T - f.width) < 0 && (l = 0), _ <= (n = T + f.width) && (n = T), l = g._getARGB(j, l), p = g._getARGB(j, p), n = g._getARGB(j, n), (i = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) < (a = 77 * (p >> 16 & 255) + 151 * (p >> 8 & 255) + 28 * (255 & p)) && (o = p, i = a), i < (a = 77 * ((p = g._getARGB(j, c)) >> 16 & 255) + 151 * (p >> 8 & 255) + 28 * (255 & p)) && (o = p, i = a), i < (c = 77 * (l >> 16 & 255) + 151 * (l >> 8 & 255) + 28 * (255 & l)) && (o = l, i = c), i < (p = 77 * (n >> 16 & 255) + 151 * (n >> 8 & 255) + 28 * (255 & n)) && (o = n, i = p), S[T++] = o;\n        g._setPixels(j, S);\n      }, erode: function(f) {\n        for (var r, s, o, i, l, n, a, c, p, j = g._toPixels(f), T = 0, _ = j.length ? j.length / 4 : 0, S = new Int32Array(_); T < _; )\n          for (s = (r = T) + f.width; T < s; )\n            i = o = g._getARGB(j, T), (p = T - 1) < r && (p = T), s <= (c = T + 1) && (c = T), (l = T - f.width) < 0 && (l = 0), _ <= (n = T + f.width) && (n = T), l = g._getARGB(j, l), p = g._getARGB(j, p), n = g._getARGB(j, n), (a = 77 * (p >> 16 & 255) + 151 * (p >> 8 & 255) + 28 * (255 & p)) < (i = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) && (o = p, i = a), (a = 77 * ((p = g._getARGB(j, c)) >> 16 & 255) + 151 * (p >> 8 & 255) + 28 * (255 & p)) < i && (o = p, i = a), (c = 77 * (l >> 16 & 255) + 151 * (l >> 8 & 255) + 28 * (255 & l)) < i && (o = l, i = c), (p = 77 * (n >> 16 & 255) + 151 * (n >> 8 & 255) + 28 * (255 & n)) < i && (o = n, i = p), S[T++] = o;\n        g._setPixels(j, S);\n      }, blur: function(f, r) {\n        for (var s, o, i, l, n, a, c, p, j, T, _ = g._toPixels(f), S = f.width, E = f.height, A = S * E, x = new Int32Array(A), P = 0; P < A; P++)\n          x[P] = g._getARGB(_, P);\n        var M, R, L, F, V, G, U, W, X = new Int32Array(A), ne = new Int32Array(A), b = new Int32Array(A), O = new Int32Array(A), D = 0, B = 3.5 * r | 0;\n        if (m !== (B = B < 1 ? 1 : B < 248 ? B : 248)) {\n          y = 1 + (m = B) << 1, u = new Int32Array(y), h = new Array(y);\n          for (var Y = 0; Y < y; Y++)\n            h[Y] = new Int32Array(256);\n          for (var J = 1, te = B - 1; J < B; J++) {\n            u[B + J] = u[te] = G = te * te, U = h[B + J], W = h[te--];\n            for (var ce = 0; ce < 256; ce++)\n              U[ce] = W[ce] = G * ce;\n          }\n          V = u[B] = B * B, U = h[B];\n          for (var re = 0; re < 256; re++)\n            U[re] = V * re;\n        }\n        for (R = 0; R < E; R++) {\n          for (M = 0; M < S; M++) {\n            if (l = i = o = n = s = 0, (a = M - m) < 0)\n              T = -a, a = 0;\n            else {\n              if (S <= a)\n                break;\n              T = 0;\n            }\n            for (L = T; L < y && !(S <= a); L++) {\n              var ue = x[a + D];\n              F = h[L], n += F[(-16777216 & ue) >>> 24], o += F[(16711680 & ue) >> 16], i += F[(65280 & ue) >> 8], l += F[255 & ue], s += u[L], a++;\n            }\n            X[c = D + M] = n / s, ne[c] = o / s, b[c] = i / s, O[c] = l / s;\n          }\n          D += S;\n        }\n        for (j = (p = -m) * S, R = D = 0; R < E; R++) {\n          for (M = 0; M < S; M++) {\n            if (l = i = o = n = s = 0, p < 0)\n              T = c = -p, a = M;\n            else {\n              if (E <= p)\n                break;\n              T = 0, c = p, a = M + j;\n            }\n            for (L = T; L < y && !(E <= c); L++)\n              F = h[L], n += F[X[a]], o += F[ne[a]], i += F[b[a]], l += F[O[a]], s += u[L], c++, a += S;\n            x[M + D] = n / s << 24 | o / s << 16 | i / s << 8 | l / s;\n          }\n          D += S, j += S, p++;\n        }\n        g._setPixels(_, x);\n      } };\n      C.default = g;\n    }, { \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.int32-array\": 222, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239 }], 302: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.uint32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.uint32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = u(t(\"../core/main\")), y = u(t(\"omggif\"));\n      function u(g) {\n        return g && g.__esModule ? g : { default: g };\n      }\n      function h(g) {\n        return function(f) {\n          if (Array.isArray(f)) {\n            for (var r = 0, s = new Array(f.length); r < f.length; r++)\n              s[r] = f[r];\n            return s;\n          }\n        }(g) || function(f) {\n          if (Symbol.iterator in Object(f) || Object.prototype.toString.call(f) === \"[object Arguments]\")\n            return Array.from(f);\n        }(g) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      m.default.prototype.createImage = function(g, f) {\n        return m.default._validateParameters(\"createImage\", arguments), new m.default.Image(g, f);\n      }, m.default.prototype.saveCanvas = function() {\n        for (var g, f, r, s, o, i, l = arguments.length, n = new Array(l), a = 0; a < l; a++)\n          n[a] = arguments[a];\n        switch (m.default._validateParameters(\"saveCanvas\", n), n[0] instanceof HTMLCanvasElement ? (g = n[0], n.shift()) : n[0] instanceof m.default.Element ? (g = n[0].elt, n.shift()) : n[0] instanceof m.default.Framebuffer ? (s = n[0], (o = this.createGraphics(s.width, s.height)).pixelDensity(pixelDensity()), s.loadPixels(), o.loadPixels(), o.pixels.set(s.pixels), o.updatePixels(), g = o.elt, n.shift()) : g = this._curElement && this._curElement.elt, 1 <= n.length && (f = n[0]), r = (r = 2 <= n.length ? n[1] : r) || m.default.prototype._checkFileExtension(f, r)[1] || \"png\") {\n          default:\n            i = \"image/png\";\n            break;\n          case \"jpeg\":\n          case \"jpg\":\n            i = \"image/jpeg\";\n        }\n        g.toBlob(function(c) {\n          m.default.prototype.downloadFile(c, f, r), o && o.remove();\n        }, i);\n      }, m.default.prototype.encodeAndDownloadGif = function(g, f) {\n        for (var r = g.gifProperties, s = r.loopLimit, o = (s === 1 ? s = null : s === null && (s = 0), new Uint8Array(g.width * g.height * r.numFrames)), i = [], l = {}, n = 0; n < r.numFrames; n++) {\n          for (var a = /* @__PURE__ */ new Set(), c = r.frames[n].image.data, p = c.length, j = new Uint32Array(g.width * g.height), T = 0, _ = 0; T < p; T += 4, _++) {\n            var S = c[T + 0] << 16 | c[T + 1] << 8 | c[T + 2] << 0;\n            a.add(S), j[_] = S;\n          }\n          var E = h(a).sort().toString();\n          l[E] === void 0 ? l[E] = { freq: 1, frames: [n] } : (l[E].freq += 1, l[E].frames.push(n)), i.push(j);\n        }\n        for (var P = [], A = Object.keys(l).sort(function(b, O) {\n          return l[O].freq - l[b].freq;\n        }), x = A[0].split(\",\").map(function(b) {\n          return parseInt(b);\n        }), P = P.concat(l[x].frames), M = new Set(x), R = 1; R < A.length; R++) {\n          var L = A[R].split(\",\").map(function(b) {\n            return parseInt(b);\n          }).filter(function(b) {\n            return !M.has(b);\n          });\n          if (x.length + L.length <= 256) {\n            for (var F = 0; F < L.length; F++)\n              x.push(L[F]), M.add(L[F]);\n            P = P.concat(l[A[R]].frames);\n          }\n        }\n        P = new Set(P);\n        for (var V = {}, G = 0; G < x.length; G++)\n          V[x[G]] || (V[x[G]] = G);\n        for (var U = 1; U < x.length; )\n          U <<= 1;\n        x.length = U;\n        for (var s = { loop: s, palette: new Uint32Array(x) }, W = new y.default.GifWriter(o, g.width, g.height, s), X = {}, ne = 0; ne < r.numFrames; ne++)\n          (function(O) {\n            var D = !P.has(O), B = D ? [] : x, Y = new Uint8Array(g.width * g.height), J = {}, te = /* @__PURE__ */ new Set(), ce = (i[O].forEach(function(ae, he) {\n              D ? (J[ae] === void 0 && (J[ae] = B.length, B.push(ae)), Y[he] = J[ae]) : Y[he] = V[ae], 0 < O && i[O - 1][he] !== ae && te.add(ae);\n            }), {}), re = B.filter(function(ae) {\n              return !te.has(ae);\n            });\n            if (0 < re.length) {\n              var re = re[0], ue = (D ? J : V)[re];\n              if (0 < O) {\n                for (var le = 0; le < i[O].length; le++)\n                  i[O - 1][le] === i[O][le] && (Y[le] = ue);\n                ce.transparent = ue, X.frameOpts.disposal = 1;\n              }\n            }\n            if (ce.delay = r.frames[O].delay / 10, D) {\n              for (var K = 1; K < B.length; )\n                K <<= 1;\n              B.length = K, ce.palette = new Uint32Array(B);\n            }\n            0 < O && W.addFrame(0, 0, g.width, g.height, X.pixelPaletteIndex, X.frameOpts), X = { pixelPaletteIndex: Y, frameOpts: ce };\n          })(ne);\n        X.frameOpts.disposal = 1, W.addFrame(0, 0, g.width, g.height, X.pixelPaletteIndex, X.frameOpts), s = new Blob([o.slice(0, W.end())], { type: \"image/gif\" }), m.default.prototype.downloadFile(s, f, \"gif\");\n      }, m.default.prototype.saveFrames = function(g, f, r, i, o) {\n        m.default._validateParameters(\"saveFrames\", arguments), r = m.default.prototype.constrain(r = r || 3, 0, 15), r *= 1e3;\n        var i = m.default.prototype.constrain(i || 15, 0, 22), l = 0, n = m.default.prototype._makeFrame, a = this._curElement.elt, c = [], p = setInterval(function() {\n          c.push(n(g + l, f, a)), l++;\n        }, 1e3 / i);\n        setTimeout(function() {\n          if (clearInterval(p), o)\n            o(c);\n          else\n            for (var j = 0, T = c; j < T.length; j++) {\n              var _ = T[j];\n              m.default.prototype.downloadFile(_.imageData, _.filename, _.ext);\n            }\n          c = [];\n        }, 0.01 + r);\n      }, m.default.prototype._makeFrame = function(g, f, o) {\n        var s, o = this ? this._curElement.elt : o;\n        if (f)\n          switch (f.toLowerCase()) {\n            case \"png\":\n              s = \"image/png\";\n              break;\n            case \"jpeg\":\n            case \"jpg\":\n              s = \"image/jpeg\";\n              break;\n            default:\n              s = \"image/png\";\n          }\n        else\n          f = \"png\", s = \"image/png\";\n        var o = (o = o.toDataURL(s)).replace(s, \"image/octet-stream\"), i = {};\n        return i.imageData = o, i.filename = g, i.ext = f, i;\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.set\": 194, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint32-array\": 238, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243, omggif: 253 }], 303: [function(t, H, C) {\n      function m(a) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(c) {\n          return typeof c;\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : typeof c;\n        })(a);\n      }\n      function y(a) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(c) {\n          return m(c);\n        } : function(c) {\n          return c && typeof Symbol == \"function\" && c.constructor === Symbol && c !== Symbol.prototype ? \"symbol\" : m(c);\n        })(a);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.copy-within\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.uint8-clamped-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.copy-within\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.uint8-clamped-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t(\"regenerator-runtime/runtime\");\n      var u = o(t(\"../core/main\")), h = o(t(\"../core/helpers\")), g = function(a) {\n        if (a && a.__esModule)\n          return a;\n        if (a === null || y(a) !== \"object\" && typeof a != \"function\")\n          return { default: a };\n        var c = s();\n        if (c && c.has(a))\n          return c.get(a);\n        var p, j = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (p in a) {\n          var _;\n          Object.prototype.hasOwnProperty.call(a, p) && ((_ = T ? Object.getOwnPropertyDescriptor(a, p) : null) && (_.get || _.set) ? Object.defineProperty(j, p, _) : j[p] = a[p]);\n        }\n        return j.default = a, c && c.set(a, j), j;\n      }(t(\"../core/constants\")), f = o(t(\"omggif\")), r = t(\"gifenc\");\n      function s() {\n        var a;\n        return typeof WeakMap != \"function\" ? null : (a = /* @__PURE__ */ new WeakMap(), s = function() {\n          return a;\n        }, a);\n      }\n      function o(a) {\n        return a && a.__esModule ? a : { default: a };\n      }\n      function i(a, c, p, j, T, _, S) {\n        try {\n          var E = a[_](S), A = E.value;\n        } catch (x) {\n          return void p(x);\n        }\n        E.done ? c(A) : Promise.resolve(A).then(j, T);\n      }\n      function l(a, c, p, j, T, _, S, E, A, x, P) {\n        var M, R, L, F, V, G, U, W, X;\n        return a === g.COVER && (M = c, L = p, U = _, W = S, G = E, X = A, R = x, F = P, V = Math.max(U / R, W / F), U /= V, W /= V, V = G, G = X, M === g.CENTER ? V += (R - U) / 2 : M === g.RIGHT && (V += R - U), L === g.CENTER ? G += (F - W) / 2 : L === g.BOTTOM && (G += F - W), E = (X = { x: V, y: G, w: U, h: W }).x, A = X.y, x = X.w, P = X.h), a === g.CONTAIN && (M = c, R = p, L = j, F = T, V = _, G = S, U = x, W = P, X = Math.max(U / V, W / G), U /= X, W /= X, X = L, L = F, M === g.CENTER ? X += (V - U) / 2 : M === g.RIGHT && (X += V - U), R === g.CENTER ? L += (G - W) / 2 : R === g.BOTTOM && (L += G - W), j = (a = { x: X, y: L, w: U, h: W }).x, T = a.y, _ = a.w, S = a.h), { sx: E, sy: A, sw: x, sh: P, dx: j, dy: T, dw: _, dh: S };\n      }\n      function n(a, c) {\n        return 0 < a && a < c ? a : c;\n      }\n      t(\"../core/friendly_errors/validate_params\"), t(\"../core/friendly_errors/file_errors\"), t(\"../core/friendly_errors/fes_core\"), u.default.prototype.loadImage = function(a, c, p) {\n        u.default._validateParameters(\"loadImage\", arguments);\n        var j = new u.default.Image(1, 1, this), T = this, _ = new Request(a, { method: \"GET\", mode: \"cors\" });\n        return fetch(a, _).then(function(S) {\n          var E, A = S.headers.get(\"content-type\");\n          A === null && console.warn(\"The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset.\"), A && A.includes(\"image/gif\") ? S.arrayBuffer().then(function(x) {\n            if (x) {\n              for (var x = new Uint8Array(x), P = j, M = c, R = p, L = (function(D) {\n                T._decrementPreload();\n              }).bind(T), F = new f.default.GifReader(x), V = (P.width = P.canvas.width = F.width, P.height = P.canvas.height = F.height, []), G = F.numFrames(), U = new Uint8ClampedArray(P.width * P.height * 4), W = 0; W < G; W++) {\n                var X = F.frameInfo(W), ne = P.drawingContext.getImageData(0, 0, P.width, P.height), b = (U = ne.data.slice(), function(D, B) {\n                  try {\n                    B.decodeAndBlitFrameRGBA(D, U);\n                  } catch (Y) {\n                    u.default._friendlyFileLoadError(8, P.src), typeof R == \"function\" ? R(Y) : console.error(Y);\n                  }\n                }(W, F), new ImageData(U, P.width, P.height)), b = (P.drawingContext.putImageData(b, 0, 0), X.delay);\n                b === 0 && (b = 10), V.push({ image: P.drawingContext.getImageData(0, 0, P.width, P.height), delay: 10 * b }), X.disposal === 2 ? P.drawingContext.clearRect(X.x, X.y, X.width, X.height) : X.disposal === 3 && P.drawingContext.putImageData(ne, 0, 0, X.x, X.y, X.width, X.height);\n              }\n              (x = F.loopCount()) === null ? x = 1 : x === 0 && (x = null), P.drawingContext.putImageData(V[0].image, 0, 0), 1 < V.length && (P.gifProperties = { displayIndex: 0, loopLimit: x, loopCount: 0, frames: V, numFrames: G, playing: !0, timeDisplayed: 0, lastChangeTime: 0 }), typeof M == \"function\" && M(P), L();\n            }\n          }, function(x) {\n            typeof p == \"function\" ? (p(x), T._decrementPreload()) : console.error(x);\n          }) : ((E = new Image()).onload = function() {\n            j.width = j.canvas.width = E.width, j.height = j.canvas.height = E.height, j.drawingContext.drawImage(E, 0, 0), j.modified = !0, typeof c == \"function\" && c(j), T._decrementPreload();\n          }, E.onerror = function(x) {\n            u.default._friendlyFileLoadError(0, E.src), typeof p == \"function\" ? (p(x), T._decrementPreload()) : console.error(x);\n          }, a.indexOf(\"data:image/\") !== 0 && (E.crossOrigin = \"Anonymous\"), E.src = a), j.modified = !0;\n        }).catch(function(S) {\n          u.default._friendlyFileLoadError(0, a), typeof p == \"function\" ? (p(S), T._decrementPreload()) : console.error(S);\n        }), j;\n      }, u.default.prototype.saveGif = function() {\n        a = regeneratorRuntime.mark(function p(j, T) {\n          var _, S, E, A, x, P, M, R, L, F, V, G, U, W, X, ne, b, O, D, B, Y, J, te, ce, re, ue, le = arguments;\n          return regeneratorRuntime.wrap(function(K) {\n            for (; ; )\n              switch (K.prev = K.next) {\n                case 0:\n                  if (_ = 2 < le.length && le[2] !== void 0 ? le[2] : { delay: 0, units: \"seconds\", silent: !1, notificationDuration: 0, notificationID: \"progressBar\" }, typeof j != \"string\")\n                    throw TypeError(\"fileName parameter must be a string\");\n                  K.next = 3;\n                  break;\n                case 3:\n                  if (typeof T != \"number\")\n                    throw TypeError(\"Duration parameter must be a number\");\n                  K.next = 5;\n                  break;\n                case 5:\n                  if (S = _ && _.delay || 0, E = _ && _.units || \"seconds\", A = _ && _.silent || !1, x = _ && _.notificationDuration || 0, P = _ && _.notificationID || \"progressBar\", typeof S != \"number\")\n                    throw TypeError(\"Delay parameter must be a number\");\n                  K.next = 12;\n                  break;\n                case 12:\n                  if (E !== \"seconds\" && E !== \"frames\")\n                    throw TypeError('Units parameter must be either \"frames\" or \"seconds\"');\n                  K.next = 14;\n                  break;\n                case 14:\n                  if (typeof A != \"boolean\")\n                    throw TypeError(\"Silent parameter must be a boolean\");\n                  K.next = 16;\n                  break;\n                case 16:\n                  if (typeof x != \"number\")\n                    throw TypeError(\"Notification duration parameter must be a number\");\n                  K.next = 18;\n                  break;\n                case 18:\n                  if (typeof P != \"string\")\n                    throw TypeError(\"Notification ID parameter must be a string\");\n                  K.next = 20;\n                  break;\n                case 20:\n                  return this._recording = !0, F = this._targetFrameRate, M = (M = 1 / (F = F !== 1 / 0 && F !== void 0 && F !== 0 ? F : 60) * 1e3) < 20 ? 20 : M, L = (R = E === \"seconds\" ? T * F : T) + (F = E === \"seconds\" ? S * F : S), F = F, this.frameCount = F, V = this._pixelDensity, this.pixelDensity(1), G = [], document.getElementById(P) !== null && document.getElementById(P).remove(), A || ((U = this.createP(\"\")).id(P), U.style(\"font-size\", \"16px\"), U.style(\"font-family\", \"Montserrat\"), U.style(\"background-color\", \"#ffffffa0\"), U.style(\"padding\", \"8px\"), U.style(\"border-radius\", \"10px\"), U.position(0, 0)), this._renderer instanceof u.default.RendererGL && (X = this.drawingContext, W = new Uint8Array(X.drawingBufferWidth * X.drawingBufferHeight * 4)), this.noLoop(), K.next = 39, Promise.resolve();\n                case 39:\n                  if (F < L)\n                    return this.redraw(), ce = void 0, ce = this._renderer instanceof u.default.RendererGL ? (W = new Uint8Array(X.drawingBufferWidth * X.drawingBufferHeight * 4), X.readPixels(0, 0, X.drawingBufferWidth, X.drawingBufferHeight, X.RGBA, X.UNSIGNED_BYTE, W), function(ae, he, _e) {\n                      for (var fe = parseInt(_e / 2), ge = 4 * he, xe = new Uint8Array(4 * he), De = 0; De < fe; ++De) {\n                        var Me = De * ge, Qe = (_e - De - 1) * ge;\n                        xe.set(ae.subarray(Me, Me + ge)), ae.copyWithin(Me, Qe, Qe + ge), ae.set(xe, Qe);\n                      }\n                      return ae;\n                    }(W, this.width, this.height)) : this.drawingContext.getImageData(0, 0, this.width, this.height).data, G.push(ce), F++, A || U.html(\"Saved frame <b>\" + G.length.toString() + \"</b> out of \" + R.toString()), K.next = 48, new Promise(function(ae) {\n                      return setTimeout(ae, 0);\n                    });\n                  K.next = 50;\n                  break;\n                case 48:\n                  K.next = 39;\n                  break;\n                case 50:\n                  A || U.html(\"Frames processed, generating color palette...\"), this.loop(), this.pixelDensity(V), ne = (0, r.GIFEncoder)(), b = function(ae) {\n                    for (var he = new Uint8Array(ae.length * ae[0].length), _e = 0; _e < ae.length; _e++)\n                      he.set(ae[_e], _e * ae[0].length);\n                    var fe = (0, r.quantize)(he, 256, { format: \"rgba4444\", oneBitAlpha: !0 });\n                    return fe.length === 256 ? fe[fe.length - 1] = [255 * Math.random(), 255 * Math.random(), 255 * Math.random(), 0] : fe.push([255 * Math.random(), 255 * Math.random(), 255 * Math.random(), 0]), fe;\n                  }(G), O = {}, D = function(ae) {\n                    for (var he = ae.length / 4, _e = new Uint8Array(he), fe = 0; fe < he; fe++) {\n                      var ge = ae[4 * fe] << 24 | ae[4 * fe + 1] << 16 | ae[4 * fe + 2] << 8 | ae[4 * fe + 3];\n                      O[ge] === void 0 && (O[ge] = (0, r.nearestColorIndex)(b, ae.slice(4 * fe, 4 * (fe + 1)))), _e[fe] = O[ge];\n                    }\n                    return _e;\n                  }, B = b.length - 1, Y = [], J = 0;\n                case 60:\n                  if (!(J < G.length)) {\n                    K.next = 71;\n                    break;\n                  }\n                  if (te = D(G[J]), ce = te.slice(), J === 0)\n                    ne.writeFrame(te, this.width, this.height, { palette: b, delay: M, dispose: 1 });\n                  else {\n                    for (re = 0; re < te.length; re++)\n                      te[re] === Y[re] && (te[re] = B);\n                    ne.writeFrame(te, this.width, this.height, { delay: M, transparent: !0, transparentIndex: B, dispose: 1 });\n                  }\n                  return Y = ce, A || U.html(\"Rendered frame <b>\" + J.toString() + \"</b> out of \" + R.toString()), K.next = 68, new Promise(function(ae) {\n                    return setTimeout(ae, 0);\n                  });\n                case 68:\n                  J++, K.next = 60;\n                  break;\n                case 71:\n                  ne.finish(), ue = ne.bytesView(), ue = new Blob([ue], { type: \"image/gif\" }), G = [], this._recording = !1, this.loop(), A || (U.html(\"Done. Downloading your gif!🌸\"), 0 < x && setTimeout(function() {\n                    return U.remove();\n                  }, 1e3 * x)), u.default.prototype.downloadFile(ue, j, \"gif\");\n                case 80:\n                case \"end\":\n                  return K.stop();\n              }\n          }, p, this);\n        });\n        var a, c = function() {\n          var p = this, j = arguments;\n          return new Promise(function(T, _) {\n            var S = a.apply(p, j);\n            function E(x) {\n              i(S, T, _, E, A, \"next\", x);\n            }\n            function A(x) {\n              i(S, T, _, E, A, \"throw\", x);\n            }\n            E(void 0);\n          });\n        };\n        return function(p, j) {\n          return c.apply(this, arguments);\n        };\n      }(), u.default.prototype.image = function(a, c, p, j, F, V, G, U, X, x, P, M) {\n        u.default._validateParameters(\"image\", arguments);\n        var W = a.width, R = a.height, L = (M = M || g.CENTER, P = P || g.CENTER, a.elt && (W = W !== void 0 ? W : a.elt.width, R = R !== void 0 ? R : a.elt.height), a.elt && a.elt.videoWidth && !a.canvas && (W = W !== void 0 ? W : a.elt.videoWidth, R = R !== void 0 ? R : a.elt.videoHeight), j || W), F = F || R, V = V || 0, G = G || 0, U = n(U !== void 0 ? U : W, W), W = n(X !== void 0 ? X : R, R), X = 1;\n        a.elt && !a.canvas && a.elt.style.width && (X = a.elt.videoWidth && !j ? a.elt.videoWidth : a.elt.width, X /= parseInt(a.elt.style.width, 10)), V *= X, G *= X, W *= X, U *= X, R = l(x, P, M, (R = h.default.modeAdjust(c, p, L, F, this._renderer._imageMode)).x, R.y, R.w, R.h, V, G, U, W), this._renderer.image(a, R.sx, R.sy, R.sw, R.sh, R.dx, R.dy, R.dw, R.dh);\n      }, u.default.prototype.tint = function() {\n        for (var a = arguments.length, c = new Array(a), p = 0; p < a; p++)\n          c[p] = arguments[p];\n        u.default._validateParameters(\"tint\", c);\n        var j = this.color.apply(this, c);\n        this._renderer._tint = j.levels;\n      }, u.default.prototype.noTint = function() {\n        this._renderer._tint = null;\n      }, u.default.prototype._getTintedImageCanvas = u.default.Renderer2D.prototype._getTintedImageCanvas, u.default.prototype.imageMode = function(a) {\n        u.default._validateParameters(\"imageMode\", arguments), a !== g.CORNER && a !== g.CORNERS && a !== g.CENTER || (this._renderer._imageMode = a);\n      }, t = u.default, C.default = t;\n    }, { \"../core/constants\": 269, \"../core/friendly_errors/fes_core\": 271, \"../core/friendly_errors/file_errors\": 272, \"../core/friendly_errors/validate_params\": 275, \"../core/helpers\": 276, \"../core/main\": 280, \"core-js/modules/es.array.copy-within\": 153, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/es.typed-array.uint8-clamped-array\": 240, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243, gifenc: 250, omggif: 253, \"regenerator-runtime/runtime\": 257 }], 304: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = u(t(\"../core/main\")), y = u(t(\"./filters\"));\n      function u(g) {\n        return g && g.__esModule ? g : { default: g };\n      }\n      function h(g, f) {\n        for (var r = 0; r < f.length; r++) {\n          var s = f[r];\n          s.enumerable = s.enumerable || !1, s.configurable = !0, \"value\" in s && (s.writable = !0), Object.defineProperty(g, s.key, s);\n        }\n      }\n      m.default.Image = function() {\n        function g(s, o) {\n          if (!(this instanceof g))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.width = s, this.height = o, this.canvas = document.createElement(\"canvas\"), this.canvas.width = this.width, this.canvas.height = this.height, this.drawingContext = this.canvas.getContext(\"2d\"), (this._pixelsState = this)._pixelDensity = 1, this.gifProperties = null, this._modified = !1, this.pixels = [];\n        }\n        var f, r;\n        return f = g, (r = [{ key: \"pixelDensity\", value: function(s) {\n          return s !== void 0 ? (s <= 0 && (m.default._friendlyParamError({ type: \"INVALID_VALUE\", format: { types: [\"Number\"] }, position: 1 }, \"pixelDensity\"), s = 1), this._pixelDensity = s, this.width /= s, this.height /= s, this) : this._pixelDensity;\n        } }, { key: \"_animateGif\", value: function(l) {\n          var o, i = this.gifProperties, l = l._lastRealFrameTime || window.performance.now();\n          i.lastChangeTime === 0 && (i.lastChangeTime = l), i.playing && (i.timeDisplayed = l - i.lastChangeTime, o = i.frames[i.displayIndex].delay, i.timeDisplayed >= o && (o = Math.floor(i.timeDisplayed / o), i.timeDisplayed = 0, i.lastChangeTime = l, i.displayIndex += o, i.loopCount = Math.floor(i.displayIndex / i.numFrames), i.loopLimit !== null && i.loopCount >= i.loopLimit ? i.playing = !1 : (l = i.displayIndex % i.numFrames, this.drawingContext.putImageData(i.frames[l].image, 0, 0), i.displayIndex = l, this.setModified(!0))));\n        } }, { key: \"_setProperty\", value: function(s, o) {\n          this[s] = o, this.setModified(!0);\n        } }, { key: \"loadPixels\", value: function() {\n          m.default.Renderer2D.prototype.loadPixels.call(this), this.setModified(!0);\n        } }, { key: \"updatePixels\", value: function(s, o, i, l) {\n          m.default.Renderer2D.prototype.updatePixels.call(this, s, o, i, l), this.setModified(!0);\n        } }, { key: \"get\", value: function(s, o, i, l) {\n          return m.default._validateParameters(\"p5.Image.get\", arguments), m.default.Renderer2D.prototype.get.apply(this, arguments);\n        } }, { key: \"_getPixel\", value: function() {\n          for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n            o[i] = arguments[i];\n          return m.default.Renderer2D.prototype._getPixel.apply(this, o);\n        } }, { key: \"set\", value: function(s, o, i) {\n          m.default.Renderer2D.prototype.set.call(this, s, o, i), this.setModified(!0);\n        } }, { key: \"resize\", value: function(s, o) {\n          s === 0 && o === 0 ? (s = this.canvas.width, o = this.canvas.height) : s === 0 ? s = this.canvas.width * o / this.canvas.height : o === 0 && (o = this.canvas.height * s / this.canvas.width), s = Math.floor(s), o = Math.floor(o);\n          var i = document.createElement(\"canvas\");\n          if (i.width = s, i.height = o, this.gifProperties)\n            for (var l = this.gifProperties, n = 0; n < l.numFrames; n++) {\n              for (var a = this.drawingContext.createImageData(s, o), c = (S = S = _ = T = j = void 0, l.frames[n].image), p = a, j = 0, T = 0; T < p.height; T++)\n                for (var _ = 0; _ < p.width; _++) {\n                  var S = Math.floor(_ * c.width / p.width), S = 4 * (Math.floor(T * c.height / p.height) * c.width + S);\n                  p.data[j++] = c.data[S++], p.data[j++] = c.data[S++], p.data[j++] = c.data[S++], p.data[j++] = c.data[+S];\n                }\n              l.frames[n].image = a;\n            }\n          i.getContext(\"2d\").drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, i.width, i.height), this.canvas.width = this.width = s, this.canvas.height = this.height = o, this.drawingContext.drawImage(i, 0, 0, s, o, 0, 0, s, o), 0 < this.pixels.length && this.loadPixels(), this.setModified(!0);\n        } }, { key: \"copy\", value: function() {\n          for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n            o[i] = arguments[i];\n          m.default.prototype.copy.apply(this, o);\n        } }, { key: \"mask\", value: function(s) {\n          var o = this.drawingContext.globalCompositeOperation, i = this._pixelDensity, l = 1, n = [s = s === void 0 ? this : s, 0, 0, (l = s instanceof m.default.Renderer ? s._pInst._pixelDensity : l) * s.width, l * s.height, 0, 0, i * this.width, i * this.height];\n          if (this.drawingContext.globalCompositeOperation = \"destination-in\", this.gifProperties) {\n            for (var a = 0; a < this.gifProperties.frames.length; a++)\n              this.drawingContext.putImageData(this.gifProperties.frames[a].image, 0, 0), this.copy.apply(this, n), this.gifProperties.frames[a].image = this.drawingContext.getImageData(0, 0, i * this.width, i * this.height);\n            this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);\n          } else\n            this.copy.apply(this, n);\n          this.drawingContext.globalCompositeOperation = o, this.setModified(!0);\n        } }, { key: \"filter\", value: function(s, o) {\n          y.default.apply(this.canvas, y.default[s], o), this.setModified(!0);\n        } }, { key: \"blend\", value: function() {\n          for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n            o[i] = arguments[i];\n          m.default._validateParameters(\"p5.Image.blend\", arguments), m.default.prototype.blend.apply(this, o), this.setModified(!0);\n        } }, { key: \"setModified\", value: function(s) {\n          this._modified = s;\n        } }, { key: \"isModified\", value: function() {\n          return this._modified;\n        } }, { key: \"save\", value: function(s, o) {\n          this.gifProperties ? m.default.prototype.encodeAndDownloadGif(this, s) : m.default.prototype.saveCanvas(this.canvas, s, o);\n        } }, { key: \"reset\", value: function() {\n          var s;\n          this.gifProperties && ((s = this.gifProperties).playing = !0, s.timeSinceStart = 0, s.timeDisplayed = 0, s.lastChangeTime = 0, s.loopCount = 0, s.displayIndex = 0, this.drawingContext.putImageData(s.frames[0].image, 0, 0));\n        } }, { key: \"getCurrentFrame\", value: function() {\n          var s;\n          if (this.gifProperties)\n            return (s = this.gifProperties).displayIndex % s.numFrames;\n        } }, { key: \"setFrame\", value: function(s) {\n          var o;\n          this.gifProperties && (s < (o = this.gifProperties).numFrames && 0 <= s ? (o.timeDisplayed = 0, o.lastChangeTime = 0, o.displayIndex = s, this.drawingContext.putImageData(o.frames[s].image, 0, 0)) : console.log(\"Cannot set GIF to a frame number that is higher than total number of frames or below zero.\"));\n        } }, { key: \"numFrames\", value: function() {\n          if (this.gifProperties)\n            return this.gifProperties.numFrames;\n        } }, { key: \"play\", value: function() {\n          this.gifProperties && (this.gifProperties.playing = !0);\n        } }, { key: \"pause\", value: function() {\n          this.gifProperties && (this.gifProperties.playing = !1);\n        } }, { key: \"delay\", value: function(s, o) {\n          if (this.gifProperties) {\n            var i = this.gifProperties;\n            if (o < i.numFrames && 0 <= o)\n              i.frames[o].delay = s;\n            else {\n              var l = !0, o = !1, n = void 0;\n              try {\n                for (var a, c = i.frames[Symbol.iterator](); !(l = (a = c.next()).done); l = !0)\n                  a.value.delay = s;\n              } catch (j) {\n                o = !0, n = j;\n              } finally {\n                try {\n                  l || c.return == null || c.return();\n                } finally {\n                  if (o)\n                    throw n;\n                }\n              }\n            }\n          }\n        } }]) && h(f.prototype, r), g;\n      }(), t = m.default.Image, C.default = t;\n    }, { \"../core/main\": 280, \"./filters\": 301, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 305: [function(t, H, C) {\n      t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.filter\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = u(t(\"../core/main\")), y = u(t(\"./filters\"));\n      function u(h) {\n        return h && h.__esModule ? h : { default: h };\n      }\n      t(\"../color/p5.Color\"), m.default.prototype.pixels = [], m.default.prototype.blend = function() {\n        for (var h, g = arguments.length, f = new Array(g), r = 0; r < g; r++)\n          f[r] = arguments[r];\n        m.default._validateParameters(\"blend\", f), this._renderer ? (h = this._renderer).blend.apply(h, f) : m.default.Renderer2D.prototype.blend.apply(this, f);\n      }, m.default.prototype.copy = function() {\n        for (var h, g, f, r, s, o, i, l, n, a = arguments.length, c = new Array(a), p = 0; p < a; p++)\n          c[p] = arguments[p];\n        if (m.default._validateParameters(\"copy\", c), c.length === 9)\n          h = c[0], g = c[1], f = c[2], r = c[3], s = c[4], o = c[5], i = c[6], l = c[7], n = c[8];\n        else {\n          if (c.length !== 8)\n            throw new Error(\"Signature not supported\");\n          h = this, g = c[0], f = c[1], r = c[2], s = c[3], o = c[4], i = c[5], l = c[6], n = c[7];\n        }\n        m.default.prototype._copyHelper(this, h, g, f, r, s, o, i, l, n);\n      }, m.default.prototype._copyHelper = function(h, g, f, r, s, o, i, l, n, a) {\n        var c = g.canvas.width / g.width, p = 0, j = 0;\n        g._renderer && g._renderer.isP3D && (p = g.width / 2, j = g.height / 2), h._renderer && h._renderer.isP3D ? (h.push(), h.resetMatrix(), h.noLights(), h.blendMode(h.BLEND), h.imageMode(h.CORNER), m.default.RendererGL.prototype.image.call(h._renderer, g, f + p, r + j, s, o, i, l, n, a), h.pop()) : h.drawingContext.drawImage(g.canvas, c * (f + p), c * (r + j), c * s, c * o, i, l, n, a);\n      }, m.default.prototype.getFilterGraphicsLayer = function() {\n        return this._renderer.getFilterGraphicsLayer();\n      }, m.default.prototype.filter = function() {\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        m.default._validateParameters(\"filter\", g);\n        var i = (function() {\n          var l, n = { shader: void 0, operation: void 0, value: void 0, useWebGL: !0 };\n          return (arguments.length <= 0 ? void 0 : arguments[0]) instanceof m.default.Shader ? n.shader = arguments.length <= 0 ? void 0 : arguments[0] : (n.operation = arguments.length <= 0 ? void 0 : arguments[0], 1 < arguments.length && typeof (arguments.length <= 1 ? void 0 : arguments[1]) == \"number\" && (n.value = arguments.length <= 1 ? void 0 : arguments[1]), ((l = arguments.length - 1) < 0 || arguments.length <= l ? void 0 : arguments[l]) === !1 && (n.useWebGL = !1)), n;\n        }).apply(void 0, g), r = i.shader, s = i.operation, o = i.value, i = i.useWebGL;\n        this._renderer.isP3D && r ? m.default.RendererGL.prototype.filter.call(this._renderer, r) : i || this._renderer.isP3D ? (!i && this._renderer.isP3D && console.warn(\"filter() with useWebGL=false is not supported in WEBGL\"), this._renderer.isP3D ? m.default.RendererGL.prototype.filter.call(this._renderer, s, o) : ((r = this.getFilterGraphicsLayer()).copy(this._renderer, 0, 0, this.width, this.height, -this.width / 2, -this.height / 2, this.width, this.height), this._renderer.clear(), this._renderer.resetMatrix(), r.filter.apply(r, g), this.copy(r._renderer, 0, 0, this.width, this.height, 0, 0, this.width, this.height), r.clear())) : this.canvas !== void 0 ? y.default.apply(this.canvas, y.default[s], o) : y.default.apply(this.elt, y.default[s], o);\n      }, m.default.prototype.get = function(h, g, f, r) {\n        var s;\n        return m.default._validateParameters(\"get\", arguments), (s = this._renderer).get.apply(s, arguments);\n      }, m.default.prototype.loadPixels = function() {\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        m.default._validateParameters(\"loadPixels\", g), this._renderer.loadPixels();\n      }, m.default.prototype.set = function(h, g, f) {\n        this._renderer.set(h, g, f);\n      }, m.default.prototype.updatePixels = function(h, g, f, r) {\n        m.default._validateParameters(\"updatePixels\", arguments), this.pixels.length !== 0 && this._renderer.updatePixels(h, g, f, r);\n      }, t = m.default, C.default = t;\n    }, { \"../color/p5.Color\": 267, \"../core/main\": 280, \"./filters\": 301, \"core-js/modules/es.array.filter\": 156 }], 306: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.from-entries\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/web.url\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.from-entries\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/web.url\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = g(t(\"../core/main\")), u = (t(\"whatwg-fetch\"), t(\"es6-promise/auto\"), g(t(\"fetch-jsonp\"))), h = g(t(\"file-saver\"));\n      function g(o) {\n        return o && o.__esModule ? o : { default: o };\n      }\n      function f(o) {\n        return (f = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      function r(o) {\n        return o.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n      }\n      function s(o, i) {\n        i && i !== !0 && i !== \"true\" || (i = \"\");\n        var l = \"\";\n        return (o = o || \"untitled\") && o.includes(\".\") && (l = o.split(\".\").pop()), i && l !== i && (l = i, o = \"\".concat(o, \".\").concat(l)), [o, l];\n      }\n      t(\"../core/friendly_errors/validate_params\"), t(\"../core/friendly_errors/file_errors\"), t(\"../core/friendly_errors/fes_core\"), y.default.prototype.loadJSON = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        y.default._validateParameters(\"loadJSON\", i);\n        for (var n, a, c, p = i[0], j = {}, T = \"json\", _ = 1; _ < i.length; _++) {\n          var S = i[_];\n          typeof S == \"string\" ? S !== \"jsonp\" && S !== \"json\" || (T = S) : typeof S == \"function\" ? n ? a = S : n = S : f(S) === \"object\" && (S.hasOwnProperty(\"jsonpCallback\") || S.hasOwnProperty(\"jsonpCallbackFunction\")) && (T = \"jsonp\", c = S);\n        }\n        var E = this;\n        return this.httpDo(p, \"GET\", c, T, function(A) {\n          for (var x in A)\n            j[x] = A[x];\n          n !== void 0 && n(A), E._decrementPreload();\n        }, function(A) {\n          if (y.default._friendlyFileLoadError(5, p), !a)\n            throw A;\n          a(A);\n        }), j;\n      }, y.default.prototype.loadStrings = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        y.default._validateParameters(\"loadStrings\", i);\n        for (var n, a, c = [], p = 1; p < i.length; p++) {\n          var j = i[p];\n          typeof j == \"function\" && (n === void 0 ? n = j : a === void 0 && (a = j));\n        }\n        var T = this;\n        return y.default.prototype.httpDo.call(this, i[0], \"GET\", \"text\", function(_) {\n          for (var S = _.replace(/\\r\\n/g, \"\\r\").replace(/\\n/g, \"\\r\").split(/\\r/), E = 0, A = S.length; E < A; E += 32768)\n            Array.prototype.push.apply(c, S.slice(E, Math.min(E + 32768, A)));\n          n !== void 0 && n(c), T._decrementPreload();\n        }, function(_) {\n          if (y.default._friendlyFileLoadError(3, _), !a)\n            throw _;\n          a(_);\n        }), c;\n      }, y.default.prototype.loadTable = function(o) {\n        var i, l, n, a = !1, c = o.substring(o.lastIndexOf(\".\") + 1, o.length);\n        c === \"csv\" ? n = \",\" : c === \"ssv\" ? n = \";\" : c === \"tsv\" && (n = \"\t\");\n        for (var p = 1; p < arguments.length; p++)\n          typeof arguments[p] == \"function\" ? i === void 0 ? i = arguments[p] : l === void 0 && (l = arguments[p]) : typeof arguments[p] == \"string\" && (arguments[p] === \"header\" && (a = !0), arguments[p] === \"csv\" ? n = \",\" : arguments[p] === \"ssv\" ? n = \";\" : arguments[p] === \"tsv\" && (n = \"\t\"));\n        var j = new y.default.Table(), T = this;\n        return this.httpDo(o, \"GET\", \"table\", function(_) {\n          for (var S, E, A = {}, x = 0, P = [], M = 0, R = null, L = function() {\n            A.currentState = x, A.token = \"\";\n          }, F = function() {\n            R.push(A.token), L();\n          }, V = function() {\n            A.currentState = 4, P.push(R), R = null;\n          }; ; ) {\n            if ((S = _[M++]) == null) {\n              if (A.escaped)\n                throw new Error(\"Unclosed quote in file.\");\n              if (R) {\n                F(), V();\n                break;\n              }\n            }\n            if (R === null && (A.escaped = !1, R = [], L()), A.currentState === x) {\n              if (S === '\"') {\n                A.escaped = !0, A.currentState = 1;\n                continue;\n              }\n              A.currentState = 1;\n            }\n            if (A.currentState === 1 && A.escaped)\n              if (S === '\"')\n                _[M] === '\"' ? (A.token += '\"', M++) : (A.escaped = !1, A.currentState = 2);\n              else {\n                if (S === \"\\r\")\n                  continue;\n                A.token += S;\n              }\n            else\n              S === \"\\r\" ? (_[M] === `\n` && M++, F(), V()) : S === `\n` ? (F(), V()) : S === n ? F() : A.currentState === 1 && (A.token += S);\n          }\n          if (a)\n            j.columns = P.shift();\n          else\n            for (var G = 0; G < P[0].length; G++)\n              j.columns[G] = \"null\";\n          for (var U = 0; U < P.length; U++)\n            (P[U].length !== 1 || P[U][0] !== \"undefined\" && P[U][0] !== \"\") && ((E = new y.default.TableRow()).arr = P[U], E.obj = function(W, X) {\n              if ((X = X || []) === void 0)\n                for (var ne = 0; ne < W.length; ne++)\n                  X[ne.toString()] = ne;\n              return Object.fromEntries(X.map(function(b, O) {\n                return [b, W[O]];\n              }));\n            }(P[U], j.columns), j.addRow(E));\n          typeof i == \"function\" && i(j), T._decrementPreload();\n        }, function(_) {\n          y.default._friendlyFileLoadError(2, o), l ? l(_) : console.error(_);\n        }), j;\n      }, y.default.prototype.loadXML = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        for (var n, a, c = new y.default.XML(), p = 1; p < i.length; p++) {\n          var j = i[p];\n          typeof j == \"function\" && (n === void 0 ? n = j : a === void 0 && (a = j));\n        }\n        var T = this;\n        return this.httpDo(i[0], \"GET\", \"xml\", function(_) {\n          for (var S in _)\n            c[S] = _[S];\n          n !== void 0 && n(c), T._decrementPreload();\n        }, function(_) {\n          if (y.default._friendlyFileLoadError(1, _), !a)\n            throw _;\n          a(_);\n        }), c;\n      }, y.default.prototype.loadBytes = function(o, i, l) {\n        var n = {}, a = this;\n        return this.httpDo(o, \"GET\", \"arrayBuffer\", function(c) {\n          n.bytes = new Uint8Array(c), typeof i == \"function\" && i(n), a._decrementPreload();\n        }, function(c) {\n          if (y.default._friendlyFileLoadError(6, o), !l)\n            throw c;\n          l(c);\n        }), n;\n      }, y.default.prototype.httpGet = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        return y.default._validateParameters(\"httpGet\", i), i.splice(1, 0, \"GET\"), y.default.prototype.httpDo.apply(this, i);\n      }, y.default.prototype.httpPost = function() {\n        for (var o = arguments.length, i = new Array(o), l = 0; l < o; l++)\n          i[l] = arguments[l];\n        return y.default._validateParameters(\"httpPost\", i), i.splice(1, 0, \"POST\"), y.default.prototype.httpDo.apply(this, i);\n      }, y.default.prototype.httpDo = function() {\n        for (var o, i, l, n = {}, a = 0, c = \"text/plain\", p = arguments.length - 1; 0 < p && typeof (p < 0 || arguments.length <= p ? void 0 : arguments[p]) == \"function\"; p--)\n          a++;\n        var j = arguments.length - a, T = arguments.length <= 0 ? void 0 : arguments[0];\n        if (j == 2 && typeof T == \"string\" && f(arguments.length <= 1 ? void 0 : arguments[1]) === \"object\")\n          P = new Request(T, arguments.length <= 1 ? void 0 : arguments[1]), i = arguments.length <= 2 ? void 0 : arguments[2], l = arguments.length <= 3 ? void 0 : arguments[3];\n        else {\n          for (var _, S = \"GET\", E = 1; E < arguments.length; E++) {\n            var A = E < 0 || arguments.length <= E ? void 0 : arguments[E];\n            if (typeof A == \"string\")\n              A === \"GET\" || A === \"POST\" || A === \"PUT\" || A === \"DELETE\" ? S = A : A === \"json\" || A === \"jsonp\" || A === \"binary\" || A === \"arrayBuffer\" || A === \"xml\" || A === \"text\" || A === \"table\" ? o = A : _ = A;\n            else if (typeof A == \"number\")\n              _ = A.toString();\n            else if (f(A) === \"object\")\n              if (A.hasOwnProperty(\"jsonpCallback\") || A.hasOwnProperty(\"jsonpCallbackFunction\"))\n                for (var x in A)\n                  n[x] = A[x];\n              else\n                c = A instanceof y.default.XML ? (_ = A.serialize(), \"application/xml\") : (_ = JSON.stringify(A), \"application/json\");\n            else\n              typeof A == \"function\" && (i ? l = A : i = A);\n          }\n          var j = S === \"GET\" ? new Headers() : new Headers({ \"Content-Type\": c }), P = new Request(T, { method: S, mode: \"cors\", body: _, headers: j });\n        }\n        return (j = (j = (o = o || (T.includes(\"json\") ? \"json\" : T.includes(\"xml\") ? \"xml\" : \"text\")) === \"jsonp\" ? (0, u.default)(T, n) : fetch(P)).then(function(M) {\n          if (!M.ok)\n            throw (R = new Error(M.body)).status = M.status, R.ok = !1, R;\n          var R = 0;\n          switch ((R = o !== \"jsonp\" ? M.headers.get(\"content-length\") : R) && 64e6 < R && y.default._friendlyFileLoadError(7, T), o) {\n            case \"json\":\n            case \"jsonp\":\n              return M.json();\n            case \"binary\":\n              return M.blob();\n            case \"arrayBuffer\":\n              return M.arrayBuffer();\n            case \"xml\":\n              return M.text().then(function(L) {\n                return L = new DOMParser().parseFromString(L, \"text/xml\"), new y.default.XML(L.documentElement);\n              });\n            default:\n              return M.text();\n          }\n        })).then(i || function() {\n        }), j.catch(l || console.error), j;\n      }, window.URL = window.URL || window.webkitURL, y.default.prototype._pWriters = [], y.default.prototype.createWriter = function(o, i) {\n        var l, n;\n        for (n in y.default.prototype._pWriters)\n          if (y.default.prototype._pWriters[n].name === o)\n            return l = new y.default.PrintWriter(o + this.millis(), i), y.default.prototype._pWriters.push(l), l;\n        return l = new y.default.PrintWriter(o, i), y.default.prototype._pWriters.push(l), l;\n      }, y.default.PrintWriter = function(o, i) {\n        var l = this;\n        this.name = o, this.content = \"\", this.write = function(n) {\n          this.content += n;\n        }, this.print = function(n) {\n          this.content += \"\".concat(n, `\n`);\n        }, this.clear = function() {\n          this.content = \"\";\n        }, this.close = function() {\n          var n, a = [];\n          for (n in a.push(this.content), y.default.prototype.writeFile(a, o, i), y.default.prototype._pWriters)\n            y.default.prototype._pWriters[n].name === this.name && y.default.prototype._pWriters.splice(n, 1);\n          l.clear(), l = {};\n        };\n      }, y.default.prototype.save = function(o, i, l) {\n        var n = arguments, a = (this._curElement || this).elt;\n        if (n.length === 0)\n          y.default.prototype.saveCanvas(a);\n        else if (n[0] instanceof y.default.Renderer || n[0] instanceof y.default.Graphics)\n          y.default.prototype.saveCanvas(n[0].elt, n[1], n[2]);\n        else if (n.length === 1 && typeof n[0] == \"string\")\n          y.default.prototype.saveCanvas(a, n[0]);\n        else\n          switch (s(n[1], n[2])[1]) {\n            case \"json\":\n              return void y.default.prototype.saveJSON(n[0], n[1], n[2]);\n            case \"txt\":\n              return void y.default.prototype.saveStrings(n[0], n[1], n[2]);\n            default:\n              n[0] instanceof Array ? y.default.prototype.saveStrings(n[0], n[1], n[2]) : n[0] instanceof y.default.Table ? y.default.prototype.saveTable(n[0], n[1], n[2]) : n[0] instanceof y.default.Image ? y.default.prototype.saveCanvas(n[0].canvas, n[1]) : n[0] instanceof y.default.SoundFile && y.default.prototype.saveSound(n[0], n[1], n[2], n[3]);\n          }\n      }, y.default.prototype.saveJSON = function(o, i, l) {\n        y.default._validateParameters(\"saveJSON\", arguments), l = l ? JSON.stringify(o) : JSON.stringify(o, void 0, 2), this.saveStrings(l.split(`\n`), i, \"json\");\n      }, y.default.prototype.saveJSONObject = y.default.prototype.saveJSON, y.default.prototype.saveJSONArray = y.default.prototype.saveJSON, y.default.prototype.saveStrings = function(o, i, l, n) {\n        y.default._validateParameters(\"saveStrings\", arguments);\n        for (var a = this.createWriter(i, l || \"txt\"), c = 0; c < o.length; c++)\n          n ? a.write(o[c] + `\\r\n`) : a.write(o[c] + `\n`);\n        a.close(), a.clear();\n      }, y.default.prototype.saveTable = function(o, i, l) {\n        y.default._validateParameters(\"saveTable\", arguments), n = l === void 0 ? i.substring(i.lastIndexOf(\".\") + 1, i.length) : l;\n        var n, a = this.createWriter(i, n), c = o.columns, p = n === \"tsv\" ? \"\t\" : \",\";\n        if (n !== \"html\") {\n          if (c[0] !== \"0\") {\n            for (var j = 0; j < c.length; j++)\n              j < c.length - 1 ? a.write(c[j] + p) : a.write(c[j]);\n            a.write(`\n`);\n          }\n          for (var T = 0; T < o.rows.length; T++) {\n            for (var _ = void 0, _ = 0; _ < o.rows[T].arr.length; _++)\n              _ < o.rows[T].arr.length - 1 ? n === \"csv\" && String(o.rows[T].arr[_]).includes(\",\") ? a.write('\"' + o.rows[T].arr[_] + '\"' + p) : a.write(o.rows[T].arr[_] + p) : n === \"csv\" && String(o.rows[T].arr[_]).includes(\",\") ? a.write('\"' + o.rows[T].arr[_] + '\"') : a.write(o.rows[T].arr[_]);\n            a.write(`\n`);\n          }\n        } else {\n          if (a.print(\"<html>\"), a.print(\"<head>\"), a.print('  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\" />'), a.print(\"</head>\"), a.print(\"<body>\"), a.print(\"  <table>\"), c[0] !== \"0\") {\n            a.print(\"    <tr>\");\n            for (var S = 0; S < c.length; S++) {\n              var E = r(c[S]);\n              a.print(\"      <td>\".concat(E)), a.print(\"      </td>\");\n            }\n            a.print(\"    </tr>\");\n          }\n          for (var A = 0; A < o.rows.length; A++) {\n            a.print(\"    <tr>\");\n            for (var x = 0; x < o.columns.length; x++) {\n              var P = r(o.rows[A].getString(x));\n              a.print(\"      <td>\".concat(P)), a.print(\"      </td>\");\n            }\n            a.print(\"    </tr>\");\n          }\n          a.print(\"  </table>\"), a.print(\"</body>\"), a.print(\"</html>\");\n        }\n        a.close(), a.clear();\n      }, y.default.prototype.writeFile = function(a, i, l) {\n        var n = \"application/octet-stream\", a = (y.default.prototype._isSafari() && (n = \"text/plain\"), new Blob(a, { type: n }));\n        y.default.prototype.downloadFile(a, i, l);\n      }, y.default.prototype.downloadFile = function(o, a, c) {\n        var n, a = s(a, c), c = a[0];\n        o instanceof Blob ? h.default.saveAs(o, c) : ((n = document.createElement(\"a\")).href = o, n.download = c, n.onclick = function(p) {\n          document.body.removeChild(p.target), p.stopPropagation();\n        }, n.style.display = \"none\", document.body.appendChild(n), y.default.prototype._isSafari() && (o = (o = `Hello, Safari user! To download this file...\n1. Go to File --> Save As.\n2. Choose \"Page Source\" as the Format.\n`) + '3. Name it with this extension: .\"'.concat(a[1], '\"'), alert(o)), n.click());\n      }, y.default.prototype._checkFileExtension = s, y.default.prototype._isSafari = function() {\n        return window.HTMLElement.toString().includes(\"Constructor\");\n      }, t = y.default, C.default = t;\n    }, { \"../core/friendly_errors/fes_core\": 271, \"../core/friendly_errors/file_errors\": 272, \"../core/friendly_errors/validate_params\": 275, \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.last-index-of\": 166, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.object.from-entries\": 182, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/web.dom-collections.iterator\": 243, \"core-js/modules/web.url\": 245, \"es6-promise/auto\": 246, \"fetch-jsonp\": 248, \"file-saver\": 249, \"whatwg-fetch\": 258 }], 307: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.replace\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(u, h) {\n        for (var g = 0; g < h.length; g++) {\n          var f = h[g];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);\n        }\n      }\n      m.default.Table = function() {\n        function u() {\n          var f = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : [], r = this, s = u;\n          if (!(r instanceof s))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.columns = [], this.rows = f;\n        }\n        var h, g;\n        return h = u, (g = [{ key: \"addRow\", value: function(f) {\n          if (f = f || new m.default.TableRow(), f.arr === void 0 || f.obj === void 0)\n            throw new Error(\"invalid TableRow: \".concat(f));\n          return (f.table = this).rows.push(f), f;\n        } }, { key: \"removeRow\", value: function(f) {\n          this.rows[f].table = null, f = this.rows.splice(f + 1, this.rows.length), this.rows.pop(), this.rows = this.rows.concat(f);\n        } }, { key: \"getRow\", value: function(f) {\n          return this.rows[f];\n        } }, { key: \"getRows\", value: function() {\n          return this.rows;\n        } }, { key: \"findRow\", value: function(f, r) {\n          if (typeof r == \"string\") {\n            for (var s = 0; s < this.rows.length; s++)\n              if (this.rows[s].obj[r] === f)\n                return this.rows[s];\n          } else\n            for (var o = 0; o < this.rows.length; o++)\n              if (this.rows[o].arr[r] === f)\n                return this.rows[o];\n          return null;\n        } }, { key: \"findRows\", value: function(f, r) {\n          var s = [];\n          if (typeof r == \"string\")\n            for (var o = 0; o < this.rows.length; o++)\n              this.rows[o].obj[r] === f && s.push(this.rows[o]);\n          else\n            for (var i = 0; i < this.rows.length; i++)\n              this.rows[i].arr[r] === f && s.push(this.rows[i]);\n          return s;\n        } }, { key: \"matchRow\", value: function(f, r) {\n          if (typeof r == \"number\") {\n            for (var s = 0; s < this.rows.length; s++)\n              if (this.rows[s].arr[r].match(f))\n                return this.rows[s];\n          } else\n            for (var o = 0; o < this.rows.length; o++)\n              if (this.rows[o].obj[r].match(f))\n                return this.rows[o];\n          return null;\n        } }, { key: \"matchRows\", value: function(f, r) {\n          var s = [];\n          if (typeof r == \"number\")\n            for (var o = 0; o < this.rows.length; o++)\n              this.rows[o].arr[r].match(f) && s.push(this.rows[o]);\n          else\n            for (var i = 0; i < this.rows.length; i++)\n              this.rows[i].obj[r].match(f) && s.push(this.rows[i]);\n          return s;\n        } }, { key: \"getColumn\", value: function(f) {\n          var r = [];\n          if (typeof f == \"string\")\n            for (var s = 0; s < this.rows.length; s++)\n              r.push(this.rows[s].obj[f]);\n          else\n            for (var o = 0; o < this.rows.length; o++)\n              r.push(this.rows[o].arr[f]);\n          return r;\n        } }, { key: \"clearRows\", value: function() {\n          delete this.rows, this.rows = [];\n        } }, { key: \"addColumn\", value: function(f) {\n          this.columns.push(f || null);\n        } }, { key: \"getColumnCount\", value: function() {\n          return this.columns.length;\n        } }, { key: \"getRowCount\", value: function() {\n          return this.rows.length;\n        } }, { key: \"removeTokens\", value: function(f, r) {\n          for (var s = [], o = 0; o < f.length; o++)\n            s.push(f.charAt(o).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n          var i = new RegExp(s.join(\"|\"), \"g\");\n          if (r === void 0)\n            for (var l = 0; l < this.columns.length; l++)\n              for (var n = 0; n < this.rows.length; n++) {\n                var a = (a = this.rows[n].arr[l]).replace(i, \"\");\n                this.rows[n].arr[l] = a, this.rows[n].obj[this.columns[l]] = a;\n              }\n          else if (typeof r == \"string\")\n            for (var c = 0; c < this.rows.length; c++) {\n              var p = (p = this.rows[c].obj[r]).replace(i, \"\"), j = (this.rows[c].obj[r] = p, this.columns.indexOf(r));\n              this.rows[c].arr[j] = p;\n            }\n          else\n            for (var T = 0; T < this.rows.length; T++) {\n              var _ = (_ = this.rows[T].arr[r]).replace(i, \"\");\n              this.rows[T].arr[r] = _, this.rows[T].obj[this.columns[r]] = _;\n            }\n        } }, { key: \"trim\", value: function(f) {\n          var r = new RegExp(\" \", \"g\");\n          if (f === void 0)\n            for (var s = 0; s < this.columns.length; s++)\n              for (var o = 0; o < this.rows.length; o++) {\n                var i = (i = this.rows[o].arr[s]).replace(r, \"\");\n                this.rows[o].arr[s] = i, this.rows[o].obj[this.columns[s]] = i;\n              }\n          else if (typeof f == \"string\")\n            for (var l = 0; l < this.rows.length; l++) {\n              var n = (n = this.rows[l].obj[f]).replace(r, \"\"), a = (this.rows[l].obj[f] = n, this.columns.indexOf(f));\n              this.rows[l].arr[a] = n;\n            }\n          else\n            for (var c = 0; c < this.rows.length; c++) {\n              var p = (p = this.rows[c].arr[f]).replace(r, \"\");\n              this.rows[c].arr[f] = p, this.rows[c].obj[this.columns[f]] = p;\n            }\n        } }, { key: \"removeColumn\", value: function(o) {\n          typeof o == \"string\" ? s = this.columns.indexOf(r = o) : r = this.columns[s = o];\n          var r, s, o = this.columns.splice(s + 1, this.columns.length);\n          this.columns.pop(), this.columns = this.columns.concat(o);\n          for (var i = 0; i < this.rows.length; i++) {\n            var l = this.rows[i].arr, n = l.splice(s + 1, l.length);\n            l.pop(), this.rows[i].arr = l.concat(n), delete this.rows[i].obj[r];\n          }\n        } }, { key: \"set\", value: function(f, r, s) {\n          this.rows[f].set(r, s);\n        } }, { key: \"setNum\", value: function(f, r, s) {\n          this.rows[f].setNum(r, s);\n        } }, { key: \"setString\", value: function(f, r, s) {\n          this.rows[f].setString(r, s);\n        } }, { key: \"get\", value: function(f, r) {\n          return this.rows[f].get(r);\n        } }, { key: \"getNum\", value: function(f, r) {\n          return this.rows[f].getNum(r);\n        } }, { key: \"getString\", value: function(f, r) {\n          return this.rows[f].getString(r);\n        } }, { key: \"getObject\", value: function(f) {\n          for (var r, s = {}, o = 0; o < this.rows.length; o++)\n            if (r = this.rows[o].obj, typeof f == \"string\") {\n              if (!(0 <= this.columns.indexOf(f)))\n                throw new Error('This table has no column named \"'.concat(f, '\"'));\n              s[r[f]] = r;\n            } else\n              s[o] = this.rows[o].obj;\n          return s;\n        } }, { key: \"getArray\", value: function() {\n          for (var f = [], r = 0; r < this.rows.length; r++)\n            f.push(this.rows[r].arr);\n          return f;\n        } }]) && y(h.prototype, g), u;\n      }(), t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.regexp.constructor\": 191, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.replace\": 201 }], 308: [function(t, H, C) {\n      t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.from-entries\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.from-entries\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function m(y, u) {\n        for (var h = 0; h < u.length; h++) {\n          var g = u[h];\n          g.enumerable = g.enumerable || !1, g.configurable = !0, \"value\" in g && (g.writable = !0), Object.defineProperty(y, g.key, g);\n        }\n      }\n      t.default.TableRow = function() {\n        function y(g, f) {\n          if (!(this instanceof y))\n            throw new TypeError(\"Cannot call a class as a function\");\n          var r = [];\n          g && (r = g.split(f = f || \",\")), this.arr = r, this.obj = Object.fromEntries(r.entries()), this.table = null;\n        }\n        var u, h;\n        return u = y, (h = [{ key: \"set\", value: function(g, f) {\n          if (typeof g == \"string\") {\n            var r = this.table.columns.indexOf(g);\n            if (!(0 <= r))\n              throw new Error('This table has no column named \"'.concat(g, '\"'));\n            this.obj[g] = f, this.arr[r] = f;\n          } else {\n            if (!(g < this.table.columns.length))\n              throw new Error(\"Column #\".concat(g, \" is out of the range of this table\"));\n            this.arr[g] = f, r = this.table.columns[g], this.obj[r] = f;\n          }\n        } }, { key: \"setNum\", value: function(g, f) {\n          f = parseFloat(f), this.set(g, f);\n        } }, { key: \"setString\", value: function(g, f) {\n          f = f.toString(), this.set(g, f);\n        } }, { key: \"get\", value: function(g) {\n          return (typeof g == \"string\" ? this.obj : this.arr)[g];\n        } }, { key: \"getNum\", value: function(g) {\n          var f = parseFloat(typeof g == \"string\" ? this.obj[g] : this.arr[g]);\n          if (f.toString() === \"NaN\")\n            throw \"Error: \".concat(this.obj[g], \" is NaN (Not a Number)\");\n          return f;\n        } }, { key: \"getString\", value: function(g) {\n          return (typeof g == \"string\" ? this.obj : this.arr)[g].toString();\n        } }]) && m(u.prototype, h), y;\n      }(), t = t.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.from-entries\": 182, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.split\": 203, \"core-js/modules/web.dom-collections.iterator\": 243 }], 309: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(h, g) {\n        for (var f = 0; f < g.length; f++) {\n          var r = g[f];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(h, r.key, r);\n        }\n      }\n      function u(h) {\n        for (var g = [], f = 0; f < h.length; f++)\n          g.push(new m.default.XML(h[f]));\n        return g;\n      }\n      m.default.XML = function() {\n        function h(r) {\n          if (!(this instanceof h))\n            throw new TypeError(\"Cannot call a class as a function\");\n          r ? this.DOM = r : (r = document.implementation.createDocument(null, \"doc\"), this.DOM = r.createElement(\"root\"));\n        }\n        var g, f;\n        return g = h, (f = [{ key: \"getParent\", value: function() {\n          return new m.default.XML(this.DOM.parentElement);\n        } }, { key: \"getName\", value: function() {\n          return this.DOM.tagName;\n        } }, { key: \"setName\", value: function(r) {\n          var s = this.DOM.innerHTML, o = this.DOM.attributes, i = document.implementation.createDocument(null, \"default\").createElement(r);\n          i.innerHTML = s;\n          for (var l = 0; l < o.length; l++)\n            i.setAttribute(o[l].nodeName, o[l].nodeValue);\n          this.DOM = i;\n        } }, { key: \"hasChildren\", value: function() {\n          return 0 < this.DOM.children.length;\n        } }, { key: \"listChildren\", value: function() {\n          for (var r = [], s = 0; s < this.DOM.childNodes.length; s++)\n            r.push(this.DOM.childNodes[s].nodeName);\n          return r;\n        } }, { key: \"getChildren\", value: function(r) {\n          return u(r ? this.DOM.getElementsByTagName(r) : this.DOM.children);\n        } }, { key: \"getChild\", value: function(r) {\n          if (typeof r != \"string\")\n            return new m.default.XML(this.DOM.children[r]);\n          var s = !0, o = !1, i = void 0;\n          try {\n            for (var l, n = this.DOM.children[Symbol.iterator](); !(s = (l = n.next()).done); s = !0) {\n              var a = l.value;\n              if (a.tagName === r)\n                return new m.default.XML(a);\n            }\n          } catch (c) {\n            o = !0, i = c;\n          } finally {\n            try {\n              s || n.return == null || n.return();\n            } finally {\n              if (o)\n                throw i;\n            }\n          }\n        } }, { key: \"addChild\", value: function(r) {\n          r instanceof m.default.XML && this.DOM.appendChild(r.DOM);\n        } }, { key: \"removeChild\", value: function(r) {\n          var s = -1;\n          if (typeof r == \"string\") {\n            for (var o = 0; o < this.DOM.children.length; o++)\n              if (this.DOM.children[o].tagName === r) {\n                s = o;\n                break;\n              }\n          } else\n            s = r;\n          s !== -1 && this.DOM.removeChild(this.DOM.children[s]);\n        } }, { key: \"getAttributeCount\", value: function() {\n          return this.DOM.attributes.length;\n        } }, { key: \"listAttributes\", value: function() {\n          var r = [], s = !0, o = !1, i = void 0;\n          try {\n            for (var l, n = this.DOM.attributes[Symbol.iterator](); !(s = (l = n.next()).done); s = !0) {\n              var a = l.value;\n              r.push(a.nodeName);\n            }\n          } catch (c) {\n            o = !0, i = c;\n          } finally {\n            try {\n              s || n.return == null || n.return();\n            } finally {\n              if (o)\n                throw i;\n            }\n          }\n          return r;\n        } }, { key: \"hasAttribute\", value: function(r) {\n          var s = {}, o = !0, i = !1, l = void 0;\n          try {\n            for (var n, a = this.DOM.attributes[Symbol.iterator](); !(o = (n = a.next()).done); o = !0) {\n              var c = n.value;\n              s[c.nodeName] = c.nodeValue;\n            }\n          } catch (p) {\n            i = !0, l = p;\n          } finally {\n            try {\n              o || a.return == null || a.return();\n            } finally {\n              if (i)\n                throw l;\n            }\n          }\n          return !!s[r];\n        } }, { key: \"getNum\", value: function(r, s) {\n          var o = {}, i = !0, l = !1, n = void 0;\n          try {\n            for (var a, c = this.DOM.attributes[Symbol.iterator](); !(i = (a = c.next()).done); i = !0) {\n              var p = a.value;\n              o[p.nodeName] = p.nodeValue;\n            }\n          } catch (j) {\n            l = !0, n = j;\n          } finally {\n            try {\n              i || c.return == null || c.return();\n            } finally {\n              if (l)\n                throw n;\n            }\n          }\n          return Number(o[r]) || s || 0;\n        } }, { key: \"getString\", value: function(r, s) {\n          var o = {}, i = !0, l = !1, n = void 0;\n          try {\n            for (var a, c = this.DOM.attributes[Symbol.iterator](); !(i = (a = c.next()).done); i = !0) {\n              var p = a.value;\n              o[p.nodeName] = p.nodeValue;\n            }\n          } catch (j) {\n            l = !0, n = j;\n          } finally {\n            try {\n              i || c.return == null || c.return();\n            } finally {\n              if (l)\n                throw n;\n            }\n          }\n          return o[r] ? String(o[r]) : s || null;\n        } }, { key: \"setAttribute\", value: function(r, s) {\n          this.DOM.setAttribute(r, s);\n        } }, { key: \"getContent\", value: function(r) {\n          var s = this.DOM.textContent;\n          return (s = s.replace(/\\s\\s+/g, \",\")) || r || null;\n        } }, { key: \"setContent\", value: function(r) {\n          this.DOM.children.length || (this.DOM.textContent = r);\n        } }, { key: \"serialize\", value: function() {\n          return new XMLSerializer().serializeToString(this.DOM);\n        } }]) && y(g.prototype, f), h;\n      }(), t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 310: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.string.includes\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(u) {\n        return function(h) {\n          if (Array.isArray(h)) {\n            for (var g = 0, f = new Array(h.length); g < h.length; g++)\n              f[g] = h[g];\n            return f;\n          }\n        }(u) || function(h) {\n          if (Symbol.iterator in Object(h) || Object.prototype.toString.call(h) === \"[object Arguments]\")\n            return Array.from(h);\n        }(u) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      m.default.prototype.abs = Math.abs, m.default.prototype.ceil = Math.ceil, m.default.prototype.constrain = function(u, h, g) {\n        return m.default._validateParameters(\"constrain\", arguments), Math.max(Math.min(u, g), h);\n      }, m.default.prototype.dist = function() {\n        for (var u = arguments.length, h = new Array(u), g = 0; g < u; g++)\n          h[g] = arguments[g];\n        return m.default._validateParameters(\"dist\", h), h.length === 4 ? Math.hypot(h[2] - h[0], h[3] - h[1]) : h.length === 6 ? Math.hypot(h[3] - h[0], h[4] - h[1], h[5] - h[2]) : void 0;\n      }, m.default.prototype.exp = Math.exp, m.default.prototype.floor = Math.floor, m.default.prototype.lerp = function(u, h, g) {\n        return m.default._validateParameters(\"lerp\", arguments), g * (h - u) + u;\n      }, m.default.prototype.log = Math.log, m.default.prototype.mag = function(u, h) {\n        return m.default._validateParameters(\"mag\", arguments), Math.hypot(u, h);\n      }, m.default.prototype.map = function(u, h, g, f, r, s) {\n        return m.default._validateParameters(\"map\", arguments), u = (u - h) / (g - h) * (r - f) + f, s ? f < r ? this.constrain(u, f, r) : this.constrain(u, r, f) : u;\n      }, m.default.prototype.max = function() {\n        for (var u = function(r) {\n          return Math.max.apply(Math, y(r));\n        }, h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return Array.isArray(g[0]) ? u(g[0]) : u(g);\n      }, m.default.prototype.min = function() {\n        for (var u = function(r) {\n          return Math.min.apply(Math, y(r));\n        }, h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return Array.isArray(g[0]) ? u(g[0]) : u(g);\n      }, m.default.prototype.norm = function(u, h, g) {\n        return m.default._validateParameters(\"norm\", arguments), this.map(u, h, g, 0, 1);\n      }, m.default.prototype.pow = Math.pow, m.default.prototype.round = function(u, h) {\n        return h ? (h = Math.pow(10, h), Math.round(u * h) / h) : Math.round(u);\n      }, m.default.prototype.sq = function(u) {\n        return u * u;\n      }, m.default.prototype.sqrt = Math.sqrt, m.default.prototype.fract = function(f) {\n        m.default._validateParameters(\"fract\", arguments);\n        var h, g = 0, f = Number(f);\n        return isNaN(f) || Math.abs(f) === 1 / 0 ? f : (f < 0 && (f = -f, g = 1), String(f).includes(\".\") && !String(f).includes(\"e\") ? (h = String(f), h = +(\"0\" + h.slice(h.indexOf(\".\"))), Math.abs(g - h)) : f < 1 ? Math.abs(g - f) : 0);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.math.hypot\": 175, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 311: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.slice\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(h, g, f) {\n        return (y = function() {\n          if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n            if (typeof Proxy == \"function\")\n              return 1;\n            try {\n              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n              })), 1;\n            } catch {\n            }\n          }\n        }() ? Reflect.construct : function(r, s, o) {\n          var i = [null];\n          return i.push.apply(i, s), s = new (Function.bind.apply(r, i))(), o && u(s, o.prototype), s;\n        }).apply(null, arguments);\n      }\n      function u(h, g) {\n        return (u = Object.setPrototypeOf || function(f, r) {\n          return f.__proto__ = r, f;\n        })(h, g);\n      }\n      m.default.prototype.createVector = function(h, g, f) {\n        return this instanceof m.default ? y(m.default.Vector, [this._fromRadians.bind(this), this._toRadians.bind(this)].concat(Array.prototype.slice.call(arguments))) : new m.default.Vector(h, g, f);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.to-string\": 193 }], 312: [function(f, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, f = (f = f(\"../core/main\")) && f.__esModule ? f : { default: f };\n      function m(r) {\n        return 0.5 * (1 - Math.cos(r * Math.PI));\n      }\n      var y, u = 4095, h = 4, g = 0.5, f = (f.default.prototype.noise = function(r) {\n        var s = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0, o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (y == null) {\n          y = new Array(4096);\n          for (var i = 0; i < 4096; i++)\n            y[i] = Math.random();\n        }\n        r < 0 && (r = -r), s < 0 && (s = -s), o < 0 && (o = -o);\n        for (var l, n, a = Math.floor(r), c = Math.floor(s), p = Math.floor(o), j = r - a, T = s - c, _ = o - p, S = 0, E = 0.5, A = 0; A < h; A++) {\n          var x = a + (c << 4) + (p << 8), P = m(j), M = m(T), R = y[x & u];\n          R += P * (y[x + 1 & u] - R), l = y[x + 16 & u], R += M * ((l += P * (y[x + 16 + 1 & u] - l)) - R), l = y[(x += 256) & u], l += P * (y[x + 1 & u] - l), n = y[x + 16 & u], l += M * ((n += P * (y[x + 16 + 1 & u] - n)) - l), S += (R += m(_) * (l - R)) * E, E *= g, a <<= 1, c <<= 1, p <<= 1, 1 <= (j *= 2) && (a++, j--), 1 <= (T *= 2) && (c++, T--), 1 <= (_ *= 2) && (p++, _--);\n        }\n        return S;\n      }, f.default.prototype.noiseDetail = function(r, s) {\n        0 < r && (h = r), 0 < s && (g = s);\n      }, f.default.prototype.noiseSeed = function(r) {\n        i = 4294967296;\n        var s, o, i, l = { setSeed: function(a) {\n          o = s = (a ?? Math.random() * i) >>> 0;\n        }, getSeed: function() {\n          return s;\n        }, rand: function() {\n          return (o = (1664525 * o + 1013904223) % i) / i;\n        } };\n        l.setSeed(r), y = new Array(4096);\n        for (var n = 0; n < 4096; n++)\n          y[n] = l.rand();\n      }, f.default);\n      C.default = f;\n    }, { \"../core/main\": 280 }], 313: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      function y(s) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.number.is-finite\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.number.is-finite\"), t(\"core-js/modules/es.string.sub\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (r = t(\"../core/main\")) && r.__esModule ? r : { default: r }, h = function(s) {\n        if (s && s.__esModule)\n          return s;\n        if (s === null || y(s) !== \"object\" && typeof s != \"function\")\n          return { default: s };\n        var o = g();\n        if (o && o.has(s))\n          return o.get(s);\n        var i, l = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (i in s) {\n          var a;\n          Object.prototype.hasOwnProperty.call(s, i) && ((a = n ? Object.getOwnPropertyDescriptor(s, i) : null) && (a.get || a.set) ? Object.defineProperty(l, i, a) : l[i] = s[i]);\n        }\n        return l.default = s, o && o.set(s, l), l;\n      }(t(\"../core/constants\"));\n      function g() {\n        var s;\n        return typeof WeakMap != \"function\" ? null : (s = /* @__PURE__ */ new WeakMap(), g = function() {\n          return s;\n        }, s);\n      }\n      function f(s, o) {\n        for (var i = 0; i < o.length; i++) {\n          var l = o[i];\n          l.enumerable = l.enumerable || !1, l.configurable = !0, \"value\" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);\n        }\n      }\n      u.default.Vector = function() {\n        function s() {\n          var p = this, n = s;\n          if (!(p instanceof n))\n            throw new TypeError(\"Cannot call a class as a function\");\n          var a, c, p = typeof (arguments.length <= 0 ? void 0 : arguments[0]) == \"function\" ? (this.isPInst = !0, this._fromRadians = arguments.length <= 0 ? void 0 : arguments[0], this._toRadians = arguments.length <= 1 ? void 0 : arguments[1], a = (arguments.length <= 2 ? void 0 : arguments[2]) || 0, c = (arguments.length <= 3 ? void 0 : arguments[3]) || 0, (arguments.length <= 4 ? void 0 : arguments[4]) || 0) : (a = (arguments.length <= 0 ? void 0 : arguments[0]) || 0, c = (arguments.length <= 1 ? void 0 : arguments[1]) || 0, (arguments.length <= 2 ? void 0 : arguments[2]) || 0);\n          this.x = a, this.y = c, this.z = p;\n        }\n        var o, i, l;\n        return o = s, l = [{ key: \"fromAngle\", value: function(n) {\n          var a = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 1;\n          return new u.default.Vector(a * Math.cos(n), a * Math.sin(n), 0);\n        } }, { key: \"fromAngles\", value: function(_, j) {\n          var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 1, p = Math.cos(j), j = Math.sin(j), T = Math.cos(_), _ = Math.sin(_);\n          return new u.default.Vector(c * _ * j, -c * T, c * _ * p);\n        } }, { key: \"random2D\", value: function() {\n          return this.fromAngle(Math.random() * h.TWO_PI);\n        } }, { key: \"random3D\", value: function() {\n          var n = Math.random() * h.TWO_PI, a = 2 * Math.random() - 1, p = Math.sqrt(1 - a * a), c = p * Math.cos(n), p = p * Math.sin(n);\n          return new u.default.Vector(c, p, a);\n        } }, { key: \"copy\", value: function(n) {\n          return n.copy(n);\n        } }, { key: \"add\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return T ? T.set(p) : (T = p.copy(), a.length === 3 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.add\")), T.add(j), T;\n        } }, { key: \"rem\", value: function(n, a) {\n          if (n instanceof u.default.Vector && a instanceof u.default.Vector)\n            return (n = n.copy()).rem(a), n;\n        } }, { key: \"sub\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return T ? T.set(p) : (T = p.copy(), a.length === 3 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.sub\")), T.sub(j), T;\n        } }, { key: \"mult\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return T ? T.set(p) : (T = p.copy(), a.length === 3 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.mult\")), T.mult(j), T;\n        } }, { key: \"rotate\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return a.length === 2 ? T = p.copy() : (T instanceof u.default.Vector || u.default._friendlyError(\"The target parameter should be of type p5.Vector\", \"p5.Vector.rotate\"), T.set(p)), T.rotate(j), T;\n        } }, { key: \"div\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return T ? T.set(p) : (T = p.copy(), a.length === 3 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.div\")), T.div(j), T;\n        } }, { key: \"dot\", value: function(n, a) {\n          return n.dot(a);\n        } }, { key: \"cross\", value: function(n, a) {\n          return n.cross(a);\n        } }, { key: \"dist\", value: function(n, a) {\n          return n.dist(a);\n        } }, { key: \"lerp\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2], _ = a[3];\n          return _ ? _.set(p) : (_ = p.copy(), a.length === 4 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.lerp\")), _.lerp(j, T), _;\n        } }, { key: \"slerp\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2], _ = a[3];\n          return _ ? _.set(p) : (_ = p.copy(), a.length === 4 && u.default._friendlyError(\"The target parameter is undefined, it should be of type p5.Vector\", \"p5.Vector.slerp\")), _.slerp(j, T), _;\n        } }, { key: \"mag\", value: function(n) {\n          return n.mag();\n        } }, { key: \"magSq\", value: function(n) {\n          return n.magSq();\n        } }, { key: \"normalize\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1];\n          return a.length < 2 ? j = p.copy() : (j instanceof u.default.Vector || u.default._friendlyError(\"The target parameter should be of type p5.Vector\", \"p5.Vector.normalize\"), j.set(p)), j.normalize();\n        } }, { key: \"limit\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return a.length < 3 ? T = p.copy() : (T instanceof u.default.Vector || u.default._friendlyError(\"The target parameter should be of type p5.Vector\", \"p5.Vector.limit\"), T.set(p)), T.limit(j);\n        } }, { key: \"setMag\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return a.length < 3 ? T = p.copy() : (T instanceof u.default.Vector || u.default._friendlyError(\"The target parameter should be of type p5.Vector\", \"p5.Vector.setMag\"), T.set(p)), T.setMag(j);\n        } }, { key: \"heading\", value: function(n) {\n          return n.heading();\n        } }, { key: \"angleBetween\", value: function(n, a) {\n          return n.angleBetween(a);\n        } }, { key: \"reflect\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          return a.length < 3 ? T = p.copy() : (T instanceof u.default.Vector || u.default._friendlyError(\"The target parameter should be of type p5.Vector\", \"p5.Vector.reflect\"), T.set(p)), T.reflect(j);\n        } }, { key: \"array\", value: function(n) {\n          return n.array();\n        } }, { key: \"equals\", value: function(n, a) {\n          var c;\n          return n instanceof u.default.Vector ? c = n : Array.isArray(n) ? c = new u.default.Vector().set(n) : u.default._friendlyError(\"The v1 parameter should be of type Array or p5.Vector\", \"p5.Vector.equals\"), c.equals(a);\n        } }], (i = [{ key: \"toString\", value: function() {\n          return \"p5.Vector Object : [\".concat(this.x, \", \").concat(this.y, \", \").concat(this.z, \"]\");\n        } }, { key: \"set\", value: function(n, a, c) {\n          return n instanceof u.default.Vector ? (this.x = n.x || 0, this.y = n.y || 0, this.z = n.z || 0) : Array.isArray(n) ? (this.x = n[0] || 0, this.y = n[1] || 0, this.z = n[2] || 0) : (this.x = n || 0, this.y = a || 0, this.z = c || 0), this;\n        } }, { key: \"copy\", value: function() {\n          return this.isPInst ? new u.default.Vector(this._fromRadians, this._toRadians, this.x, this.y, this.z) : new u.default.Vector(this.x, this.y, this.z);\n        } }, { key: \"add\", value: function(n, a, c) {\n          return n instanceof u.default.Vector ? (this.x += n.x || 0, this.y += n.y || 0, this.z += n.z || 0) : Array.isArray(n) ? (this.x += n[0] || 0, this.y += n[1] || 0, this.z += n[2] || 0) : (this.x += n || 0, this.y += a || 0, this.z += c || 0), this;\n        } }, { key: \"calculateRemainder2D\", value: function(n, a) {\n          return n !== 0 && (this.x = this.x % n), a !== 0 && (this.y = this.y % a), this;\n        } }, { key: \"calculateRemainder3D\", value: function(n, a, c) {\n          return n !== 0 && (this.x = this.x % n), a !== 0 && (this.y = this.y % a), c !== 0 && (this.z = this.z % c), this;\n        } }, { key: \"rem\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p, j, T, _ = a[0], S = a[1], E = a[2];\n          if (_ instanceof u.default.Vector) {\n            if ([_.x, _.y, _.z].every(Number.isFinite))\n              return p = parseFloat(_.x), j = parseFloat(_.y), T = parseFloat(_.z), this.calculateRemainder3D(p, j, T);\n          } else if (Array.isArray(_)) {\n            if (_.every(Number.isFinite))\n              return _.length === 2 ? this.calculateRemainder2D(_[0], _[1]) : _.length === 3 ? this.calculateRemainder3D(_[0], _[1], _[2]) : void 0;\n          } else if (a.length === 1) {\n            if (Number.isFinite(_) && _ !== 0)\n              return this.x = this.x % _, this.y = this.y % _, this.z = this.z % _, this;\n          } else if (a.length === 2) {\n            if (a.every(Number.isFinite))\n              return this.calculateRemainder2D(_, S);\n          } else if (a.length === 3 && a.every(Number.isFinite))\n            return this.calculateRemainder3D(_, S, E);\n        } }, { key: \"sub\", value: function(n, a, c) {\n          return n instanceof u.default.Vector ? (this.x -= n.x || 0, this.y -= n.y || 0, this.z -= n.z || 0) : Array.isArray(n) ? (this.x -= n[0] || 0, this.y -= n[1] || 0, this.z -= n[2] || 0) : (this.x -= n || 0, this.y -= a || 0, this.z -= c || 0), this;\n        } }, { key: \"mult\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p, j = a[0], T = a[1], _ = a[2];\n          return j instanceof u.default.Vector ? Number.isFinite(j.x) && Number.isFinite(j.y) && Number.isFinite(j.z) && typeof j.x == \"number\" && typeof j.y == \"number\" && typeof j.z == \"number\" ? (this.x *= j.x, this.y *= j.y, this.z *= j.z) : console.warn(\"p5.Vector.prototype.mult:\", \"x contains components that are either undefined or not finite numbers\") : Array.isArray(j) ? j.every(function(S) {\n            return Number.isFinite(S);\n          }) && j.every(function(S) {\n            return typeof S == \"number\";\n          }) ? j.length === 1 ? (this.x *= j[0], this.y *= j[0], this.z *= j[0]) : j.length === 2 ? (this.x *= j[0], this.y *= j[1]) : j.length === 3 && (this.x *= j[0], this.y *= j[1], this.z *= j[2]) : console.warn(\"p5.Vector.prototype.mult:\", \"x contains elements that are either undefined or not finite numbers\") : (p = a).every(function(S) {\n            return Number.isFinite(S);\n          }) && p.every(function(S) {\n            return typeof S == \"number\";\n          }) ? (a.length === 1 && (this.x *= j, this.y *= j, this.z *= j), a.length === 2 && (this.x *= j, this.y *= T), a.length === 3 && (this.x *= j, this.y *= T, this.z *= _)) : console.warn(\"p5.Vector.prototype.mult:\", \"x, y, or z arguments are either undefined or not a finite number\"), this;\n        } }, { key: \"div\", value: function() {\n          for (var n = arguments.length, a = new Array(n), c = 0; c < n; c++)\n            a[c] = arguments[c];\n          var p = a[0], j = a[1], T = a[2];\n          if (p instanceof u.default.Vector)\n            if (Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.z) && typeof p.x == \"number\" && typeof p.y == \"number\" && typeof p.z == \"number\") {\n              var _ = p.z === 0 && this.z === 0;\n              if (p.x === 0 || p.y === 0 || !_ && p.z === 0)\n                return console.warn(\"p5.Vector.prototype.div:\", \"divide by 0\"), this;\n              this.x /= p.x, this.y /= p.y, _ || (this.z /= p.z);\n            } else\n              console.warn(\"p5.Vector.prototype.div:\", \"x contains components that are either undefined or not finite numbers\");\n          else if (Array.isArray(p))\n            if (p.every(Number.isFinite) && p.every(function(S) {\n              return typeof S == \"number\";\n            })) {\n              if (p.some(function(S) {\n                return S === 0;\n              }))\n                return console.warn(\"p5.Vector.prototype.div:\", \"divide by 0\"), this;\n              p.length === 1 ? (this.x /= p[0], this.y /= p[0], this.z /= p[0]) : p.length === 2 ? (this.x /= p[0], this.y /= p[1]) : p.length === 3 && (this.x /= p[0], this.y /= p[1], this.z /= p[2]);\n            } else\n              console.warn(\"p5.Vector.prototype.div:\", \"x contains components that are either undefined or not finite numbers\");\n          else if (a.every(Number.isFinite) && a.every(function(S) {\n            return typeof S == \"number\";\n          })) {\n            if (a.some(function(S) {\n              return S === 0;\n            }))\n              return console.warn(\"p5.Vector.prototype.div:\", \"divide by 0\"), this;\n            a.length === 1 && (this.x /= p, this.y /= p, this.z /= p), a.length === 2 && (this.x /= p, this.y /= j), a.length === 3 && (this.x /= p, this.y /= j, this.z /= T);\n          } else\n            console.warn(\"p5.Vector.prototype.div:\", \"x, y, or z arguments are either undefined or not a finite number\");\n          return this;\n        } }, { key: \"mag\", value: function() {\n          return Math.sqrt(this.magSq());\n        } }, { key: \"magSq\", value: function() {\n          var n = this.x, a = this.y, c = this.z;\n          return n * n + a * a + c * c;\n        } }, { key: \"dot\", value: function(n, a, c) {\n          return n instanceof u.default.Vector ? this.dot(n.x, n.y, n.z) : this.x * (n || 0) + this.y * (a || 0) + this.z * (c || 0);\n        } }, { key: \"cross\", value: function(p) {\n          var a = this.y * p.z - this.z * p.y, c = this.z * p.x - this.x * p.z, p = this.x * p.y - this.y * p.x;\n          return this.isPInst ? new u.default.Vector(this._fromRadians, this._toRadians, a, c, p) : new u.default.Vector(a, c, p);\n        } }, { key: \"dist\", value: function(n) {\n          return n.copy().sub(this).mag();\n        } }, { key: \"normalize\", value: function() {\n          var n = this.mag();\n          return n !== 0 && this.mult(1 / n), this;\n        } }, { key: \"limit\", value: function(n) {\n          var a = this.magSq();\n          return n * n < a && this.div(Math.sqrt(a)).mult(n), this;\n        } }, { key: \"setMag\", value: function(n) {\n          return this.normalize().mult(n);\n        } }, { key: \"heading\", value: function() {\n          var n = Math.atan2(this.y, this.x);\n          return this.isPInst ? this._fromRadians(n) : n;\n        } }, { key: \"setHeading\", value: function(n) {\n          this.isPInst && (n = this._toRadians(n));\n          var a = this.mag();\n          return this.x = a * Math.cos(n), this.y = a * Math.sin(n), this;\n        } }, { key: \"rotate\", value: function(a) {\n          var a = this.heading() + a, c = (this.isPInst && (a = this._toRadians(a)), this.mag());\n          return this.x = Math.cos(a) * c, this.y = Math.sin(a) * c, this;\n        } }, { key: \"angleBetween\", value: function(n) {\n          var a;\n          return this.magSq() * n.magSq() == 0 ? NaN : (a = this.cross(n), n = Math.atan2(a.mag(), this.dot(n)) * Math.sign(a.z || 1), this.isPInst ? this._fromRadians(n) : n);\n        } }, { key: \"lerp\", value: function(n, a, c, p) {\n          return n instanceof u.default.Vector ? this.lerp(n.x, n.y, n.z, a) : (this.x += (n - this.x) * p || 0, this.y += (a - this.y) * p || 0, this.z += (c - this.z) * p || 0, this);\n        } }, { key: \"slerp\", value: function(n, a) {\n          if (a !== 0) {\n            if (a === 1)\n              return this.set(n);\n            var c = this.mag(), p = n.mag();\n            if (c * p == 0)\n              this.mult(1 - a).add(n.x * a, n.y * a, n.z * a);\n            else {\n              var j = this.cross(n), T = j.mag(), _ = Math.atan2(T, this.dot(n));\n              if (0 < T)\n                j.x /= T, j.y /= T, j.z /= T;\n              else {\n                if (_ < 0.5 * Math.PI)\n                  return this.mult(1 - a).add(n.x * a, n.y * a, n.z * a), this;\n                this.z === 0 && n.z === 0 ? j.set(0, 0, 1) : this.x !== 0 ? j.set(this.y, -this.x, 0).normalize() : j.set(1, 0, 0);\n              }\n              T = j.cross(this), n = 1 - a + a * p / c, j = n * Math.cos(a * _), p = n * Math.sin(a * _), this.x = this.x * j + T.x * p, this.y = this.y * j + T.y * p, this.z = this.z * j + T.z * p;\n            }\n          }\n          return this;\n        } }, { key: \"reflect\", value: function(n) {\n          return n.normalize(), this.sub(n.mult(2 * this.dot(n)));\n        } }, { key: \"array\", value: function() {\n          return [this.x || 0, this.y || 0, this.z || 0];\n        } }, { key: \"equals\", value: function(T, a, c) {\n          var p, j, T = T instanceof u.default.Vector ? (p = T.x || 0, j = T.y || 0, T.z || 0) : Array.isArray(T) ? (p = T[0] || 0, j = T[1] || 0, T[2] || 0) : (p = T || 0, j = a || 0, c || 0);\n          return this.x === p && this.y === j && this.z === T;\n        } }]) && f(o.prototype, i), l && f(o, l), s;\n      }();\n      var r = u.default.Vector;\n      C.default = r;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.every\": 154, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.some\": 169, \"core-js/modules/es.math.sign\": 177, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.number.is-finite\": 179, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.sub\": 205, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 314: [function(g, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (g = g(\"../core/main\")) && g.__esModule ? g : { default: g }, y = \"_lcg_random_state\", u = 4294967296, h = 0, g = (m.default.prototype._lcg = function(f) {\n        return this[f] = (1664525 * this[f] + 1013904223) % u, this[f] / u;\n      }, m.default.prototype._lcgSetSeed = function(f, r) {\n        this[f] = (r ?? Math.random() * u) >>> 0;\n      }, m.default.prototype.randomSeed = function(f) {\n        this._lcgSetSeed(y, f), this._gaussian_previous = !1;\n      }, m.default.prototype.random = function(f, r) {\n        var s, o;\n        return m.default._validateParameters(\"random\", arguments), s = this[y] != null ? this._lcg(y) : Math.random(), f === void 0 ? s : r === void 0 ? Array.isArray(f) ? f[Math.floor(s * f.length)] : s * f : (r < f && (o = f, f = r, r = o), s * (r - f) + f);\n      }, m.default.prototype.randomGaussian = function(f) {\n        var r, s, o, i, l = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (this._gaussian_previous)\n          r = h, this._gaussian_previous = !1;\n        else {\n          for (; 1 <= (i = (s = this.random(2) - 1) * s + (o = this.random(2) - 1) * o); )\n            ;\n          r = s * (i = Math.sqrt(-2 * Math.log(i) / i)), h = o * i, this._gaussian_previous = !0;\n        }\n        return r * l + (f || 0);\n      }, m.default);\n      C.default = g;\n    }, { \"../core/main\": 280 }], 315: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, h = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\"));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      u.default.prototype._angleMode = h.RADIANS, u.default.prototype.acos = function(r) {\n        return this._fromRadians(Math.acos(r));\n      }, u.default.prototype.asin = function(r) {\n        return this._fromRadians(Math.asin(r));\n      }, u.default.prototype.atan = function(r) {\n        return this._fromRadians(Math.atan(r));\n      }, u.default.prototype.atan2 = function(r, s) {\n        return this._fromRadians(Math.atan2(r, s));\n      }, u.default.prototype.cos = function(r) {\n        return Math.cos(this._toRadians(r));\n      }, u.default.prototype.sin = function(r) {\n        return Math.sin(this._toRadians(r));\n      }, u.default.prototype.tan = function(r) {\n        return Math.tan(this._toRadians(r));\n      }, u.default.prototype.degrees = function(r) {\n        return r * h.RAD_TO_DEG;\n      }, u.default.prototype.radians = function(r) {\n        return r * h.DEG_TO_RAD;\n      }, u.default.prototype.angleMode = function(r) {\n        if (u.default._validateParameters(\"angleMode\", arguments), r === void 0)\n          return this._angleMode;\n        r !== h.DEGREES && r !== h.RADIANS || r !== this._angleMode && (r === h.RADIANS ? (this._setProperty(\"pRotationX\", this.pRotationX * h.DEG_TO_RAD), this._setProperty(\"pRotationY\", this.pRotationY * h.DEG_TO_RAD), this._setProperty(\"pRotationZ\", this.pRotationZ * h.DEG_TO_RAD)) : (this._setProperty(\"pRotationX\", this.pRotationX * h.RAD_TO_DEG), this._setProperty(\"pRotationY\", this.pRotationY * h.RAD_TO_DEG), this._setProperty(\"pRotationZ\", this.pRotationZ * h.RAD_TO_DEG)), this._angleMode = r);\n      }, u.default.prototype._toRadians = function(r) {\n        return this._angleMode === h.DEGREES ? r * h.DEG_TO_RAD : r;\n      }, u.default.prototype._toDegrees = function(r) {\n        return this._angleMode === h.RADIANS ? r * h.RAD_TO_DEG : r;\n      }, u.default.prototype._fromRadians = function(r) {\n        return this._angleMode === h.DEGREES ? r * h.RAD_TO_DEG : r;\n      }, u.default.prototype._fromDegrees = function(r) {\n        return this._angleMode === h.RADIANS ? r * h.DEG_TO_RAD : r;\n      };\n      var f = u.default;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 316: [function(t, H, C) {\n      t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      m.default.prototype.textAlign = function(y, u) {\n        var h;\n        return m.default._validateParameters(\"textAlign\", arguments), (h = this._renderer).textAlign.apply(h, arguments);\n      }, m.default.prototype.textLeading = function(y) {\n        var u;\n        return m.default._validateParameters(\"textLeading\", arguments), (u = this._renderer).textLeading.apply(u, arguments);\n      }, m.default.prototype.textSize = function(y) {\n        var u;\n        return m.default._validateParameters(\"textSize\", arguments), (u = this._renderer).textSize.apply(u, arguments);\n      }, m.default.prototype.textStyle = function(y) {\n        var u;\n        return m.default._validateParameters(\"textStyle\", arguments), (u = this._renderer).textStyle.apply(u, arguments);\n      }, m.default.prototype.textWidth = function() {\n        for (var y = arguments.length, u = new Array(y), h = 0; h < y; h++)\n          u[h] = arguments[h];\n        if (u[0] += \"\", m.default._validateParameters(\"textWidth\", u), u[0].length === 0)\n          return 0;\n        for (var g = u[0].replace(/\\t/g, \"  \").split(/\\r?\\n|\\r|\\n/g), f = [], r = 0; r < g.length; r++)\n          f.push(this._renderer.textWidth(g[r]));\n        return Math.max.apply(Math, f);\n      }, m.default.prototype.textAscent = function() {\n        for (var y = arguments.length, u = new Array(y), h = 0; h < y; h++)\n          u[h] = arguments[h];\n        return m.default._validateParameters(\"textAscent\", u), this._renderer.textAscent();\n      }, m.default.prototype.textDescent = function() {\n        for (var y = arguments.length, u = new Array(y), h = 0; h < y; h++)\n          u[h] = arguments[h];\n        return m.default._validateParameters(\"textDescent\", u), this._renderer.textDescent();\n      }, m.default.prototype._updateTextMetrics = function() {\n        return this._renderer._updateTextMetrics();\n      }, m.default.prototype.textWrap = function(y) {\n        return m.default._validateParameters(\"textWrap\", [y]), this._renderer.textWrap(y);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203 }], 317: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      function y(o) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.last-index-of\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.split\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (s = t(\"../core/main\")) && s.__esModule ? s : { default: s }, h = r(t(\"../core/constants\")), g = r(t(\"opentype.js\"));\n      function f() {\n        var o;\n        return typeof WeakMap != \"function\" ? null : (o = /* @__PURE__ */ new WeakMap(), f = function() {\n          return o;\n        }, o);\n      }\n      function r(o) {\n        if (o && o.__esModule)\n          return o;\n        if (o === null || y(o) !== \"object\" && typeof o != \"function\")\n          return { default: o };\n        var i = f();\n        if (i && i.has(o))\n          return i.get(o);\n        var l, n, a = {}, c = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (l in o)\n          Object.prototype.hasOwnProperty.call(o, l) && ((n = c ? Object.getOwnPropertyDescriptor(o, l) : null) && (n.get || n.set) ? Object.defineProperty(a, l, n) : a[l] = o[l]);\n        return a.default = o, i && i.set(o, a), a;\n      }\n      t(\"../core/friendly_errors/validate_params\"), t(\"../core/friendly_errors/file_errors\"), t(\"../core/friendly_errors/fes_core\"), u.default.prototype.loadFont = function(o, i, l) {\n        u.default._validateParameters(\"loadFont\", arguments);\n        var n = new u.default.Font(this), a = this;\n        return g.load(o, function(j, T) {\n          if (j)\n            return u.default._friendlyFileLoadError(4, o), l !== void 0 ? l(j) : void console.error(j, o);\n          n.font = T, i !== void 0 && i(n), a._decrementPreload();\n          var j = o.split(\"\\\\\").pop().split(\"/\").pop(), T = j.lastIndexOf(\".\"), _ = T < 1 ? null : j.slice(T + 1);\n          [\"ttf\", \"otf\", \"woff\", \"woff2\"].includes(_) && (_ = j.slice(0, T !== -1 ? T : 0), (j = document.createElement(\"style\")).appendChild(document.createTextNode(`\n@font-face {\nfont-family: `.concat(_, `;\nsrc: url(`).concat(o, `);\n}\n`))), document.head.appendChild(j));\n        }), n;\n      }, u.default.prototype.text = function(o, i, l, n, a) {\n        var c;\n        return u.default._validateParameters(\"text\", arguments), this._renderer._doFill || this._renderer._doStroke ? (c = this._renderer).text.apply(c, arguments) : this;\n      }, u.default.prototype.textFont = function(o, i) {\n        if (u.default._validateParameters(\"textFont\", arguments), arguments.length) {\n          if (o)\n            return this._renderer._setProperty(\"_textFont\", o), i && (this._renderer._setProperty(\"_textSize\", i), this._renderer._leadingSet || this._renderer._setProperty(\"_textLeading\", i * h._DEFAULT_LEADMULT)), this._renderer._applyTextProperties();\n          throw new Error(\"null font passed to textFont\");\n        }\n        return this._renderer._textFont;\n      };\n      var s = u.default;\n      C.default = s;\n    }, { \"../core/constants\": 269, \"../core/friendly_errors/fes_core\": 271, \"../core/friendly_errors/file_errors\": 272, \"../core/friendly_errors/validate_params\": 275, \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.last-index-of\": 166, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243, \"opentype.js\": 254 }], 318: [function(t, H, C) {\n      function m(S) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(E) {\n          return typeof E;\n        } : function(E) {\n          return E && typeof Symbol == \"function\" && E.constructor === Symbol && E !== Symbol.prototype ? \"symbol\" : typeof E;\n        })(S);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (y = t(\"../core/main\")) && y.__esModule ? y : { default: y }, u = function(S) {\n        if (S && S.__esModule)\n          return S;\n        if (S === null || g(S) !== \"object\" && typeof S != \"function\")\n          return { default: S };\n        var E = h();\n        if (E && E.has(S))\n          return E.get(S);\n        var A, x = {}, P = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (A in S) {\n          var M;\n          Object.prototype.hasOwnProperty.call(S, A) && ((M = P ? Object.getOwnPropertyDescriptor(S, A) : null) && (M.get || M.set) ? Object.defineProperty(x, A, M) : x[A] = S[A]);\n        }\n        return x.default = S, E && E.set(S, x), x;\n      }(t(\"../core/constants\"));\n      function h() {\n        var S;\n        return typeof WeakMap != \"function\" ? null : (S = /* @__PURE__ */ new WeakMap(), h = function() {\n          return S;\n        }, S);\n      }\n      function g(S) {\n        return (g = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(E) {\n          return m(E);\n        } : function(E) {\n          return E && typeof Symbol == \"function\" && E.constructor === Symbol && E !== Symbol.prototype ? \"symbol\" : m(E);\n        })(S);\n      }\n      function f(S, E) {\n        for (var A = 0; A < E.length; A++) {\n          var x = E[A];\n          x.enumerable = x.enumerable || !1, x.configurable = !0, \"value\" in x && (x.writable = !0), Object.defineProperty(S, x.key, x);\n        }\n      }\n      function r(S, E) {\n        var A = S.length;\n        return S[E < 0 ? E % A + A : E % A];\n      }\n      function s(S, E, A, x) {\n        var P, M, R;\n        return x ? (s.tmpPoint1 === void 0 && (s.tmpPoint1 = [], s.tmpPoint2 = []), M = s.tmpPoint1, R = s.tmpPoint2, M.x = E.x - S.x, M.y = E.y - S.y, R.x = A.x - E.x, R.y = A.y - E.y, P = M.x * R.x + M.y * R.y, M = Math.sqrt(M.x * M.x + M.y * M.y), R = Math.sqrt(R.x * R.x + R.y * R.y), Math.acos(P / (M * R)) < x) : (E[0] - S[0]) * (A[1] - S[1]) - (A[0] - S[0]) * (E[1] - S[1]) == 0;\n      }\n      function o(O, B, D, Y, J, M, R, L, F) {\n        var V = 1 - F, U = Math.pow(V, 3), W = Math.pow(V, 2), b = F * F, X = b * F, G = U * O + 3 * W * F * D + 3 * V * F * F * J + X * R, U = U * B + 3 * W * F * Y + 3 * V * F * F * M + X * L, W = O + 2 * F * (D - O) + b * (J - 2 * D + O), X = B + 2 * F * (Y - B) + b * (M - 2 * Y + B), ne = D + 2 * F * (J - D) + b * (R - 2 * J + D), b = Y + 2 * F * (M - Y) + b * (L - 2 * M + Y), O = V * O + F * D, D = V * B + F * Y, B = V * J + F * R, Y = V * M + F * L, J = 90 - 180 * Math.atan2(W - ne, X - b) / Math.PI;\n        return (ne < W || X < b) && (J += 180), { x: G, y: U, m: { x: W, y: X }, n: { x: ne, y: b }, start: { x: O, y: D }, end: { x: B, y: Y }, alpha: J };\n      }\n      function i(S, E, A, x, P, M, R, L, F) {\n        return F == null ? T(S, E, A, x, P, M, R, L) : o(S, E, A, x, P, M, R, L, function(V, G, U, W, X, ne, b, O, D) {\n          if (!(D < 0 || T(V, G, U, W, X, ne, b, O) < D)) {\n            var B, Y = 0.5, J = 1 - Y;\n            for (B = T(V, G, U, W, X, ne, b, O, J); 0.01 < Math.abs(B - D); )\n              B = T(V, G, U, W, X, ne, b, O, J += (B < D ? 1 : -1) * (Y /= 2));\n            return J;\n          }\n        }(S, E, A, x, P, M, R, L, F));\n      }\n      function l(S, E, A) {\n        for (var x, P, M, R, L, F = 0, V = 0, G = (S = function(U, W) {\n          function X(fe, ge, xe) {\n            var De, Me;\n            if (!fe)\n              return [\"C\", ge.x, ge.y, ge.x, ge.y, ge.x, ge.y];\n            switch (fe[0] in { T: 1, Q: 1 } || (ge.qx = ge.qy = null), fe[0]) {\n              case \"M\":\n                ge.X = fe[1], ge.Y = fe[2];\n                break;\n              case \"A\":\n                fe = [\"C\"].concat(a.apply(0, [ge.x, ge.y].concat(fe.slice(1))));\n                break;\n              case \"S\":\n                Me = xe === \"C\" || xe === \"S\" ? (De = 2 * ge.x - ge.bx, 2 * ge.y - ge.by) : (De = ge.x, ge.y), fe = [\"C\", De, Me].concat(fe.slice(1));\n                break;\n              case \"T\":\n                xe === \"Q\" || xe === \"T\" ? (ge.qx = 2 * ge.x - ge.qx, ge.qy = 2 * ge.y - ge.qy) : (ge.qx = ge.x, ge.qy = ge.y), fe = [\"C\"].concat(j(ge.x, ge.y, ge.qx, ge.qy, fe[1], fe[2]));\n                break;\n              case \"Q\":\n                ge.qx = fe[1], ge.qy = fe[2], fe = [\"C\"].concat(j(ge.x, ge.y, fe[1], fe[2], fe[3], fe[4]));\n                break;\n              case \"L\":\n                fe = [\"C\"].concat(p(ge.x, ge.y, fe[1], fe[2]));\n                break;\n              case \"H\":\n                fe = [\"C\"].concat(p(ge.x, ge.y, fe[1], ge.y));\n                break;\n              case \"V\":\n                fe = [\"C\"].concat(p(ge.x, ge.y, ge.x, fe[1]));\n                break;\n              case \"Z\":\n                fe = [\"C\"].concat(p(ge.x, ge.y, ge.X, ge.Y));\n            }\n            return fe;\n          }\n          function ne(fe, ge) {\n            if (7 < fe[ge].length) {\n              fe[ge].shift();\n              for (var xe = fe[ge]; xe.length; )\n                te[ge] = \"A\", B && (ce[ge] = \"A\"), fe.splice(ge++, 0, [\"C\"].concat(xe.splice(0, 6)));\n              fe.splice(ge, 1), O = Math.max(D.length, B && B.length || 0);\n            }\n          }\n          function b(fe, ge, xe, De, Me) {\n            fe && ge && fe[Me][0] === \"M\" && ge[Me][0] !== \"M\" && (ge.splice(Me, 0, [\"M\", De.x, De.y]), xe.bx = 0, xe.by = 0, xe.x = fe[Me][1], xe.y = fe[Me][2], O = Math.max(D.length, B && B.length || 0));\n          }\n          var O, D = n(U), B = W && n(W), Y = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, J = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, te = [], ce = [], re = \"\", ue = \"\";\n          O = Math.max(D.length, B && B.length || 0);\n          for (var le = 0; le < O; le++) {\n            (re = D[le] ? D[le][0] : re) !== \"C\" && (te[le] = re, le && (ue = te[le - 1])), D[le] = X(D[le], Y, ue), te[le] !== \"A\" && re === \"C\" && (te[le] = \"C\"), ne(D, le), B && ((re = B[le] ? B[le][0] : re) !== \"C\" && (ce[le] = re, le && (ue = ce[le - 1])), B[le] = X(B[le], J, ue), ce[le] !== \"A\" && re === \"C\" && (ce[le] = \"C\"), ne(B, le)), b(D, B, Y, J, le), b(B, D, J, Y, le);\n            var K = D[le], ae = B && B[le], he = K.length, _e = B && ae.length;\n            Y.x = K[he - 2], Y.y = K[he - 1], Y.bx = parseFloat(K[he - 4]) || Y.x, Y.by = parseFloat(K[he - 3]) || Y.y, J.bx = B && (parseFloat(ae[_e - 4]) || J.x), J.by = B && (parseFloat(ae[_e - 3]) || J.y), J.x = B && ae[_e - 2], J.y = B && ae[_e - 1];\n          }\n          return B ? [D, B] : D;\n        }(S)).length; V < G; V++) {\n          if ((M = S[V])[0] === \"M\")\n            x = +M[1], P = +M[2];\n          else {\n            if (E < F + (R = i(x, P, M[1], M[2], M[3], M[4], M[5], M[6])) && !A)\n              return { x: (L = i(x, P, M[1], M[2], M[3], M[4], M[5], M[6], E - F)).x, y: L.y, alpha: L.alpha };\n            F += R, x = +M[5], P = +M[6];\n          }\n          M.shift();\n        }\n        return L = (L = A ? F : o(x, P, M[0], M[1], M[2], M[3], M[4], M[5], 1)).alpha ? { x: L.x, y: L.y, alpha: L.alpha } : L;\n      }\n      function n(S) {\n        var E = [], A = 0, x = 0, P = 0, M = 0, R = 0;\n        if (S) {\n          S[0][0] === \"M\" && (P = A = +S[0][1], M = x = +S[0][2], R++, E[0] = [\"M\", A, x]);\n          for (var L, F, V = S.length === 3 && S[0][0] === \"M\" && S[1][0].toUpperCase() === \"R\" && S[2][0].toUpperCase() === \"Z\", G = R, U = S.length; G < U; G++) {\n            if (E.push(L = []), (F = S[G])[0] !== F[0].toUpperCase())\n              switch (L[0] = F[0].toUpperCase(), L[0]) {\n                case \"A\":\n                  L[1] = F[1], L[2] = F[2], L[3] = F[3], L[4] = F[4], L[5] = F[5], L[6] = +(F[6] + A), L[7] = +(F[7] + x);\n                  break;\n                case \"V\":\n                  L[1] = +F[1] + x;\n                  break;\n                case \"H\":\n                  L[1] = +F[1] + A;\n                  break;\n                case \"R\":\n                  for (var W, X = 2, ne = (W = [A, x].concat(F.slice(1))).length; X < ne; X++)\n                    W[X] = +W[X] + A, W[++X] = +W[X] + x;\n                  E.pop(), E = E.concat(c(W, V));\n                  break;\n                case \"M\":\n                  P = +F[1] + A, M = +F[2] + x;\n                  break;\n                default:\n                  for (var b = 1, O = F.length; b < O; b++)\n                    L[b] = +F[b] + (b % 2 ? A : x);\n              }\n            else if (F[0] === \"R\")\n              W = [A, x].concat(F.slice(1)), E.pop(), E = E.concat(c(W, V)), L = [\"R\"].concat(F.slice(-2));\n            else\n              for (var D = 0, B = F.length; D < B; D++)\n                L[D] = F[D];\n            switch (L[0]) {\n              case \"Z\":\n                A = P, x = M;\n                break;\n              case \"H\":\n                A = L[1];\n                break;\n              case \"V\":\n                x = L[1];\n                break;\n              case \"M\":\n                P = L[L.length - 2], M = L[L.length - 1];\n                break;\n              default:\n                A = L[L.length - 2], x = L[L.length - 1];\n            }\n          }\n        }\n        return E;\n      }\n      function a(S, E, A, x, B, te, Y, L, F, V) {\n        function G(_e, fe, ge) {\n          return { x: _e * Math.cos(ge) - fe * Math.sin(ge), y: _e * Math.sin(ge) + fe * Math.cos(ge) };\n        }\n        var U, O = Math.PI, D = 120 * O / 180, W = O / 180 * (+B || 0), X = [], ne = (V ? (le = V[0], U = V[1], re = V[2], ue = V[3]) : (S = (J = G(S, E, -W)).x, E = J.y, 1 < (ne = (b = (S - (L = (J = G(L, F, -W)).x)) / 2) * b / (A * A) + (J = (E - (F = J.y)) / 2) * J / (x * x)) && (A *= ne = Math.sqrt(ne), x *= ne), ne = A * A, ce = x * x, re = (te = (te === Y ? -1 : 1) * Math.sqrt(Math.abs((ne * ce - ne * J * J - ce * b * b) / (ne * J * J + ce * b * b)))) * A * J / x + (S + L) / 2, ue = te * -x * b / A + (E + F) / 2, le = Math.asin(((E - ue) / x).toFixed(9)), U = Math.asin(((F - ue) / x).toFixed(9)), (le = S < re ? O - le : le) < 0 && (le = 2 * O + le), (U = L < re ? O - U : U) < 0 && (U = 2 * O + U), Y && U < le && (le -= 2 * O), !Y && le < U && (U -= 2 * O)), U - le), b = (Math.abs(ne) > D && (ce = U, J = L, te = F, U = le + D * (Y && le < U ? 1 : -1), X = a(L = re + A * Math.cos(U), F = ue + x * Math.sin(U), A, x, B, 0, Y, J, te, [U, ce, re, ue])), ne = U - le, Math.cos(le)), O = Math.sin(le), D = Math.cos(U), B = Math.sin(U), Y = Math.tan(ne / 4), J = 4 / 3 * A * Y, te = 4 / 3 * x * Y, ce = [S, E], re = [S + J * O, E - te * b], ue = [L + J * B, F - te * D], le = [L, F];\n        if (re[0] = 2 * ce[0] - re[0], re[1] = 2 * ce[1] - re[1], V)\n          return [re, ue, le].concat(X);\n        for (var K = [], ae = 0, he = (X = [re, ue, le].concat(X).join().split(\",\")).length; ae < he; ae++)\n          K[ae] = ae % 2 ? G(X[ae - 1], X[ae], W).y : G(X[ae], X[ae + 1], W).x;\n        return K;\n      }\n      function c(S, E) {\n        for (var A = [], x = 0, P = S.length; x < P - 2 * !E; x += 2) {\n          var M = [{ x: +S[x - 2], y: +S[x - 1] }, { x: +S[x], y: +S[x + 1] }, { x: +S[x + 2], y: +S[x + 3] }, { x: +S[x + 4], y: +S[x + 5] }];\n          E ? x ? P - 4 === x ? M[3] = { x: +S[0], y: +S[1] } : P - 2 === x && (M[2] = { x: +S[0], y: +S[1] }, M[3] = { x: +S[2], y: +S[3] }) : M[0] = { x: +S[P - 2], y: +S[P - 1] } : P - 4 === x ? M[3] = M[2] : x || (M[0] = { x: +S[x], y: +S[x + 1] }), A.push([\"C\", (-M[0].x + 6 * M[1].x + M[2].x) / 6, (-M[0].y + 6 * M[1].y + M[2].y) / 6, (M[1].x + 6 * M[2].x - M[3].x) / 6, (M[1].y + 6 * M[2].y - M[3].y) / 6, M[2].x, M[2].y]);\n        }\n        return A;\n      }\n      function p(S, E, A, x) {\n        return [S, E, A, x, A, x];\n      }\n      function j(S, E, A, x, P, M) {\n        return [1 / 3 * S + 2 / 3 * A, 1 / 3 * E + 2 / 3 * x, 1 / 3 * P + 2 / 3 * A, 1 / 3 * M + 2 / 3 * x, P, M];\n      }\n      function T(S, E, A, x, P, M, R, L, F) {\n        for (var V = (F = 1 < (F = F ?? 1) ? 1 : F < 0 ? 0 : F) / 2, G = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], U = 0, W = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], X = 0; X < 12; X++) {\n          var b = V * G[X] + V, ne = _(b, S, A, P, R), b = _(b, E, x, M, L);\n          U += W[X] * Math.sqrt(ne * ne + b * b);\n        }\n        return V * U;\n      }\n      function _(S, E, A, x, P) {\n        return S * (S * (-3 * E + 9 * A - 9 * x + 3 * P) + 6 * E - 12 * A + 6 * x) - 3 * E + 3 * A;\n      }\n      y.default.Font = function() {\n        function S(x) {\n          if (!(this instanceof S))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.parent = x, this.cache = {}, this.font = void 0;\n        }\n        var E, A;\n        return E = S, (A = [{ key: \"textBounds\", value: function(x) {\n          var P = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0, M = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 0, V = 3 < arguments.length ? arguments[3] : void 0, R = 4 < arguments.length ? arguments[4] : void 0, L = R && R.renderer && R.renderer._pInst || this.parent, F = L._renderer.drawingContext, V = (F.textAlign || u.LEFT, F.textBaseline || u.BASELINE, V || L._renderer._textSize);\n          if (!J) {\n            for (var G = [], U = [], W = [], X = (W[0] = [], []), ne = this._scale(V), b = L._renderer.textLeading(), O = 0, D = (this.font.forEachGlyph(x, P, M, V, R, function(re, ue, le, K) {\n              var ae = re.getMetrics();\n              re.index === 0 ? W[O += 1] = [] : (W[O].push(ue + ae.xMin * ne), W[O].push(ue + ae.xMax * ne), X.push(le + O * b + -ae.yMin * ne), X.push(le + O * b + -ae.yMax * ne));\n            }), 0 < W[O].length && (G[O] = Math.min.apply(null, W[O]), U[O] = Math.max.apply(null, W[O])), 0), B = 0; B <= O; B++) {\n              G[B] = Math.min.apply(null, W[B]), U[B] = Math.max.apply(null, W[B]);\n              var Y = U[B] - G[B];\n              D < Y && (D = Y);\n            }\n            var F = Math.min.apply(null, G), J = { x: F, y: M = Math.min.apply(null, X), h: Math.max.apply(null, X) - M, w: D, advance: F - P }, V = this._handleAlignment(L._renderer, x, J.x, J.y, J.w + J.advance);\n            J.x = V.x, J.y = V.y;\n          }\n          return J;\n        } }, { key: \"textToPoints\", value: function(x, P, M, R, L) {\n          var F = P, V = [], G = x.split(/\\r?\\n|\\r|\\n/g);\n          R = R || this.parent._renderer._textSize;\n          for (var U, W, X, ne = 0; ne < G.length; ne++) {\n            var b = 0;\n            P = F;\n            for (var O = (O = G[ne]).replace(\"\t\", \"  \"), D = this._getGlyphs(O), B = 0; B < D.length; B++) {\n              if (W = O, !((X = D)[U = B].name && X[U].name === \"space\" || W.length === X.length && W[U] === \" \"))\n                for (var Y = function(re) {\n                  for (var ue, le = [], K = 0; K < re.length; K++)\n                    re[K].type === \"M\" && (ue && le.push(ue), ue = []), ue.push(function(ae) {\n                      var he = [ae.type];\n                      return ae.type === \"M\" || ae.type === \"L\" ? he.push(ae.x, ae.y) : ae.type === \"C\" ? he.push(ae.x1, ae.y1, ae.x2, ae.y2, ae.x, ae.y) : ae.type === \"Q\" && he.push(ae.x1, ae.y1, ae.x, ae.y), he;\n                    }(re[K]));\n                  return le.push(ue), le;\n                }(D[B].getPath(P, M, R).commands), J = 0; J < Y.length; J++)\n                  for (var te = function(re, ue) {\n                    for (var ue = function(fe, ge) {\n                      if (g(fe) !== \"object\")\n                        fe = ge;\n                      else\n                        for (var xe in ge)\n                          fe[xe] === void 0 && (fe[xe] = ge[xe]);\n                      return fe;\n                    }(ue, { sampleFactor: 0.1, simplifyThreshold: 0 }), le = l(re, 0, 1), K = le / (le * ue.sampleFactor), ae = [], he = 0; he < le; he += K)\n                      ae.push(l(re, he));\n                    return ue.simplifyThreshold && function(_e) {\n                      for (var fe = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0, ge = 0, xe = _e.length - 1; 3 < _e.length && 0 <= xe; --xe)\n                        s(r(_e, xe - 1), r(_e, xe), r(_e, xe + 1), fe) && (_e.splice(xe % _e.length, 1), ge++);\n                    }(ae, ue.simplifyThreshold), ae;\n                  }(Y[J], L), ce = 0; ce < te.length; ce++)\n                    te[ce].x += b, V.push(te[ce]);\n              b += D[B].advanceWidth * this._scale(R);\n            }\n            M += this.parent._renderer._textLeading;\n          }\n          return V;\n        } }, { key: \"_getGlyphs\", value: function(x) {\n          return this.font.stringToGlyphs(x);\n        } }, { key: \"_getPath\", value: function(x, F, M, R) {\n          var L = (R && R.renderer && R.renderer._pInst || this.parent)._renderer, F = this._handleAlignment(L, x, F, M);\n          return this.font.getPath(x, F.x, F.y, L._textSize, R);\n        } }, { key: \"_getPathData\", value: function(x, P, M, R) {\n          var L = 3;\n          return typeof x == \"string\" && 2 < arguments.length ? x = this._getPath(x, P, M, R) : g(P) === \"object\" && (R = P), R && typeof R.decimals == \"number\" && (L = R.decimals), x.toPathData(L);\n        } }, { key: \"_getSVG\", value: function(x, P, M, R) {\n          var L = 3;\n          return typeof x == \"string\" && 2 < arguments.length ? x = this._getPath(x, P, M, R) : g(P) === \"object\" && (R = P), R && (typeof R.decimals == \"number\" && (L = R.decimals), typeof R.strokeWidth == \"number\" && (x.strokeWidth = R.strokeWidth), R.fill !== void 0 && (x.fill = R.fill), R.stroke !== void 0 && (x.stroke = R.stroke)), x.toSVG(L);\n        } }, { key: \"_renderPath\", value: function(V, U, W, R) {\n          var L = R && R.renderer || this.parent._renderer, F = L.drawingContext, V = (g(V) === \"object\" && V.commands ? V : this._getPath(V, U, W, R)).commands, G = (F.beginPath(), !0), U = !1, W = void 0;\n          try {\n            for (var X, ne = V[Symbol.iterator](); !(G = (X = ne.next()).done); G = !0) {\n              var b = X.value;\n              b.type === \"M\" ? F.moveTo(b.x, b.y) : b.type === \"L\" ? F.lineTo(b.x, b.y) : b.type === \"C\" ? F.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y) : b.type === \"Q\" ? F.quadraticCurveTo(b.x1, b.y1, b.x, b.y) : b.type === \"Z\" && F.closePath();\n            }\n          } catch (O) {\n            U = !0, W = O;\n          } finally {\n            try {\n              G || ne.return == null || ne.return();\n            } finally {\n              if (U)\n                throw W;\n            }\n          }\n          return L._doStroke && L._strokeSet && !L._clipping && F.stroke(), L._doFill && !L._clipping && (L._fillSet || L._setFill(u._DEFAULT_TEXT_FILL), F.fill()), this;\n        } }, { key: \"_textWidth\", value: function(x, P) {\n          return this.font.getAdvanceWidth(x, P);\n        } }, { key: \"_textAscent\", value: function(x) {\n          return this.font.ascender * this._scale(x);\n        } }, { key: \"_textDescent\", value: function(x) {\n          return -this.font.descender * this._scale(x);\n        } }, { key: \"_scale\", value: function(x) {\n          return 1 / this.font.unitsPerEm * (x || this.parent._renderer._textSize);\n        } }, { key: \"_handleAlignment\", value: function(x, P, M, R, L) {\n          var F = x._textSize;\n          switch (L === void 0 && (L = this._textWidth(P, F)), x._textAlign) {\n            case u.CENTER:\n              M -= L / 2;\n              break;\n            case u.RIGHT:\n              M -= L;\n          }\n          switch (x._textBaseline) {\n            case u.TOP:\n              R += this._textAscent(F);\n              break;\n            case u.CENTER:\n              R += this._textAscent(F) / 2;\n              break;\n            case u.BOTTOM:\n              R -= this._textDescent(F);\n          }\n          return { x: M, y: R };\n        } }]) && f(E.prototype, A), S;\n      }(), t = y.default, C.default = t;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.number.to-fixed\": 180, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 319: [function(t, H, C) {\n      t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.array-buffer.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.array-buffer.constructor\"), t(\"core-js/modules/es.object.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.prototype.append = function(m, y) {\n        return m.push(y), m;\n      }, t.default.prototype.arrayCopy = function(m, y, u, h, g) {\n        var f, r;\n        m = g !== void 0 ? (r = Math.min(g, m.length), f = h, m.slice(y, r + y)) : (r = u !== void 0 ? (r = u, Math.min(r, m.length)) : m.length, u = y, m.slice(f = 0, r)), Array.prototype.splice.apply(u, [f, r].concat(m));\n      }, t.default.prototype.concat = function(m, y) {\n        return m.concat(y);\n      }, t.default.prototype.reverse = function(m) {\n        return m.reverse();\n      }, t.default.prototype.shorten = function(m) {\n        return m.pop(), m;\n      }, t.default.prototype.shuffle = function(m, y) {\n        for (var u, h, g = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(m), f = (m = y || g ? m : m.slice()).length; 1 < f; )\n          u = this.random(0, 1) * f | 0, h = m[--f], m[f] = m[u], m[u] = h;\n        return m;\n      }, t.default.prototype.sort = function(m, h) {\n        var u = h ? m.slice(0, Math.min(h, m.length)) : m, h = h ? m.slice(Math.min(h, m.length)) : [];\n        return (u = typeof u[0] == \"string\" ? u.sort() : u.sort(function(g, f) {\n          return g - f;\n        })).concat(h);\n      }, t.default.prototype.splice = function(m, y, u) {\n        return Array.prototype.splice.apply(m, [u, 0].concat(y)), m;\n      }, t.default.prototype.subset = function(m, y, u) {\n        return u !== void 0 ? m.slice(y, y + u) : m.slice(y, m.length);\n      }, t = t.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array-buffer.constructor\": 151, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.object.to-string\": 187 }], 320: [function(t, H, C) {\n      t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.repeat\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.repeat\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      m.default.prototype.float = function(y) {\n        return y instanceof Array ? y.map(parseFloat) : parseFloat(y);\n      }, m.default.prototype.int = function(y) {\n        var u = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 10;\n        return y === 1 / 0 || y === \"Infinity\" ? 1 / 0 : y === -1 / 0 || y === \"-Infinity\" ? -1 / 0 : typeof y == \"string\" ? parseInt(y, u) : typeof y == \"number\" ? 0 | y : typeof y == \"boolean\" ? y ? 1 : 0 : y instanceof Array ? y.map(function(h) {\n          return m.default.prototype.int(h, u);\n        }) : void 0;\n      }, m.default.prototype.str = function(y) {\n        return y instanceof Array ? y.map(m.default.prototype.str) : String(y);\n      }, m.default.prototype.boolean = function(y) {\n        return typeof y == \"number\" ? y !== 0 : typeof y == \"string\" ? y.toLowerCase() === \"true\" : typeof y == \"boolean\" ? y : y instanceof Array ? y.map(m.default.prototype.boolean) : void 0;\n      }, m.default.prototype.byte = function(y) {\n        return y = m.default.prototype.int(y, 10), typeof y == \"number\" ? (y + 128) % 256 - 128 : y instanceof Array ? y.map(m.default.prototype.byte) : void 0;\n      }, m.default.prototype.char = function(y) {\n        return typeof y != \"number\" || isNaN(y) ? y instanceof Array ? y.map(m.default.prototype.char) : typeof y == \"string\" ? m.default.prototype.char(parseInt(y, 10)) : void 0 : String.fromCharCode(y);\n      }, m.default.prototype.unchar = function(y) {\n        return typeof y == \"string\" && y.length === 1 ? y.charCodeAt(0) : y instanceof Array ? y.map(m.default.prototype.unchar) : void 0;\n      }, m.default.prototype.hex = function(y, u) {\n        if (u = u ?? 8, y instanceof Array)\n          return y.map(function(g) {\n            return m.default.prototype.hex(g, u);\n          });\n        if (y === 1 / 0 || y === -1 / 0)\n          return (y === 1 / 0 ? \"F\" : \"0\").repeat(u);\n        if (typeof y == \"number\") {\n          y < 0 && (y = 4294967295 + y + 1);\n          for (var h = Number(y).toString(16).toUpperCase(); h.length < u; )\n            h = \"0\".concat(h);\n          return h = h.length >= u ? h.substring(h.length - u, h.length) : h;\n        }\n      }, m.default.prototype.unhex = function(y) {\n        return y instanceof Array ? y.map(m.default.prototype.unhex) : parseInt(\"0x\".concat(y), 16);\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.repeat\": 200 }], 321: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.pad-start\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.constructor\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.pad-start\"), t(\"core-js/modules/es.string.replace\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (r = t(\"../core/main\")) && r.__esModule ? r : { default: r };\n      function y(s, o) {\n        return function(i) {\n          if (Array.isArray(i))\n            return i;\n        }(s) || function(i, l) {\n          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === \"[object Arguments]\") {\n            var n = [], a = !0, c = !1, p = void 0;\n            try {\n              for (var j, T = i[Symbol.iterator](); !(a = (j = T.next()).done) && (n.push(j.value), !l || n.length !== l); a = !0)\n                ;\n            } catch (_) {\n              c = !0, p = _;\n            } finally {\n              try {\n                a || T.return == null || T.return();\n              } finally {\n                if (c)\n                  throw p;\n              }\n            }\n            return n;\n          }\n        }(s, o) || function() {\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }();\n      }\n      function u(s, o, i) {\n        var n = y(s.toString().split(\".\"), 2), l = n[0], n = n[1];\n        return i === void 0 ? (l = l.padStart(o, \"0\"), n ? l + \".\" + n : l) : (l = (s = y(s.toFixed(i).toString().split(\".\"), 2))[0], n = s[1], l = l.padStart(o, \"0\"), n === void 0 ? l : l + \".\" + n);\n      }\n      function h(n, o) {\n        var i = (n = n.toString()).indexOf(\".\"), l = i !== -1 ? n.substring(i) : \"\", n = (n = i !== -1 ? n.substring(0, i) : n).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n        if (o === 0)\n          l = \"\";\n        else if (o !== void 0)\n          if (o > l.length)\n            for (var a = o - (l += i === -1 ? \".\" : \"\").length + 1, c = 0; c < a; c++)\n              l += \"0\";\n          else\n            l = l.substring(0, o + 1);\n        return n + l;\n      }\n      function g(s) {\n        return 0 < parseFloat(s) ? \"+\".concat(s.toString()) : s.toString();\n      }\n      function f(s) {\n        return 0 <= parseFloat(s) ? \" \".concat(s.toString()) : s.toString();\n      }\n      t(\"../core/friendly_errors/validate_params\"), t(\"../core/friendly_errors/file_errors\"), t(\"../core/friendly_errors/fes_core\"), m.default.prototype.join = function(s, o) {\n        return m.default._validateParameters(\"join\", arguments), s.join(o);\n      }, m.default.prototype.match = function(s, o) {\n        return m.default._validateParameters(\"match\", arguments), s.match(o);\n      }, m.default.prototype.matchAll = function(s, o) {\n        m.default._validateParameters(\"matchAll\", arguments);\n        for (var i = new RegExp(o, \"g\"), l = i.exec(s), n = []; l !== null; )\n          n.push(l), l = i.exec(s);\n        return n;\n      }, m.default.prototype.nf = function(s, o, i) {\n        return m.default._validateParameters(\"nf\", arguments), s instanceof Array ? s.map(function(l) {\n          return u(l, o, i);\n        }) : Object.prototype.toString.call(s) === \"[object Arguments]\" ? s.length === 3 ? this.nf(s[0], s[1], s[2]) : s.length === 2 ? this.nf(s[0], s[1]) : this.nf(s[0]) : u(s, o, i);\n      }, m.default.prototype.nfc = function(s, o) {\n        return m.default._validateParameters(\"nfc\", arguments), s instanceof Array ? s.map(function(i) {\n          return h(i, o);\n        }) : h(s, o);\n      }, m.default.prototype.nfp = function() {\n        for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n          o[i] = arguments[i];\n        m.default._validateParameters(\"nfp\", o);\n        var l = m.default.prototype.nf.apply(this, o);\n        return l instanceof Array ? l.map(g) : g(l);\n      }, m.default.prototype.nfs = function() {\n        for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)\n          o[i] = arguments[i];\n        m.default._validateParameters(\"nfs\", o);\n        var l = m.default.prototype.nf.apply(this, o);\n        return l instanceof Array ? l.map(f) : f(l);\n      }, m.default.prototype.split = function(s, o) {\n        return m.default._validateParameters(\"split\", arguments), s.split(o);\n      }, m.default.prototype.splitTokens = function(s, o) {\n        var i, l;\n        return m.default._validateParameters(\"splitTokens\", arguments), l = o !== void 0 ? (l = /\\]/g.exec(o = o), (i = /\\[/g.exec(o)) && l ? (o = o.slice(0, l.index) + o.slice(l.index + 1), i = /\\[/g.exec(o), o = o.slice(0, i.index) + o.slice(i.index + 1), new RegExp(\"[\\\\[\".concat(o, \"\\\\]]\"), \"g\")) : l ? (o = o.slice(0, l.index) + o.slice(l.index + 1), new RegExp(\"[\".concat(o, \"\\\\]]\"), \"g\")) : i ? (o = o.slice(0, i.index) + o.slice(i.index + 1), new RegExp(\"[\".concat(o, \"\\\\[]\"), \"g\")) : new RegExp(\"[\".concat(o, \"]\"), \"g\")) : /\\s/g, s.split(l).filter(function(n) {\n          return n;\n        });\n      }, m.default.prototype.trim = function(s) {\n        return m.default._validateParameters(\"trim\", arguments), s instanceof Array ? s.map(this.trim) : s.trim();\n      };\n      var r = m.default;\n      C.default = r;\n    }, { \"../core/friendly_errors/fes_core\": 271, \"../core/friendly_errors/file_errors\": 272, \"../core/friendly_errors/validate_params\": 275, \"../core/main\": 280, \"core-js/modules/es.array.filter\": 156, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.number.to-fixed\": 180, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.constructor\": 191, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.pad-start\": 199, \"core-js/modules/es.string.replace\": 201, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 322: [function(t, H, C) {\n      Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t }, t.default.prototype.day = function() {\n        return (/* @__PURE__ */ new Date()).getDate();\n      }, t.default.prototype.hour = function() {\n        return (/* @__PURE__ */ new Date()).getHours();\n      }, t.default.prototype.minute = function() {\n        return (/* @__PURE__ */ new Date()).getMinutes();\n      }, t.default.prototype.millis = function() {\n        return this._millisStart === -1 ? 0 : window.performance.now() - this._millisStart;\n      }, t.default.prototype.month = function() {\n        return (/* @__PURE__ */ new Date()).getMonth() + 1;\n      }, t.default.prototype.second = function() {\n        return (/* @__PURE__ */ new Date()).getSeconds();\n      }, t.default.prototype.year = function() {\n        return (/* @__PURE__ */ new Date()).getFullYear();\n      }, t = t.default, C.default = t;\n    }, { \"../core/main\": 280 }], 323: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      function y(s) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.number.to-fixed\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (r = t(\"../core/main\")) && r.__esModule ? r : { default: r }, h = (t(\"./p5.Geometry\"), function(s) {\n        if (s && s.__esModule)\n          return s;\n        if (s === null || y(s) !== \"object\" && typeof s != \"function\")\n          return { default: s };\n        var o = g();\n        if (o && o.has(s))\n          return o.get(s);\n        var i, l = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (i in s) {\n          var a;\n          Object.prototype.hasOwnProperty.call(s, i) && ((a = n ? Object.getOwnPropertyDescriptor(s, i) : null) && (a.get || a.set) ? Object.defineProperty(l, i, a) : l[i] = s[i]);\n        }\n        return l.default = s, o && o.set(s, l), l;\n      }(t(\"../core/constants\")));\n      function g() {\n        var s;\n        return typeof WeakMap != \"function\" ? null : (s = /* @__PURE__ */ new WeakMap(), g = function() {\n          return s;\n        }, s);\n      }\n      u.default.prototype.beginGeometry = function() {\n        return this._renderer.beginGeometry();\n      }, u.default.prototype.endGeometry = function() {\n        return this._renderer.endGeometry();\n      }, u.default.prototype.buildGeometry = function(s) {\n        return this._renderer.buildGeometry(s);\n      }, u.default.prototype.freeGeometry = function(s) {\n        this._renderer._freeBuffers(s.gid);\n      }, u.default.prototype.plane = function() {\n        var s, o = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 50, i = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : o, l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 1, n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : 1, a = (this._assert3d(\"plane\"), u.default._validateParameters(\"plane\", arguments), \"plane|\".concat(l, \"|\").concat(n));\n        return this._renderer.geometryInHash(a) || ((s = new u.default.Geometry(l, n, function() {\n          for (var c, p, j = 0; j <= this.detailY; j++)\n            for (var T = j / this.detailY, _ = 0; _ <= this.detailX; _++)\n              c = _ / this.detailX, p = new u.default.Vector(c - 0.5, T - 0.5, 0), this.vertices.push(p), this.uvs.push(c, T);\n        })).computeFaces().computeNormals(), l <= 1 && n <= 1 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY\"), this._renderer.createBuffers(a, s)), this._renderer.drawBuffersScaled(a, o, i, 1), this;\n      }, u.default.prototype.box = function(s, o, i, l, n) {\n        this._assert3d(\"box\"), u.default._validateParameters(\"box\", arguments), s === void 0 && (s = 50), o === void 0 && (o = s), i === void 0 && (i = o);\n        var a, c = this._renderer.attributes && this._renderer.attributes.perPixelLighting, c = (n === void 0 && (n = c ? 1 : 4), \"box|\".concat(l = l === void 0 ? c ? 1 : 4 : l, \"|\").concat(n));\n        return this._renderer.geometryInHash(c) || ((a = new u.default.Geometry(l, n, function() {\n          var p = this;\n          this.edges = [[0, 1], [1, 3], [3, 2], [6, 7], [8, 9], [9, 11], [14, 15], [16, 17], [17, 19], [18, 19], [20, 21], [22, 23]], [[0, 4, 2, 6], [1, 3, 5, 7], [0, 1, 4, 5], [2, 6, 3, 7], [0, 2, 1, 3], [4, 5, 6, 7]].forEach(function(j, T) {\n            for (var T = 4 * T, _ = 0; _ < 4; _++) {\n              var S = j[_], S = new u.default.Vector((2 * (1 & S) - 1) / 2, ((2 & S) - 1) / 2, ((4 & S) / 2 - 1) / 2);\n              p.vertices.push(S), p.uvs.push(1 & _, (2 & _) / 2);\n            }\n            p.faces.push([T, 1 + T, 2 + T]), p.faces.push([2 + T, 1 + T, 3 + T]);\n          });\n        })).computeNormals(), l <= 4 && n <= 4 ? a._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw stroke on box objects with more than 4 detailX or 4 detailY\"), this._renderer.createBuffers(c, a)), this._renderer.drawBuffersScaled(c, s, o, i), this;\n      }, u.default.prototype.sphere = function() {\n        var s = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 50, o = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 24, i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 16;\n        return this._assert3d(\"sphere\"), u.default._validateParameters(\"sphere\", arguments), this.ellipsoid(s, s, s, o, i), this;\n      };\n      function f(s, o, i, l, n, a, c) {\n        s = s <= 0 ? 1 : s, o = o < 0 ? 0 : o, i = i <= 0 ? s : i, l = l < 3 ? 3 : l;\n        for (var p, j, T = (a = a === void 0 || a) ? -2 : 0, _ = (n = n < 1 ? 1 : n) + ((c = c === void 0 ? o !== 0 : c) ? 2 : 0), S = Math.atan2(s - o, i), E = Math.sin(S), A = Math.cos(S), x = T; x <= _; ++x) {\n          var P = x / n, M = i * P, R = void 0, R = x < 0 ? (P = M = 0, s) : n < x ? (M = i, P = 1, o) : s + (o - s) * P;\n          for (x !== -2 && x !== n + 2 || (R = 0), M -= i / 2, p = 0; p < l; ++p) {\n            var L = p / (l - 1), V = 2 * Math.PI * L, F = Math.sin(V), V = Math.cos(V), G = (this.vertices.push(new u.default.Vector(F * R, M, V * R)), void 0), G = x < 0 ? new u.default.Vector(0, -1, 0) : n < x && o ? new u.default.Vector(0, 1, 0) : new u.default.Vector(F * A, E, V * A);\n            this.vertexNormals.push(G), this.uvs.push(L, P);\n          }\n        }\n        var U = 0;\n        if (a) {\n          for (j = 0; j < l; ++j)\n            this.faces.push([U + j, U + l + (j + 1) % l, U + l + j]);\n          U += 2 * l;\n        }\n        for (x = 0; x < n; ++x) {\n          for (p = 0; p < l; ++p) {\n            var W = (p + 1) % l;\n            this.faces.push([U + p, U + W, U + l + W]), this.faces.push([U + p, U + l + W, U + l + p]);\n          }\n          U += l;\n        }\n        if (c)\n          for (U += l, p = 0; p < l; ++p)\n            this.faces.push([U + p, U + (p + 1) % l, U + l]);\n      }\n      u.default.prototype.cylinder = function() {\n        var s, o = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 50, i = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : o, l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 24, n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : 1, a = !(4 < arguments.length && arguments[4] !== void 0) || arguments[4], c = !(5 < arguments.length && arguments[5] !== void 0) || arguments[5], p = (this._assert3d(\"cylinder\"), u.default._validateParameters(\"cylinder\", arguments), \"cylinder|\".concat(l, \"|\").concat(n, \"|\").concat(a, \"|\").concat(c));\n        return this._renderer.geometryInHash(p) || (s = new u.default.Geometry(l, n), f.call(s, 1, 1, 1, l, n, a, c), l <= 24 && n <= 16 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY\"), this._renderer.createBuffers(p, s)), this._renderer.drawBuffersScaled(p, o, i, o), this;\n      }, u.default.prototype.cone = function() {\n        var s, o = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 50, i = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : o, l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 24, n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : 1, a = !(4 < arguments.length && arguments[4] !== void 0) || arguments[4], c = (this._assert3d(\"cone\"), u.default._validateParameters(\"cone\", arguments), \"cone|\".concat(l, \"|\").concat(n, \"|\").concat(a));\n        return this._renderer.geometryInHash(c) || (s = new u.default.Geometry(l, n), f.call(s, 1, 0, 1, l, n, a, !1), l <= 24 && n <= 16 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY\"), this._renderer.createBuffers(c, s)), this._renderer.drawBuffersScaled(c, o, i, o), this;\n      }, u.default.prototype.ellipsoid = function() {\n        var s, o = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 50, i = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : o, l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : o, n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : 24, a = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 16, c = (this._assert3d(\"ellipsoid\"), u.default._validateParameters(\"ellipsoid\", arguments), \"ellipsoid|\".concat(n, \"|\").concat(a));\n        return this._renderer.geometryInHash(c) || ((s = new u.default.Geometry(n, a, function() {\n          for (var p = 0; p <= this.detailY; p++)\n            for (var j = p / this.detailY, T = Math.PI * j - Math.PI / 2, _ = Math.cos(T), S = Math.sin(T), E = 0; E <= this.detailX; E++) {\n              var A = E / this.detailX, P = 2 * Math.PI * A, x = Math.cos(P), P = Math.sin(P), P = new u.default.Vector(_ * P, S, _ * x);\n              this.vertices.push(P), this.vertexNormals.push(P), this.uvs.push(A, j);\n            }\n        })).computeFaces(), n <= 24 && a <= 24 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY\"), this._renderer.createBuffers(c, s)), this._renderer.drawBuffersScaled(c, o, i, l), this;\n      }, u.default.prototype.torus = function(s, c, i, l) {\n        if (this._assert3d(\"torus\"), u.default._validateParameters(\"torus\", arguments), s === void 0)\n          s = 50;\n        else if (!s)\n          return;\n        if (c === void 0)\n          c = 10;\n        else if (!c)\n          return;\n        i === void 0 && (i = 24), l === void 0 && (l = 16);\n        var n, a = (c / s).toPrecision(4), c = \"torus|\".concat(a, \"|\").concat(i, \"|\").concat(l);\n        return this._renderer.geometryInHash(c) || ((n = new u.default.Geometry(i, l, function() {\n          for (var p = 0; p <= this.detailY; p++)\n            for (var j = p / this.detailY, T = 2 * Math.PI * j, _ = Math.cos(T), S = Math.sin(T), E = 1 + a * _, A = 0; A <= this.detailX; A++) {\n              var x = A / this.detailX, P = 2 * Math.PI * x, R = Math.cos(P), P = Math.sin(P), M = new u.default.Vector(E * R, E * P, a * S), R = new u.default.Vector(_ * R, _ * P, S);\n              this.vertices.push(M), this.vertexNormals.push(R), this.uvs.push(x, j);\n            }\n        })).computeFaces(), i <= 24 && l <= 16 ? n._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log(\"Cannot draw strokes on torus object with more than 24 detailX or 16 detailY\"), this._renderer.createBuffers(c, n)), this._renderer.drawBuffersScaled(c, s, s, s), this;\n      }, u.default.RendererGL.prototype.point = function(s, o) {\n        var i = [];\n        return i.push(new u.default.Vector(s, o, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : 0)), this._drawPoints(i, this.immediateMode.buffers.point), this;\n      }, u.default.RendererGL.prototype.triangle = function(c) {\n        var o = c[0], i = c[1], l = c[2], n = c[3], a = c[4], c = c[5], p = (this.geometryInHash(\"tri\") || ((p = new u.default.Geometry(1, 1, function() {\n          var _ = [];\n          _.push(new u.default.Vector(0, 0, 0)), _.push(new u.default.Vector(1, 0, 0)), _.push(new u.default.Vector(0, 1, 0)), this.edges = [[0, 1], [1, 2], [2, 0]], this.vertices = _, this.faces = [[0, 1, 2]], this.uvs = [0, 0, 1, 0, 1, 1];\n        }))._edgesToVertices(), p.computeNormals(), this.createBuffers(\"tri\", p)), this.uMVMatrix.copy());\n        try {\n          var j = Math.sign(o * n - l * i + l * c - a * n + a * i - o * c), T = new u.default.Matrix([l - o, n - i, 0, 0, a - o, c - i, 0, 0, 0, 0, j, 0, o, i, 0, 1]).mult(this.uMVMatrix);\n          this.uMVMatrix = T, this.drawBuffers(\"tri\");\n        } finally {\n          this.uMVMatrix = p;\n        }\n        return this;\n      }, u.default.RendererGL.prototype.ellipse = function(s) {\n        this.arc(s[0], s[1], s[2], s[3], 0, h.TWO_PI, h.OPEN, s[4]);\n      }, u.default.RendererGL.prototype.arc = function() {\n        var s, o = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], l = arguments.length <= 2 ? void 0 : arguments[2], n = arguments.length <= 3 ? void 0 : arguments[3], a = arguments.length <= 4 ? void 0 : arguments[4], c = arguments.length <= 5 ? void 0 : arguments[5], p = arguments.length <= 6 ? void 0 : arguments[6], j = (arguments.length <= 7 ? void 0 : arguments[7]) || 25, T = (Math.abs(c - a) >= h.TWO_PI ? \"\".concat(_ = \"ellipse\", \"|\") : \"\".concat(_ = \"arc\", \"|\").concat(a, \"|\").concat(c, \"|\").concat(p, \"|\")).concat(j, \"|\"), _ = (this.geometryInHash(T) || ((s = new u.default.Geometry(j, 1, function() {\n          if (a.toFixed(10) !== c.toFixed(10)) {\n            p !== h.PIE && p !== void 0 || (this.vertices.push(new u.default.Vector(0.5, 0.5, 0)), this.uvs.push([0.5, 0.5]));\n            for (var S = 0; S <= j; S++) {\n              var A = (c - a) * (S / j) + a, E = 0.5 + Math.cos(A) / 2, A = 0.5 + Math.sin(A) / 2;\n              this.vertices.push(new u.default.Vector(E, A, 0)), this.uvs.push([E, A]), S < j - 1 && (this.faces.push([0, S + 1, S + 2]), this.edges.push([S + 1, S + 2]));\n            }\n            switch (p) {\n              case h.PIE:\n                this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.edges.push([0, 1]), this.edges.push([this.vertices.length - 2, this.vertices.length - 1]), this.edges.push([0, this.vertices.length - 1]);\n                break;\n              case h.CHORD:\n                this.edges.push([0, 1]), this.edges.push([0, this.vertices.length - 1]);\n                break;\n              case h.OPEN:\n                this.edges.push([0, 1]);\n                break;\n              default:\n                this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.edges.push([this.vertices.length - 2, this.vertices.length - 1]);\n            }\n          }\n        })).computeNormals(), j <= 50 ? s._edgesToVertices(s) : this._doStroke && console.log(\"Cannot apply a stroke to an \".concat(_, \" with more than 50 detail\")), this.createBuffers(T, s)), this.uMVMatrix.copy());\n        try {\n          this.uMVMatrix.translate([o, i, 0]), this.uMVMatrix.scale(l, n, 1), this.drawBuffers(T);\n        } finally {\n          this.uMVMatrix = _;\n        }\n        return this;\n      }, u.default.RendererGL.prototype.rect = function(s) {\n        var o = s[0], i = s[1], l = s[2], n = s[3];\n        if (s[4] === void 0) {\n          var p = this._pInst._glAttributes.perPixelLighting, a = s[4] || (p ? 1 : 24), c = s[5] || (p ? 1 : 16), p = \"rect|\".concat(a, \"|\").concat(c), j = (this.geometryInHash(p) || ((j = new u.default.Geometry(a, c, function() {\n            for (var G = 0; G <= this.detailY; G++)\n              for (var U = G / this.detailY, W = 0; W <= this.detailX; W++) {\n                var X = W / this.detailX, ne = new u.default.Vector(X, U, 0);\n                this.vertices.push(ne), this.uvs.push(X, U);\n              }\n            0 < a && 0 < c && (this.edges = [[0, a], [a, (a + 1) * (c + 1) - 1], [(a + 1) * (c + 1) - 1, (a + 1) * c], [(a + 1) * c, 0]]);\n          })).computeFaces().computeNormals()._edgesToVertices(), this.createBuffers(p, j)), this.uMVMatrix.copy());\n          try {\n            this.uMVMatrix.translate([o, i, 0]), this.uMVMatrix.scale(l, n, 1), this.drawBuffers(p);\n          } finally {\n            this.uMVMatrix = j;\n          }\n        } else {\n          var p = s[4], j = s[5] === void 0 ? p : s[5], T = s[6] === void 0 ? j : s[6], s = s[7] === void 0 ? T : s[7], P = l, _ = n, A = ((P += o) < o && (A = o, o = P, P = A), (_ += i) < i && (A = i, i = _, _ = A), Math.min((P - o) / 2, (_ - i) / 2)), S = (A < p && (p = A), A < j && (j = A), A < T && (T = A), A < s && (s = A), o), E = i, A = P, o = _, x = (this.beginShape(), j !== 0 ? (this.vertex(A - j, E), this.quadraticVertex(A, E, A, E + j)) : this.vertex(A, E), T !== 0 ? (this.vertex(A, o - T), this.quadraticVertex(A, o, A - T, o)) : this.vertex(A, o), s !== 0 ? (this.vertex(S + s, o), this.quadraticVertex(S, o, S, o - s)) : this.vertex(S, o), p !== 0 ? (this.vertex(S, E + p), this.quadraticVertex(S, E, S + p, E)) : this.vertex(S, E), !(this.immediateMode.geometry.uvs.length = 0)), i = !1, P = void 0;\n          try {\n            for (var M, R = this.immediateMode.geometry.vertices[Symbol.iterator](); !(x = (M = R.next()).done); x = !0) {\n              var L = M.value, F = (L.x - S) / l, V = (L.y - E) / n;\n              this.immediateMode.geometry.uvs.push(F, V);\n            }\n          } catch (b) {\n            i = !0, P = b;\n          } finally {\n            try {\n              x || R.return == null || R.return();\n            } finally {\n              if (i)\n                throw P;\n            }\n          }\n          this.endShape(h.CLOSE);\n        }\n        return this;\n      }, u.default.RendererGL.prototype.quad = function(s, o, i, l, n, a, c, p, j, T, _, S) {\n        var E = 12 < arguments.length && arguments[12] !== void 0 ? arguments[12] : 2, A = 13 < arguments.length && arguments[13] !== void 0 ? arguments[13] : 2, x = \"quad|\".concat(s, \"|\").concat(o, \"|\").concat(i, \"|\").concat(l, \"|\").concat(n, \"|\").concat(a, \"|\").concat(c, \"|\").concat(p, \"|\").concat(j, \"|\").concat(T, \"|\").concat(_, \"|\").concat(S, \"|\").concat(E, \"|\").concat(A);\n        if (!this.geometryInHash(x)) {\n          var P = new u.default.Geometry(E, A, function() {\n            for (var W = 1 / (this.detailX - 1), X = 1 / (this.detailY - 1), ne = 0; ne < this.detailY; ne++)\n              for (var b = 0; b < this.detailX; b++) {\n                var O = b * W, D = ne * X;\n                this.vertices.push(new u.default.Vector((1 - O) * ((1 - D) * s + D * T) + O * ((1 - D) * l + D * c), (1 - O) * ((1 - D) * o + D * _) + O * ((1 - D) * n + D * p), (1 - O) * ((1 - D) * i + D * S) + O * ((1 - D) * a + D * j))), this.uvs.push([O, D]);\n              }\n          });\n          P.faces = [];\n          for (var M = 0; M < A - 1; M++)\n            for (var R = 0; R < E - 1; R++) {\n              var L = R + M * E, F = R + 1 + (M + 1) * E, V = R + (M + 1) * E;\n              P.faces.push([L, R + 1 + M * E, F]), P.faces.push([L, F, V]);\n            }\n          P.computeNormals();\n          for (var G = [P.edges.length = 0, 2, 3, 1], U = 0; U < G.length; U++)\n            P.edges.push([G[U], G[(U + 1) % G.length]]);\n          P._edgesToVertices(), this.createBuffers(x, P);\n        }\n        return this.drawBuffers(x), this;\n      }, u.default.RendererGL.prototype.bezier = function(s, o, i, l, n, a, c, p, j, T, _, S) {\n        arguments.length === 8 && (_ = p, T = c, p = a, c = n, n = l, l = i, i = a = j = S = 0);\n        var E = this._pInst._bezierDetail || 20;\n        this.beginShape();\n        for (var A = 0; A <= E; A++) {\n          var x = Math.pow(1 - A / E, 3), P = A / E * 3 * Math.pow(1 - A / E, 2), M = 3 * Math.pow(A / E, 2) * (1 - A / E), R = Math.pow(A / E, 3);\n          this.vertex(s * x + l * P + c * M + T * R, o * x + n * P + p * M + _ * R, i * x + a * P + j * M + S * R);\n        }\n        return this.endShape(), this;\n      }, u.default.RendererGL.prototype.curve = function(s, o, i, l, n, a, c, p, j, T, _, S) {\n        arguments.length === 8 && (T = c, _ = p, c = n, p = l, n = l = i, i = a = j = S = 0);\n        var E = this._pInst._curveDetail;\n        this.beginShape();\n        for (var A = 0; A <= E; A++) {\n          var x = 0.5 * Math.pow(A / E, 3), P = 0.5 * Math.pow(A / E, 2), M = A / E * 0.5;\n          this.vertex(x * (3 * l - s - 3 * c + T) + P * (2 * s - 5 * l + 4 * c - T) + M * (-s + c) + 2 * l * 0.5, x * (3 * n - o - 3 * p + _) + P * (2 * o - 5 * n + 4 * p - _) + M * (-o + p) + 2 * n * 0.5, x * (3 * a - i - 3 * j + S) + P * (2 * i - 5 * a + 4 * j - S) + M * (-i + j) + 2 * a * 0.5);\n        }\n        return this.endShape(), this;\n      }, u.default.RendererGL.prototype.line = function() {\n        return arguments.length === 6 ? (this.beginShape(h.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]), this.vertex(arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5]), this.endShape()) : arguments.length === 4 && (this.beginShape(h.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], 0), this.vertex(arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], 0), this.endShape()), this;\n      }, u.default.RendererGL.prototype.bezierVertex = function() {\n        if (this.immediateMode._bezierVertex.length === 0)\n          throw Error(\"vertex() must be used once before calling bezierVertex()\");\n        var s, o, i, l, n, a, c = [], p = [], j = arguments.length;\n        if (this._lookUpTableBezier.length === 0 || this._lutBezierDetail !== this._pInst._curveDetail) {\n          this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;\n          for (var T = 1 / this._lutBezierDetail, _ = 0, S = 1, E = 0; _ < 1; ) {\n            if (a = parseFloat(_.toFixed(6)), this._lookUpTableBezier[E] = this._bezierCoefficients(a), S.toFixed(6) === T.toFixed(6)) {\n              a = parseFloat(S.toFixed(6)) + parseFloat(_.toFixed(6)), ++E, this._lookUpTableBezier[E] = this._bezierCoefficients(a);\n              break;\n            }\n            _ += T, S -= T, ++E;\n          }\n        }\n        for (var A = this._lookUpTableBezier.length, x = [], P = 0; P < 4; P++)\n          x.push([]);\n        x[0] = this.immediateMode.geometry.vertexColors.slice(-4), x[3] = this.curFillColor.slice();\n        var M = [];\n        for (P = 0; P < 4; P++)\n          M.push([]);\n        if (M[0] = this.immediateMode.geometry.vertexStrokeColors.slice(-4), M[3] = this.curStrokeColor.slice(), j === 6) {\n          this.isBezier = !0;\n          var c = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 4 ? void 0 : arguments[4]], p = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 5 ? void 0 : arguments[5]], R = Math.hypot(c[0] - c[1], p[0] - p[1]), F = Math.hypot(c[1] - c[2], p[1] - p[2]), L = Math.hypot(c[2] - c[3], p[2] - p[3]), F = R + F + L;\n          for (R /= F, L /= F, n = 0; n < 4; n++)\n            x[1].push(x[0][n] * (1 - R) + x[3][n] * R), x[2].push(x[0][n] * L + x[3][n] * (1 - L)), M[1].push(M[0][n] * (1 - R) + M[3][n] * R), M[2].push(M[0][n] * L + M[3][n] * (1 - L));\n          for (l = 0; l < A; l++) {\n            for (this.curFillColor = [0, 0, 0, 0], this.curStrokeColor = [0, 0, 0, 0], P = s = o = 0; P < 4; P++) {\n              for (n = 0; n < 4; n++)\n                this.curFillColor[n] += this._lookUpTableBezier[l][P] * x[P][n], this.curStrokeColor[n] += this._lookUpTableBezier[l][P] * M[P][n];\n              s += c[P] * this._lookUpTableBezier[l][P], o += p[P] * this._lookUpTableBezier[l][P];\n            }\n            this.vertex(s, o);\n          }\n          this.curFillColor = x[3], this.curStrokeColor = M[3], this.immediateMode._bezierVertex[0] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._bezierVertex[1] = arguments.length <= 5 ? void 0 : arguments[5];\n        } else if (j === 9) {\n          this.isBezier = !0, c = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 6 ? void 0 : arguments[6]], p = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 7 ? void 0 : arguments[7]];\n          var V = [this.immediateMode._bezierVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 8 ? void 0 : arguments[8]], G = Math.hypot(c[0] - c[1], p[0] - p[1], V[0] - V[1]), F = Math.hypot(c[1] - c[2], p[1] - p[2], V[1] - V[2]), U = Math.hypot(c[2] - c[3], p[2] - p[3], V[2] - V[3]), j = G + F + U;\n          for (G /= j, U /= j, n = 0; n < 4; n++)\n            x[1].push(x[0][n] * (1 - G) + x[3][n] * G), x[2].push(x[0][n] * U + x[3][n] * (1 - U)), M[1].push(M[0][n] * (1 - G) + M[3][n] * G), M[2].push(M[0][n] * U + M[3][n] * (1 - U));\n          for (l = 0; l < A; l++) {\n            for (this.curFillColor = [0, 0, 0, 0], this.curStrokeColor = [0, 0, 0, 0], P = s = o = i = 0; P < 4; P++) {\n              for (n = 0; n < 4; n++)\n                this.curFillColor[n] += this._lookUpTableBezier[l][P] * x[P][n], this.curStrokeColor[n] += this._lookUpTableBezier[l][P] * M[P][n];\n              s += c[P] * this._lookUpTableBezier[l][P], o += p[P] * this._lookUpTableBezier[l][P], i += V[P] * this._lookUpTableBezier[l][P];\n            }\n            this.vertex(s, o, i);\n          }\n          this.curFillColor = x[3], this.curStrokeColor = M[3], this.immediateMode._bezierVertex[0] = arguments.length <= 6 ? void 0 : arguments[6], this.immediateMode._bezierVertex[1] = arguments.length <= 7 ? void 0 : arguments[7], this.immediateMode._bezierVertex[2] = arguments.length <= 8 ? void 0 : arguments[8];\n        }\n      }, u.default.RendererGL.prototype.quadraticVertex = function() {\n        if (this.immediateMode._quadraticVertex.length === 0)\n          throw Error(\"vertex() must be used once before calling quadraticVertex()\");\n        var s, o, i, l, n, a, c = [], p = [], j = arguments.length;\n        if (this._lookUpTableQuadratic.length === 0 || this._lutQuadraticDetail !== this._pInst._curveDetail) {\n          this._lookUpTableQuadratic = [], this._lutQuadraticDetail = this._pInst._curveDetail;\n          for (var T = 1 / this._lutQuadraticDetail, _ = 0, S = 1, E = 0; _ < 1; ) {\n            if (a = parseFloat(_.toFixed(6)), this._lookUpTableQuadratic[E] = this._quadraticCoefficients(a), S.toFixed(6) === T.toFixed(6)) {\n              a = parseFloat(S.toFixed(6)) + parseFloat(_.toFixed(6)), ++E, this._lookUpTableQuadratic[E] = this._quadraticCoefficients(a);\n              break;\n            }\n            _ += T, S -= T, ++E;\n          }\n        }\n        for (var A = this._lookUpTableQuadratic.length, x = [], P = 0; P < 3; P++)\n          x.push([]);\n        x[0] = this.immediateMode.geometry.vertexColors.slice(-4), x[2] = this.curFillColor.slice();\n        var M = [];\n        for (P = 0; P < 3; P++)\n          M.push([]);\n        if (M[0] = this.immediateMode.geometry.vertexStrokeColors.slice(-4), M[2] = this.curStrokeColor.slice(), j === 4) {\n          this.isQuadratic = !0;\n          var c = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2]], p = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3]], R = Math.hypot(c[0] - c[1], p[0] - p[1]);\n          for (R /= R + Math.hypot(c[1] - c[2], p[1] - p[2]), n = 0; n < 4; n++)\n            x[1].push(x[0][n] * (1 - R) + x[2][n] * R), M[1].push(M[0][n] * (1 - R) + M[2][n] * R);\n          for (l = 0; l < A; l++) {\n            for (this.curFillColor = [0, 0, 0, 0], this.curStrokeColor = [0, 0, 0, 0], P = s = o = 0; P < 3; P++) {\n              for (n = 0; n < 4; n++)\n                this.curFillColor[n] += this._lookUpTableQuadratic[l][P] * x[P][n], this.curStrokeColor[n] += this._lookUpTableQuadratic[l][P] * M[P][n];\n              s += c[P] * this._lookUpTableQuadratic[l][P], o += p[P] * this._lookUpTableQuadratic[l][P];\n            }\n            this.vertex(s, o);\n          }\n          this.curFillColor = x[2], this.curStrokeColor = M[2], this.immediateMode._quadraticVertex[0] = arguments.length <= 2 ? void 0 : arguments[2], this.immediateMode._quadraticVertex[1] = arguments.length <= 3 ? void 0 : arguments[3];\n        } else if (j === 6) {\n          this.isQuadratic = !0, c = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3]], p = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4]];\n          var L = [this.immediateMode._quadraticVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5]], F = Math.hypot(c[0] - c[1], p[0] - p[1], L[0] - L[1]);\n          for (F /= F + Math.hypot(c[1] - c[2], p[1] - p[2], L[1] - L[2]), n = 0; n < 4; n++)\n            x[1].push(x[0][n] * (1 - F) + x[2][n] * F), M[1].push(M[0][n] * (1 - F) + M[2][n] * F);\n          for (l = 0; l < A; l++) {\n            for (this.curFillColor = [0, 0, 0, 0], this.curStrokeColor = [0, 0, 0, 0], P = s = o = i = 0; P < 3; P++) {\n              for (n = 0; n < 4; n++)\n                this.curFillColor[n] += this._lookUpTableQuadratic[l][P] * x[P][n], this.curStrokeColor[n] += this._lookUpTableQuadratic[l][P] * M[P][n];\n              s += c[P] * this._lookUpTableQuadratic[l][P], o += p[P] * this._lookUpTableQuadratic[l][P], i += L[P] * this._lookUpTableQuadratic[l][P];\n            }\n            this.vertex(s, o, i);\n          }\n          this.curFillColor = x[2], this.curStrokeColor = M[2], this.immediateMode._quadraticVertex[0] = arguments.length <= 3 ? void 0 : arguments[3], this.immediateMode._quadraticVertex[1] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._quadraticVertex[2] = arguments.length <= 5 ? void 0 : arguments[5];\n        }\n      }, u.default.RendererGL.prototype.curveVertex = function() {\n        var s, o, i, l, n, a, c = [], p = [], j = arguments.length;\n        if (this._lookUpTableBezier.length === 0 || this._lutBezierDetail !== this._pInst._curveDetail) {\n          this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;\n          for (var T = 1 / this._lutBezierDetail, _ = 0, S = 1, E = 0; _ < 1; ) {\n            if (a = parseFloat(_.toFixed(6)), this._lookUpTableBezier[E] = this._bezierCoefficients(a), S.toFixed(6) === T.toFixed(6)) {\n              a = parseFloat(S.toFixed(6)) + parseFloat(_.toFixed(6)), ++E, this._lookUpTableBezier[E] = this._bezierCoefficients(a);\n              break;\n            }\n            _ += T, S -= T, ++E;\n          }\n        }\n        var A = this._lookUpTableBezier.length;\n        if (j === 2) {\n          if (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), this.immediateMode._curveVertex.length === 8) {\n            for (this.isCurve = !0, c = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[6]]), p = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[7]]), n = 0; n < A; n++)\n              o = c[0] * this._lookUpTableBezier[n][0] + c[1] * this._lookUpTableBezier[n][1] + c[2] * this._lookUpTableBezier[n][2] + c[3] * this._lookUpTableBezier[n][3], i = p[0] * this._lookUpTableBezier[n][0] + p[1] * this._lookUpTableBezier[n][1] + p[2] * this._lookUpTableBezier[n][2] + p[3] * this._lookUpTableBezier[n][3], this.vertex(o, i);\n            for (n = 0; n < j; n++)\n              this.immediateMode._curveVertex.shift();\n          }\n        } else if (j === 3 && (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), this.immediateMode._curveVertex.push(arguments.length <= 2 ? void 0 : arguments[2]), this.immediateMode._curveVertex.length === 12)) {\n          for (this.isCurve = !0, c = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[6], this.immediateMode._curveVertex[9]]), p = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[7], this.immediateMode._curveVertex[10]]), s = this._bezierToCatmull([this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[8], this.immediateMode._curveVertex[11]]), n = 0; n < A; n++)\n            o = c[0] * this._lookUpTableBezier[n][0] + c[1] * this._lookUpTableBezier[n][1] + c[2] * this._lookUpTableBezier[n][2] + c[3] * this._lookUpTableBezier[n][3], i = p[0] * this._lookUpTableBezier[n][0] + p[1] * this._lookUpTableBezier[n][1] + p[2] * this._lookUpTableBezier[n][2] + p[3] * this._lookUpTableBezier[n][3], l = s[0] * this._lookUpTableBezier[n][0] + s[1] * this._lookUpTableBezier[n][1] + s[2] * this._lookUpTableBezier[n][2] + s[3] * this._lookUpTableBezier[n][3], this.vertex(o, i, l);\n          for (n = 0; n < j; n++)\n            this.immediateMode._curveVertex.shift();\n        }\n      }, u.default.RendererGL.prototype.image = function(s, S, i, E, n, a, c, p, j) {\n        this._isErasing && this.blendMode(this._cachedBlendMode), this._pInst.push(), this._pInst.noLights(), this._pInst.noStroke(), this._pInst.texture(s), this._pInst.textureMode(h.NORMAL);\n        var T = 0, _ = (S <= s.width && (T = S / s.width), 1), S = (S + E <= s.width && (_ = (S + E) / s.width), 0), E = (i <= s.height && (S = i / s.height), 1);\n        i + n <= s.height && (E = (i + n) / s.height), this.beginShape(), this.vertex(a, c, 0, T, S), this.vertex(a + p, c, 0, _, S), this.vertex(a + p, c + j, 0, _, E), this.vertex(a, c + j, 0, T, E), this.endShape(h.CLOSE), this._pInst.pop(), this._isErasing && this.blendMode(h.REMOVE);\n      };\n      var r = u.default;\n      C.default = r;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.Geometry\": 332, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.math.hypot\": 175, \"core-js/modules/es.math.sign\": 177, \"core-js/modules/es.number.to-fixed\": 180, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 324: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      function y(o) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.every\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.object.assign\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (s = t(\"../core/main\")) && s.__esModule ? s : { default: s }, h = function(o) {\n        if (o && o.__esModule)\n          return o;\n        if (o === null || y(o) !== \"object\" && typeof o != \"function\")\n          return { default: o };\n        var i = g();\n        if (i && i.has(o))\n          return i.get(o);\n        var l, n = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (l in o) {\n          var c;\n          Object.prototype.hasOwnProperty.call(o, l) && ((c = a ? Object.getOwnPropertyDescriptor(o, l) : null) && (c.get || c.set) ? Object.defineProperty(n, l, c) : n[l] = o[l]);\n        }\n        return n.default = o, i && i.set(o, n), n;\n      }(t(\"../core/constants\"));\n      function g() {\n        var o;\n        return typeof WeakMap != \"function\" ? null : (o = /* @__PURE__ */ new WeakMap(), g = function() {\n          return o;\n        }, o);\n      }\n      function f(o) {\n        return function(i) {\n          if (Array.isArray(i)) {\n            for (var l = 0, n = new Array(i.length); l < i.length; l++)\n              n[l] = i[l];\n            return n;\n          }\n        }(o) || function(i) {\n          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === \"[object Arguments]\")\n            return Array.from(i);\n        }(o) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function r(o, i) {\n        for (var l = 0; l < i.length; l++) {\n          var n = i[l];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);\n        }\n      }\n      var s = function() {\n        function o(n) {\n          if (!(this instanceof o))\n            throw new TypeError(\"Cannot call a class as a function\");\n          (this.renderer = n)._pInst.push(), this.identityMatrix = new u.default.Matrix(), n.uMVMatrix = new u.default.Matrix(), this.geometry = new u.default.Geometry(), this.geometry.gid = \"_p5_GeometryBuilder_\".concat(o.nextGeometryId), o.nextGeometryId++, this.hasTransform = !1;\n        }\n        var i, l;\n        return i = o, (l = [{ key: \"transformVertices\", value: function(n) {\n          var a = this;\n          return this.hasTransform ? n.map(function(c) {\n            return a.renderer.uMVMatrix.multiplyPoint(c);\n          }) : n;\n        } }, { key: \"transformNormals\", value: function(n) {\n          var a = this;\n          return this.hasTransform ? n.map(function(c) {\n            return a.renderer.uNMatrix.multiplyVec3(c);\n          }) : n;\n        } }, { key: \"addGeometry\", value: function(n) {\n          for (var a, c = this, p = (this.hasTransform = !this.renderer.uMVMatrix.mat4.every(function(T, _) {\n            return T === c.identityMatrix.mat4[_];\n          }), this.hasTransform && this.renderer.uNMatrix.inverseTranspose(this.renderer.uMVMatrix), this.geometry.vertices.length), j = ((a = this.geometry.vertices).push.apply(a, f(this.transformVertices(n.vertices))), (a = this.geometry.vertexNormals).push.apply(a, f(this.transformNormals(n.vertexNormals))), (a = this.geometry.uvs).push.apply(a, f(n.uvs)), this.renderer._doFill && (a = this.geometry.faces).push.apply(a, f(n.faces.map(function(T) {\n            return T.map(function(_) {\n              return _ + p;\n            });\n          }))), this.renderer._doStroke && (a = this.geometry.edges).push.apply(a, f(n.edges.map(function(T) {\n            return T.map(function(_) {\n              return _ + p;\n            });\n          }))), f(n.vertexColors)); j.length < 4 * n.vertices.length; )\n            j.push.apply(j, f(this.renderer.curFillColor));\n          (a = this.geometry.vertexColors).push.apply(a, f(j));\n        } }, { key: \"addImmediate\", value: function() {\n          var n = this.renderer.immediateMode.geometry, a = this.renderer.immediateMode.shapeMode, c = [];\n          if (this.renderer._doFill)\n            if (a === h.TRIANGLE_STRIP || a === h.QUAD_STRIP)\n              for (var p = 2; p < n.vertices.length; p++)\n                p % 2 == 0 ? c.push([p, p - 1, p - 2]) : c.push([p, p - 2, p - 1]);\n            else if (a === h.TRIANGLE_FAN)\n              for (var j = 2; j < n.vertices.length; j++)\n                c.push([0, j - 1, j]);\n            else\n              for (var T = 0; T < n.vertices.length; T += 3)\n                c.push([T, T + 1, T + 2]);\n          this.addGeometry(Object.assign({}, n, { faces: c }));\n        } }, { key: \"addRetained\", value: function(n) {\n          this.addGeometry(n.model);\n        } }, { key: \"finish\", value: function() {\n          return this.renderer._pInst.pop(), this.geometry;\n        } }]) && r(i.prototype, l), o;\n      }();\n      s.nextGeometryId = 0, C.default = s;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.every\": 154, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 325: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.math.sign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var y = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, u = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || g(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = h();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\"));\n      function h() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), h = function() {\n          return r;\n        }, r);\n      }\n      function g(r) {\n        return (g = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      y.default.prototype.orbitControl = function(r, s, o, j) {\n        var l = this, n = (this._assert3d(\"orbitControl\"), y.default._validateParameters(\"orbitControl\", arguments), this._renderer._curCamera);\n        r === void 0 && (r = 1), s === void 0 && (s = r), o === void 0 && (o = 1), g(j) !== \"object\" && (j = {}), this.contextMenuDisabled !== !0 && (this.canvas.oncontextmenu = function() {\n          return !1;\n        }, this._setProperty(\"contextMenuDisabled\", !0)), this.wheelDefaultDisabled !== !0 && (this.canvas.onwheel = function() {\n          return !1;\n        }, this._setProperty(\"wheelDefaultDisabled\", !0));\n        var _ = j.disableTouchActions;\n        this.touchActionsDisabled === !0 || _ !== void 0 && !_ || (this.canvas.style[\"touch-action\"] = \"none\", this._setProperty(\"touchActionsDisabled\", !0));\n        var a, c, p, _ = j.freeRotation, j = _ !== void 0 && _, T = [], _ = (this.touches.forEach(function(R) {\n          l._renderer.prevTouches.forEach(function(L) {\n            R.id === L.id && (L = { x: R.x, y: R.y, px: L.x, py: L.y }, T.push(L));\n          });\n        }), this._renderer.prevTouches = this.touches, 0), S = 0, E = 0, A = 0, x = 0, P = this.height < this.width ? this.height : this.width, M = !1;\n        return 0 < T.length ? (M = 0 < T[0].x && T[0].x < this.width && 0 < T[0].y && T[0].y < this.height, T.length === 1 ? (S = -r * ((a = T[0]).x - a.px) / P, E = s * (a.y - a.py) / P) : (a = T[0], c = T[1], _ = -(Math.hypot(a.x - c.x, a.y - c.y) - Math.hypot(a.px - c.px, a.py - c.py)) * o * 4e-4, A = 0.5 * (a.x + c.x) - 0.5 * (a.px + c.px), x = 0.5 * (a.y + c.y) - 0.5 * (a.py + c.py)), 0 < this.touches.length ? M && (this._renderer.executeRotateAndMove = !0, this._renderer.executeZoom = !0) : (this._renderer.executeRotateAndMove = !1, this._renderer.executeZoom = !1)) : (M = 0 < this.mouseX && this.mouseX < this.width && 0 < this.mouseY && this.mouseY < this.height, this._mouseWheelDeltaY !== 0 ? (_ = Math.sign(this._mouseWheelDeltaY) * o, _ *= 0.01, this._mouseWheelDeltaY = 0, M && (this._renderer.executeZoom = !0)) : this._renderer.executeZoom = !1, this.mouseIsPressed ? (this.mouseButton === this.LEFT ? (S = -r * this.movedX / P, E = s * this.movedY / P) : this.mouseButton === this.RIGHT && (A = this.movedX, x = this.movedY * n.yScale), M && (this._renderer.executeRotateAndMove = !0)) : this._renderer.executeRotateAndMove = !1), _ !== 0 && this._renderer.executeZoom && (this._renderer.zoomVelocity += _), 1e-3 < Math.abs(this._renderer.zoomVelocity) ? (j ? n._orbitFree(0, 0, this._renderer.zoomVelocity) : n._orbit(0, 0, this._renderer.zoomVelocity), n.projMatrix.mat4[15] !== 0 && (n.projMatrix.mat4[0] *= Math.pow(10, -this._renderer.zoomVelocity), n.projMatrix.mat4[5] *= Math.pow(10, -this._renderer.zoomVelocity), this._renderer.uPMatrix.mat4[0] = n.projMatrix.mat4[0], this._renderer.uPMatrix.mat4[5] = n.projMatrix.mat4[5]), this._renderer.zoomVelocity *= 0.85) : this._renderer.zoomVelocity = 0, S === 0 && E === 0 || !this._renderer.executeRotateAndMove || this._renderer.rotateVelocity.add(0.6 * S, 0.6 * E), 1e-6 < this._renderer.rotateVelocity.magSq() ? (j ? n._orbitFree(-this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0) : n._orbit(this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0), this._renderer.rotateVelocity.mult(0.85)) : this._renderer.rotateVelocity.set(0, 0), A === 0 && x === 0 || !this._renderer.executeRotateAndMove || (a = 2 * A / this.width, c = 2 * -x / this.height, this._renderer.moveVelocity.add(0.15 * a, 0.15 * c)), 1e-6 < this._renderer.moveVelocity.magSq() ? (o = n._getLocalAxes(), r = n.eyeX - n.centerX, s = n.eyeY - n.centerY, P = n.eyeZ - n.centerZ, M = Math.sqrt(r * r + s * s + P * P), _ = new y.default.Vector(n.centerX, n.centerY, n.centerZ), _ = n.cameraMatrix.multiplyPoint(_), (_ = this._renderer.uPMatrix.multiplyAndNormalizePoint(_)).x -= this._renderer.moveVelocity.x, _.y -= this._renderer.moveVelocity.y, E = (S = this._renderer.uPMatrix.mat4)[15] === 0 ? (p = (S[8] + _.x) / S[0] * M, (S[9] + _.y) / S[5] * M) : (p = (_.x - S[12]) / S[0], (_.y - S[13]) / S[5]), n.setPosition(n.eyeX + p * o.x[0] + E * o.y[0], n.eyeY + p * o.x[1] + E * o.y[1], n.eyeZ + p * o.x[2] + E * o.y[2]), this._renderer.moveVelocity.mult(0.85)) : this._renderer.moveVelocity.set(0, 0), this;\n      }, y.default.prototype.debugMode = function() {\n        this._assert3d(\"debugMode\");\n        for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)\n          s[o] = arguments[o];\n        y.default._validateParameters(\"debugMode\", s);\n        for (var i = this._registeredMethods.post.length - 1; 0 <= i; i--)\n          this._registeredMethods.post[i].toString() !== this._grid().toString() && this._registeredMethods.post[i].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(i, 1);\n        s[0] === u.GRID ? this.registerMethod(\"post\", this._grid(s[1], s[2], s[3], s[4], s[5])) : s[0] === u.AXES ? this.registerMethod(\"post\", this._axesIcon(s[1], s[2], s[3], s[4])) : (this.registerMethod(\"post\", this._grid(s[0], s[1], s[2], s[3], s[4])), this.registerMethod(\"post\", this._axesIcon(s[5], s[6], s[7], s[8])));\n      }, y.default.prototype.noDebugMode = function() {\n        this._assert3d(\"noDebugMode\");\n        for (var r = this._registeredMethods.post.length - 1; 0 <= r; r--)\n          this._registeredMethods.post[r].toString() !== this._grid().toString() && this._registeredMethods.post[r].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(r, 1);\n      }, y.default.prototype._grid = function(r, s, o, i, l) {\n        r === void 0 && (r = this.width / 2), s === void 0 && (s = Math.round(r / 30) < 4 ? 4 : Math.round(r / 30)), o === void 0 && (o = 0), i === void 0 && (i = 0), l === void 0 && (l = 0);\n        var n = r / s, a = r / 2;\n        return function() {\n          this.push(), this.stroke(255 * this._renderer.curStrokeColor[0], 255 * this._renderer.curStrokeColor[1], 255 * this._renderer.curStrokeColor[2]), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix);\n          for (var c = 0; c <= s; c++)\n            this.beginShape(this.LINES), this.vertex(-a + o, i, c * n - a + l), this.vertex(a + o, i, c * n - a + l), this.endShape();\n          for (var p = 0; p <= s; p++)\n            this.beginShape(this.LINES), this.vertex(p * n - a + o, i, -a + l), this.vertex(p * n - a + o, i, a + l), this.endShape();\n          this.pop();\n        };\n      }, y.default.prototype._axesIcon = function(r, s, o, i) {\n        return r === void 0 && (r = 40 < this.width / 20 ? this.width / 20 : 40), s === void 0 && (s = -this.width / 4), o === void 0 && (o = s), i === void 0 && (i = s), function() {\n          this.push(), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix), this.strokeWeight(2), this.stroke(255, 0, 0), this.beginShape(this.LINES), this.vertex(s, o, i), this.vertex(s + r, o, i), this.endShape(), this.stroke(0, 255, 0), this.beginShape(this.LINES), this.vertex(s, o, i), this.vertex(s, o + r, i), this.endShape(), this.stroke(0, 0, 255), this.beginShape(this.LINES), this.vertex(s, o, i), this.vertex(s, o, i + r), this.endShape(), this.pop();\n        };\n      };\n      var f = y.default;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.math.hypot\": 175, \"core-js/modules/es.math.sign\": 177, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 326: [function(t, H, C) {\n      t(\"core-js/modules/es.array.filter\"), t(\"core-js/modules/es.array.filter\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      m.default.prototype.ambientLight = function(y, u, h, g) {\n        this._assert3d(\"ambientLight\"), m.default._validateParameters(\"ambientLight\", arguments);\n        var f = this.color.apply(this, arguments);\n        return this._renderer.ambientLightColors.push(f._array[0], f._array[1], f._array[2]), this._renderer._enableLighting = !0, this;\n      }, m.default.prototype.specularColor = function(y, u, h) {\n        this._assert3d(\"specularColor\"), m.default._validateParameters(\"specularColor\", arguments);\n        var g = this.color.apply(this, arguments);\n        return this._renderer.specularColors = [g._array[0], g._array[1], g._array[2]], this;\n      }, m.default.prototype.directionalLight = function(y, l, i, g, f, r) {\n        this._assert3d(\"directionalLight\"), m.default._validateParameters(\"directionalLight\", arguments), y = y instanceof m.default.Color ? y : this.color(y, l, i);\n        var s, o, l = arguments[arguments.length - 1], i = typeof l == \"number\" ? (s = arguments[arguments.length - 3], o = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (s = l.x, o = l.y, l.z), l = Math.sqrt(s * s + o * o + i * i);\n        return this._renderer.directionalLightDirections.push(s / l, o / l, i / l), this._renderer.directionalLightDiffuseColors.push(y._array[0], y._array[1], y._array[2]), Array.prototype.push.apply(this._renderer.directionalLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = !0, this;\n      }, m.default.prototype.pointLight = function(y, i, l, g, f, r) {\n        this._assert3d(\"pointLight\"), m.default._validateParameters(\"pointLight\", arguments), y = y instanceof m.default.Color ? y : this.color(y, i, l);\n        var s, o, i = arguments[arguments.length - 1], l = typeof i == \"number\" ? (s = arguments[arguments.length - 3], o = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (s = i.x, o = i.y, i.z);\n        return this._renderer.pointLightPositions.push(s, o, l), this._renderer.pointLightDiffuseColors.push(y._array[0], y._array[1], y._array[2]), Array.prototype.push.apply(this._renderer.pointLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = !0, this;\n      }, m.default.prototype.imageLight = function(y) {\n        this._renderer.activeImageLight = y, this._renderer._enableLighting = !0;\n      }, m.default.prototype.panorama = function(y) {\n        this.filter(this._renderer._getSphereMapping(y));\n      }, m.default.prototype.lights = function() {\n        this._assert3d(\"lights\");\n        var y = this.color(\"rgb(128,128,128)\");\n        return this.ambientLight(y), this.directionalLight(y, 0, 0, -1), this;\n      }, m.default.prototype.lightFalloff = function(y, u, h) {\n        return this._assert3d(\"lightFalloff\"), m.default._validateParameters(\"lightFalloff\", arguments), y < 0 && (y = 0, console.warn(\"Value of constant argument in lightFalloff() should be never be negative. Set to 0.\")), u < 0 && (u = 0, console.warn(\"Value of linear argument in lightFalloff() should be never be negative. Set to 0.\")), h < 0 && (h = 0, console.warn(\"Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.\")), y === 0 && u === 0 && h === 0 && (y = 1, console.warn(\"Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.\")), this._renderer.constantAttenuation = y, this._renderer.linearAttenuation = u, this._renderer.quadraticAttenuation = h, this;\n      }, m.default.prototype.spotLight = function(y, u, h, g, f, r, s, o, i, l, n) {\n        this._assert3d(\"spotLight\"), m.default._validateParameters(\"spotLight\", arguments);\n        var a, c, p, j = arguments.length;\n        switch (j) {\n          case 11:\n          case 10:\n            a = this.color(y, u, h), c = new m.default.Vector(g, f, r), p = new m.default.Vector(s, o, i);\n            break;\n          case 9:\n            y instanceof m.default.Color ? (a = y, c = new m.default.Vector(u, h, g), p = new m.default.Vector(f, r, s), l = o, n = i) : g instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, p = new m.default.Vector(f, r, s), l = o, n = i) : s instanceof m.default.Vector ? (a = this.color(y, u, h), c = new m.default.Vector(g, f, r), p = s, l = o, n = i) : (a = this.color(y, u, h), c = new m.default.Vector(g, f, r), p = new m.default.Vector(s, o, i));\n            break;\n          case 8:\n            l = (p = y instanceof m.default.Color ? (a = y, c = new m.default.Vector(u, h, g), new m.default.Vector(f, r, s)) : g instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, new m.default.Vector(f, r, s)) : (a = this.color(y, u, h), c = new m.default.Vector(g, f, r), s), o);\n            break;\n          case 7:\n            y instanceof m.default.Color && u instanceof m.default.Vector ? (a = y, c = u, p = new m.default.Vector(h, g, f), l = r, n = s) : y instanceof m.default.Color && f instanceof m.default.Vector ? (a = y, c = new m.default.Vector(u, h, g), p = f, l = r, n = s) : g instanceof m.default.Vector && f instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, p = f, l = r, n = s) : p = y instanceof m.default.Color ? (a = y, c = new m.default.Vector(u, h, g), new m.default.Vector(f, r, s)) : g instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, new m.default.Vector(f, r, s)) : (a = this.color(y, u, h), c = new m.default.Vector(g, f, r), s);\n            break;\n          case 6:\n            g instanceof m.default.Vector && f instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, p = f, l = r) : y instanceof m.default.Color && f instanceof m.default.Vector ? (a = y, c = new m.default.Vector(u, h, g), p = f, l = r) : y instanceof m.default.Color && u instanceof m.default.Vector && (a = y, c = u, p = new m.default.Vector(h, g, f), l = r);\n            break;\n          case 5:\n            y instanceof m.default.Color && u instanceof m.default.Vector && h instanceof m.default.Vector ? (a = y, c = u, p = h, l = g, n = f) : g instanceof m.default.Vector && f instanceof m.default.Vector ? (a = this.color(y, u, h), c = g, p = f) : y instanceof m.default.Color && f instanceof m.default.Vector ? (a = y, c = new m.default.Vector(u, h, g), p = f) : y instanceof m.default.Color && u instanceof m.default.Vector && (a = y, c = u, p = new m.default.Vector(h, g, f));\n            break;\n          case 4:\n            a = y, c = u, p = h, l = g;\n            break;\n          case 3:\n            a = y, c = u, p = h;\n            break;\n          default:\n            return console.warn(\"Sorry, input for spotlight() is not in prescribed format. Too \".concat(j < 3 ? \"few\" : \"many\", \" arguments were provided\")), this;\n        }\n        return this._renderer.spotLightDiffuseColors.push(a._array[0], a._array[1], a._array[2]), Array.prototype.push.apply(this._renderer.spotLightSpecularColors, this._renderer.specularColors), this._renderer.spotLightPositions.push(c.x, c.y, c.z), p.normalize(), this._renderer.spotLightDirections.push(p.x, p.y, p.z), l === void 0 && (l = Math.PI / 3), n !== void 0 && n < 1 ? (n = 1, console.warn(\"Value of concentration needs to be greater than 1. Setting it to 1\")) : n === void 0 && (n = 100), l = this._renderer._pInst._toRadians(l), this._renderer.spotLightAngle.push(Math.cos(l)), this._renderer.spotLightConc.push(n), this._renderer._enableLighting = !0, this;\n      }, m.default.prototype.noLights = function() {\n        this._assert3d(\"noLights\");\n        for (var y = arguments.length, u = new Array(y), h = 0; h < y; h++)\n          u[h] = arguments[h];\n        return m.default._validateParameters(\"noLights\", u), this._renderer.activeImageLight = null, this._renderer._enableLighting = !1, this._renderer.ambientLightColors.length = 0, this._renderer.specularColors = [1, 1, 1], this._renderer.directionalLightDirections.length = 0, this._renderer.directionalLightDiffuseColors.length = 0, this._renderer.directionalLightSpecularColors.length = 0, this._renderer.pointLightPositions.length = 0, this._renderer.pointLightDiffuseColors.length = 0, this._renderer.pointLightSpecularColors.length = 0, this._renderer.spotLightPositions.length = 0, this._renderer.spotLightDirections.length = 0, this._renderer.spotLightDiffuseColors.length = 0, this._renderer.spotLightSpecularColors.length = 0, this._renderer.spotLightAngle.length = 0, this._renderer.spotLightConc.length = 0, this._renderer.constantAttenuation = 1, this._renderer.linearAttenuation = 0, this._renderer.quadraticAttenuation = 0, this._renderer._useShininess = 1, this._renderer._useMetalness = 0, this;\n      }, t = m.default, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.filter\": 156 }], 327: [function(t, H, C) {\n      function m(s) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n          return typeof o;\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        })(s);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.splice\"), t(\"core-js/modules/es.object.assign\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.promise\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.match\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.trim\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t(\"regenerator-runtime/runtime\");\n      var y = (r = t(\"../core/main\")) && r.__esModule ? r : { default: r };\n      function u(s) {\n        return function(o) {\n          if (Array.isArray(o)) {\n            for (var i = 0, l = new Array(o.length); i < o.length; i++)\n              l[i] = o[i];\n            return l;\n          }\n        }(s) || function(o) {\n          if (Symbol.iterator in Object(o) || Object.prototype.toString.call(o) === \"[object Arguments]\")\n            return Array.from(o);\n        }(s) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function h(s, o, i, l, n, a, c) {\n        try {\n          var p = s[a](c), j = p.value;\n        } catch (T) {\n          return void i(T);\n        }\n        p.done ? o(j) : Promise.resolve(j).then(l, n);\n      }\n      function g(s) {\n        return function() {\n          var o = this, i = arguments;\n          return new Promise(function(l, n) {\n            var a = s.apply(o, i);\n            function c(j) {\n              h(a, l, n, c, p, \"next\", j);\n            }\n            function p(j) {\n              h(a, l, n, c, p, \"throw\", j);\n            }\n            c(void 0);\n          });\n        };\n      }\n      function f(s) {\n        return (f = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(o) {\n          return m(o);\n        } : function(o) {\n          return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : m(o);\n        })(s);\n      }\n      t(\"./p5.Geometry\"), y.default.prototype.loadModel = function(s, o) {\n        y.default._validateParameters(\"loadModel\", arguments);\n        var i, l, n = !1, a = !1, c = !1, p = s.slice(-4), j = (o && f(o) === \"object\" ? (n = o.normalize || !1, i = o.successCallback, l = o.failureCallback, p = o.fileType || p, a = o.flipU || !1, c = o.flipV || !1) : typeof o == \"boolean\" ? (n = o, i = arguments[2], l = arguments[3], arguments[4] !== void 0 && (p = arguments[4])) : (i = typeof o == \"function\" ? o : void 0, l = arguments[2], arguments[3] !== void 0 && (p = arguments[3])), new y.default.Geometry()), T = (j.gid = \"\".concat(s, \"|\").concat(n), this);\n        function _() {\n          return (_ = g(regeneratorRuntime.mark(function E(A) {\n            var x, P, M, R;\n            return regeneratorRuntime.wrap(function(L) {\n              for (; ; )\n                switch (L.prev = L.next) {\n                  case 0:\n                    for (x = [], P = 0; P < A.length; P++)\n                      (M = A[P].match(/^mtllib (.+)/)) && function() {\n                        var F = \"\", V = M[1], G = s.split(\"/\");\n                        F = 1 < G.length ? (G.pop(), G.join(\"/\") + \"/\" + V) : V, x.push(function() {\n                          return S.apply(this, arguments);\n                        }(F).then(function(U) {\n                          return U ? (W = T, X = F, new Promise(function(ne, b) {\n                            var O = null, D = {};\n                            W.loadStrings(X, function(B) {\n                              for (var Y = 0; Y < B.length; ++Y) {\n                                var J, te = B[Y].trim().split(/\\s+/);\n                                te[0] === \"newmtl\" ? (J = te[1], D[O = J] = {}) : te[0] === \"Kd\" ? D[O].diffuseColor = [parseFloat(te[1]), parseFloat(te[2]), parseFloat(te[3])] : te[0] === \"Ka\" ? D[O].ambientColor = [parseFloat(te[1]), parseFloat(te[2]), parseFloat(te[3])] : te[0] === \"Ks\" ? D[O].specularColor = [parseFloat(te[1]), parseFloat(te[2]), parseFloat(te[3])] : te[0] === \"map_Kd\" && (D[O].texturePath = te[1]);\n                              }\n                              ne(D);\n                            }, b);\n                          })) : (console.warn(\"MTL file not found or error in parsing; proceeding without materials: \".concat(F)), {});\n                          var W, X;\n                        }).catch(function(U) {\n                          return console.warn(\"Error loading MTL file: \".concat(F), U), {};\n                        }));\n                      }();\n                    return L.prev = 2, L.next = 5, Promise.all(x);\n                  case 5:\n                    return R = L.sent, R = Object.assign.apply(Object, [{}].concat(u(R))), L.abrupt(\"return\", R);\n                  case 10:\n                    return L.prev = 10, L.t0 = L.catch(2), L.abrupt(\"return\", {});\n                  case 13:\n                  case \"end\":\n                    return L.stop();\n                }\n            }, E, null, [[2, 10]]);\n          }))).apply(this, arguments);\n        }\n        function S() {\n          return (S = g(regeneratorRuntime.mark(function E(A) {\n            var x;\n            return regeneratorRuntime.wrap(function(P) {\n              for (; ; )\n                switch (P.prev = P.next) {\n                  case 0:\n                    return P.prev = 0, P.next = 3, fetch(A, { method: \"HEAD\" });\n                  case 3:\n                    return x = P.sent, P.abrupt(\"return\", x.ok);\n                  case 7:\n                    return P.prev = 7, P.t0 = P.catch(0), P.abrupt(\"return\", !1);\n                  case 10:\n                  case \"end\":\n                    return P.stop();\n                }\n            }, E, null, [[0, 7]]);\n          }))).apply(this, arguments);\n        }\n        return p.match(/\\.stl$/i) ? this.httpDo(s, \"GET\", \"arrayBuffer\", function(E) {\n          (function(A, x) {\n            if (function(P) {\n              for (var M = new DataView(P), R = [115, 111, 108, 105, 100], L = 0; L < 5; L++)\n                if (function(F, V, G) {\n                  for (var U = 0, W = F.length; U < W; U++)\n                    if (F[U] !== V.getUint8(G + U, !1))\n                      return;\n                  return 1;\n                }(R, M, L))\n                  return;\n              return 1;\n            }(x))\n              (function(P, M) {\n                for (var R, L, F, V, G, U, W, X = new DataView(M), ne = X.getUint32(80, !0), b = !1, O = 0; O < 70; O++)\n                  X.getUint32(O, !1) === 1129270351 && X.getUint8(O + 4) === 82 && X.getUint8(O + 5) === 61 && (b = !0, V = [], G = X.getUint8(O + 6) / 255, U = X.getUint8(O + 7) / 255, W = X.getUint8(O + 8) / 255);\n                for (var D = 0; D < ne; D++) {\n                  for (var B, Y = 84 + 50 * D, J = X.getFloat32(Y, !0), te = X.getFloat32(4 + Y, !0), ce = X.getFloat32(8 + Y, !0), re = (b && (B = X.getUint16(48 + Y, !0), F = 32768 & B ? (R = G, L = U, W) : (R = (31 & B) / 31, L = (B >> 5 & 31) / 31, (B >> 10 & 31) / 31)), new y.default.Vector(J, te, ce)), ue = 1; ue <= 3; ue++) {\n                    var le = Y + 12 * ue, le = new y.default.Vector(X.getFloat32(le, !0), X.getFloat32(4 + le, !0), X.getFloat32(8 + le, !0));\n                    P.vertices.push(le), P.vertexNormals.push(re), b && V.push(R, L, F);\n                  }\n                  P.faces.push([3 * D, 3 * D + 1, 3 * D + 2]), P.uvs.push([0, 0], [0, 0], [0, 0]);\n                }\n              })(A, x);\n            else {\n              if (x = new DataView(x), !(\"TextDecoder\" in window))\n                return console.warn(\"Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)\");\n              x = new TextDecoder(\"utf-8\").decode(x).split(`\n`), function(P, M) {\n                for (var R, L, F = \"\", V = [], G = 0; G < M.length; ++G) {\n                  for (var U = M[G].trim(), W = U.split(\" \"), X = 0; X < W.length; ++X)\n                    W[X] === \"\" && W.splice(X, 1);\n                  if (W.length !== 0)\n                    switch (F) {\n                      case \"\":\n                        if (W[0] !== \"solid\")\n                          return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"solid\"'));\n                        F = \"solid\";\n                        break;\n                      case \"solid\":\n                        if (W[0] !== \"facet\" || W[1] !== \"normal\")\n                          return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"facet normal\"'));\n                        R = new y.default.Vector(parseFloat(W[2]), parseFloat(W[3]), parseFloat(W[4])), P.vertexNormals.push(R, R, R), F = \"facet normal\";\n                        break;\n                      case \"facet normal\":\n                        if (W[0] !== \"outer\" || W[1] !== \"loop\")\n                          return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"outer loop\"'));\n                        F = \"vertex\";\n                        break;\n                      case \"vertex\":\n                        if (W[0] === \"vertex\")\n                          L = new y.default.Vector(parseFloat(W[1]), parseFloat(W[2]), parseFloat(W[3])), P.vertices.push(L), P.uvs.push([0, 0]), V.push(P.vertices.indexOf(L));\n                        else {\n                          if (W[0] !== \"endloop\")\n                            return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"vertex\" or \"endloop\"'));\n                          P.faces.push(V), V = [], F = \"endloop\";\n                        }\n                        break;\n                      case \"endloop\":\n                        if (W[0] !== \"endfacet\")\n                          return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"endfacet\"'));\n                        F = \"endfacet\";\n                        break;\n                      case \"endfacet\":\n                        if (W[0] !== \"endsolid\") {\n                          if (W[0] !== \"facet\" || W[1] !== \"normal\")\n                            return console.error(U), console.error('Invalid state \"'.concat(W[0], '\", should be \"endsolid\" or \"facet normal\"'));\n                          R = new y.default.Vector(parseFloat(W[2]), parseFloat(W[3]), parseFloat(W[4])), P.vertexNormals.push(R, R, R), F = \"facet normal\";\n                        }\n                        break;\n                      default:\n                        console.error('Invalid state \"'.concat(F, '\"'));\n                    }\n                }\n              }(A, x);\n            }\n          })(j, E), n && j.normalize(), a && j.flipU(), c && j.flipV(), T._decrementPreload(), typeof i == \"function\" && i(j);\n        }, l) : p.match(/\\.obj$/i) ? this.loadStrings(s, function() {\n          var E = g(regeneratorRuntime.mark(function A(x) {\n            var P;\n            return regeneratorRuntime.wrap(function(M) {\n              for (; ; )\n                switch (M.prev = M.next) {\n                  case 0:\n                    return M.prev = 0, M.next = 3, function() {\n                      return _.apply(this, arguments);\n                    }(x);\n                  case 3:\n                    P = M.sent, function(R, L) {\n                      for (var F = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {}, V = { v: [], vt: [], vn: [] }, G = {}, U = null, W = /* @__PURE__ */ new Set(), X = !1, ne = !1, b = 0; b < L.length; ++b) {\n                        var O = L[b].trim().split(/\\b\\s+/);\n                        if (0 < O.length) {\n                          if (O[0] === \"usemtl\")\n                            U = O[1];\n                          else if (O[0] === \"v\" || O[0] === \"vn\") {\n                            var D = new y.default.Vector(parseFloat(O[1]), parseFloat(O[2]), parseFloat(O[3]));\n                            V[O[0]].push(D);\n                          } else if (O[0] === \"vt\")\n                            D = [parseFloat(O[1]), 1 - parseFloat(O[2])], V[O[0]].push(D);\n                          else if (O[0] === \"f\")\n                            for (var B = 3; B < O.length; ++B) {\n                              for (var Y = [], J = [1, B - 1, B], te = 0; te < J.length; ++te) {\n                                for (var ce, re = O[J[te]], ue = re.split(\"/\"), le = 0; le < ue.length; le++)\n                                  ue[le] = parseInt(ue[le]) - 1;\n                                G[re] || (G[re] = {}), G[re][U] === void 0 ? (ce = R.vertices.length, R.vertices.push(V.v[ue[0]].copy()), R.uvs.push(V.vt[ue[1]] ? V.vt[ue[1]].slice() : [0, 0]), R.vertexNormals.push(V.vn[ue[2]] ? V.vn[ue[2]].copy() : new y.default.Vector()), G[re][U] = ce, Y.push(ce), U && F[U] && F[U].diffuseColor && W.add(V.v[ue[0]])) : Y.push(G[re][U]);\n                              }\n                              if (Y[0] !== Y[1] && Y[0] !== Y[2] && Y[1] !== Y[2])\n                                if (R.faces.push(Y), U && F[U] && F[U].diffuseColor) {\n                                  X = X = !0;\n                                  for (var K = F[U].diffuseColor, ae = 0; ae < Y.length; ae++)\n                                    R.vertexColors.push(K[0]), R.vertexColors.push(K[1]), R.vertexColors.push(K[2]);\n                                } else\n                                  ne = !0;\n                            }\n                        }\n                      }\n                      if (R.vertexNormals.length === 0 && R.computeNormals(), X === ne)\n                        throw new Error(\"Model coloring is inconsistent. Either all vertices should have colors or none should.\");\n                    }(j, x, P), M.next = 11;\n                    break;\n                  case 7:\n                    return M.prev = 7, M.t0 = M.catch(0), l ? l(M.t0) : y.default._friendlyError(\"Error during parsing: \" + M.t0.message), M.abrupt(\"return\");\n                  case 11:\n                    return M.prev = 11, n && j.normalize(), a && j.flipU(), c && j.flipV(), T._decrementPreload(), typeof i == \"function\" && i(j), M.finish(11);\n                  case 18:\n                  case \"end\":\n                    return M.stop();\n                }\n            }, A, null, [[0, 7, 11, 18]]);\n          }));\n          return function(A) {\n            return E.apply(this, arguments);\n          };\n        }(), l) : (y.default._friendlyFileLoadError(3, s), l ? l() : y.default._friendlyError(\"Sorry, the file type is invalid. Only OBJ and STL files are supported.\")), j;\n      }, y.default.prototype.model = function(s) {\n        this._assert3d(\"model\"), y.default._validateParameters(\"model\", arguments), 0 < s.vertices.length && (this._renderer.geometryInHash(s.gid) || (s.edges.length === 0 && s._makeTriangleEdges(), s._edgesToVertices(), this._renderer.createBuffers(s.gid, s)), this._renderer.drawBuffers(s.gid));\n      };\n      var r = y.default;\n      C.default = r;\n    }, { \"../core/main\": 280, \"./p5.Geometry\": 332, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.splice\": 170, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.promise\": 188, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.set\": 194, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.match\": 198, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.trim\": 206, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243, \"regenerator-runtime/runtime\": 257 }], 328: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.includes\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.join\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.includes\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, h = function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\"));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      t(\"./p5.Texture\"), u.default.prototype.loadShader = function(r, s, o, i) {\n        u.default._validateParameters(\"loadShader\", arguments), i = i || console.error;\n        function l() {\n          a._decrementPreload(), o && o(n);\n        }\n        var n = new u.default.Shader(), a = this, c = !1, p = !1;\n        return this.loadStrings(r, function(j) {\n          n._vertSrc = j.join(`\n`), p = !0, c && l();\n        }, i), this.loadStrings(s, function(j) {\n          n._fragSrc = j.join(`\n`), c = !0, p && l();\n        }, i), n;\n      }, u.default.prototype.createShader = function(r, s) {\n        return u.default._validateParameters(\"createShader\", arguments), new u.default.Shader(this._renderer, r, s);\n      }, u.default.prototype.createFilterShader = function(r) {\n        u.default._validateParameters(\"createFilterShader\", arguments);\n        var s = r.includes(\"#version 300 es\") ? `#version 300 es\n    uniform mat4 uModelViewMatrix;\n    uniform mat4 uProjectionMatrix;\n\n    in vec3 aPosition;\n    in vec2 aTexCoord;\n    out vec2 vTexCoord;\n\n    void main() {\n      // transferring texcoords for the frag shader\n      vTexCoord = aTexCoord;\n\n      // copy position with a fourth coordinate for projection (1.0 is normal)\n      vec4 positionVec4 = vec4(aPosition, 1.0);\n\n      // project to 3D space\n      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n    }\n  ` : `\n    uniform mat4 uModelViewMatrix;\n    uniform mat4 uProjectionMatrix;\n\n    attribute vec3 aPosition;\n    // texcoords only come from p5 to vertex shader\n    // so pass texcoords on to the fragment shader in a varying variable\n    attribute vec2 aTexCoord;\n    varying vec2 vTexCoord;\n\n    void main() {\n      // transferring texcoords for the frag shader\n      vTexCoord = aTexCoord;\n\n      // copy position with a fourth coordinate for projection (1.0 is normal)\n      vec4 positionVec4 = vec4(aPosition, 1.0);\n\n      // project to 3D space\n      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n    }\n  `, s = new u.default.Shader(this._renderer, s, r);\n        return this._renderer.GL ? s.ensureCompiledOnContext(this) : s.ensureCompiledOnContext(this._renderer.getFilterGraphicsLayer()), s;\n      }, u.default.prototype.shader = function(r) {\n        return this._assert3d(\"shader\"), u.default._validateParameters(\"shader\", arguments), r.ensureCompiledOnContext(this), r.isStrokeShader() ? this._renderer.userStrokeShader = r : (this._renderer.userFillShader = r, this._renderer._useNormalMaterial = !1), this;\n      }, u.default.prototype.resetShader = function() {\n        return this._renderer.userFillShader = this._renderer.userStrokeShader = null, this;\n      }, u.default.prototype.texture = function(r) {\n        return this._assert3d(\"texture\"), u.default._validateParameters(\"texture\", arguments), r.gifProperties && r._animateGif(this), this._renderer.drawMode = h.TEXTURE, this._renderer._useNormalMaterial = !1, this._renderer._tex = r, this._renderer._setProperty(\"_doFill\", !0), this;\n      }, u.default.prototype.textureMode = function(r) {\n        r !== h.IMAGE && r !== h.NORMAL ? console.warn(\"You tried to set \".concat(r, \" textureMode only supports IMAGE & NORMAL \")) : this._renderer.textureMode = r;\n      }, u.default.prototype.textureWrap = function(r) {\n        var s = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : r, o = (this._renderer.textureWrapX = r, this._renderer.textureWrapY = s, !0), i = !1, l = void 0;\n        try {\n          for (var n, a = this._renderer.textures.values()[Symbol.iterator](); !(o = (n = a.next()).done); o = !0)\n            n.value.setWrapMode(r, s);\n        } catch (c) {\n          i = !0, l = c;\n        } finally {\n          try {\n            o || a.return == null || a.return();\n          } finally {\n            if (i)\n              throw l;\n          }\n        }\n      }, u.default.prototype.normalMaterial = function() {\n        this._assert3d(\"normalMaterial\");\n        for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)\n          s[o] = arguments[o];\n        return u.default._validateParameters(\"normalMaterial\", s), this._renderer.drawMode = h.FILL, this._renderer._useSpecularMaterial = !1, this._renderer._useEmissiveMaterial = !1, this._renderer._useNormalMaterial = !0, this._renderer.curFillColor = [1, 1, 1, 1], this._renderer._setProperty(\"_doFill\", !0), this.noStroke(), this;\n      }, u.default.prototype.ambientMaterial = function(r, s, o) {\n        this._assert3d(\"ambientMaterial\"), u.default._validateParameters(\"ambientMaterial\", arguments);\n        var i = u.default.prototype.color.apply(this, arguments);\n        return this._renderer._hasSetAmbient = !0, this._renderer.curAmbientColor = i._array, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this._renderer._setProperty(\"_doFill\", !0), this;\n      }, u.default.prototype.emissiveMaterial = function(r, s, o, i) {\n        this._assert3d(\"emissiveMaterial\"), u.default._validateParameters(\"emissiveMaterial\", arguments);\n        var l = u.default.prototype.color.apply(this, arguments);\n        return this._renderer.curEmissiveColor = l._array, this._renderer._useEmissiveMaterial = !0, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this;\n      }, u.default.prototype.specularMaterial = function(r, s, o, i) {\n        this._assert3d(\"specularMaterial\"), u.default._validateParameters(\"specularMaterial\", arguments);\n        var l = u.default.prototype.color.apply(this, arguments);\n        return this._renderer.curSpecularColor = l._array, this._renderer._useSpecularMaterial = !0, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this;\n      }, u.default.prototype.shininess = function(r) {\n        return this._assert3d(\"shininess\"), u.default._validateParameters(\"shininess\", arguments), this._renderer._useShininess = r = r < 1 ? 1 : r, this;\n      }, u.default.prototype.metalness = function(r) {\n        return this._assert3d(\"metalness\"), r = 1 - Math.exp(-r / 100), this._renderer._useMetalness = r, this;\n      }, u.default.RendererGL.prototype._applyColorBlend = function(r, l) {\n        var o = this.GL, i = this.drawMode === h.TEXTURE, l = l || this.userFillShader || this.userStrokeShader || this.userPointShader || i || this.curBlendMode !== h.BLEND || r[r.length - 1] < 1 || this._isErasing;\n        return l !== this._isBlending && (l || this.curBlendMode !== h.BLEND && this.curBlendMode !== h.ADD ? o.enable(o.BLEND) : o.disable(o.BLEND), o.depthMask(!0), this._isBlending = l), this._applyBlendMode(), r;\n      }, u.default.RendererGL.prototype._applyBlendMode = function() {\n        if (this._cachedBlendMode !== this.curBlendMode) {\n          var r = this.GL;\n          switch (this.curBlendMode) {\n            case h.BLEND:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA);\n              break;\n            case h.ADD:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ONE);\n              break;\n            case h.REMOVE:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ZERO, r.ONE_MINUS_SRC_ALPHA);\n              break;\n            case h.MULTIPLY:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA);\n              break;\n            case h.SCREEN:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ONE_MINUS_SRC_COLOR);\n              break;\n            case h.EXCLUSION:\n              r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD), r.blendFuncSeparate(r.ONE_MINUS_DST_COLOR, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE);\n              break;\n            case h.REPLACE:\n              r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO);\n              break;\n            case h.SUBTRACT:\n              r.blendEquationSeparate(r.FUNC_REVERSE_SUBTRACT, r.FUNC_ADD), r.blendFuncSeparate(r.ONE, r.ONE, r.ONE, r.ONE_MINUS_SRC_ALPHA);\n              break;\n            case h.DARKEST:\n              this.blendExt ? (r.blendEquationSeparate(this.blendExt.MIN || this.blendExt.MIN_EXT, r.FUNC_ADD), r.blendFuncSeparate(r.ONE, r.ONE, r.ONE, r.ONE)) : console.warn(\"blendMode(DARKEST) does not work in your browser in WEBGL mode.\");\n              break;\n            case h.LIGHTEST:\n              this.blendExt ? (r.blendEquationSeparate(this.blendExt.MAX || this.blendExt.MAX_EXT, r.FUNC_ADD), r.blendFuncSeparate(r.ONE, r.ONE, r.ONE, r.ONE)) : console.warn(\"blendMode(LIGHTEST) does not work in your browser in WEBGL mode.\");\n              break;\n            default:\n              console.error(\"Oops! Somehow RendererGL set curBlendMode to an unsupported mode.\");\n          }\n          this._isErasing || (this._cachedBlendMode = this.curBlendMode);\n        }\n      };\n      var f = u.default;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.Texture\": 339, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.join\": 165, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 329: [function(t, H, C) {\n      t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.hypot\"), t(\"core-js/modules/es.string.sub\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(u, h) {\n        for (var g = 0; g < h.length; g++) {\n          var f = h[g];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);\n        }\n      }\n      m.default.prototype.camera = function() {\n        var u;\n        this._assert3d(\"camera\");\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"camera\", g), (u = this._renderer._curCamera).camera.apply(u, g), this;\n      }, m.default.prototype.perspective = function() {\n        var u;\n        this._assert3d(\"perspective\");\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"perspective\", g), (u = this._renderer._curCamera).perspective.apply(u, g), this;\n      }, m.default.prototype.linePerspective = function(u) {\n        if (m.default._validateParameters(\"linePerspective\", arguments), !(this._renderer instanceof m.default.RendererGL))\n          throw new Error(\"linePerspective() must be called in WebGL mode.\");\n        if (u === void 0)\n          return this._renderer._curCamera.useLinePerspective;\n        this._renderer._curCamera.useLinePerspective = u;\n      }, m.default.prototype.ortho = function() {\n        var u;\n        this._assert3d(\"ortho\");\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"ortho\", g), (u = this._renderer._curCamera).ortho.apply(u, g), this;\n      }, m.default.prototype.frustum = function() {\n        var u;\n        this._assert3d(\"frustum\");\n        for (var h = arguments.length, g = new Array(h), f = 0; f < h; f++)\n          g[f] = arguments[f];\n        return m.default._validateParameters(\"frustum\", g), (u = this._renderer._curCamera).frustum.apply(u, g), this;\n      }, m.default.prototype.createCamera = function() {\n        this._assert3d(\"createCamera\");\n        var u = new m.default.Camera(this._renderer);\n        return u._computeCameraDefaultSettings(), u._setDefaultCamera(), this._renderer._curCamera = u;\n      }, m.default.Camera = function() {\n        function u(f) {\n          if (!(this instanceof u))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this._renderer = f, this.cameraType = \"default\", this.useLinePerspective = !0, this.cameraMatrix = new m.default.Matrix(), this.projMatrix = new m.default.Matrix(), this.yScale = 1;\n        }\n        var h, g;\n        return h = u, (g = [{ key: \"perspective\", value: function(i, r, s, o) {\n          this.cameraType = 0 < arguments.length ? \"custom\" : \"default\", i === void 0 ? (i = this.defaultCameraFOV, this.cameraFOV = i) : this.cameraFOV = this._renderer._pInst._toRadians(i), r === void 0 && (r = this.defaultAspectRatio), s === void 0 && (s = this.defaultCameraNear), o === void 0 && (o = this.defaultCameraFar), s <= 1e-4 && (s = 0.01, console.log(\"Avoid perspective near plane values close to or below 0. Setting value to 0.01.\")), o < s && console.log(\"Perspective far plane value is less than near plane value. Nothing will be shown.\"), this.aspectRatio = r, this.cameraNear = s, this.cameraFar = o, this.projMatrix = m.default.Matrix.identity();\n          var i = 1 / Math.tan(this.cameraFOV / 2), l = 1 / (this.cameraNear - this.cameraFar);\n          this.projMatrix.set(i / r, 0, 0, 0, 0, -i * this.yScale, 0, 0, 0, 0, (o + s) * l, -1, 0, 0, 2 * o * s * l, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix);\n        } }, { key: \"ortho\", value: function(_, T, s, o, i, l) {\n          _ === void 0 && (_ = -this._renderer.width / 2), T === void 0 && (T = +this._renderer.width / 2), s === void 0 && (s = -this._renderer.height / 2), o === void 0 && (o = +this._renderer.height / 2), i === void 0 && (i = 0), l === void 0 && (l = Math.max(this._renderer.width, this._renderer.height) + 800), this.cameraNear = i;\n          var S = T - _, n = o - s, a = (this.cameraFar = l) - i, c = 2 / S, p = 2 / n * this.yScale, j = -2 / a, T = -(T + _) / S, _ = -(o + s) / n, S = -(l + i) / a;\n          this.projMatrix = m.default.Matrix.identity(), this.projMatrix.set(c, 0, 0, 0, 0, -p, 0, 0, 0, 0, j, 0, T, _, S, 1), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix), this.cameraType = \"custom\";\n        } }, { key: \"frustum\", value: function(_, T, s, o, i, l) {\n          _ === void 0 && (_ = 0.05 * -this._renderer.width), T === void 0 && (T = 0.05 * +this._renderer.width), s === void 0 && (s = 0.05 * +this._renderer.height), o === void 0 && (o = 0.05 * -this._renderer.height), i === void 0 && (i = this.defaultCameraNear), l === void 0 && (l = this.defaultCameraFar), this.cameraNear = i;\n          var S = T - _, n = o - s, a = (this.cameraFar = l) - i, c = 2 * i / S, p = 2 * i / n * this.yScale, j = -2 * l * i / a, T = (T + _) / S, _ = (o + s) / n, S = -(l + i) / a;\n          this.projMatrix = m.default.Matrix.identity(), this.projMatrix.set(c, 0, 0, 0, 0, -p, 0, 0, T, _, S, -1, 0, 0, j, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix), this.cameraType = \"custom\";\n        } }, { key: \"_rotateView\", value: function(c, r, s, o) {\n          var i = this.centerX, l = this.centerY, n = this.centerZ, a = (i -= this.eyeX, l -= this.eyeY, n -= this.eyeZ, m.default.Matrix.identity(this._renderer._pInst)), c = (a.rotate(this._renderer._pInst._toRadians(c), r, s, o), [i * a.mat4[0] + l * a.mat4[4] + n * a.mat4[8], i * a.mat4[1] + l * a.mat4[5] + n * a.mat4[9], i * a.mat4[2] + l * a.mat4[6] + n * a.mat4[10]]);\n          c[0] += this.eyeX, c[1] += this.eyeY, c[2] += this.eyeZ, this.camera(this.eyeX, this.eyeY, this.eyeZ, c[0], c[1], c[2], this.upX, this.upY, this.upZ);\n        } }, { key: \"pan\", value: function(f) {\n          var r = this._getLocalAxes();\n          this._rotateView(f, r.y[0], r.y[1], r.y[2]);\n        } }, { key: \"tilt\", value: function(f) {\n          var r = this._getLocalAxes();\n          this._rotateView(f, r.x[0], r.x[1], r.x[2]);\n        } }, { key: \"lookAt\", value: function(f, r, s) {\n          this.camera(this.eyeX, this.eyeY, this.eyeZ, f, r, s, this.upX, this.upY, this.upZ);\n        } }, { key: \"camera\", value: function(f, r, s, o, i, l, n, a, c) {\n          return f === void 0 && (f = this.defaultEyeX, r = this.defaultEyeY, s = this.defaultEyeZ, o = f, i = r, a = 1, c = n = l = 0), this.eyeX = f, this.eyeY = r, this.eyeZ = s, o !== void 0 && (this.centerX = o, this.centerY = i, this.centerZ = l), n !== void 0 && (this.upX = n, this.upY = a, this.upZ = c), o = this._getLocalAxes(), this.cameraMatrix.set(o.x[0], o.y[0], o.z[0], 0, o.x[1], o.y[1], o.z[1], 0, o.x[2], o.y[2], o.z[2], 0, 0, 0, 0, 1), i = -f, this.cameraMatrix.translate([i, -r, -s]), this._isActive() && this._renderer.uMVMatrix.set(this.cameraMatrix), this;\n        } }, { key: \"move\", value: function(o, i, s) {\n          var l = this._getLocalAxes(), o = [l.x[0] * o, l.x[1] * o, l.x[2] * o], i = [l.y[0] * i, l.y[1] * i, l.y[2] * i], l = [l.z[0] * s, l.z[1] * s, l.z[2] * s];\n          this.camera(this.eyeX + o[0] + i[0] + l[0], this.eyeY + o[1] + i[1] + l[1], this.eyeZ + o[2] + i[2] + l[2], this.centerX + o[0] + i[0] + l[0], this.centerY + o[1] + i[1] + l[1], this.centerZ + o[2] + i[2] + l[2], this.upX, this.upY, this.upZ);\n        } }, { key: \"setPosition\", value: function(f, r, s) {\n          var o = f - this.eyeX, i = r - this.eyeY, l = s - this.eyeZ;\n          this.camera(f, r, s, this.centerX + o, this.centerY + i, this.centerZ + l, this.upX, this.upY, this.upZ);\n        } }, { key: \"set\", value: function(f) {\n          for (var r = 0, s = [\"eyeX\", \"eyeY\", \"eyeZ\", \"centerX\", \"centerY\", \"centerZ\", \"upX\", \"upY\", \"upZ\", \"cameraFOV\", \"aspectRatio\", \"cameraNear\", \"cameraFar\", \"cameraType\", \"yScale\"]; r < s.length; r++) {\n            var o = s[r];\n            this[o] = f[o];\n          }\n          this.cameraMatrix = f.cameraMatrix.copy(), this.projMatrix = f.projMatrix.copy(), this._isActive() && (this._renderer.uMVMatrix.mat4 = this.cameraMatrix.mat4.slice(), this._renderer.uPMatrix.mat4 = this.projMatrix.mat4.slice());\n        } }, { key: \"slerp\", value: function(f, r, s) {\n          var o, i, l, n, a, c, p, j, T, _, S, E, A, x, P, M, R, L;\n          s === 0 ? this.set(f) : s === 1 ? this.set(r) : (this.projMatrix.mat4[15] !== 0 && (this.projMatrix.mat4[0] = f.projMatrix.mat4[0] * Math.pow(r.projMatrix.mat4[0] / f.projMatrix.mat4[0], s), this.projMatrix.mat4[5] = f.projMatrix.mat4[5] * Math.pow(r.projMatrix.mat4[5] / f.projMatrix.mat4[5], s), this._isActive() && (this._renderer.uPMatrix.mat4 = this.projMatrix.mat4.slice())), n = new m.default.Vector(f.eyeX, f.eyeY, f.eyeZ), a = new m.default.Vector(r.eyeX, r.eyeY, r.eyeZ), M = new m.default.Vector(f.centerX, f.centerY, f.centerZ), L = new m.default.Vector(r.centerX, r.centerY, r.centerZ), l = m.default.Vector.dist(n, M), o = m.default.Vector.dist(a, L), o = l * Math.pow(o / l, s), l = m.default.Vector.sub(n, a), i = 1, 1e-6 < (R = (x = n.copy().sub(a).sub(M).add(L)).magSq()) && (i = m.default.Vector.dot(l, x) / R, i = Math.max(0, Math.min(i, 1))), l = m.default.Vector.lerp(m.default.Vector.lerp(n, M, i), m.default.Vector.lerp(a, L, i), s), x = f.cameraMatrix.createSubMatrix3x3(), R = r.cameraMatrix.createSubMatrix3x3(), n = x.row(2), M = R.row(2), a = x.row(1), L = R.row(1), f = new m.default.Vector(), r = new m.default.Vector(), c = new m.default.Vector(), p = new m.default.Vector(), 1 - (j = 0.5 * ((x = (R = R.mult3x3(x.copy().transpose3x3())).diagonal())[0] + x[1] + x[2] - 1)) < 1e-7 ? (f.set(m.default.Vector.lerp(n, M, s)).normalize(), c.set(f).mult(i * o).add(l), p.set(f).mult((i - 1) * o).add(l), r.set(m.default.Vector.lerp(a, L, s)).normalize()) : (M = 1 / (1 - j), L = Math.max(x[0], x[1], x[2]), E = R.mat3[1] + R.mat3[3], A = R.mat3[2] + R.mat3[6], P = R.mat3[5] + R.mat3[7], L = L === x[0] ? (_ = 0.5 * E * (M /= T = Math.sqrt((x[0] - j) * M)), S = 0.5 * A * M, 0.5 * (R.mat3[7] - R.mat3[5]) / T) : L === x[1] ? (S = 0.5 * P * (M /= _ = Math.sqrt((x[1] - j) * M)), T = 0.5 * E * M, 0.5 * (R.mat3[2] - R.mat3[6]) / _) : (T = 0.5 * A * (M /= S = Math.sqrt((x[2] - j) * M)), _ = 0.5 * P * M, 0.5 * (R.mat3[3] - R.mat3[1]) / S), E = s * Math.atan2(L, j), A = Math.cos(E), x = Math.sin(E), (L = new m.default.Matrix(\"mat3\", [A + (P = 1 - A) * T * T, P * (M = T * _) + x * S, P * (R = S * T) - x * _, P * M - x * S, A + P * _ * _, P * (s = _ * S) + x * T, P * R + x * _, P * s - x * T, A + P * S * S])).multiplyVec3(n, f), c.set(f).mult(i * o).add(l), p.set(f).mult((i - 1) * o).add(l), L.multiplyVec3(a, r)), this.camera(c.x, c.y, c.z, p.x, p.y, p.z, r.x, r.y, r.z));\n        } }, { key: \"_computeCameraDefaultSettings\", value: function() {\n          this.defaultAspectRatio = this._renderer.width / this._renderer.height, this.defaultEyeX = 0, this.defaultEyeY = 0, this.defaultEyeZ = 800, this.defaultCameraFOV = 2 * Math.atan(this._renderer.height / 2 / this.defaultEyeZ), this.defaultCenterX = 0, this.defaultCenterY = 0, this.defaultCenterZ = 0, this.defaultCameraNear = 0.1 * this.defaultEyeZ, this.defaultCameraFar = 10 * this.defaultEyeZ;\n        } }, { key: \"_setDefaultCamera\", value: function() {\n          this.cameraFOV = this.defaultCameraFOV, this.aspectRatio = this.defaultAspectRatio, this.eyeX = this.defaultEyeX, this.eyeY = this.defaultEyeY, this.eyeZ = this.defaultEyeZ, this.centerX = this.defaultCenterX, this.centerY = this.defaultCenterY, this.centerZ = this.defaultCenterZ, this.upX = 0, this.upY = 1, this.upZ = 0, this.cameraNear = this.defaultCameraNear, this.cameraFar = this.defaultCameraFar, this.perspective(), this.camera(), this.cameraType = \"default\";\n        } }, { key: \"_resize\", value: function() {\n          this.cameraType === \"default\" && (this._computeCameraDefaultSettings(), this.cameraFOV = this.defaultCameraFOV, this.aspectRatio = this.defaultAspectRatio, this.perspective());\n        } }, { key: \"copy\", value: function() {\n          var f = new m.default.Camera(this._renderer);\n          return f.cameraFOV = this.cameraFOV, f.aspectRatio = this.aspectRatio, f.eyeX = this.eyeX, f.eyeY = this.eyeY, f.eyeZ = this.eyeZ, f.centerX = this.centerX, f.centerY = this.centerY, f.centerZ = this.centerZ, f.upX = this.upX, f.upY = this.upY, f.upZ = this.upZ, f.cameraNear = this.cameraNear, f.cameraFar = this.cameraFar, f.cameraType = this.cameraType, f.cameraMatrix = this.cameraMatrix.copy(), f.projMatrix = this.projMatrix.copy(), f.yScale = this.yScale, f;\n        } }, { key: \"_getLocalAxes\", value: function() {\n          var f = this.eyeX - this.centerX, r = this.eyeY - this.centerY, s = this.eyeZ - this.centerZ, n = Math.sqrt(f * f + r * r + s * s), n = (n !== 0 && (f /= n, r /= n, s /= n), this.upX), o = (a = this.upY) * s - (c = this.upZ) * r, i = -n * s + c * f, l = n * r - a * f, n = r * l - s * i, a = -f * l + s * o, c = f * i - r * o, p = Math.sqrt(o * o + i * i + l * l), p = (p !== 0 && (o /= p, i /= p, l /= p), Math.sqrt(n * n + a * a + c * c));\n          return p !== 0 && (n /= p, a /= p, c /= p), { x: [o, i, l], y: [n, a, c], z: [f, r, s] };\n        } }, { key: \"_orbit\", value: function(f, p, c) {\n          var i = this.eyeX - this.centerX, l = this.eyeY - this.centerY, n = this.eyeZ - this.centerZ, o = Math.hypot(i, l, n), i = new m.default.Vector(i, l, n).normalize(), l = new m.default.Vector(this.upX, this.upY, this.upZ).normalize(), n = m.default.Vector.cross(l, i).normalize(), a = m.default.Vector.cross(n, l), c = ((o = (o *= Math.pow(10, c)) < this.cameraNear ? this.cameraNear : o) > this.cameraFar && (o = this.cameraFar), Math.acos(Math.max(-1, Math.min(1, m.default.Vector.dot(i, l)))) + p), p = f;\n          (c <= 0 || c >= Math.PI) && (this.upX *= -1, this.upY *= -1, this.upZ *= -1), l.mult(Math.cos(c)), a.mult(Math.cos(p) * Math.sin(c)), n.mult(Math.sin(p) * Math.sin(c)), i.set(l).add(a).add(n), this.eyeX = o * i.x + this.centerX, this.eyeY = o * i.y + this.centerY, this.eyeZ = o * i.z + this.centerZ, this.camera(this.eyeX, this.eyeY, this.eyeZ, this.centerX, this.centerY, this.centerZ, this.upX, this.upY, this.upZ);\n        } }, { key: \"_orbitFree\", value: function(c, p, T) {\n          var i = this.eyeX - this.centerX, l = this.eyeY - this.centerY, n = this.eyeZ - this.centerZ, o = Math.hypot(i, l, n), i = new m.default.Vector(i, l, n).normalize(), l = new m.default.Vector(this.upX, this.upY, this.upZ), n = m.default.Vector.cross(l, i).normalize(), a = m.default.Vector.cross(i, n), _ = Math.atan2(p, c), _ = (a.mult(Math.sin(_)), n.mult(Math.cos(_)).add(a), Math.sqrt(c * c + p * p)), a = m.default.Vector.cross(i, n), c = ((o = (o *= Math.pow(10, T)) < this.cameraNear ? this.cameraNear : o) > this.cameraFar && (o = this.cameraFar), Math.cos(_)), p = Math.sin(_), T = l.dot(i), _ = l.dot(n), j = T * c + _ * p, T = -T * p + _ * c, _ = l.dot(a);\n          l.x = j * i.x + T * n.x + _ * a.x, l.y = j * i.y + T * n.y + _ * a.y, l.z = j * i.z + T * n.z + _ * a.z, n.mult(-p), i.mult(c).add(n).mult(o), this.camera(i.x + this.centerX, i.y + this.centerY, i.z + this.centerZ, this.centerX, this.centerY, this.centerZ, l.x, l.y, l.z);\n        } }, { key: \"_isActive\", value: function() {\n          return this === this._renderer._curCamera;\n        } }]) && y(h.prototype, g), u;\n      }(), m.default.prototype.setCamera = function(u) {\n        this._renderer._curCamera = u, this._renderer.uPMatrix.set(u.projMatrix);\n      }, t = m.default.Camera, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.math.hypot\": 175, \"core-js/modules/es.string.sub\": 205 }], 330: [function(t, H, C) {\n      t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.log2\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.float32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.math.log2\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.float32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function m(y, u) {\n        for (var h = 0; h < u.length; h++) {\n          var g = u[h];\n          g.enumerable = g.enumerable || !1, g.configurable = !0, \"value\" in g && (g.writable = !0), Object.defineProperty(y, g.key, g);\n        }\n      }\n      t.default.DataArray = function() {\n        function y() {\n          var g = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 128, f = this, r = y;\n          if (!(f instanceof r))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.length = 0, this.data = new Float32Array(g), this.initialLength = g;\n        }\n        var u, h;\n        return u = y, (h = [{ key: \"dataArray\", value: function() {\n          return this.subArray(0, this.length);\n        } }, { key: \"clear\", value: function() {\n          this.length = 0;\n        } }, { key: \"rescale\", value: function() {\n          var g;\n          this.length < this.data.length / 2 && (g = 1 << Math.ceil(Math.log2(this.length)), (g = new Float32Array(g)).set(this.data.subarray(0, this.length), 0), this.data = g);\n        } }, { key: \"reset\", value: function() {\n          this.clear(), this.data = new Float32Array(this.initialLength);\n        } }, { key: \"push\", value: function() {\n          for (var g = arguments.length, f = new Array(g), r = 0; r < g; r++)\n            f[r] = arguments[r];\n          this.ensureLength(this.length + f.length), this.data.set(f, this.length), this.length += f.length;\n        } }, { key: \"slice\", value: function(g, f) {\n          return this.data.slice(g, Math.min(f, this.length));\n        } }, { key: \"subArray\", value: function(g, f) {\n          return this.data.subarray(g, Math.min(f, this.length));\n        } }, { key: \"ensureLength\", value: function(g) {\n          for (; this.data.length < g; ) {\n            var f = new Float32Array(2 * this.data.length);\n            f.set(this.data, 0), this.data = f;\n          }\n        } }]) && m(u.prototype, h), y;\n      }(), t = t.default.DataArray, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.math.log2\": 176, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.float32-array\": 216, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236 }], 331: [function(E, H, C) {\n      function m(A) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(x) {\n          return typeof x;\n        } : function(x) {\n          return x && typeof Symbol == \"function\" && x.constructor === Symbol && x !== Symbol.prototype ? \"symbol\" : typeof x;\n        })(A);\n      }\n      function y(A) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(x) {\n          return m(x);\n        } : function(x) {\n          return x && typeof Symbol == \"function\" && x.constructor === Symbol && x !== Symbol.prototype ? \"symbol\" : m(x);\n        })(A);\n      }\n      E(\"core-js/modules/es.symbol\"), E(\"core-js/modules/es.symbol.description\"), E(\"core-js/modules/es.symbol.iterator\"), E(\"core-js/modules/es.array.fill\"), E(\"core-js/modules/es.array.includes\"), E(\"core-js/modules/es.array.iterator\"), E(\"core-js/modules/es.object.get-own-property-descriptor\"), E(\"core-js/modules/es.object.get-prototype-of\"), E(\"core-js/modules/es.object.to-string\"), E(\"core-js/modules/es.reflect.construct\"), E(\"core-js/modules/es.reflect.get\"), E(\"core-js/modules/es.regexp.to-string\"), E(\"core-js/modules/es.string.includes\"), E(\"core-js/modules/es.string.iterator\"), E(\"core-js/modules/es.typed-array.float32-array\"), E(\"core-js/modules/es.typed-array.uint8-array\"), E(\"core-js/modules/es.typed-array.uint8-clamped-array\"), E(\"core-js/modules/es.typed-array.copy-within\"), E(\"core-js/modules/es.typed-array.every\"), E(\"core-js/modules/es.typed-array.fill\"), E(\"core-js/modules/es.typed-array.filter\"), E(\"core-js/modules/es.typed-array.find\"), E(\"core-js/modules/es.typed-array.find-index\"), E(\"core-js/modules/es.typed-array.for-each\"), E(\"core-js/modules/es.typed-array.includes\"), E(\"core-js/modules/es.typed-array.index-of\"), E(\"core-js/modules/es.typed-array.iterator\"), E(\"core-js/modules/es.typed-array.join\"), E(\"core-js/modules/es.typed-array.last-index-of\"), E(\"core-js/modules/es.typed-array.map\"), E(\"core-js/modules/es.typed-array.reduce\"), E(\"core-js/modules/es.typed-array.reduce-right\"), E(\"core-js/modules/es.typed-array.reverse\"), E(\"core-js/modules/es.typed-array.set\"), E(\"core-js/modules/es.typed-array.slice\"), E(\"core-js/modules/es.typed-array.some\"), E(\"core-js/modules/es.typed-array.sort\"), E(\"core-js/modules/es.typed-array.subarray\"), E(\"core-js/modules/es.typed-array.to-locale-string\"), E(\"core-js/modules/es.typed-array.to-string\"), E(\"core-js/modules/es.weak-map\"), E(\"core-js/modules/web.dom-collections.iterator\"), E(\"core-js/modules/es.array.fill\"), E(\"core-js/modules/es.array.includes\"), E(\"core-js/modules/es.array.iterator\"), E(\"core-js/modules/es.object.get-prototype-of\"), E(\"core-js/modules/es.object.to-string\"), E(\"core-js/modules/es.string.includes\"), E(\"core-js/modules/es.typed-array.float32-array\"), E(\"core-js/modules/es.typed-array.uint8-array\"), E(\"core-js/modules/es.typed-array.uint8-clamped-array\"), E(\"core-js/modules/es.typed-array.copy-within\"), E(\"core-js/modules/es.typed-array.every\"), E(\"core-js/modules/es.typed-array.fill\"), E(\"core-js/modules/es.typed-array.filter\"), E(\"core-js/modules/es.typed-array.find\"), E(\"core-js/modules/es.typed-array.find-index\"), E(\"core-js/modules/es.typed-array.for-each\"), E(\"core-js/modules/es.typed-array.includes\"), E(\"core-js/modules/es.typed-array.index-of\"), E(\"core-js/modules/es.typed-array.iterator\"), E(\"core-js/modules/es.typed-array.join\"), E(\"core-js/modules/es.typed-array.last-index-of\"), E(\"core-js/modules/es.typed-array.map\"), E(\"core-js/modules/es.typed-array.reduce\"), E(\"core-js/modules/es.typed-array.reduce-right\"), E(\"core-js/modules/es.typed-array.reverse\"), E(\"core-js/modules/es.typed-array.set\"), E(\"core-js/modules/es.typed-array.slice\"), E(\"core-js/modules/es.typed-array.some\"), E(\"core-js/modules/es.typed-array.sort\"), E(\"core-js/modules/es.typed-array.subarray\"), E(\"core-js/modules/es.typed-array.to-locale-string\"), E(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (S = E(\"../core/main\")) && S.__esModule ? S : { default: S }, h = function(A) {\n        if (A && A.__esModule)\n          return A;\n        if (A === null || y(A) !== \"object\" && typeof A != \"function\")\n          return { default: A };\n        var x = r();\n        if (x && x.has(A))\n          return x.get(A);\n        var P, M = {}, R = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (P in A) {\n          var L;\n          Object.prototype.hasOwnProperty.call(A, P) && ((L = R ? Object.getOwnPropertyDescriptor(A, P) : null) && (L.get || L.set) ? Object.defineProperty(M, P, L) : M[P] = A[P]);\n        }\n        return M.default = A, x && x.set(A, M), M;\n      }(E(\"../core/constants\")), g = E(\"./p5.Texture\"), f = E(\"./p5.RendererGL\");\n      function r() {\n        var A;\n        return typeof WeakMap != \"function\" ? null : (A = /* @__PURE__ */ new WeakMap(), r = function() {\n          return A;\n        }, A);\n      }\n      function s(A, x) {\n        return function(P) {\n          if (Array.isArray(P))\n            return P;\n        }(A) || function(P, M) {\n          if (Symbol.iterator in Object(P) || Object.prototype.toString.call(P) === \"[object Arguments]\") {\n            var R = [], L = !0, F = !1, V = void 0;\n            try {\n              for (var G, U = P[Symbol.iterator](); !(L = (G = U.next()).done) && (R.push(G.value), !M || R.length !== M); L = !0)\n                ;\n            } catch (W) {\n              F = !0, V = W;\n            } finally {\n              try {\n                L || U.return == null || U.return();\n              } finally {\n                if (F)\n                  throw V;\n              }\n            }\n            return R;\n          }\n        }(A, x) || function() {\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }();\n      }\n      function o(A, x, P) {\n        return x in A ? Object.defineProperty(A, x, { value: P, enumerable: !0, configurable: !0, writable: !0 }) : A[x] = P, A;\n      }\n      function i(A, x) {\n        if (!(A instanceof x))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function l(A, x) {\n        for (var P = 0; P < x.length; P++) {\n          var M = x[P];\n          M.enumerable = M.enumerable || !1, M.configurable = !0, \"value\" in M && (M.writable = !0), Object.defineProperty(A, M.key, M);\n        }\n      }\n      function n(A, x, P) {\n        x && l(A.prototype, x);\n      }\n      function a(A, x, P) {\n        return (a = typeof Reflect < \"u\" && Reflect.get ? Reflect.get : function(F, R, L) {\n          var F = function(V, G) {\n            for (; !Object.prototype.hasOwnProperty.call(V, G) && (V = j(V)) !== null; )\n              ;\n            return V;\n          }(F, R);\n          if (F)\n            return (F = Object.getOwnPropertyDescriptor(F, R)).get ? F.get.call(L) : F.value;\n        })(A, x, P || A);\n      }\n      function c(A, x) {\n        return (c = Object.setPrototypeOf || function(P, M) {\n          return P.__proto__ = M, P;\n        })(A, x);\n      }\n      function p(A) {\n        return function() {\n          var x, P = j(A), P = (x = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (x = j(this).constructor, Reflect.construct(P, arguments, x)) : P.apply(this, arguments), this);\n          if (!x || y(x) !== \"object\" && typeof x != \"function\") {\n            if (P !== void 0)\n              return P;\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n          return x;\n        };\n      }\n      function j(A) {\n        return (j = Object.setPrototypeOf ? Object.getPrototypeOf : function(x) {\n          return x.__proto__ || Object.getPrototypeOf(x);\n        })(A);\n      }\n      var T = function(A) {\n        var x = M;\n        if (typeof A != \"function\" && A !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        x.prototype = Object.create(A && A.prototype, { constructor: { value: x, writable: !0, configurable: !0 } }), A && c(x, A);\n        var P = p(M);\n        function M(R) {\n          var L;\n          return i(this, M), (L = P.call(this, R.target._renderer)).fbo = R, L.yScale = -1, L;\n        }\n        return n(M, [{ key: \"_computeCameraDefaultSettings\", value: function() {\n          a(j(M.prototype), \"_computeCameraDefaultSettings\", this).call(this), this.defaultAspectRatio = this.fbo.width / this.fbo.height, this.defaultCameraFOV = 2 * Math.atan(this.fbo.height / 2 / this.defaultEyeZ);\n        } }]), M;\n      }(u.default.Camera), _ = (u.default.FramebufferCamera = T, function() {\n        function A(x, P) {\n          i(this, A), this.framebuffer = x, this.property = P;\n        }\n        return n(A, [{ key: \"rawTexture\", value: function() {\n          return this.framebuffer[this.property];\n        } }, { key: \"width\", get: function() {\n          return this.framebuffer.width * this.framebuffer.density;\n        } }, { key: \"height\", get: function() {\n          return this.framebuffer.height * this.framebuffer.density;\n        } }]), A;\n      }()), S = (u.default.FramebufferTexture = _, function() {\n        function A(x) {\n          var P = this, M = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, R = (i(this, A), this.target = x, this.target._renderer.framebuffers.add(this), this._isClipApplied = !1, this.pixels = [], this.format = M.format || h.UNSIGNED_BYTE, this.channels = M.channels || (x._renderer._pInst._glAttributes.alpha ? h.RGBA : h.RGB), this.useDepth = M.depth === void 0 || M.depth, this.depthFormat = M.depthFormat || h.FLOAT, this.textureFiltering = M.textureFiltering || h.LINEAR, M.antialias === void 0 ? this.antialiasSamples = x._renderer._pInst._glAttributes.antialias ? 2 : 0 : typeof M.antialias == \"number\" ? this.antialiasSamples = M.antialias : this.antialiasSamples = M.antialias ? 2 : 0, this.antialias = 0 < this.antialiasSamples, this.antialias && x.webglVersion !== h.WEBGL2 && (console.warn(\"Antialiasing is unsupported in a WebGL 1 context\"), this.antialias = !1), this.density = M.density || x.pixelDensity(), x._renderer.GL);\n          if (this.gl = R, M.width && M.height ? (L = x._renderer._adjustDimensions(M.width, M.height), this.width = L.adjustedWidth, this.height = L.adjustedHeight, this._autoSized = !1) : (M.width === void 0 != (M.height === void 0) && console.warn(\"Please supply both width and height for a framebuffer to give it a size. Only one was given, so the framebuffer will match the size of its canvas.\"), this.width = x.width, this.height = x.height, this._autoSized = !0), this._checkIfFormatsAvailable(), M.stencil && !this.useDepth && console.warn(\"A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored.\"), this.useStencil = this.useDepth && (M.stencil === void 0 || M.stencil), this.framebuffer = R.createFramebuffer(), !this.framebuffer)\n            throw new Error(\"Unable to create a framebuffer\");\n          if (this.antialias && (this.aaFramebuffer = R.createFramebuffer(), !this.aaFramebuffer))\n            throw new Error(\"Unable to create a framebuffer for antialiasing\");\n          this._recreateTextures();\n          var L = this.target._renderer._curCamera;\n          this.defaultCamera = this.createCamera(), this.filterCamera = this.createCamera(), this.target._renderer._curCamera = L, this.draw(function() {\n            return P.target.clear();\n          });\n        }\n        return n(A, [{ key: \"resize\", value: function(x, P) {\n          this._autoSized = !1;\n          var M = this.target._renderer._adjustDimensions(x, P);\n          x = M.adjustedWidth, P = M.adjustedHeight, this.width = x, this.height = P, this._handleResize();\n        } }, { key: \"pixelDensity\", value: function(x) {\n          if (!x)\n            return this.density;\n          this._autoSized = !1, this.density = x, this._handleResize();\n        } }, { key: \"autoSized\", value: function(x) {\n          if (x === void 0)\n            return this._autoSized;\n          this._autoSized = x, this._handleResize();\n        } }, { key: \"_checkIfFormatsAvailable\", value: function() {\n          var x = this.gl, x = (this.useDepth && this.target.webglVersion === h.WEBGL && !x.getExtension(\"WEBGL_depth_texture\") && (console.warn(\"Unable to create depth textures in this environment. Falling back to a framebuffer without depth.\"), this.useDepth = !1), this.useDepth && this.target.webglVersion === h.WEBGL && this.depthFormat === h.FLOAT && (console.warn(\"FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT.\"), this.depthFormat = h.UNSIGNED_INT), [h.UNSIGNED_BYTE, h.FLOAT, h.HALF_FLOAT].includes(this.format) || (console.warn(\"Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE.\"), this.format = h.UNSIGNED_BYTE), this.useDepth && ![h.UNSIGNED_INT, h.FLOAT].includes(this.depthFormat) && (console.warn(\"Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT.\"), this.depthFormat = h.FLOAT), (0, g.checkWebGLCapabilities)(this.target._renderer));\n          x.float || this.format !== h.FLOAT || (console.warn(\"This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE.\"), this.format = h.UNSIGNED_BYTE), this.useDepth && !x.float && this.depthFormat === h.FLOAT && (console.warn(\"This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT.\"), this.depthFormat = h.UNSIGNED_INT), x.halfFloat || this.format !== h.HALF_FLOAT || (console.warn(\"This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE.\"), this.format = h.UNSIGNED_BYTE), this.channels === h.RGB && [h.FLOAT, h.HALF_FLOAT].includes(this.format) && (console.warn(\"FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA.\"), this.channels = h.RGBA);\n        } }, { key: \"_recreateTextures\", value: function() {\n          var x = this.gl, P = (this._updateSize(), x.getParameter(x.TEXTURE_BINDING_2D)), M = x.getParameter(x.FRAMEBUFFER_BINDING), R = x.createTexture();\n          if (!R)\n            throw new Error(\"Unable to create color texture\");\n          x.bindTexture(x.TEXTURE_2D, R);\n          var L = this._glColorFormat();\n          if (x.texImage2D(x.TEXTURE_2D, 0, L.internalFormat, this.width * this.density, this.height * this.density, 0, L.format, L.type, null), this.colorTexture = R, x.bindFramebuffer(x.FRAMEBUFFER, this.framebuffer), x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, R, 0), this.useDepth) {\n            var R = x.createTexture();\n            if (!R)\n              throw new Error(\"Unable to create depth texture\");\n            var F = this._glDepthFormat();\n            x.bindTexture(x.TEXTURE_2D, R), x.texImage2D(x.TEXTURE_2D, 0, F.internalFormat, this.width * this.density, this.height * this.density, 0, F.format, F.type, null), x.framebufferTexture2D(x.FRAMEBUFFER, this.useStencil ? x.DEPTH_STENCIL_ATTACHMENT : x.DEPTH_ATTACHMENT, x.TEXTURE_2D, R, 0), this.depthTexture = R;\n          }\n          this.antialias && (this.colorRenderbuffer = x.createRenderbuffer(), x.bindRenderbuffer(x.RENDERBUFFER, this.colorRenderbuffer), x.renderbufferStorageMultisample(x.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, x.getParameter(x.MAX_SAMPLES))), L.internalFormat, this.width * this.density, this.height * this.density), this.useDepth && (F = this._glDepthFormat(), this.depthRenderbuffer = x.createRenderbuffer(), x.bindRenderbuffer(x.RENDERBUFFER, this.depthRenderbuffer), x.renderbufferStorageMultisample(x.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, x.getParameter(x.MAX_SAMPLES))), F.internalFormat, this.width * this.density, this.height * this.density)), x.bindFramebuffer(x.FRAMEBUFFER, this.aaFramebuffer), x.framebufferRenderbuffer(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.RENDERBUFFER, this.colorRenderbuffer), this.useDepth && x.framebufferRenderbuffer(x.FRAMEBUFFER, this.useStencil ? x.DEPTH_STENCIL_ATTACHMENT : x.DEPTH_ATTACHMENT, x.RENDERBUFFER, this.depthRenderbuffer)), this.useDepth && (this.depth = new _(this, \"depthTexture\"), R = x.NEAREST, this.depthP5Texture = new u.default.Texture(this.target._renderer, this.depth, { minFilter: R, magFilter: R }), this.target._renderer.textures.set(this.depth, this.depthP5Texture)), this.color = new _(this, \"colorTexture\"), L = this.textureFiltering === h.LINEAR ? x.LINEAR : x.NEAREST, this.colorP5Texture = new u.default.Texture(this.target._renderer, this.color, { minFilter: L, magFilter: L }), this.target._renderer.textures.set(this.color, this.colorP5Texture), x.bindTexture(x.TEXTURE_2D, P), x.bindFramebuffer(x.FRAMEBUFFER, M);\n        } }, { key: \"_glColorFormat\", value: function() {\n          var x, P, M = this.gl, R = this.format === h.FLOAT ? M.FLOAT : this.format === h.HALF_FLOAT ? this.target.webglVersion === h.WEBGL2 ? M.HALF_FLOAT : M.getExtension(\"OES_texture_half_float\").HALF_FLOAT_OES : M.UNSIGNED_BYTE, L = this.channels === h.RGBA ? M.RGBA : M.RGB;\n          return { internalFormat: this.target.webglVersion === h.WEBGL2 ? (o(P = {}, M.FLOAT, o({}, M.RGBA, M.RGBA32F)), o(P, M.HALF_FLOAT, o({}, M.RGBA, M.RGBA16F)), o(P, M.UNSIGNED_BYTE, (o(x = {}, M.RGBA, M.RGBA8), o(x, M.RGB, M.RGB8), x)), P[R][L]) : this.format === h.HALF_FLOAT ? M.RGBA : L, format: L, type: R };\n        } }, { key: \"_glDepthFormat\", value: function() {\n          var M = this.gl, x = this.useStencil ? this.depthFormat === h.FLOAT ? M.FLOAT_32_UNSIGNED_INT_24_8_REV : this.target.webglVersion === h.WEBGL2 ? M.UNSIGNED_INT_24_8 : M.getExtension(\"WEBGL_depth_texture\").UNSIGNED_INT_24_8_WEBGL : this.depthFormat === h.FLOAT ? M.FLOAT : M.UNSIGNED_INT, P = this.useStencil ? M.DEPTH_STENCIL : M.DEPTH_COMPONENT, M = this.useStencil ? this.depthFormat === h.FLOAT ? M.DEPTH32F_STENCIL8 : this.target.webglVersion === h.WEBGL2 ? M.DEPTH24_STENCIL8 : M.DEPTH_STENCIL : this.target.webglVersion === h.WEBGL2 ? this.depthFormat === h.FLOAT ? M.DEPTH_COMPONENT32F : M.DEPTH_COMPONENT24 : M.DEPTH_COMPONENT;\n          return { internalFormat: M, format: P, type: x };\n        } }, { key: \"_updateSize\", value: function() {\n          this._autoSized && (this.width = this.target.width, this.height = this.target.height, this.density = this.target.pixelDensity());\n        } }, { key: \"_canvasSizeChanged\", value: function() {\n          this._autoSized && this._handleResize();\n        } }, { key: \"_handleResize\", value: function() {\n          var R = this.color, x = this.depth, P = this.colorRenderbuffer, M = this.depthRenderbuffer, R = (this._deleteTexture(R), x && this._deleteTexture(x), this.gl);\n          P && R.deleteRenderbuffer(P), M && R.deleteRenderbuffer(M), this._recreateTextures(), this.defaultCamera._resize();\n        } }, { key: \"createCamera\", value: function() {\n          var x = new T(this);\n          return x._computeCameraDefaultSettings(), x._setDefaultCamera(), this.target._renderer._curCamera = x;\n        } }, { key: \"_deleteTexture\", value: function(x) {\n          this.gl.deleteTexture(x.rawTexture()), this.target._renderer.textures.delete(x);\n        } }, { key: \"remove\", value: function() {\n          var x = this.gl;\n          this._deleteTexture(this.color), this.depth && this._deleteTexture(this.depth), x.deleteFramebuffer(this.framebuffer), this.aaFramebuffer && x.deleteFramebuffer(this.aaFramebuffer), this.depthRenderbuffer && x.deleteRenderbuffer(this.depthRenderbuffer), this.colorRenderbuffer && x.deleteRenderbuffer(this.colorRenderbuffer), this.target._renderer.framebuffers.delete(this);\n        } }, { key: \"begin\", value: function() {\n          this.prevFramebuffer = this.target._renderer.activeFramebuffer(), this.prevFramebuffer && this.prevFramebuffer._beforeEnd(), this.target._renderer.activeFramebuffers.push(this), this._beforeBegin(), this.target.push(), this.target.setCamera(this.defaultCamera), this.target._renderer.uMVMatrix.set(this.target._renderer._curCamera.cameraMatrix), this.target._renderer._applyStencilTestIfClipping();\n        } }, { key: \"_framebufferToBind\", value: function() {\n          return this.antialias ? this.aaFramebuffer : this.framebuffer;\n        } }, { key: \"_beforeBegin\", value: function() {\n          var x = this.gl;\n          x.bindFramebuffer(x.FRAMEBUFFER, this._framebufferToBind()), this.target._renderer.viewport(this.width * this.density, this.height * this.density);\n        } }, { key: \"_beforeEnd\", value: function() {\n          if (this.antialias) {\n            var x = this.gl, P = (x.bindFramebuffer(x.READ_FRAMEBUFFER, this.aaFramebuffer), x.bindFramebuffer(x.DRAW_FRAMEBUFFER, this.framebuffer), [[x.COLOR_BUFFER_BIT, this.colorP5Texture.glMagFilter]]);\n            this.useDepth && P.push([x.DEPTH_BUFFER_BIT, this.depthP5Texture.glMagFilter]);\n            for (var M = 0, R = P; M < R.length; M++) {\n              var F = s(R[M], 2), L = F[0], F = F[1];\n              x.blitFramebuffer(0, 0, this.width * this.density, this.height * this.density, 0, 0, this.width * this.density, this.height * this.density, L, F);\n            }\n          }\n        } }, { key: \"end\", value: function() {\n          var x = this.gl;\n          if (this.target.pop(), this.target._renderer.activeFramebuffers.pop() !== this)\n            throw new Error(\"It looks like you've called end() while another Framebuffer is active.\");\n          this._beforeEnd(), this.prevFramebuffer ? this.prevFramebuffer._beforeBegin() : (x.bindFramebuffer(x.FRAMEBUFFER, null), this.target._renderer.viewport(this.target._renderer._origViewport.width, this.target._renderer._origViewport.height)), this.target._renderer._applyStencilTestIfClipping();\n        } }, { key: \"draw\", value: function(x) {\n          this.begin(), x(), this.end();\n        } }, { key: \"loadPixels\", value: function() {\n          var x = this.gl, P = this.target._renderer.activeFramebuffer(), M = (x.bindFramebuffer(x.FRAMEBUFFER, this.framebuffer), this._glColorFormat());\n          this.pixels = (0, f.readPixelsWebGL)(this.pixels, x, this.framebuffer, 0, 0, this.width * this.density, this.height * this.density, M.format, M.type), P ? x.bindFramebuffer(x.FRAMEBUFFER, P._framebufferToBind()) : x.bindFramebuffer(x.FRAMEBUFFER, null);\n        } }, { key: \"get\", value: function(x, P, M, R) {\n          u.default._validateParameters(\"p5.Framebuffer.get\", arguments);\n          var L = this._glColorFormat();\n          if (x === void 0 && P === void 0)\n            P = x = 0, M = this.width, R = this.height;\n          else if (M === void 0 && R === void 0)\n            return (x < 0 || P < 0 || x >= this.width || P >= this.height) && (console.warn(\"The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped.\"), x = this.target.constrain(x, 0, this.width - 1), P = this.target.constrain(P, 0, this.height - 1)), (0, f.readPixelWebGL)(this.gl, this.framebuffer, x * this.density, P * this.density, L.format, L.type);\n          x = this.target.constrain(x, 0, this.width - 1), P = this.target.constrain(P, 0, this.height - 1), M = this.target.constrain(M, 1, this.width - x), R = this.target.constrain(R, 1, this.height - P);\n          for (var F = (0, f.readPixelsWebGL)(void 0, this.gl, this.framebuffer, x * this.density, P * this.density, M * this.density, R * this.density, L.format, L.type), V = new Uint8ClampedArray(M * R * this.density * this.density * 4), G = (V.fill(255), L.type === this.gl.RGB ? 3 : 4), U = 0; U < R * this.density; U++)\n            for (var W = 0; W < M * this.density; W++)\n              for (var X = 0; X < 4; X++) {\n                var ne, b = 4 * (U * M * this.density + W) + X;\n                X < G && (ne = G == 4 ? b : (U * M * this.density + W) * G + X, V[b] = F[ne]);\n              }\n          return x = new u.default.Image(M * this.density, R * this.density), x.imageData = x.canvas.getContext(\"2d\").createImageData(x.width, x.height), x.imageData.data.set(V), x.pixels = x.imageData.data, x.updatePixels(), this.density !== 1 && x.resize(M, R), x;\n        } }, { key: \"updatePixels\", value: function() {\n          var x = this.gl, P = (this.colorP5Texture.bindTexture(), this._glColorFormat()), M = P.format === x.RGBA ? 4 : 3, M = this.width * this.height * this.density * this.density * M, R = P.type === x.UNSIGNED_BYTE ? Uint8Array : Float32Array;\n          if (!(this.pixels instanceof R) || this.pixels.length !== M)\n            throw new Error(\"The pixels array has not been set correctly. Please call loadPixels() before updatePixels().\");\n          x.texImage2D(x.TEXTURE_2D, 0, P.internalFormat, this.width * this.density, this.height * this.density, 0, P.format, P.type, this.pixels), this.colorP5Texture.unbindTexture(), R = this.target._renderer.activeFramebuffer(), this.antialias ? (this.begin(), this.target.push(), this.target.imageMode(this.target.CENTER), this.target.resetMatrix(), this.target.noStroke(), this.target.clear(), this.target.image(this, 0, 0), this.target.pop(), this.useDepth && (x.clearDepth(1), x.clear(x.DEPTH_BUFFER_BIT)), this.end()) : (x.bindFramebuffer(x.FRAMEBUFFER, this.framebuffer), this.useDepth && (x.clearDepth(1), x.clear(x.DEPTH_BUFFER_BIT)), R ? x.bindFramebuffer(x.FRAMEBUFFER, R._framebufferToBind()) : x.bindFramebuffer(x.FRAMEBUFFER, null));\n        } }]), A;\n      }()), E = u.default.Framebuffer = S;\n      C.default = E;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.RendererGL\": 337, \"./p5.Texture\": 339, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.reflect.get\": 190, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.float32-array\": 216, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/es.typed-array.uint8-clamped-array\": 240, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 332: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      function y(o) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.flat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.unscopables.flat\"), t(\"core-js/modules/es.map\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.flat\"), t(\"core-js/modules/es.array.for-each\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.unscopables.flat\"), t(\"core-js/modules/es.map\"), t(\"core-js/modules/es.number.constructor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.set\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/web.dom-collections.for-each\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (s = t(\"../core/main\")) && s.__esModule ? s : { default: s }, h = function(o) {\n        if (o && o.__esModule)\n          return o;\n        if (o === null || y(o) !== \"object\" && typeof o != \"function\")\n          return { default: o };\n        var i = g();\n        if (i && i.has(o))\n          return i.get(o);\n        var l, n = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (l in o) {\n          var c;\n          Object.prototype.hasOwnProperty.call(o, l) && ((c = a ? Object.getOwnPropertyDescriptor(o, l) : null) && (c.get || c.set) ? Object.defineProperty(n, l, c) : n[l] = o[l]);\n        }\n        return n.default = o, i && i.set(o, n), n;\n      }(t(\"../core/constants\"));\n      function g() {\n        var o;\n        return typeof WeakMap != \"function\" ? null : (o = /* @__PURE__ */ new WeakMap(), g = function() {\n          return o;\n        }, o);\n      }\n      function f(o) {\n        return function(i) {\n          if (Array.isArray(i)) {\n            for (var l = 0, n = new Array(i.length); l < i.length; l++)\n              n[l] = i[l];\n            return n;\n          }\n        }(o) || function(i) {\n          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === \"[object Arguments]\")\n            return Array.from(i);\n        }(o) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function r(o, i) {\n        for (var l = 0; l < i.length; l++) {\n          var n = i[l];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);\n        }\n      }\n      u.default.Geometry = function() {\n        function o(n, a, c) {\n          if (!(this instanceof o))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.vertices = [], this.boundingBoxCache = null, this.lineVertices = new u.default.DataArray(), this.lineTangentsIn = new u.default.DataArray(), this.lineTangentsOut = new u.default.DataArray(), this.lineSides = new u.default.DataArray(), this.vertexNormals = [], this.faces = [], this.uvs = [], this.edges = [], this.vertexColors = [], this.vertexStrokeColors = [], this.lineVertexColors = new u.default.DataArray(), this.detailX = n !== void 0 ? n : 1, this.detailY = a !== void 0 ? a : 1, this.dirtyFlags = {}, this._hasFillTransparency = void 0, this._hasStrokeTransparency = void 0, c instanceof Function && c.call(this);\n        }\n        var i, l;\n        return i = o, (l = [{ key: \"calculateBoundingBox\", value: function() {\n          if (!this.boundingBoxCache) {\n            for (var n = new u.default.Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), a = new u.default.Vector(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), c = 0; c < this.vertices.length; c++) {\n              var p = this.vertices[c];\n              n.x = Math.min(n.x, p.x), n.y = Math.min(n.y, p.y), n.z = Math.min(n.z, p.z), a.x = Math.max(a.x, p.x), a.y = Math.max(a.y, p.y), a.z = Math.max(a.z, p.z);\n            }\n            var j = new u.default.Vector(a.x - n.x, a.y - n.y, a.z - n.z), T = new u.default.Vector((n.x + a.x) / 2, (n.y + a.y) / 2, (n.z + a.z) / 2);\n            this.boundingBoxCache = { min: n, max: a, size: j, offset: T };\n          }\n          return this.boundingBoxCache;\n        } }, { key: \"reset\", value: function() {\n          this._hasFillTransparency = void 0, this._hasStrokeTransparency = void 0, this.lineVertices.clear(), this.lineTangentsIn.clear(), this.lineTangentsOut.clear(), this.lineSides.clear(), this.vertices.length = 0, this.edges.length = 0, this.vertexColors.length = 0, this.vertexStrokeColors.length = 0, this.lineVertexColors.clear(), this.vertexNormals.length = 0, this.uvs.length = 0, this.dirtyFlags = {};\n        } }, { key: \"hasFillTransparency\", value: function() {\n          if (this._hasFillTransparency === void 0) {\n            this._hasFillTransparency = !1;\n            for (var n = 0; n < this.vertexColors.length; n += 4)\n              if (this.vertexColors[n + 3] < 1) {\n                this._hasFillTransparency = !0;\n                break;\n              }\n          }\n          return this._hasFillTransparency;\n        } }, { key: \"hasStrokeTransparency\", value: function() {\n          if (this._hasStrokeTransparency === void 0) {\n            this._hasStrokeTransparency = !1;\n            for (var n = 0; n < this.lineVertexColors.length; n += 4)\n              if (this.lineVertexColors[n + 3] < 1) {\n                this._hasStrokeTransparency = !0;\n                break;\n              }\n          }\n          return this._hasStrokeTransparency;\n        } }, { key: \"clearColors\", value: function() {\n          return this.vertexColors = [], this;\n        } }, { key: \"flipU\", value: function() {\n          this.uvs = this.uvs.flat().map(function(n, a) {\n            return a % 2 == 0 ? 1 - n : n;\n          });\n        } }, { key: \"flipV\", value: function() {\n          this.uvs = this.uvs.flat().map(function(n, a) {\n            return a % 2 == 0 ? n : 1 - n;\n          });\n        } }, { key: \"computeFaces\", value: function() {\n          this.faces.length = 0;\n          for (var n, a, c, p = this.detailX + 1, j = 0; j < this.detailY; j++)\n            for (var T = 0; T < this.detailX; T++)\n              a = (j + 1) * p + T + 1, this.faces.push([j * p + T, n = j * p + T + 1, c = (j + 1) * p + T]), this.faces.push([c, n, a]);\n          return this;\n        } }, { key: \"_getFaceNormal\", value: function(a) {\n          var a = this.faces[a], c = this.vertices[a[0]], j = this.vertices[a[1]], a = this.vertices[a[2]], j = u.default.Vector.sub(j, c), a = u.default.Vector.sub(a, c), c = u.default.Vector.cross(j, a), p = u.default.Vector.mag(c), j = p / (u.default.Vector.mag(j) * u.default.Vector.mag(a));\n          return j === 0 || isNaN(j) ? (console.warn(\"p5.Geometry.prototype._getFaceNormal:\", \"face has colinear sides or a repeated vertex\"), c) : (1 < j && (j = 1), c.mult(Math.asin(j) / p));\n        } }, { key: \"computeNormals\", value: function() {\n          var n, a = this, c = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : h.FLAT, p = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).roundToPrecision, j = this.vertexNormals, T = this.vertices, _ = this.faces;\n          if (c === h.SMOOTH) {\n            for (var S = {}, E = [], A = Math.pow(10, p === void 0 ? 3 : p), x = function(F) {\n              return Math.round(F * A) / A;\n            }, P = function(F) {\n              return \"\".concat(x(F.x), \",\").concat(x(F.y), \",\").concat(x(F.z));\n            }, M = 0; M < T.length; M++) {\n              var R = T[M], L = P(R);\n              S[L] === void 0 && (S[L] = E.length, E.push(R));\n            }\n            _.forEach(function(F) {\n              for (var V = 0; V < 3; ++V) {\n                var G = F[V], G = T[G], G = P(G);\n                F[V] = S[G];\n              }\n            }), this.edges.forEach(function(F) {\n              for (var V = 0; V < 2; ++V) {\n                var G = F[V], G = T[G], G = P(G);\n                F[V] = S[G];\n              }\n            }), this.vertices = T = E;\n          }\n          for (n = j.length = 0; n < T.length; ++n)\n            j.push(new u.default.Vector());\n          for (_.forEach(function(F, V) {\n            for (var G = a._getFaceNormal(V), U = 0; U < 3; ++U) {\n              var W = F[U];\n              j[W].add(G);\n            }\n          }), n = 0; n < T.length; ++n)\n            j[n].normalize();\n          return this;\n        } }, { key: \"averageNormals\", value: function() {\n          for (var n = 0; n <= this.detailY; n++) {\n            var a = this.detailX + 1, c = u.default.Vector.add(this.vertexNormals[n * a], this.vertexNormals[n * a + this.detailX]), c = u.default.Vector.div(c, 2);\n            this.vertexNormals[n * a] = c, this.vertexNormals[n * a + this.detailX] = c;\n          }\n          return this;\n        } }, { key: \"averagePoleNormals\", value: function() {\n          for (var n = new u.default.Vector(0, 0, 0), a = 0; a < this.detailX; a++)\n            n.add(this.vertexNormals[a]);\n          for (var n = u.default.Vector.div(n, this.detailX), c = 0; c < this.detailX; c++)\n            this.vertexNormals[c] = n;\n          n = new u.default.Vector(0, 0, 0);\n          for (var p = this.vertices.length - 1; p > this.vertices.length - 1 - this.detailX; p--)\n            n.add(this.vertexNormals[p]);\n          n = u.default.Vector.div(n, this.detailX);\n          for (var j = this.vertices.length - 1; j > this.vertices.length - 1 - this.detailX; j--)\n            this.vertexNormals[j] = n;\n          return this;\n        } }, { key: \"_makeTriangleEdges\", value: function() {\n          for (var n = this.edges.length = 0; n < this.faces.length; n++)\n            this.edges.push([this.faces[n][0], this.faces[n][1]]), this.edges.push([this.faces[n][1], this.faces[n][2]]), this.edges.push([this.faces[n][2], this.faces[n][0]]);\n          return this;\n        } }, { key: \"_edgesToVertices\", value: function() {\n          this.lineVertices.clear(), this.lineTangentsIn.clear(), this.lineTangentsOut.clear(), this.lineSides.clear();\n          for (var n, a = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), p = 0; p < this.edges.length; p++) {\n            var j, T = this.edges[p - 1], _ = this.edges[p], S = this.vertices[_[0]], E = this.vertices[_[1]], A = 0 < this.vertexStrokeColors.length ? this.vertexStrokeColors.slice(4 * _[0], 4 * (_[0] + 1)) : [0, 0, 0, 0], x = 0 < this.vertexStrokeColors.length ? this.vertexStrokeColors.slice(4 * _[1], 4 * (_[1] + 1)) : [0, 0, 0, 0], P = E.copy().sub(S).normalize(), M = 0 < P.magSq();\n            M && this._addSegment(S, E, A, x, P), 0 < p && T[1] === _[0] ? c.has(_[0]) || (c.add(_[0]), a.delete(_[0]), n && M && P.dot(n) < 1 - 1e-8 && this._addJoin(S, n, P, A)) : (M && !c.has(_[0]) && ((j = a.get(_[0])) ? (this._addJoin(S, j.dir, P, A), a.delete(_[0]), c.add(_[0])) : a.set(_[0], { point: S, dir: P.copy().mult(-1), color: A })), n && !c.has(T[1]) && ((j = a.get(T[1])) ? (this._addJoin(this.vertices[T[1]], n, j.dir.copy().mult(-1), A), a.delete(T[1]), c.add(T[1])) : a.set(T[1], { point: this.vertices[T[1]], dir: n, color: A }), n = void 0)), p !== this.edges.length - 1 || c.has(_[1]) || ((S = a.get(_[1])) ? (this._addJoin(E, P, S.dir.copy().mult(-1), x), a.delete(_[1]), c.add(_[1])) : a.set(_[1], { point: E, dir: P, color: x })), M && (n = P);\n          }\n          var R = !0, L = !1, F = void 0;\n          try {\n            for (var V, G = a.values()[Symbol.iterator](); !(R = (V = G.next()).done); R = !0) {\n              var U = V.value, W = U.point, X = U.dir, ne = U.color;\n              this._addCap(W, X, ne);\n            }\n          } catch (b) {\n            L = !0, F = b;\n          } finally {\n            try {\n              R || G.return == null || G.return();\n            } finally {\n              if (L)\n                throw F;\n            }\n          }\n          return this;\n        } }, { key: \"_addSegment\", value: function(T, _, c, p, j) {\n          var T = T.array(), _ = _.array(), S = j.array();\n          this.lineSides.push(1, 1, -1, 1, -1, -1);\n          for (var E = 0, A = [this.lineTangentsIn, this.lineTangentsOut]; E < A.length; E++)\n            for (var x = A[E], P = 0; P < 6; P++)\n              x.push.apply(x, f(S));\n          return (j = this.lineVertices).push.apply(j, f(T).concat(f(_), f(T), f(_), f(_), f(T))), (j = this.lineVertexColors).push.apply(j, f(c).concat(f(p), f(c), f(p), f(p), f(c))), this;\n        } }, { key: \"_addCap\", value: function(n, a, c) {\n          for (var p, j = n.array(), T = a.array(), _ = [0, 0, 0], S = 0; S < 6; S++)\n            (p = this.lineVertices).push.apply(p, f(j)), (p = this.lineTangentsIn).push.apply(p, f(T)), (p = this.lineTangentsOut).push.apply(p, _), (p = this.lineVertexColors).push.apply(p, f(c));\n          return this.lineSides.push(-1, 2, -2, 1, 2, -1), this;\n        } }, { key: \"_addJoin\", value: function(n, a, c, p) {\n          for (var j, T = n.array(), _ = a.array(), S = c.array(), E = 0; E < 12; E++)\n            (j = this.lineVertices).push.apply(j, f(T)), (j = this.lineTangentsIn).push.apply(j, f(_)), (j = this.lineTangentsOut).push.apply(j, f(S)), (j = this.lineVertexColors).push.apply(j, f(p));\n          return this.lineSides.push(-1, -3, -2, -1, 0, -3), this.lineSides.push(3, 1, 2, 3, 0, 1), this;\n        } }, { key: \"normalize\", value: function() {\n          if (0 < this.vertices.length) {\n            for (var n = this.vertices[0].copy(), a = this.vertices[0].copy(), c = 0; c < this.vertices.length; c++)\n              n.x = Math.max(n.x, this.vertices[c].x), a.x = Math.min(a.x, this.vertices[c].x), n.y = Math.max(n.y, this.vertices[c].y), a.y = Math.min(a.y, this.vertices[c].y), n.z = Math.max(n.z, this.vertices[c].z), a.z = Math.min(a.z, this.vertices[c].z);\n            for (var p = u.default.Vector.lerp(n, a, 0.5), j = u.default.Vector.sub(n, a), T = 200 / Math.max(Math.max(j.x, j.y), j.z), _ = 0; _ < this.vertices.length; _++)\n              this.vertices[_].sub(p), this.vertices[_].mult(T);\n          }\n          return this;\n        } }]) && r(i.prototype, l), o;\n      }();\n      var s = u.default.Geometry;\n      C.default = s;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.flat\": 159, \"core-js/modules/es.array.for-each\": 160, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.unscopables.flat\": 172, \"core-js/modules/es.map\": 174, \"core-js/modules/es.number.constructor\": 178, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.set\": 194, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.sub\": 205, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.for-each\": 242, \"core-js/modules/web.dom-collections.iterator\": 243 }], 333: [function(g, H, C) {\n      g(\"core-js/modules/es.array.iterator\"), g(\"core-js/modules/es.object.to-string\"), g(\"core-js/modules/es.typed-array.float32-array\"), g(\"core-js/modules/es.typed-array.copy-within\"), g(\"core-js/modules/es.typed-array.every\"), g(\"core-js/modules/es.typed-array.fill\"), g(\"core-js/modules/es.typed-array.filter\"), g(\"core-js/modules/es.typed-array.find\"), g(\"core-js/modules/es.typed-array.find-index\"), g(\"core-js/modules/es.typed-array.for-each\"), g(\"core-js/modules/es.typed-array.includes\"), g(\"core-js/modules/es.typed-array.index-of\"), g(\"core-js/modules/es.typed-array.iterator\"), g(\"core-js/modules/es.typed-array.join\"), g(\"core-js/modules/es.typed-array.last-index-of\"), g(\"core-js/modules/es.typed-array.map\"), g(\"core-js/modules/es.typed-array.reduce\"), g(\"core-js/modules/es.typed-array.reduce-right\"), g(\"core-js/modules/es.typed-array.reverse\"), g(\"core-js/modules/es.typed-array.set\"), g(\"core-js/modules/es.typed-array.slice\"), g(\"core-js/modules/es.typed-array.some\"), g(\"core-js/modules/es.typed-array.sort\"), g(\"core-js/modules/es.typed-array.subarray\"), g(\"core-js/modules/es.typed-array.to-locale-string\"), g(\"core-js/modules/es.typed-array.to-string\"), g(\"core-js/modules/es.array.iterator\"), g(\"core-js/modules/es.object.to-string\"), g(\"core-js/modules/es.typed-array.float32-array\"), g(\"core-js/modules/es.typed-array.copy-within\"), g(\"core-js/modules/es.typed-array.every\"), g(\"core-js/modules/es.typed-array.fill\"), g(\"core-js/modules/es.typed-array.filter\"), g(\"core-js/modules/es.typed-array.find\"), g(\"core-js/modules/es.typed-array.find-index\"), g(\"core-js/modules/es.typed-array.for-each\"), g(\"core-js/modules/es.typed-array.includes\"), g(\"core-js/modules/es.typed-array.index-of\"), g(\"core-js/modules/es.typed-array.iterator\"), g(\"core-js/modules/es.typed-array.join\"), g(\"core-js/modules/es.typed-array.last-index-of\"), g(\"core-js/modules/es.typed-array.map\"), g(\"core-js/modules/es.typed-array.reduce\"), g(\"core-js/modules/es.typed-array.reduce-right\"), g(\"core-js/modules/es.typed-array.reverse\"), g(\"core-js/modules/es.typed-array.set\"), g(\"core-js/modules/es.typed-array.slice\"), g(\"core-js/modules/es.typed-array.some\"), g(\"core-js/modules/es.typed-array.sort\"), g(\"core-js/modules/es.typed-array.subarray\"), g(\"core-js/modules/es.typed-array.to-locale-string\"), g(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (g = g(\"../core/main\")) && g.__esModule ? g : { default: g };\n      function y(f, r) {\n        for (var s = 0; s < r.length; s++) {\n          var o = r[s];\n          o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(f, o.key, o);\n        }\n      }\n      var u = Array, h = function(f) {\n        return Array.isArray(f);\n      }, g = (typeof Float32Array < \"u\" && (u = Float32Array, h = function(f) {\n        return Array.isArray(f) || f instanceof Float32Array;\n      }), m.default.Matrix = function() {\n        function f() {\n          var i = this, l = f;\n          if (i instanceof l)\n            return arguments.length && ((i = arguments.length - 1) < 0 || arguments.length <= i ? void 0 : arguments[i]) instanceof m.default && (this.p5 = (l = arguments.length - 1) < 0 || arguments.length <= l ? void 0 : arguments[l]), (arguments.length <= 0 ? void 0 : arguments[0]) === \"mat3\" ? this.mat3 = Array.isArray(arguments.length <= 1 ? void 0 : arguments[1]) ? arguments.length <= 1 ? void 0 : arguments[1] : new u([1, 0, 0, 0, 1, 0, 0, 0, 1]) : this.mat4 = Array.isArray(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : new u([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this;\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n        var r, s, o;\n        return r = f, o = [{ key: \"identity\", value: function(i) {\n          return new m.default.Matrix(i);\n        } }], (s = [{ key: \"set\", value: function(i) {\n          var l = arguments;\n          if (i instanceof m.default.Matrix ? l = i.mat4 : h(i) && (l = i), l.length !== 16)\n            m.default._friendlyError(\"Expected 16 values but received \".concat(l.length, \".\"), \"p5.Matrix.set\");\n          else\n            for (var n = 0; n < 16; n++)\n              this.mat4[n] = l[n];\n          return this;\n        } }, { key: \"get\", value: function() {\n          return new m.default.Matrix(this.mat4, this.p5);\n        } }, { key: \"copy\", value: function() {\n          var i;\n          return this.mat3 !== void 0 ? ((i = new m.default.Matrix(\"mat3\", this.p5)).mat3[0] = this.mat3[0], i.mat3[1] = this.mat3[1], i.mat3[2] = this.mat3[2], i.mat3[3] = this.mat3[3], i.mat3[4] = this.mat3[4], i.mat3[5] = this.mat3[5], i.mat3[6] = this.mat3[6], i.mat3[7] = this.mat3[7], i.mat3[8] = this.mat3[8]) : ((i = new m.default.Matrix(this.p5)).mat4[0] = this.mat4[0], i.mat4[1] = this.mat4[1], i.mat4[2] = this.mat4[2], i.mat4[3] = this.mat4[3], i.mat4[4] = this.mat4[4], i.mat4[5] = this.mat4[5], i.mat4[6] = this.mat4[6], i.mat4[7] = this.mat4[7], i.mat4[8] = this.mat4[8], i.mat4[9] = this.mat4[9], i.mat4[10] = this.mat4[10], i.mat4[11] = this.mat4[11], i.mat4[12] = this.mat4[12], i.mat4[13] = this.mat4[13], i.mat4[14] = this.mat4[14], i.mat4[15] = this.mat4[15]), i;\n        } }, { key: \"transpose\", value: function(i) {\n          var l, n, a, c, p, j;\n          return i instanceof m.default.Matrix ? (l = i.mat4[1], n = i.mat4[2], a = i.mat4[3], c = i.mat4[6], p = i.mat4[7], j = i.mat4[11], this.mat4[0] = i.mat4[0], this.mat4[1] = i.mat4[4], this.mat4[2] = i.mat4[8], this.mat4[3] = i.mat4[12], this.mat4[4] = l, this.mat4[5] = i.mat4[5], this.mat4[6] = i.mat4[9], this.mat4[7] = i.mat4[13], this.mat4[8] = n, this.mat4[9] = c, this.mat4[10] = i.mat4[10], this.mat4[11] = i.mat4[14], this.mat4[12] = a, this.mat4[13] = p, this.mat4[14] = j, this.mat4[15] = i.mat4[15]) : h(i) && (l = i[1], n = i[2], a = i[3], c = i[6], p = i[7], j = i[11], this.mat4[0] = i[0], this.mat4[1] = i[4], this.mat4[2] = i[8], this.mat4[3] = i[12], this.mat4[4] = l, this.mat4[5] = i[5], this.mat4[6] = i[9], this.mat4[7] = i[13], this.mat4[8] = n, this.mat4[9] = c, this.mat4[10] = i[10], this.mat4[11] = i[14], this.mat4[12] = a, this.mat4[13] = p, this.mat4[14] = j, this.mat4[15] = i[15]), this;\n        } }, { key: \"invert\", value: function(F) {\n          F instanceof m.default.Matrix ? (l = F.mat4[0], n = F.mat4[1], a = F.mat4[2], c = F.mat4[3], p = F.mat4[4], j = F.mat4[5], T = F.mat4[6], _ = F.mat4[7], S = F.mat4[8], E = F.mat4[9], A = F.mat4[10], x = F.mat4[11], P = F.mat4[12], M = F.mat4[13], R = F.mat4[14], L = F.mat4[15]) : h(F) && (l = F[0], n = F[1], a = F[2], c = F[3], p = F[4], j = F[5], T = F[6], _ = F[7], S = F[8], E = F[9], A = F[10], x = F[11], P = F[12], M = F[13], R = F[14], L = F[15]);\n          var l, n, a, c, p, j, T, _, S, E, A, x, P, M, R, L, F = l * j - n * p, V = l * T - a * p, G = l * _ - c * p, U = n * T - a * j, W = n * _ - c * j, X = a * _ - c * T, ne = S * M - E * P, b = S * R - A * P, O = S * L - x * P, D = E * R - A * M, B = E * L - x * M, Y = A * L - x * R, J = F * Y - V * B + G * D + U * O - W * b + X * ne;\n          return J ? (this.mat4[0] = (j * Y - T * B + _ * D) * (J = 1 / J), this.mat4[1] = (a * B - n * Y - c * D) * J, this.mat4[2] = (M * X - R * W + L * U) * J, this.mat4[3] = (A * W - E * X - x * U) * J, this.mat4[4] = (T * O - p * Y - _ * b) * J, this.mat4[5] = (l * Y - a * O + c * b) * J, this.mat4[6] = (R * G - P * X - L * V) * J, this.mat4[7] = (S * X - A * G + x * V) * J, this.mat4[8] = (p * B - j * O + _ * ne) * J, this.mat4[9] = (n * O - l * B - c * ne) * J, this.mat4[10] = (P * W - M * G + L * F) * J, this.mat4[11] = (E * G - S * W - x * F) * J, this.mat4[12] = (j * b - p * D - T * ne) * J, this.mat4[13] = (l * D - n * b + a * ne) * J, this.mat4[14] = (M * V - P * U - R * F) * J, this.mat4[15] = (S * U - E * V + A * F) * J, this) : null;\n        } }, { key: \"invert3x3\", value: function() {\n          var i = this.mat3[0], l = this.mat3[1], n = this.mat3[2], a = this.mat3[3], c = this.mat3[4], p = this.mat3[5], j = this.mat3[6], T = this.mat3[7], _ = this.mat3[8], S = _ * c - p * T, E = -_ * a + p * j, A = T * a - c * j, x = i * S + l * E + n * A;\n          return x ? (this.mat3[0] = S * (x = 1 / x), this.mat3[1] = (-_ * l + n * T) * x, this.mat3[2] = (p * l - n * c) * x, this.mat3[3] = E * x, this.mat3[4] = (_ * i - n * j) * x, this.mat3[5] = (-p * i + n * a) * x, this.mat3[6] = A * x, this.mat3[7] = (-T * i + l * j) * x, this.mat3[8] = (c * i - l * a) * x, this) : null;\n        } }, { key: \"transpose3x3\", value: function(i) {\n          var l = (i = i === void 0 ? this.mat3 : i)[1], n = i[2], a = i[5];\n          return this.mat3[0] = i[0], this.mat3[1] = i[3], this.mat3[2] = i[6], this.mat3[3] = l, this.mat3[4] = i[4], this.mat3[5] = i[7], this.mat3[6] = n, this.mat3[7] = a, this.mat3[8] = i[8], this;\n        } }, { key: \"inverseTranspose\", value: function(i) {\n          if (i = i.mat4, this.mat3 === void 0 ? m.default._friendlyError(\"sorry, this function only works with mat3\") : (this.mat3[0] = i[0], this.mat3[1] = i[1], this.mat3[2] = i[2], this.mat3[3] = i[4], this.mat3[4] = i[5], this.mat3[5] = i[6], this.mat3[6] = i[8], this.mat3[7] = i[9], this.mat3[8] = i[10]), i = this.invert3x3(), i)\n            i.transpose3x3(this.mat3);\n          else\n            for (var l = 0; l < 9; l++)\n              this.mat3[l] = 0;\n          return this;\n        } }, { key: \"determinant\", value: function() {\n          var i = this.mat4[0] * this.mat4[5] - this.mat4[1] * this.mat4[4], l = this.mat4[0] * this.mat4[6] - this.mat4[2] * this.mat4[4], n = this.mat4[0] * this.mat4[7] - this.mat4[3] * this.mat4[4], a = this.mat4[1] * this.mat4[6] - this.mat4[2] * this.mat4[5], c = this.mat4[1] * this.mat4[7] - this.mat4[3] * this.mat4[5], p = this.mat4[2] * this.mat4[7] - this.mat4[3] * this.mat4[6], j = this.mat4[8] * this.mat4[13] - this.mat4[9] * this.mat4[12], T = this.mat4[8] * this.mat4[14] - this.mat4[10] * this.mat4[12], _ = this.mat4[8] * this.mat4[15] - this.mat4[11] * this.mat4[12], S = this.mat4[9] * this.mat4[14] - this.mat4[10] * this.mat4[13], E = this.mat4[9] * this.mat4[15] - this.mat4[11] * this.mat4[13];\n          return i * (this.mat4[10] * this.mat4[15] - this.mat4[11] * this.mat4[14]) - l * E + n * S + a * _ - c * T + p * j;\n        } }, { key: \"mult\", value: function(n) {\n          var l;\n          if (n === this || n === this.mat4)\n            l = this.copy().mat4;\n          else if (n instanceof m.default.Matrix)\n            l = n.mat4;\n          else if (h(n))\n            l = n;\n          else {\n            if (arguments.length !== 16)\n              return;\n            l = arguments;\n          }\n          var n = this.mat4[0], a = this.mat4[1], c = this.mat4[2], p = this.mat4[3];\n          return this.mat4[0] = n * l[0] + a * l[4] + c * l[8] + p * l[12], this.mat4[1] = n * l[1] + a * l[5] + c * l[9] + p * l[13], this.mat4[2] = n * l[2] + a * l[6] + c * l[10] + p * l[14], this.mat4[3] = n * l[3] + a * l[7] + c * l[11] + p * l[15], n = this.mat4[4], a = this.mat4[5], c = this.mat4[6], p = this.mat4[7], this.mat4[4] = n * l[0] + a * l[4] + c * l[8] + p * l[12], this.mat4[5] = n * l[1] + a * l[5] + c * l[9] + p * l[13], this.mat4[6] = n * l[2] + a * l[6] + c * l[10] + p * l[14], this.mat4[7] = n * l[3] + a * l[7] + c * l[11] + p * l[15], n = this.mat4[8], a = this.mat4[9], c = this.mat4[10], p = this.mat4[11], this.mat4[8] = n * l[0] + a * l[4] + c * l[8] + p * l[12], this.mat4[9] = n * l[1] + a * l[5] + c * l[9] + p * l[13], this.mat4[10] = n * l[2] + a * l[6] + c * l[10] + p * l[14], this.mat4[11] = n * l[3] + a * l[7] + c * l[11] + p * l[15], n = this.mat4[12], a = this.mat4[13], c = this.mat4[14], p = this.mat4[15], this.mat4[12] = n * l[0] + a * l[4] + c * l[8] + p * l[12], this.mat4[13] = n * l[1] + a * l[5] + c * l[9] + p * l[13], this.mat4[14] = n * l[2] + a * l[6] + c * l[10] + p * l[14], this.mat4[15] = n * l[3] + a * l[7] + c * l[11] + p * l[15], this;\n        } }, { key: \"apply\", value: function(n) {\n          var l;\n          if (n === this || n === this.mat4)\n            l = this.copy().mat4;\n          else if (n instanceof m.default.Matrix)\n            l = n.mat4;\n          else if (h(n))\n            l = n;\n          else {\n            if (arguments.length !== 16)\n              return;\n            l = arguments;\n          }\n          var n = this.mat4, a = n[0], c = n[4], p = n[8], j = n[12], a = (n[0] = l[0] * a + l[1] * c + l[2] * p + l[3] * j, n[4] = l[4] * a + l[5] * c + l[6] * p + l[7] * j, n[8] = l[8] * a + l[9] * c + l[10] * p + l[11] * j, n[12] = l[12] * a + l[13] * c + l[14] * p + l[15] * j, n[1]), c = n[5], p = n[9], j = n[13], a = (n[1] = l[0] * a + l[1] * c + l[2] * p + l[3] * j, n[5] = l[4] * a + l[5] * c + l[6] * p + l[7] * j, n[9] = l[8] * a + l[9] * c + l[10] * p + l[11] * j, n[13] = l[12] * a + l[13] * c + l[14] * p + l[15] * j, n[2]), c = n[6], p = n[10], j = n[14], a = (n[2] = l[0] * a + l[1] * c + l[2] * p + l[3] * j, n[6] = l[4] * a + l[5] * c + l[6] * p + l[7] * j, n[10] = l[8] * a + l[9] * c + l[10] * p + l[11] * j, n[14] = l[12] * a + l[13] * c + l[14] * p + l[15] * j, n[3]), c = n[7], p = n[11], j = n[15];\n          return n[3] = l[0] * a + l[1] * c + l[2] * p + l[3] * j, n[7] = l[4] * a + l[5] * c + l[6] * p + l[7] * j, n[11] = l[8] * a + l[9] * c + l[10] * p + l[11] * j, n[15] = l[12] * a + l[13] * c + l[14] * p + l[15] * j, this;\n        } }, { key: \"scale\", value: function(i, l, n) {\n          return i instanceof m.default.Vector ? (l = i.y, n = i.z, i = i.x) : i instanceof Array && (l = i[1], n = i[2], i = i[0]), this.mat4[0] *= i, this.mat4[1] *= i, this.mat4[2] *= i, this.mat4[3] *= i, this.mat4[4] *= l, this.mat4[5] *= l, this.mat4[6] *= l, this.mat4[7] *= l, this.mat4[8] *= n, this.mat4[9] *= n, this.mat4[10] *= n, this.mat4[11] *= n, this;\n        } }, { key: \"rotate\", value: function(F, B, D, a) {\n          B instanceof m.default.Vector ? (D = B.y, a = B.z, B = B.x) : B instanceof Array && (D = B[1], a = B[2], B = B[0]);\n          var c = Math.sqrt(B * B + D * D + a * a), c = (B *= 1 / c, D *= 1 / c, a *= 1 / c, this.mat4[0]), p = this.mat4[1], j = this.mat4[2], T = this.mat4[3], _ = this.mat4[4], S = this.mat4[5], E = this.mat4[6], A = this.mat4[7], x = this.mat4[8], P = this.mat4[9], M = this.mat4[10], R = this.mat4[11], L = Math.sin(F), F = Math.cos(F), V = 1 - F, G = B * B * V + F, U = D * B * V + a * L, W = a * B * V - D * L, X = B * D * V - a * L, ne = D * D * V + F, b = a * D * V + B * L, O = B * a * V + D * L, D = D * a * V - B * L, B = a * a * V + F;\n          return this.mat4[0] = c * G + _ * U + x * W, this.mat4[1] = p * G + S * U + P * W, this.mat4[2] = j * G + E * U + M * W, this.mat4[3] = T * G + A * U + R * W, this.mat4[4] = c * X + _ * ne + x * b, this.mat4[5] = p * X + S * ne + P * b, this.mat4[6] = j * X + E * ne + M * b, this.mat4[7] = T * X + A * ne + R * b, this.mat4[8] = c * O + _ * D + x * B, this.mat4[9] = p * O + S * D + P * B, this.mat4[10] = j * O + E * D + M * B, this.mat4[11] = T * O + A * D + R * B, this;\n        } }, { key: \"translate\", value: function(a) {\n          var l = a[0], n = a[1], a = a[2] || 0;\n          this.mat4[12] += this.mat4[0] * l + this.mat4[4] * n + this.mat4[8] * a, this.mat4[13] += this.mat4[1] * l + this.mat4[5] * n + this.mat4[9] * a, this.mat4[14] += this.mat4[2] * l + this.mat4[6] * n + this.mat4[10] * a, this.mat4[15] += this.mat4[3] * l + this.mat4[7] * n + this.mat4[11] * a;\n        } }, { key: \"rotateX\", value: function(i) {\n          this.rotate(i, 1, 0, 0);\n        } }, { key: \"rotateY\", value: function(i) {\n          this.rotate(i, 0, 1, 0);\n        } }, { key: \"rotateZ\", value: function(i) {\n          this.rotate(i, 0, 0, 1);\n        } }, { key: \"perspective\", value: function(c, l, n, a) {\n          var c = 1 / Math.tan(c / 2), p = 1 / (n - a);\n          return this.mat4[0] = c / l, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = c, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = (a + n) * p, this.mat4[11] = -1, this.mat4[12] = 0, this.mat4[13] = 0, this.mat4[14] = 2 * a * n * p, this.mat4[15] = 0, this;\n        } }, { key: \"ortho\", value: function(i, l, n, a, c, p) {\n          var j = 1 / (i - l), T = 1 / (n - a), _ = 1 / (c - p);\n          return this.mat4[0] = -2 * j, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = -2 * T, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = 2 * _, this.mat4[11] = 0, this.mat4[12] = (i + l) * j, this.mat4[13] = (a + n) * T, this.mat4[14] = (p + c) * _, this.mat4[15] = 1, this;\n        } }, { key: \"multiplyVec4\", value: function(i, l, n, a) {\n          var c = new Array(4), p = this.mat4;\n          return c[0] = p[0] * i + p[4] * l + p[8] * n + p[12] * a, c[1] = p[1] * i + p[5] * l + p[9] * n + p[13] * a, c[2] = p[2] * i + p[6] * l + p[10] * n + p[14] * a, c[3] = p[3] * i + p[7] * l + p[11] * n + p[15] * a, c;\n        } }, { key: \"multiplyPoint\", value: function(n) {\n          var a = n.x, l = n.y, n = n.z, a = this.multiplyVec4(a, l, n, 1);\n          return new m.default.Vector(a[0], a[1], a[2]);\n        } }, { key: \"multiplyAndNormalizePoint\", value: function(n) {\n          var a = n.x, l = n.y, n = n.z, a = this.multiplyVec4(a, l, n, 1);\n          return a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], new m.default.Vector(a[0], a[1], a[2]);\n        } }, { key: \"multiplyDirection\", value: function(n) {\n          var a = n.x, l = n.y, n = n.z, a = this.multiplyVec4(a, l, n, 0);\n          return new m.default.Vector(a[0], a[1], a[2]);\n        } }, { key: \"mult3x3\", value: function(n) {\n          var l;\n          if (n === this || n === this.mat3)\n            l = this.copy().mat3;\n          else if (n instanceof m.default.Matrix)\n            l = n.mat3;\n          else if (h(n))\n            l = n;\n          else {\n            if (arguments.length !== 9)\n              return;\n            l = arguments;\n          }\n          var n = this.mat3[0], a = this.mat3[1], c = this.mat3[2];\n          return this.mat3[0] = n * l[0] + a * l[3] + c * l[6], this.mat3[1] = n * l[1] + a * l[4] + c * l[7], this.mat3[2] = n * l[2] + a * l[5] + c * l[8], n = this.mat3[3], a = this.mat3[4], c = this.mat3[5], this.mat3[3] = n * l[0] + a * l[3] + c * l[6], this.mat3[4] = n * l[1] + a * l[4] + c * l[7], this.mat3[5] = n * l[2] + a * l[5] + c * l[8], n = this.mat3[6], a = this.mat3[7], c = this.mat3[8], this.mat3[6] = n * l[0] + a * l[3] + c * l[6], this.mat3[7] = n * l[1] + a * l[4] + c * l[7], this.mat3[8] = n * l[2] + a * l[5] + c * l[8], this;\n        } }, { key: \"column\", value: function(i) {\n          return new m.default.Vector(this.mat3[3 * i], this.mat3[3 * i + 1], this.mat3[3 * i + 2]);\n        } }, { key: \"row\", value: function(i) {\n          return new m.default.Vector(this.mat3[i], this.mat3[i + 3], this.mat3[i + 6]);\n        } }, { key: \"diagonal\", value: function() {\n          return this.mat3 !== void 0 ? [this.mat3[0], this.mat3[4], this.mat3[8]] : [this.mat4[0], this.mat4[5], this.mat4[10], this.mat4[15]];\n        } }, { key: \"multiplyVec3\", value: function(i, l) {\n          return (l = l === void 0 ? i.copy() : l).x = this.row(0).dot(i), l.y = this.row(1).dot(i), l.z = this.row(2).dot(i), l;\n        } }, { key: \"createSubMatrix3x3\", value: function() {\n          var i = new m.default.Matrix(\"mat3\");\n          return i.mat3[0] = this.mat4[0], i.mat3[1] = this.mat4[1], i.mat3[2] = this.mat4[2], i.mat3[3] = this.mat4[4], i.mat3[4] = this.mat4[5], i.mat3[5] = this.mat4[6], i.mat3[6] = this.mat4[8], i.mat3[7] = this.mat4[9], i.mat3[8] = this.mat4[10], i;\n        } }]) && y(r.prototype, s), o && y(r, o), f;\n      }(), m.default.Matrix);\n      C.default = g;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.float32-array\": 216, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236 }], 334: [function(t, H, C) {\n      t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.map\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0, t = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function m(y, u) {\n        for (var h = 0; h < u.length; h++) {\n          var g = u[h];\n          g.enumerable = g.enumerable || !1, g.configurable = !0, \"value\" in g && (g.writable = !0), Object.defineProperty(y, g.key, g);\n        }\n      }\n      t.default.RenderBuffer = function() {\n        function y(g, f, r, s, o, i) {\n          if (!(this instanceof y))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this.size = g, this.src = f, this.dst = r, this.attr = s, this._renderer = o, this.map = i;\n        }\n        var u, h;\n        return u = y, (h = [{ key: \"_prepareBuffer\", value: function(g, f) {\n          var r, s, o, n = f.attributes, i = this._renderer.GL, l = g.model || g, n = n[this.attr];\n          n && (r = g[this.dst], 0 < (s = l[this.src]).length ? ((o = !r) && (g[this.dst] = r = i.createBuffer()), i.bindBuffer(i.ARRAY_BUFFER, r), !o && l.dirtyFlags[this.src] === !1 || (o = (g = this.map) ? g(s) : s, this._renderer._bindBuffer(r, i.ARRAY_BUFFER, o), l.dirtyFlags[this.src] = !1), f.enableAttrib(n, this.size)) : (g = n.location) !== -1 && this._renderer.registerEnabled.has(g) && (i.disableVertexAttribArray(g), this._renderer.registerEnabled.delete(g)));\n        } }]) && m(u.prototype, h), y;\n      }(), t = t.default.RenderBuffer, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.map\": 167 }], 335: [function(t, H, C) {\n      function m(o) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(i) {\n          return typeof i;\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : typeof i;\n        })(o);\n      }\n      function y(o) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(i) {\n          return m(i);\n        } : function(i) {\n          return i && typeof Symbol == \"function\" && i.constructor === Symbol && i !== Symbol.prototype ? \"symbol\" : m(i);\n        })(o);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.find-index\"), t(\"core-js/modules/es.array.from\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.map\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.concat\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.find-index\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.map\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.map\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (s = t(\"../core/main\")) && s.__esModule ? s : { default: s }, h = function(o) {\n        if (o && o.__esModule)\n          return o;\n        if (o === null || y(o) !== \"object\" && typeof o != \"function\")\n          return { default: o };\n        var i = g();\n        if (i && i.has(o))\n          return i.get(o);\n        var l, n = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (l in o) {\n          var c;\n          Object.prototype.hasOwnProperty.call(o, l) && ((c = a ? Object.getOwnPropertyDescriptor(o, l) : null) && (c.get || c.set) ? Object.defineProperty(n, l, c) : n[l] = o[l]);\n        }\n        return n.default = o, i && i.set(o, n), n;\n      }(t(\"../core/constants\"));\n      function g() {\n        var o;\n        return typeof WeakMap != \"function\" ? null : (o = /* @__PURE__ */ new WeakMap(), g = function() {\n          return o;\n        }, o);\n      }\n      function f(o) {\n        return function(i) {\n          if (Array.isArray(i)) {\n            for (var l = 0, n = new Array(i.length); l < i.length; l++)\n              n[l] = i[l];\n            return n;\n          }\n        }(o) || function(i) {\n          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === \"[object Arguments]\")\n            return Array.from(i);\n        }(o) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      t(\"./p5.RenderBuffer\"), u.default.RendererGL.prototype.beginShape = function(o) {\n        return this.immediateMode.shapeMode = o !== void 0 ? o : h.TESS, this.immediateMode.geometry.reset(), this.immediateMode.contourIndices = [], this;\n      };\n      var r = { vertices: 1, vertexNormals: 1, vertexColors: 4, vertexStrokeColors: 4, uvs: 2 }, s = (u.default.RendererGL.prototype.beginContour = function() {\n        if (this.immediateMode.shapeMode !== h.TESS)\n          throw new Error(\"WebGL mode can only use contours with beginShape(TESS).\");\n        this.immediateMode.contourIndices.push(this.immediateMode.geometry.vertices.length);\n      }, u.default.RendererGL.prototype.vertex = function(o, i) {\n        if (this.immediateMode.shapeMode === h.QUADS && this.immediateMode.geometry.vertices.length % 6 == 3)\n          for (var l in r) {\n            var n = r[l], l = this.immediateMode.geometry[l];\n            l.push.apply(l, f(l.slice(l.length - 3 * n, l.length - 2 * n)).concat(f(l.slice(l.length - n, l.length))));\n          }\n        var a, c, p = a = c = 0, j = (arguments.length === 3 ? p = arguments[2] : arguments.length === 4 ? (a = arguments[2], c = arguments[3]) : arguments.length === 5 && (p = arguments[2], a = arguments[3], c = arguments[4]), new u.default.Vector(o, i, p)), j = (this.immediateMode.geometry.vertices.push(j), this.immediateMode.geometry.vertexNormals.push(this._currentNormal), this.curFillColor || [0.5, 0.5, 0.5, 1]), j = (this.immediateMode.geometry.vertexColors.push(j[0], j[1], j[2], j[3]), this.curStrokeColor || [0.5, 0.5, 0.5, 1]);\n        return this.immediateMode.geometry.vertexStrokeColors.push(j[0], j[1], j[2], j[3]), this.textureMode !== h.IMAGE || this.isProcessingVertices || (this._tex !== null ? 0 < this._tex.width && 0 < this._tex.height && (a /= this._tex.width, c /= this._tex.height) : this.userFillShader === void 0 && this.userStrokeShader === void 0 && this.userPointShader === void 0 && this._tex === null && 4 <= arguments.length && console.warn(\"You must first call texture() before using vertex() with image based u and v coordinates\")), this.immediateMode.geometry.uvs.push(a, c), this.immediateMode._bezierVertex[0] = o, this.immediateMode._bezierVertex[1] = i, this.immediateMode._bezierVertex[2] = p, this.immediateMode._quadraticVertex[0] = o, this.immediateMode._quadraticVertex[1] = i, this.immediateMode._quadraticVertex[2] = p, this;\n      }, u.default.RendererGL.prototype.normal = function(o, i, l) {\n        return o instanceof u.default.Vector ? this._currentNormal = o : this._currentNormal = new u.default.Vector(o, i, l), this;\n      }, u.default.RendererGL.prototype.endShape = function(o, i, l, n, a, c) {\n        var p, j = 6 < arguments.length && arguments[6] !== void 0 ? arguments[6] : 1;\n        return this.immediateMode.shapeMode === h.POINTS ? this._drawPoints(this.immediateMode.geometry.vertices, this.immediateMode.buffers.point) : (this.immediateMode.geometry.vertices.length === 3 && this.immediateMode.shapeMode === h.TESS && (this.immediateMode.shapeMode, h.TRIANGLES), this.isProcessingVertices = !0, this._processVertices.apply(this, arguments), p = this.isProcessingVertices = !1, this.immediateMode.shapeMode !== h.LINE_STRIP && this.immediateMode.shapeMode !== h.LINES || (this.immediateMode.shapeMode = h.TRIANGLE_FAN, p = !0), this.immediateMode.shapeMode === h.QUADS ? this.immediateMode.shapeMode = h.TRIANGLES : this.immediateMode.shapeMode === h.QUAD_STRIP && (this.immediateMode.shapeMode = h.TRIANGLE_STRIP), this._doFill && !p && !this.geometryBuilder && 3 <= this.immediateMode.geometry.vertices.length && this._drawImmediateFill(j), this._doStroke && !this.geometryBuilder && 1 <= this.immediateMode.geometry.lineVertices.length && this._drawImmediateStroke(), this.geometryBuilder && this.geometryBuilder.addImmediate(), this.isBezier = !1, this.isQuadratic = !1, this.isCurve = !1, this.immediateMode._bezierVertex.length = 0, this.immediateMode._quadraticVertex.length = 0, this.immediateMode._curveVertex.length = 0), this;\n      }, u.default.RendererGL.prototype._processVertices = function(o) {\n        var i;\n        this.immediateMode.geometry.vertices.length !== 0 && (i = this._doStroke, o = o === h.CLOSE, i && (this.immediateMode.geometry.edges = this._calculateEdges(this.immediateMode.shapeMode, this.immediateMode.geometry.vertices, o), this.geometryBuilder || this.immediateMode.geometry._edgesToVertices()), i = this.immediateMode.shapeMode === h.TESS, o = 0 < this.immediateMode.contourIndices.length, this._doFill && (this.isBezier || this.isQuadratic || this.isCurve || i || o) && this.immediateMode.shapeMode !== h.LINES && this._tesselateShape());\n      }, u.default.RendererGL.prototype._calculateEdges = function(o, i, l) {\n        var n = [], a = 0, c = this.immediateMode.contourIndices.slice(), p = 0;\n        switch (o) {\n          case h.TRIANGLE_STRIP:\n            for (a = 0; a < i.length - 2; a++)\n              n.push([a, a + 1]), n.push([a, a + 2]);\n            n.push([a, a + 1]);\n            break;\n          case h.TRIANGLE_FAN:\n            for (a = 1; a < i.length - 1; a++)\n              n.push([0, a]), n.push([a, a + 1]);\n            n.push([0, i.length - 1]);\n            break;\n          case h.TRIANGLES:\n            for (a = 0; a < i.length - 2; a += 3)\n              n.push([a, a + 1]), n.push([a + 1, a + 2]), n.push([a + 2, a]);\n            break;\n          case h.LINES:\n            for (a = 0; a < i.length - 1; a += 2)\n              n.push([a, a + 1]);\n            break;\n          case h.QUADS:\n            for (a = 0; a < i.length - 5; a += 6)\n              n.push([a, a + 1]), n.push([a + 1, a + 2]), n.push([a + 3, a + 5]), n.push([a + 4, a + 5]);\n            break;\n          case h.QUAD_STRIP:\n            for (a = 0; a < i.length - 2; a += 2)\n              n.push([a, a + 1]), n.push([a, a + 2]), n.push([a + 1, a + 3]);\n            n.push([a, a + 1]);\n            break;\n          default:\n            for (a = 0; a < i.length; a++)\n              a + 1 < i.length && a + 1 !== c[0] ? n.push([a, a + 1]) : ((l || p) && n.push([a, p]), 0 < c.length && (p = c.shift()));\n        }\n        return o !== h.TESS && l && n.push([i.length - 1, 0]), n;\n      }, u.default.RendererGL.prototype._tesselateShape = function() {\n        for (var o = this, i = (this.immediateMode.shapeMode = h.TRIANGLES, [[]]), l = 0; l < this.immediateMode.geometry.vertices.length; l++)\n          0 < this.immediateMode.contourIndices.length && this.immediateMode.contourIndices[0] === l && (this.immediateMode.contourIndices.shift(), i.push([])), i[i.length - 1].push(this.immediateMode.geometry.vertices[l].x, this.immediateMode.geometry.vertices[l].y, this.immediateMode.geometry.vertices[l].z, this.immediateMode.geometry.uvs[2 * l], this.immediateMode.geometry.uvs[2 * l + 1], this.immediateMode.geometry.vertexColors[4 * l], this.immediateMode.geometry.vertexColors[4 * l + 1], this.immediateMode.geometry.vertexColors[4 * l + 2], this.immediateMode.geometry.vertexColors[4 * l + 3], this.immediateMode.geometry.vertexNormals[l].x, this.immediateMode.geometry.vertexNormals[l].y, this.immediateMode.geometry.vertexNormals[l].z);\n        for (var n, a = this._triangulate(i), c = this.immediateMode.geometry.vertices, p = (this.immediateMode.geometry.vertices = [], this.immediateMode.geometry.vertexNormals = [], this.immediateMode.geometry.uvs = [], []), j = 0, T = a.length; j < T; j += u.default.RendererGL.prototype.tessyVertexSize)\n          p.push.apply(p, f(a.slice(j + 5, j + 9))), this.normal.apply(this, f(a.slice(j + 9, j + 12))), this.vertex.apply(this, f(a.slice(j, j + 5)));\n        this.geometryBuilder && (n = /* @__PURE__ */ new Map(), this.immediateMode.geometry.edges = this.immediateMode.geometry.edges.map(function(_) {\n          return _.map(function(S) {\n            if (!n.has(S)) {\n              var E = c[S], A = o.immediateMode.geometry.vertices.findIndex(function(V) {\n                return E.x === V.x && E.y === V.y && E.z === V.z;\n              });\n              if (A === -1) {\n                for (var x = 1 / 0, P = 0, M = 0; M < o.immediateMode.geometry.vertices.length; M++) {\n                  var L = o.immediateMode.geometry.vertices[M], F = E.x - L.x, R = E.y - L.y, L = E.z - L.z, F = F * F + R * R + L * L;\n                  F < x && (x = F, P = M);\n                }\n                A = P;\n              }\n              n.set(S, A);\n            }\n            return n.get(S);\n          });\n        })), this.immediateMode.geometry.vertexColors = p;\n      }, u.default.RendererGL.prototype._drawImmediateFill = function() {\n        var o, i = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 1, l = this.GL, n = (this._useVertexColor = 0 < this.immediateMode.geometry.vertexColors.length, o = this._getImmediateFillShader(), this._setFillUniforms(o), !0), a = !1, c = void 0;\n        try {\n          for (var p, j = this.immediateMode.buffers.fill[Symbol.iterator](); !(n = (p = j.next()).done); n = !0)\n            p.value._prepareBuffer(this.immediateMode.geometry, o);\n        } catch (T) {\n          a = !0, c = T;\n        } finally {\n          try {\n            n || j.return == null || j.return();\n          } finally {\n            if (a)\n              throw c;\n          }\n        }\n        if (o.disableRemainingAttributes(), this._applyColorBlend(this.curFillColor, this.immediateMode.geometry.hasFillTransparency()), i === 1)\n          l.drawArrays(this.immediateMode.shapeMode, 0, this.immediateMode.geometry.vertices.length);\n        else\n          try {\n            l.drawArraysInstanced(this.immediateMode.shapeMode, 0, this.immediateMode.geometry.vertices.length, i);\n          } catch {\n            console.log(\"🌸 p5.js says: Instancing is only supported in WebGL2 mode\");\n          }\n        o.unbindShader();\n      }, u.default.RendererGL.prototype._drawImmediateStroke = function() {\n        var o = this.GL, i = (this._useLineColor = 0 < this.immediateMode.geometry.vertexStrokeColors.length, this._getImmediateStrokeShader()), l = (this._setStrokeUniforms(i), !0), n = !1, a = void 0;\n        try {\n          for (var c, p = this.immediateMode.buffers.stroke[Symbol.iterator](); !(l = (c = p.next()).done); l = !0)\n            c.value._prepareBuffer(this.immediateMode.geometry, i);\n        } catch (j) {\n          n = !0, a = j;\n        } finally {\n          try {\n            l || p.return == null || p.return();\n          } finally {\n            if (n)\n              throw a;\n          }\n        }\n        i.disableRemainingAttributes(), this._applyColorBlend(this.curStrokeColor, this.immediateMode.geometry.hasFillTransparency()), o.drawArrays(o.TRIANGLES, 0, this.immediateMode.geometry.lineVertices.length / 3), i.unbindShader();\n      }, u.default.RendererGL);\n      C.default = s;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.RenderBuffer\": 334, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.find-index\": 157, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.map\": 174, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 336: [function(t, H, C) {\n      function m(r) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(s) {\n          return typeof s;\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : typeof s;\n        })(r);\n      }\n      function y(r) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(s) {\n          return m(s);\n        } : function(s) {\n          return s && typeof Symbol == \"function\" && s.constructor === Symbol && s !== Symbol.prototype ? \"symbol\" : m(s);\n        })(r);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.typed-array.float32-array\"), t(\"core-js/modules/es.typed-array.uint16-array\"), t(\"core-js/modules/es.typed-array.uint32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.fill\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.typed-array.float32-array\"), t(\"core-js/modules/es.typed-array.uint16-array\"), t(\"core-js/modules/es.typed-array.uint32-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var u = (f = t(\"../core/main\")) && f.__esModule ? f : { default: f }, h = (t(\"./p5.RendererGL\"), t(\"./p5.RenderBuffer\"), function(r) {\n        if (r && r.__esModule)\n          return r;\n        if (r === null || y(r) !== \"object\" && typeof r != \"function\")\n          return { default: r };\n        var s = g();\n        if (s && s.has(r))\n          return s.get(r);\n        var o, i = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (o in r) {\n          var n;\n          Object.prototype.hasOwnProperty.call(r, o) && ((n = l ? Object.getOwnPropertyDescriptor(r, o) : null) && (n.get || n.set) ? Object.defineProperty(i, o, n) : i[o] = r[o]);\n        }\n        return i.default = r, s && s.set(r, i), i;\n      }(t(\"../core/constants\")));\n      function g() {\n        var r;\n        return typeof WeakMap != \"function\" ? null : (r = /* @__PURE__ */ new WeakMap(), g = function() {\n          return r;\n        }, r);\n      }\n      u.default.RendererGL.prototype.freeGeometry = function(r) {\n        r.gid ? this._freeBuffers(r.gid) : console.warn(\"The model you passed to freeGeometry does not have an id!\");\n      }, u.default.RendererGL.prototype._initBufferDefaults = function(r) {\n        var s;\n        return this._freeBuffers(r), 1e3 < Object.keys(this.retainedMode.geometry).length && (s = Object.keys(this.retainedMode.geometry)[0], this._freeBuffers(s)), this.retainedMode.geometry[r] = {};\n      }, u.default.RendererGL.prototype._freeBuffers = function(r) {\n        var s, o = this.retainedMode.geometry[r];\n        function i(l) {\n          var n = !0, a = !1, c = void 0;\n          try {\n            for (var p, j = l[Symbol.iterator](); !(n = (p = j.next()).done); n = !0) {\n              var T = p.value;\n              o[T.dst] && (s.deleteBuffer(o[T.dst]), o[T.dst] = null);\n            }\n          } catch (_) {\n            a = !0, c = _;\n          } finally {\n            try {\n              n || j.return == null || j.return();\n            } finally {\n              if (a)\n                throw c;\n            }\n          }\n        }\n        o && (delete this.retainedMode.geometry[r], s = this.GL, o.indexBuffer && s.deleteBuffer(o.indexBuffer), i(this.retainedMode.buffers.stroke), i(this.retainedMode.buffers.fill));\n      }, u.default.RendererGL.prototype.createBuffers = function(a, s) {\n        var o, i, l, n = this.GL, a = this._initBufferDefaults(a), c = (a.model = s, a.indexBuffer);\n        return s.faces.length ? (c = c || (a.indexBuffer = n.createBuffer()), l = (i = (o = u.default.RendererGL.prototype._flatten(s.faces)).some(function(p) {\n          return 65535 < p;\n        })) ? Uint32Array : Uint16Array, this._bindBuffer(c, n.ELEMENT_ARRAY_BUFFER, o, l), a.indexBufferType = i ? n.UNSIGNED_INT : n.UNSIGNED_SHORT, a.vertexCount = 3 * s.faces.length) : (c && (n.deleteBuffer(c), a.indexBuffer = null), a.vertexCount = s.vertices ? s.vertices.length : 0), a.lineVertexCount = s.lineVertices ? s.lineVertices.length / 3 : 0, a;\n      }, u.default.RendererGL.prototype.drawBuffers = function(r) {\n        var s = this.GL, o = this.retainedMode.geometry[r];\n        if (!this.geometryBuilder && this._doFill && 0 < this.retainedMode.geometry[r].vertexCount) {\n          this._useVertexColor = 0 < o.model.vertexColors.length;\n          var i = this._getRetainedFillShader(), l = (this._setFillUniforms(i), !0), n = !1, a = void 0;\n          try {\n            for (var c, p = this.retainedMode.buffers.fill[Symbol.iterator](); !(l = (c = p.next()).done); l = !0)\n              c.value._prepareBuffer(o, i);\n          } catch (E) {\n            n = !0, a = E;\n          } finally {\n            try {\n              l || p.return == null || p.return();\n            } finally {\n              if (n)\n                throw a;\n            }\n          }\n          i.disableRemainingAttributes(), o.indexBuffer && this._bindBuffer(o.indexBuffer, s.ELEMENT_ARRAY_BUFFER), this._applyColorBlend(this.curFillColor, o.model.hasFillTransparency()), this._drawElements(s.TRIANGLES, r), i.unbindShader();\n        }\n        if (!this.geometryBuilder && this._doStroke && 0 < o.lineVertexCount) {\n          this._useLineColor = 0 < o.model.vertexStrokeColors.length;\n          var j = this._getRetainedStrokeShader(), T = (this._setStrokeUniforms(j), !0), n = !1, a = void 0;\n          try {\n            for (var _, S = this.retainedMode.buffers.stroke[Symbol.iterator](); !(T = (_ = S.next()).done); T = !0)\n              _.value._prepareBuffer(o, j);\n          } catch (x) {\n            n = !0, a = x;\n          } finally {\n            try {\n              T || S.return == null || S.return();\n            } finally {\n              if (n)\n                throw a;\n            }\n          }\n          j.disableRemainingAttributes(), this._applyColorBlend(this.curStrokeColor, o.model.hasStrokeTransparency()), this._drawArrays(s.TRIANGLES, r), j.unbindShader();\n        }\n        return this.geometryBuilder && this.geometryBuilder.addRetained(o), this;\n      }, u.default.RendererGL.prototype.drawBuffersScaled = function(r, s, o, i) {\n        var l = this.uMVMatrix.copy();\n        try {\n          this.uMVMatrix.scale(s, o, i), this.drawBuffers(r);\n        } finally {\n          this.uMVMatrix = l;\n        }\n      }, u.default.RendererGL.prototype._drawArrays = function(r, s) {\n        return this.GL.drawArrays(r, 0, this.retainedMode.geometry[s].lineVertexCount), this;\n      }, u.default.RendererGL.prototype._drawElements = function(r, o) {\n        var o = this.retainedMode.geometry[o], i = this.GL;\n        if (o.indexBuffer) {\n          if (this._pInst.webglVersion !== h.WEBGL2 && o.indexBufferType === i.UNSIGNED_INT && !i.getExtension(\"OES_element_index_uint\"))\n            throw new Error(\"Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.\");\n          i.drawElements(i.TRIANGLES, o.vertexCount, o.indexBufferType, 0);\n        } else\n          i.drawArrays(r || i.TRIANGLES, 0, o.vertexCount);\n      }, u.default.RendererGL.prototype._drawPoints = function(r, s) {\n        var o = this.GL, i = this._getImmediatePointShader();\n        this._setPointUniforms(i), this._bindBuffer(s, o.ARRAY_BUFFER, this._vToNArray(r), Float32Array, o.STATIC_DRAW), i.enableAttrib(i.attributes.aPosition, 3), this._applyColorBlend(this.curStrokeColor), o.drawArrays(o.Points, 0, r.length), i.unbindShader();\n      };\n      var f = u.default.RendererGL;\n      C.default = f;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.RenderBuffer\": 334, \"./p5.RendererGL\": 337, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.some\": 169, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.float32-array\": 216, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint16-array\": 237, \"core-js/modules/es.typed-array.uint32-array\": 238, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 337: [function(M, H, C) {\n      function m(U) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(W) {\n          return typeof W;\n        } : function(W) {\n          return W && typeof Symbol == \"function\" && W.constructor === Symbol && W !== Symbol.prototype ? \"symbol\" : typeof W;\n        })(U);\n      }\n      function y(U) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(W) {\n          return m(W);\n        } : function(W) {\n          return W && typeof Symbol == \"function\" && W.constructor === Symbol && W !== Symbol.prototype ? \"symbol\" : m(W);\n        })(U);\n      }\n      M(\"core-js/modules/es.symbol\"), M(\"core-js/modules/es.symbol.description\"), M(\"core-js/modules/es.symbol.iterator\"), M(\"core-js/modules/es.array.concat\"), M(\"core-js/modules/es.array.copy-within\"), M(\"core-js/modules/es.array.every\"), M(\"core-js/modules/es.array.fill\"), M(\"core-js/modules/es.array.flat\"), M(\"core-js/modules/es.array.flat-map\"), M(\"core-js/modules/es.array.from\"), M(\"core-js/modules/es.array.includes\"), M(\"core-js/modules/es.array.iterator\"), M(\"core-js/modules/es.array.map\"), M(\"core-js/modules/es.array.slice\"), M(\"core-js/modules/es.array.some\"), M(\"core-js/modules/es.array.unscopables.flat\"), M(\"core-js/modules/es.array.unscopables.flat-map\"), M(\"core-js/modules/es.map\"), M(\"core-js/modules/es.object.assign\"), M(\"core-js/modules/es.object.get-own-property-descriptor\"), M(\"core-js/modules/es.object.get-prototype-of\"), M(\"core-js/modules/es.object.to-string\"), M(\"core-js/modules/es.reflect.construct\"), M(\"core-js/modules/es.reflect.get\"), M(\"core-js/modules/es.regexp.to-string\"), M(\"core-js/modules/es.set\"), M(\"core-js/modules/es.string.includes\"), M(\"core-js/modules/es.string.iterator\"), M(\"core-js/modules/es.typed-array.float32-array\"), M(\"core-js/modules/es.typed-array.float64-array\"), M(\"core-js/modules/es.typed-array.int16-array\"), M(\"core-js/modules/es.typed-array.uint8-array\"), M(\"core-js/modules/es.typed-array.uint16-array\"), M(\"core-js/modules/es.typed-array.uint32-array\"), M(\"core-js/modules/es.typed-array.copy-within\"), M(\"core-js/modules/es.typed-array.every\"), M(\"core-js/modules/es.typed-array.fill\"), M(\"core-js/modules/es.typed-array.filter\"), M(\"core-js/modules/es.typed-array.find\"), M(\"core-js/modules/es.typed-array.find-index\"), M(\"core-js/modules/es.typed-array.for-each\"), M(\"core-js/modules/es.typed-array.includes\"), M(\"core-js/modules/es.typed-array.index-of\"), M(\"core-js/modules/es.typed-array.iterator\"), M(\"core-js/modules/es.typed-array.join\"), M(\"core-js/modules/es.typed-array.last-index-of\"), M(\"core-js/modules/es.typed-array.map\"), M(\"core-js/modules/es.typed-array.reduce\"), M(\"core-js/modules/es.typed-array.reduce-right\"), M(\"core-js/modules/es.typed-array.reverse\"), M(\"core-js/modules/es.typed-array.set\"), M(\"core-js/modules/es.typed-array.slice\"), M(\"core-js/modules/es.typed-array.some\"), M(\"core-js/modules/es.typed-array.sort\"), M(\"core-js/modules/es.typed-array.subarray\"), M(\"core-js/modules/es.typed-array.to-locale-string\"), M(\"core-js/modules/es.typed-array.to-string\"), M(\"core-js/modules/es.weak-map\"), M(\"core-js/modules/web.dom-collections.iterator\"), M(\"core-js/modules/es.symbol\"), M(\"core-js/modules/es.symbol.description\"), M(\"core-js/modules/es.symbol.iterator\"), M(\"core-js/modules/es.array.concat\"), M(\"core-js/modules/es.array.copy-within\"), M(\"core-js/modules/es.array.every\"), M(\"core-js/modules/es.array.fill\"), M(\"core-js/modules/es.array.flat\"), M(\"core-js/modules/es.array.flat-map\"), M(\"core-js/modules/es.array.from\"), M(\"core-js/modules/es.array.includes\"), M(\"core-js/modules/es.array.iterator\"), M(\"core-js/modules/es.array.map\"), M(\"core-js/modules/es.array.slice\"), M(\"core-js/modules/es.array.some\"), M(\"core-js/modules/es.array.unscopables.flat\"), M(\"core-js/modules/es.array.unscopables.flat-map\"), M(\"core-js/modules/es.map\"), M(\"core-js/modules/es.object.assign\"), M(\"core-js/modules/es.object.to-string\"), M(\"core-js/modules/es.set\"), M(\"core-js/modules/es.string.includes\"), M(\"core-js/modules/es.string.iterator\"), M(\"core-js/modules/es.typed-array.float32-array\"), M(\"core-js/modules/es.typed-array.float64-array\"), M(\"core-js/modules/es.typed-array.int16-array\"), M(\"core-js/modules/es.typed-array.uint8-array\"), M(\"core-js/modules/es.typed-array.uint16-array\"), M(\"core-js/modules/es.typed-array.uint32-array\"), M(\"core-js/modules/es.typed-array.copy-within\"), M(\"core-js/modules/es.typed-array.every\"), M(\"core-js/modules/es.typed-array.fill\"), M(\"core-js/modules/es.typed-array.filter\"), M(\"core-js/modules/es.typed-array.find\"), M(\"core-js/modules/es.typed-array.find-index\"), M(\"core-js/modules/es.typed-array.for-each\"), M(\"core-js/modules/es.typed-array.includes\"), M(\"core-js/modules/es.typed-array.index-of\"), M(\"core-js/modules/es.typed-array.iterator\"), M(\"core-js/modules/es.typed-array.join\"), M(\"core-js/modules/es.typed-array.last-index-of\"), M(\"core-js/modules/es.typed-array.map\"), M(\"core-js/modules/es.typed-array.reduce\"), M(\"core-js/modules/es.typed-array.reduce-right\"), M(\"core-js/modules/es.typed-array.reverse\"), M(\"core-js/modules/es.typed-array.set\"), M(\"core-js/modules/es.typed-array.slice\"), M(\"core-js/modules/es.typed-array.some\"), M(\"core-js/modules/es.typed-array.sort\"), M(\"core-js/modules/es.typed-array.subarray\"), M(\"core-js/modules/es.typed-array.to-locale-string\"), M(\"core-js/modules/es.typed-array.to-string\"), M(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.readPixelsWebGL = V, C.readPixelWebGL = G, C.default = void 0;\n      var u = o(M(\"../core/main\")), h = function(U) {\n        if (U && U.__esModule)\n          return U;\n        if (U === null || y(U) !== \"object\" && typeof U != \"function\")\n          return { default: U };\n        var W = s();\n        if (W && W.has(U))\n          return W.get(U);\n        var X, ne = {}, b = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (X in U) {\n          var O;\n          Object.prototype.hasOwnProperty.call(U, X) && ((O = b ? Object.getOwnPropertyDescriptor(U, X) : null) && (O.get || O.set) ? Object.defineProperty(ne, X, O) : ne[X] = U[X]);\n        }\n        return ne.default = U, W && W.set(U, ne), ne;\n      }(M(\"../core/constants\")), g = o(M(\"./GeometryBuilder\")), f = o(M(\"libtess\")), r = (M(\"./p5.Shader\"), M(\"./p5.Camera\"), M(\"../core/p5.Renderer\"), M(\"./p5.Matrix\"), M(\"./p5.Framebuffer\"), M(\"path\"), M(\"./p5.Texture\"));\n      function s() {\n        var U;\n        return typeof WeakMap != \"function\" ? null : (U = /* @__PURE__ */ new WeakMap(), s = function() {\n          return U;\n        }, U);\n      }\n      function o(U) {\n        return U && U.__esModule ? U : { default: U };\n      }\n      function i(U) {\n        return function(W) {\n          if (Array.isArray(W)) {\n            for (var X = 0, ne = new Array(W.length); X < W.length; X++)\n              ne[X] = W[X];\n            return ne;\n          }\n        }(U) || function(W) {\n          if (Symbol.iterator in Object(W) || Object.prototype.toString.call(W) === \"[object Arguments]\")\n            return Array.from(W);\n        }(U) || function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }();\n      }\n      function l(U, W) {\n        for (var X = 0; X < W.length; X++) {\n          var ne = W[X];\n          ne.enumerable = ne.enumerable || !1, ne.configurable = !0, \"value\" in ne && (ne.writable = !0), Object.defineProperty(U, ne.key, ne);\n        }\n      }\n      function n(U, W, X) {\n        return (n = typeof Reflect < \"u\" && Reflect.get ? Reflect.get : function(D, b, O) {\n          var D = function(B, Y) {\n            for (; !Object.prototype.hasOwnProperty.call(B, Y) && (B = j(B)) !== null; )\n              ;\n            return B;\n          }(D, b);\n          if (D)\n            return (D = Object.getOwnPropertyDescriptor(D, b)).get ? D.get.call(O) : D.value;\n        })(U, W, X || U);\n      }\n      function a(U, W) {\n        return (a = Object.setPrototypeOf || function(X, ne) {\n          return X.__proto__ = ne, X;\n        })(U, W);\n      }\n      function c(U) {\n        return function() {\n          var W, X, ne = j(U);\n          return W = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (W = j(this).constructor, Reflect.construct(ne, arguments, W)) : ne.apply(this, arguments), ne = this, !(X = W) || y(X) !== \"object\" && typeof X != \"function\" ? p(ne) : X;\n        };\n      }\n      function p(U) {\n        if (U === void 0)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return U;\n      }\n      function j(U) {\n        return (j = Object.setPrototypeOf ? Object.getPrototypeOf : function(W) {\n          return W.__proto__ || Object.getPrototypeOf(W);\n        })(U);\n      }\n      function T(U, W, X) {\n        W in U ? Object.defineProperty(U, W, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : U[W] = X;\n      }\n      function _(U, W) {\n        P += \"#define STROKE_CAP_\".concat(U, \" \").concat(W, `\n`), A[h[U]] = W;\n      }\n      function S(U, W) {\n        P += \"#define STROKE_JOIN_\".concat(U, \" \").concat(W, `\n`), x[h[U]] = W;\n      }\n      var E, A = {}, x = {}, P = \"\", M = (_(\"ROUND\", 0), _(\"PROJECT\", 1), _(\"SQUARE\", 2), S(\"ROUND\", 0), S(\"MITER\", 1), S(\"BEVEL\", 2), `#define PI 3.141592\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\nuniform mat3 uCameraRotation;\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];\t\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\nuniform float metallic;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\n// setting from  _setImageLightUniforms()\n// boolean to initiate the calculateImageDiffuse and calculateImageSpecular\nuniform bool uUseImageLight;\n// texture for use in calculateImageDiffuse\nuniform sampler2D environmentMapDiffused;\n// texture for use in calculateImageSpecular\nuniform sampler2D environmentMapSpecular;\n// roughness for use in calculateImageSpecular\nuniform float levelOfDetail;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  float specularIntensity = mix(1.0, 0.4, metallic);\n  float diffuseIntensity = mix(1.0, 0.1, metallic);\n  if (uSpecular)\n    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, uShininess)) * specularIntensity;\n    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;\n  return lr;\n}\n\n// converts the range of \"value\" from [min1 to max1] to [min2 to max2]\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 mapTextureToNormal( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );\n  return angles;\n}\n\n\nvec3 calculateImageDiffuse( vec3 vNormal, vec3 vViewPosition ){\n  // make 2 seperate builds \n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position\n  vec3 worldNormal = normalize(vNormal * uCameraRotation);\n  vec2 newTexCoor = mapTextureToNormal( worldNormal );\n  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);\n}\n\nvec3 calculateImageSpecular( vec3 vNormal, vec3 vViewPosition ){\n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);\n  vec3 worldNormal = normalize(vNormal);\n  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );\n  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;\n  vec2 newTexCoor = mapTextureToNormal( R );\n#ifdef WEBGL2\n  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, levelOfDetail);\n#else\n  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);\n#endif\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(\n    pow(outColor.xyz, vec3(10)),\n    pow(outColor.xyz, vec3(1.2)),\n    metallic \n  );\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  if( uUseImageLight ){\n    totalDiffuse += calculateImageDiffuse(normal, modelPosition);\n    totalSpecular += calculateImageSpecular(normal, modelPosition);\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n`), R = { sphereMappingFrag: `#define PI 3.141592\n\nprecision highp float;\n  \nuniform sampler2D uSampler;\nuniform mat3 uNewNormalMatrix;\nuniform float uFovY;\nuniform float uAspect;\n\nvarying vec2 vTexCoord;\n  \nvoid main() {\n    float uFovX = uFovY * uAspect; \n    vec4 newTexColor = texture2D(uSampler, vTexCoord);\n    float angleY = mix(uFovY/2.0,  -uFovY/2.0, vTexCoord.y);\n    float angleX = mix(uFovX/2.0, -uFovX/2.0, vTexCoord.x);\n    vec3 rotatedNormal = vec3( angleX, angleY, 1.0 );\n    rotatedNormal = uNewNormalMatrix * normalize(rotatedNormal);\n    vec2 suv;\n    suv.y = 0.5 + 0.5 * (-rotatedNormal.y);\n    suv.x = atan(rotatedNormal.z, rotatedNormal.x) / (2.0 * PI) + 0.5;\n    newTexColor = texture2D(uSampler, suv.xy);\n    gl_FragColor = newTexColor;\n}\n`, immediateVert: `IN vec3 aPosition;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uResolution;\nuniform float uPointSize;\n\nOUT vec4 vColor;\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n  gl_PointSize = uPointSize;\n}\n`, vertexColorVert: `IN vec3 aPosition;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nOUT vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n}\n`, vertexColorFrag: `IN vec4 vColor;\nvoid main(void) {\n  OUT_COLOR = vec4(vColor.rgb, 1.) * vColor.a;\n}\n`, normalVert: `IN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec4 uMaterialColor;\nuniform bool uUseVertexColor;\n\nOUT vec3 vVertexNormal;\nOUT highp vec2 vVertTexCoord;\nOUT vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vVertexNormal = normalize(vec3( uNormalMatrix * aNormal ));\n  vVertTexCoord = aTexCoord;\n  vColor = (uUseVertexColor ? aVertexColor : uMaterialColor);\n}\n`, normalFrag: `IN vec3 vVertexNormal;\nvoid main(void) {\n  OUT_COLOR = vec4(vVertexNormal, 1.0);\n}\n`, basicFrag: `IN vec4 vColor;\nvoid main(void) {\n  OUT_COLOR = vec4(vColor.rgb, 1.) * vColor.a;\n}\n`, lightVert: M + `// include lighting.glgl\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT highp vec2 vVertTexCoord;\nOUT vec3 vDiffuseColor;\nOUT vec3 vSpecularColor;\nOUT vec4 vColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n  \n  vColor = (uUseVertexColor ? aVertexColor : uMaterialColor);\n}\n`, lightTextureFrag: `uniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nIN highp vec2 vVertTexCoord;\nIN vec3 vDiffuseColor;\nIN vec3 vSpecularColor;\nIN vec4 vColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    OUT_COLOR = vColor;\n  }\n  else {\n    vec4 baseColor = isTexture\n      // Textures come in with premultiplied alpha. To apply tint and still have\n      // premultiplied alpha output, we need to multiply the RGB channels by the\n      // tint RGB, and all channels by the tint alpha.\n      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)\n      // Colors come in with unmultiplied alpha, so we need to multiply the RGB\n      // channels by alpha to convert it to premultiplied alpha.\n      : vec4(vColor.rgb * vColor.a, vColor.a);\n    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);\n  }\n}\n`, phongVert: `precision highp int;\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT vec3 vNormal;\nOUT vec2 vTexCoord;\nOUT vec3 vViewPosition;\nOUT vec3 vAmbientColor;\nOUT vec4 vColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Pass varyings to fragment shader\n  vViewPosition = viewModelPosition.xyz;\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  vNormal = uNormalMatrix * aNormal;\n  vTexCoord = aTexCoord;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n  \n  vColor = (uUseVertexColor ? aVertexColor : uMaterialColor);\n}\n`, phongFrag: M + `// include lighting.glsl\nprecision highp int;\n\nuniform bool uHasSetAmbient;\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nIN vec3 vNormal;\nIN vec2 vTexCoord;\nIN vec3 vViewPosition;\nIN vec3 vAmbientColor;\nIN vec4 vColor;\n\nvoid main(void) {\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n  // Calculating final color as result of all lights (plus emissive term).\n\n  vec4 baseColor = isTexture\n    // Textures come in with premultiplied alpha. To apply tint and still have\n    // premultiplied alpha output, we need to multiply the RGB channels by the\n    // tint RGB, and all channels by the tint alpha.\n    ? TEXTURE(uSampler, vTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)\n    // Colors come in with unmultiplied alpha, so we need to multiply the RGB\n    // channels by alpha to convert it to premultiplied alpha.\n    : vec4(vColor.rgb * vColor.a, vColor.a);\n  OUT_COLOR = vec4(diffuse * baseColor.rgb + \n                    vAmbientColor * (\n                      uHasSetAmbient ? uAmbientMatColor.rgb : baseColor.rgb\n                    ) + \n                    specular * uSpecularMatColor.rgb + \n                    uEmissiveMatColor.rgb, baseColor.a);\n}\n`, fontVert: `IN vec3 aPosition;\nIN vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nOUT vec2 vTexCoord;\nOUT float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // Expand glyph bounding boxes by 1px on each side to give a bit of room\n  // for antialiasing\n  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;\n  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;\n  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;\n  vec2 pixelScale = vec2(\n    1. / length(newOrigin - newDX),\n    1. / length(newOrigin - newDY)\n  );\n  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5)) * vec2(1., -1.);\n  vec2 textureOffset = offset * (1. / vec2(\n    uGlyphRect.z - uGlyphRect.x,\n    uGlyphRect.w - uGlyphRect.y\n  ));\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n\n  positionVec4.xy += offset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord + textureOffset;\n  w = gl_Position.w;\n}\n`, fontFrag: `#ifndef WEBGL2\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if 0\n  // simulate integer math using floats\n\t#define int float\n\t#define ivec2 vec2\n\t#define INT(x) float(x)\n\n\tint ifloor(float v) { return floor(v); }\n\tivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n\tprecision highp int;\n\t#define INT(x) x\n\n\tint ifloor(float v) { return int(v); }\n\tint ifloor(int v) { return v; }\n\tivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nIN vec2 vTexCoord;\n\n// some helper functions\nint ROUND(float v) { return ifloor(v + 0.5); }\nivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = ROUND(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;\n  OUT_COLOR *= saturate(max(antialias, cover));\n}\n`, lineVert: P + `/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\nprecision mediump int;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform bool uUseLineColor;\nuniform vec4 uMaterialColor;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\nuniform int uStrokeJoin;\n\nIN vec4 aPosition;\nIN vec3 aTangentIn;\nIN vec3 aTangentOut;\nIN float aSide;\nIN vec4 aVertexColor;\n\nOUT vec4 vColor;\nOUT vec2 vTangent;\nOUT vec2 vCenter;\nOUT vec2 vPosition;\nOUT float vMaxDist;\nOUT float vCap;\nOUT float vJoin;\n\nvec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {\n  // Rotate and translate so a starts at the origin and goes out to the right\n  bPoint -= aPoint;\n  vec2 rotatedBFrom = vec2(\n    bPoint.x*aDir.x + bPoint.y*aDir.y,\n    bPoint.y*aDir.x - bPoint.x*aDir.y\n  );\n  vec2 bTo = bPoint + bDir;\n  vec2 rotatedBTo = vec2(\n    bTo.x*aDir.x + bTo.y*aDir.y,\n    bTo.y*aDir.x - bTo.x*aDir.y\n  );\n  float intersectionDistance =\n    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /\n    (rotatedBTo.y - rotatedBFrom.y);\n  return aPoint + aDir * intersectionDistance;\n}\n\nvoid main() {\n  // Caps have one of either the in or out tangent set to 0\n  vCap = (aTangentIn == vec3(0.)) != (aTangentOut == (vec3(0.)))\n    ? 1. : 0.;\n\n  // Joins have two unique, defined tangents\n  vJoin = (\n    aTangentIn != vec3(0.) &&\n    aTangentOut != vec3(0.) &&\n    aTangentIn != aTangentOut\n  ) ? 1. : 0.;\n\n  vec4 posp = uModelViewMatrix * aPosition;\n  vec4 posqIn = uModelViewMatrix * (aPosition + vec4(aTangentIn, 0));\n  vec4 posqOut = uModelViewMatrix * (aPosition + vec4(aTangentOut, 0));\n\n  float facingCamera = pow(\n    // The word space tangent's z value is 0 if it's facing the camera\n    abs(normalize(posqIn-posp).z),\n\n    // Using pow() here to ramp \\`facingCamera\\` up from 0 to 1 really quickly\n    // so most lines get scaled and don't get clipped\n    0.25\n  );\n\n  // using a scale <1 moves the lines towards the camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  float scale = mix(1., 0.995, facingCamera);\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  posp.xyz = posp.xyz * scale;\n  posqIn.xyz = posqIn.xyz * scale;\n  posqOut.xyz = posqOut.xyz * scale;\n\n  vec4 p = uProjectionMatrix * posp;\n  vec4 qIn = uProjectionMatrix * posqIn;\n  vec4 qOut = uProjectionMatrix * posqOut;\n  vCenter = p.xy;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);\n  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);\n\n  vec2 curPerspScale;\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n\n    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.\n    // Multiplying again by its sign here negates the flip to get just the scale.\n    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  vec2 offset;\n  if (vJoin == 1.) {\n    vTangent = normalize(tangentIn + tangentOut);\n    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);\n    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);\n    float side = sign(aSide);\n    float sideEnum = abs(aSide);\n\n    // We generate vertices for joins on either side of the centerline, but\n    // the \"elbow\" side is the only one needing a join. By not setting the\n    // offset for the other side, all its vertices will end up in the same\n    // spot and not render, effectively discarding it.\n    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {\n      // Side enums:\n      //   1: the side going into the join\n      //   2: the middle of the join\n      //   3: the side going out of the join\n      if (sideEnum == 2.) {\n        // Calculate the position + tangent on either side of the join, and\n        // find where the lines intersect to find the elbow of the join\n        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;\n        vec2 intersection = lineIntersection(\n          c + (side * normalIn * uStrokeWeight / 2.),\n          tangentIn,\n          c + (side * normalOut * uStrokeWeight / 2.),\n          tangentOut\n        );\n        offset = (intersection - c);\n\n        // When lines are thick and the angle of the join approaches 180, the\n        // elbow might be really far from the center. We'll apply a limit to\n        // the magnitude to avoid lines going across the whole screen when this\n        // happens.\n        float mag = length(offset);\n        float maxMag = 3. * uStrokeWeight;\n        if (mag > maxMag) {\n          offset *= maxMag / mag;\n        }\n      } else if (sideEnum == 1.) {\n        offset = side * normalIn * uStrokeWeight / 2.;\n      } else if (sideEnum == 3.) {\n        offset = side * normalOut * uStrokeWeight / 2.;\n      }\n    }\n    if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);\n      vMaxDist = abs(dot(avgNormal, normalIn * uStrokeWeight / 2.));\n    } else {\n      vMaxDist = uStrokeWeight / 2.;\n    }\n  } else {\n    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;\n    vTangent = tangent;\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    float normalOffset = sign(aSide);\n    // Caps will have side values of -2 or 2 on the edge of the cap that\n    // extends out from the line\n    float tangentOffset = abs(aSide) - 1.;\n    offset = (normal * normalOffset + tangent * tangentOffset) *\n      uStrokeWeight * 0.5;\n    vMaxDist = uStrokeWeight / 2.;\n  }\n  vPosition = vCenter + offset;\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n  \n  vColor = (uUseLineColor ? aVertexColor : uMaterialColor);\n}\n`, lineFrag: P + `precision mediump int;\n\nuniform vec4 uMaterialColor;\nuniform int uStrokeCap;\nuniform int uStrokeJoin;\nuniform float uStrokeWeight;\n\nIN vec4 vColor;\nIN vec2 vTangent;\nIN vec2 vCenter;\nIN vec2 vPosition;\nIN float vMaxDist;\nIN float vCap;\nIN float vJoin;\n\nfloat distSquared(vec2 a, vec2 b) {\n  vec2 aToB = b - a;\n  return dot(aToB, aToB);\n}\n\nvoid main() {\n  if (vCap > 0.) {\n    if (\n      uStrokeCap == STROKE_CAP_ROUND &&\n      distSquared(vPosition, vCenter) > uStrokeWeight * uStrokeWeight * 0.25\n    ) {\n      discard;\n    } else if (\n      uStrokeCap == STROKE_CAP_SQUARE &&\n      dot(vPosition - vCenter, vTangent) > 0.\n    ) {\n      discard;\n    }\n    // Use full area for PROJECT\n  } else if (vJoin > 0.) {\n    if (\n      uStrokeJoin == STROKE_JOIN_ROUND &&\n      distSquared(vPosition, vCenter) > uStrokeWeight * uStrokeWeight * 0.25\n    ) {\n      discard;\n    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 normal = vec2(-vTangent.y, vTangent.x);\n      if (abs(dot(vPosition - vCenter, normal)) > vMaxDist) {\n        discard;\n      }\n    }\n    // Use full area for MITER\n  }\n  OUT_COLOR = vec4(vColor.rgb, 1.) * vColor.a;\n}\n`, pointVert: `IN vec3 aPosition;\nuniform float uPointSize;\nOUT float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nvoid main() {\n\tvec4 positionVec4 =  vec4(aPosition, 1.0);\n\tgl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n\tgl_PointSize = uPointSize;\n\tvStrokeWeight = uPointSize;\n}\n`, pointFrag: `precision mediump int;\nuniform vec4 uMaterialColor;\nIN float vStrokeWeight;\n\nvoid main(){\n  float mask = 0.0;\n\n  // make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n  // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n  mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n  // if strokeWeight is 1 or less lets just draw a square\n  // this prevents weird artifacting from carving circles when our points are really small\n  // if strokeWeight is larger than 1, we just use it as is\n\n  mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n  // throw away the borders of the mask\n  // otherwise we get weird alpha blending issues\n\n  if(mask > 0.98){\n    discard;\n  }\n\n  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;\n}\n`, imageLightVert: `precision highp float;\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nvarying vec3 localPos;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPosition;\nvarying vec2 vTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n  \n  // orient the normals and pass to the fragment shader\n  vWorldNormal = uNormalMatrix * aNormal;\n  \n  // send the view position to the fragment shader\n  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;\n  \n  localPos = vWorldPosition;\n  vTexCoord = aTexCoord;\n}\n\n\n/*\nin the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.\n*/\n`, imageLightDiffusedFrag: `precision highp float;\nvarying vec3 localPos;\n\n// the HDR cubemap converted (can be from an equirectangular environment map.)\nuniform sampler2D environmentMap;\nvarying vec2 vTexCoord;\n\nconst float PI = 3.14159265359;\n\nvec2 nTOE( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( phi, theta );\n  return angles;\n}\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid main()\n{   \t \n\t// the sample direction equals the hemisphere's orientation\n  float phi = vTexCoord.x * 2.0 * PI;\n  float theta = vTexCoord.y * PI;\n  float x = sin(theta) * cos(phi);\n  float y = sin(theta) * sin(phi);\n  float z = cos(theta);\n  vec3 normal = vec3( x, y, z);\n\n\t// Discretely sampling the hemisphere given the integral's\n  // spherical coordinates translates to the following fragment code:\n\tvec3 irradiance = vec3(0.0);  \n\tvec3 up\t= vec3(0.0, 1.0, 0.0);\n\tvec3 right = normalize(cross(up, normal));\n\tup = normalize(cross(normal, right));\n\n\t//  We specify a fixed sampleDelta delta value to traverse\n  // the hemisphere; decreasing or increasing the sample delta\n  // will increase or decrease the accuracy respectively.\n\tconst float sampleDelta = 0.100;\n\tfloat nrSamples = 0.0;\n  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;\n\tfor(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)\n\t{\n    float phi = rawPhi + randomOffset;\n    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)\n    {\n      float theta = rawTheta + randomOffset;\n      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance\n      float x = sin(theta) * cos(phi);\n      float y = sin(theta) * sin(phi);\n      float z = cos(theta);\n      vec3 tangentSample = vec3( x, y, z);\n      \n      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;\n        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n\t}\n\t// divide by the total number of samples taken, giving us the average sampled irradiance.\n\tirradiance = PI * irradiance * (1.0 / float(nrSamples )) ;\n  \n \n\tgl_FragColor = vec4(irradiance, 1.0);\n}`, imageLightSpecularFrag: `precision highp float;\\r\nvarying vec3 localPos;\\r\nvarying vec2 vTexCoord;\\r\n\\r\n// our texture\\r\nuniform sampler2D environmentMap;\\r\nuniform float roughness;\\r\n\\r\nconst float PI = 3.14159265359;\\r\n\\r\nfloat VanDerCorput(int bits);\\r\nvec2 HammersleyNoBitOps(int i, int N);\\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\\r\n\\r\n\\r\nvec2 nTOE( vec3 v ){\\r\n  // x = r sin(phi) cos(theta)   \\r\n  // y = r cos(phi)  \\r\n  // z = r sin(phi) sin(theta)\\r\n  float phi = acos( v.y );\\r\n  // if phi is 0, then there are no x, z components\\r\n  float theta = 0.0;\\r\n  // else \\r\n  theta = acos(v.x / sin(phi));\\r\n  float sinTheta = v.z / sin(phi);\\r\n  if (sinTheta < 0.0) {\\r\n    // Turn it into -theta, but in the 0-2PI range\\r\n    theta = 2.0 * PI - theta;\\r\n  }\\r\n  theta = theta / (2.0 * 3.14159);\\r\n  phi = phi / 3.14159 ;\\r\n  \\r\n  vec2 angles = vec2( phi, theta );\\r\n  return angles;\\r\n}\\r\n\\r\n\\r\nvoid main(){\\r\n  const int SAMPLE_COUNT = 400; // 4096\\r\n  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\\r\n  float totalWeight = 0.0;\\r\n  vec3 prefilteredColor = vec3(0.0);\\r\n  float phi = vTexCoord.x * 2.0 * PI;\\r\n  float theta = vTexCoord.y * PI;\\r\n  float x = sin(theta) * cos(phi);\\r\n  float y = sin(theta) * sin(phi);\\r\n  float z = cos(theta);\\r\n  vec3 N = vec3(x,y,z);\\r\n  vec3 V = N;\\r\n  for (int i = 0; i < SAMPLE_COUNT; ++i)\\r\n  {\\r\n    // break at smaller sample numbers for low roughness levels\\r\n    if(i == lowRoughnessLimit)\\r\n    {\\r\n      break;\\r\n    }\\r\n    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\\r\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\\r\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\\r\n\\r\n    float NdotL = max(dot(N, L), 0.0);\\r\n    if (NdotL > 0.0)\\r\n    {\\r\n      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\\r\n      totalWeight += NdotL;\\r\n    }\\r\n  }\\r\n  prefilteredColor = prefilteredColor / totalWeight;\\r\n\\r\n  gl_FragColor = vec4(prefilteredColor, 1.0);\\r\n}\\r\n\\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\\r\n  float a = roughness * roughness;\\r\n\\r\n  float phi = 2.0 * PI * Xi.x;\\r\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\\r\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\r\n  // from spherical coordinates to cartesian coordinates\\r\n  vec3 H;\\r\n  H.x = cos(phi) * sinTheta;\\r\n  H.y = sin(phi) * sinTheta;\\r\n  H.z = cosTheta;\\r\n\\r\n  // from tangent-space vector to world-space sample vector\\r\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\r\n  vec3 tangent = normalize(cross(up, N));\\r\n  vec3 bitangent = cross(N, tangent);\\r\n\\r\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\\r\n  return normalize(sampleVec);\\r\n}\\r\n\\r\n\\r\nfloat VanDerCorput(int n, int base)\\r\n{\\r\n#ifdef WEBGL2\\r\n\\r\n    uint bits = uint(n);\\r\n    bits = (bits << 16u) | (bits >> 16u);\\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\\r\n\\r\n#else\\r\n\\r\n  float invBase = 1.0 / float(base);\\r\n  float denom = 1.0;\\r\n  float result = 0.0;\\r\n\\r\n\\r\n  for (int i = 0; i < 32; ++i)\\r\n  {\\r\n        if (n > 0)\\r\n        {\\r\n        denom = mod(float(n), 2.0);\\r\n        result += denom * invBase;\\r\n        invBase = invBase / 2.0;\\r\n        n = int(float(n) / 2.0);\\r\n        }\\r\n  }\\r\n\\r\n\\r\n  return result;\\r\n\\r\n#endif\\r\n}\\r\n\\r\nvec2 HammersleyNoBitOps(int i, int N)\\r\n{\\r\n  return vec2(float(i) / float(N), VanDerCorput(i, 2));\\r\n}\\r\n` }, L = R.sphereMappingFrag;\n      for (E in R)\n        R[E] = `#ifdef WEBGL2\n\n#define IN in\n#define OUT out\n\n#ifdef FRAGMENT_SHADER\nout vec4 outColor;\n#define OUT_COLOR outColor\n#endif\n#define TEXTURE texture\n\n#else\n\n#ifdef FRAGMENT_SHADER\n#define IN varying\n#else\n#define IN attribute\n#endif\n#define OUT varying\n#define TEXTURE texture2D\n\n#ifdef FRAGMENT_SHADER\n#define OUT_COLOR gl_FragColor\n#endif\n\n#endif\n` + R[E];\n      T(M = {}, h.GRAY, `precision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 tex = texture2D(tex0, vTexCoord);\n  float gray = luma(tex.rgb);\n  gl_FragColor = vec4(gray, gray, gray, tex.a);\n}\n`), T(M, h.ERODE, `// Reduces the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the darkest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum < lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n`), T(M, h.DILATE, `// Increase the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the brightest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum > lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n`), T(M, h.BLUR, `precision highp float;\n\n// Two-pass blur filter, unweighted kernel.\n// See also a similar blur at Adam Ferriss' repo of shader examples:\n// https://github.com/aferriss/p5jsShaderExamples/blob/gh-pages/4_image-effects/4-9_single-pass-blur/effect.frag\n\n\nuniform sampler2D tex0;\nvarying vec2 vTexCoord;\nuniform vec2 direction;\nuniform vec2 canvasSize;\nuniform float radius;\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n// This isn't a real Gaussian weight, it's a quadratic weight. It's what the\n// CPU mode's blur uses though, so we also use it here to match.\nfloat quadWeight(float x, float e) {\n  return pow(e-abs(x), 2.);\n}\n\nvoid main(){\n  vec2 uv = vTexCoord;\n\n  // A reasonable maximum number of samples\n  const float maxSamples = 64.0;\n\n  float numSamples = floor(7. * radius);\n  if (fract(numSamples / 2.) == 0.) {\n    numSamples++;\n  }\n  vec4 avg = vec4(0.0);\n  float total = 0.0;\n\n  // Calculate the spacing to avoid skewing if numSamples > maxSamples\n  float spacing = 1.0;\n  if (numSamples > maxSamples) {\n    spacing = numSamples / maxSamples;\n    numSamples = maxSamples;\n  }\n\n  float randomOffset = (spacing - 1.0) * mix(-0.5, 0.5, random(gl_FragCoord.xy));\n  for (float i = 0.0; i < maxSamples; i++) {\n    if (i >= numSamples) break;\n\n    float sample = i * spacing - (numSamples - 1.0) * 0.5 * spacing + randomOffset;\n    vec2 sampleCoord = uv + vec2(sample, sample) / canvasSize * direction;\n    float weight = quadWeight(sample, (numSamples - 1.0) * 0.5 * spacing);\n\n    avg += weight * texture2D(tex0, sampleCoord);\n    total += weight;\n  }\n\n  avg /= total;\n  gl_FragColor = avg;\n}\n`), T(M, h.POSTERIZE, `// Limit color space for a stylized cartoon / poster effect\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nvec3 quantize(vec3 color, float n) {\n  // restrict values to N options/bins\n  // and floor each channel to nearest value\n  //\n  // eg. when N = 5, values = 0.0, 0.25, 0.50, 0.75, 1.0\n  // then quantize (0.1, 0.7, 0.9) -> (0.0, 0.5, 1.0)\n\n  color = color * n;\n  color = floor(color);\n  color = color / (n - 1.0);\n  return color;\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n\n  vec3 restrictedColor = quantize(color.rgb / color.a, filterParameter);\n\n  gl_FragColor = vec4(restrictedColor.rgb * color.a, color.a);\n}\n`), T(M, h.OPAQUE, `// Set alpha channel to entirely opaque\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  gl_FragColor = vec4(color.rgb / color.a, 1.0);\n}\n`), T(M, h.INVERT, `// Set each pixel to inverse value\n// Note that original INVERT does not change the opacity, so this follows suit\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\nvec4 color = texture2D(tex0, vTexCoord);\nvec3 origColor = color.rgb / color.a;\nvec3 invertedColor = vec3(1.0) - origColor;\ngl_FragColor = vec4(invertedColor * color.a, color.a);\n}\n`), T(M, h.THRESHOLD, `// Convert pixels to either white or black, \n// depending on if their luma is above or below filterParameter\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float gray = luma(color.rgb / color.a);\n  // floor() used to match src/image/filters.js\n  float threshold = floor(filterParameter * 255.0) / 255.0;\n  float blackOrWhite = step(threshold, gray);\n  gl_FragColor = vec4(vec3(blackOrWhite) * color.a, color.a);\n}\n`);\n      var F = M;\n      function V(U, W, ce, ne, b, O, D, B, Y, J) {\n        var te = W.getParameter(W.FRAMEBUFFER_BINDING), ce = (W.bindFramebuffer(W.FRAMEBUFFER, ce), B === W.RGBA ? 4 : 3), re = O * D * ce, ue = Y === W.UNSIGNED_BYTE ? Uint8Array : Float32Array;\n        if (U instanceof ue && U.length === re || (U = new ue(re)), W.readPixels(ne, J ? J - b - D : b, O, D, B, Y, U), W.bindFramebuffer(W.FRAMEBUFFER, te), J)\n          for (var le = Math.floor(D / 2), K = new ue(O * ce), ae = 0; ae < le; ae++) {\n            var he = ae * O * 4, _e = (D - ae - 1) * O * 4;\n            K.set(U.subarray(he, he + 4 * O)), U.copyWithin(he, _e, _e + 4 * O), U.set(K, _e);\n          }\n        return U;\n      }\n      function G(U, Y, X, ne, b, O, D) {\n        var B = U.getParameter(U.FRAMEBUFFER_BINDING), Y = (U.bindFramebuffer(U.FRAMEBUFFER, Y), b === U.RGBA ? 4 : 3), Y = new (O === U.UNSIGNED_BYTE ? Uint8Array : Float32Array)(Y);\n        return U.readPixels(X, D ? D - ne - 1 : ne, 1, 1, b, O, Y), U.bindFramebuffer(U.FRAMEBUFFER, B), Array.from(Y);\n      }\n      u.default.prototype.setAttributes = function(U, W) {\n        if (this._glAttributes === void 0)\n          console.log(\"You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.\");\n        else {\n          var X = !0;\n          if (W !== void 0 ? (this._glAttributes === null && (this._glAttributes = {}), this._glAttributes[U] !== W && (this._glAttributes[U] = W, X = !1)) : U instanceof Object && this._glAttributes !== U && (this._glAttributes = U, X = !1), this._renderer.isP3D && !X) {\n            if (!this._setupDone) {\n              for (var ne in this._renderer.retainedMode.geometry)\n                if (this._renderer.retainedMode.geometry.hasOwnProperty(ne))\n                  return void u.default._friendlyError(\"Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()\");\n            }\n            this.push(), this._renderer._resetContext(), this.pop(), this._renderer._curCamera && (this._renderer._curCamera._renderer = this._renderer);\n          }\n        }\n      }, u.default.RendererGL = function(U) {\n        var W = ne;\n        if (typeof U != \"function\" && U !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        W.prototype = Object.create(U && U.prototype, { constructor: { value: W, writable: !0, configurable: !0 } }), U && a(W, U);\n        var X = c(ne);\n        function ne(b, O, D, B) {\n          if (this instanceof ne)\n            return (b = X.call(this, b, O, D))._setAttributeDefaults(O), b._initContext(), b.isP3D = !0, b.geometryBuilder = void 0, b.GL = b.drawingContext, b._pInst._setProperty(\"drawingContext\", b.drawingContext), b._isErasing = !1, b._clipDepths = [], b._isClipApplied = !1, b._stencilTestOn = !1, b._enableLighting = !1, b.ambientLightColors = [], b.mixedAmbientLight = [], b.mixedSpecularColor = [], b.specularColors = [1, 1, 1], b.directionalLightDirections = [], b.directionalLightDiffuseColors = [], b.directionalLightSpecularColors = [], b.pointLightPositions = [], b.pointLightDiffuseColors = [], b.pointLightSpecularColors = [], b.spotLightPositions = [], b.spotLightDirections = [], b.spotLightDiffuseColors = [], b.spotLightSpecularColors = [], b.spotLightAngle = [], b.spotLightConc = [], b.activeImageLight = null, b.diffusedTextures = /* @__PURE__ */ new Map(), b.specularTextures = /* @__PURE__ */ new Map(), b.drawMode = h.FILL, b.curFillColor = b._cachedFillStyle = [1, 1, 1, 1], b.curAmbientColor = b._cachedFillStyle = [1, 1, 1, 1], b.curSpecularColor = b._cachedFillStyle = [0, 0, 0, 0], b.curEmissiveColor = b._cachedFillStyle = [0, 0, 0, 0], b.curStrokeColor = b._cachedStrokeStyle = [0, 0, 0, 1], b.curBlendMode = h.BLEND, b.preEraseBlend = void 0, b._cachedBlendMode = void 0, b.webglVersion === h.WEBGL2 ? b.blendExt = b.GL : b.blendExt = b.GL.getExtension(\"EXT_blend_minmax\"), b._isBlending = !1, b._hasSetAmbient = !1, b._useSpecularMaterial = !1, b._useEmissiveMaterial = !1, b._useNormalMaterial = !1, b._useShininess = 1, b._useMetalness = 0, b._useLineColor = !1, b._useVertexColor = !1, b.registerEnabled = /* @__PURE__ */ new Set(), b._tint = [255, 255, 255, 255], b.constantAttenuation = 1, b.linearAttenuation = 0, b.quadraticAttenuation = 0, b.uMVMatrix = new u.default.Matrix(), b.uPMatrix = new u.default.Matrix(), b.uNMatrix = new u.default.Matrix(\"mat3\"), b.curMatrix = new u.default.Matrix(\"mat3\"), b._currentNormal = new u.default.Vector(0, 0, 1), b._curCamera = new u.default.Camera(p(b)), b._curCamera._computeCameraDefaultSettings(), b._curCamera._setDefaultCamera(), b.filterCamera = new u.default.Camera(p(b)), b.filterCamera._computeCameraDefaultSettings(), b.filterCamera._setDefaultCamera(), b.prevTouches = [], b.zoomVelocity = 0, b.rotateVelocity = new u.default.Vector(0, 0), b.moveVelocity = new u.default.Vector(0, 0), b.executeZoom = !1, b.executeRotateAndMove = !1, b.specularShader = void 0, b.sphereMapping = void 0, b.diffusedShader = void 0, b._defaultLightShader = void 0, b._defaultImmediateModeShader = void 0, b._defaultNormalShader = void 0, b._defaultColorShader = void 0, b._defaultPointShader = void 0, b.userFillShader = void 0, b.userStrokeShader = void 0, b.userPointShader = void 0, b.retainedMode = { geometry: {}, buffers: { stroke: [new u.default.RenderBuffer(4, \"lineVertexColors\", \"lineColorBuffer\", \"aVertexColor\", p(b)), new u.default.RenderBuffer(3, \"lineVertices\", \"lineVerticesBuffer\", \"aPosition\", p(b)), new u.default.RenderBuffer(3, \"lineTangentsIn\", \"lineTangentsInBuffer\", \"aTangentIn\", p(b)), new u.default.RenderBuffer(3, \"lineTangentsOut\", \"lineTangentsOutBuffer\", \"aTangentOut\", p(b)), new u.default.RenderBuffer(1, \"lineSides\", \"lineSidesBuffer\", \"aSide\", p(b))], fill: [new u.default.RenderBuffer(3, \"vertices\", \"vertexBuffer\", \"aPosition\", p(b), b._vToNArray), new u.default.RenderBuffer(3, \"vertexNormals\", \"normalBuffer\", \"aNormal\", p(b), b._vToNArray), new u.default.RenderBuffer(4, \"vertexColors\", \"colorBuffer\", \"aVertexColor\", p(b)), new u.default.RenderBuffer(3, \"vertexAmbients\", \"ambientBuffer\", \"aAmbientColor\", p(b)), new u.default.RenderBuffer(2, \"uvs\", \"uvBuffer\", \"aTexCoord\", p(b), b._flatten)], text: [new u.default.RenderBuffer(3, \"vertices\", \"vertexBuffer\", \"aPosition\", p(b), b._vToNArray), new u.default.RenderBuffer(2, \"uvs\", \"uvBuffer\", \"aTexCoord\", p(b), b._flatten)] } }, b.immediateMode = { geometry: new u.default.Geometry(), shapeMode: h.TRIANGLE_FAN, contourIndices: [], _bezierVertex: [], _quadraticVertex: [], _curveVertex: [], buffers: { fill: [new u.default.RenderBuffer(3, \"vertices\", \"vertexBuffer\", \"aPosition\", p(b), b._vToNArray), new u.default.RenderBuffer(3, \"vertexNormals\", \"normalBuffer\", \"aNormal\", p(b), b._vToNArray), new u.default.RenderBuffer(4, \"vertexColors\", \"colorBuffer\", \"aVertexColor\", p(b)), new u.default.RenderBuffer(3, \"vertexAmbients\", \"ambientBuffer\", \"aAmbientColor\", p(b)), new u.default.RenderBuffer(2, \"uvs\", \"uvBuffer\", \"aTexCoord\", p(b), b._flatten)], stroke: [new u.default.RenderBuffer(4, \"lineVertexColors\", \"lineColorBuffer\", \"aVertexColor\", p(b)), new u.default.RenderBuffer(3, \"lineVertices\", \"lineVerticesBuffer\", \"aPosition\", p(b)), new u.default.RenderBuffer(3, \"lineTangentsIn\", \"lineTangentsInBuffer\", \"aTangentIn\", p(b)), new u.default.RenderBuffer(3, \"lineTangentsOut\", \"lineTangentsOutBuffer\", \"aTangentOut\", p(b)), new u.default.RenderBuffer(1, \"lineSides\", \"lineSidesBuffer\", \"aSide\", p(b))], point: b.GL.createBuffer() } }, b.pointSize = 5, b.curStrokeWeight = 1, b.curStrokeCap = h.ROUND, b.curStrokeJoin = h.ROUND, b.textures = /* @__PURE__ */ new Map(), b.framebuffers = /* @__PURE__ */ new Set(), b.activeFramebuffers = [], b.filterShader = void 0, b.filterLayer = void 0, b.filterLayerTemp = void 0, b.defaultFilterShaders = {}, b.textureMode = h.IMAGE, b.textureWrapX = h.CLAMP, b.textureWrapY = h.CLAMP, b._tex = null, b._curveTightness = 6, b._lookUpTableBezier = [], b._lookUpTableQuadratic = [], b._lutBezierDetail = 0, b._lutQuadraticDetail = 0, b.isProcessingVertices = !1, b._tessy = b._initTessy(), b.fontInfos = {}, b._curShader = void 0, b;\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n        return W = ne, (U = [{ key: \"beginGeometry\", value: function() {\n          if (this.geometryBuilder)\n            throw new Error(\"It looks like `beginGeometry()` is being called while another p5.Geometry is already being build.\");\n          this.geometryBuilder = new g.default(this);\n        } }, { key: \"endGeometry\", value: function() {\n          var b;\n          if (this.geometryBuilder)\n            return b = this.geometryBuilder.finish(), this.geometryBuilder = void 0, b;\n          throw new Error(\"Make sure you call beginGeometry() before endGeometry()!\");\n        } }, { key: \"buildGeometry\", value: function(b) {\n          return this.beginGeometry(), b(), this.endGeometry();\n        } }, { key: \"_setAttributeDefaults\", value: function(b) {\n          var O = { alpha: !0, depth: !0, stencil: !0, antialias: navigator.userAgent.toLowerCase().includes(\"safari\"), premultipliedAlpha: !0, preserveDrawingBuffer: !0, perPixelLighting: !0, version: 2 };\n          b._glAttributes === null ? b._glAttributes = O : b._glAttributes = Object.assign(O, b._glAttributes);\n        } }, { key: \"_initContext\", value: function() {\n          if (this._pInst._glAttributes.version !== 1 && (this.drawingContext = this.canvas.getContext(\"webgl2\", this._pInst._glAttributes)), this.webglVersion = this.drawingContext ? h.WEBGL2 : h.WEBGL, this._pInst._setProperty(\"webglVersion\", this.webglVersion), this.drawingContext || (this.drawingContext = this.canvas.getContext(\"webgl\", this._pInst._glAttributes) || this.canvas.getContext(\"experimental-webgl\", this._pInst._glAttributes)), this.drawingContext === null)\n            throw new Error(\"Error creating webgl context\");\n          var b = this.drawingContext;\n          b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL), b.viewport(0, 0, b.drawingBufferWidth, b.drawingBufferHeight), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), this._viewport = this.drawingContext.getParameter(this.drawingContext.VIEWPORT);\n        } }, { key: \"_getParam\", value: function() {\n          var b = this.drawingContext;\n          return b.getParameter(b.MAX_TEXTURE_SIZE);\n        } }, { key: \"_adjustDimensions\", value: function(b, O) {\n          this._maxTextureSize || (this._maxTextureSize = this._getParam());\n          var B = this._maxTextureSize, B = (u.default.prototype._maxAllowedPixelDimensions, Math.floor(B / this.pixelDensity())), D = Math.min(b, B), B = Math.min(O, B);\n          return D === b && B === O || console.warn(\"Warning: The requested width/height exceeds hardware limits. \" + \"Adjusting dimensions to width: \".concat(D, \", height: \").concat(B, \".\")), { adjustedWidth: D, adjustedHeight: B };\n        } }, { key: \"_resetContext\", value: function(b, O) {\n          var D, B = this.width, Y = this.height, te = this.canvas.id, J = this._pInst instanceof u.default.Graphics, te = (J ? ((D = this._pInst).canvas.parentNode.removeChild(D.canvas), D.canvas = document.createElement(\"canvas\"), (D._pInst._userNode || document.body).appendChild(D.canvas), u.default.Element.call(D, D.canvas, D._pInst), D.width = B, D.height = Y) : ((D = this.canvas) && D.parentNode.removeChild(D), (D = document.createElement(\"canvas\")).id = te, (this._pInst._userNode || document.body).appendChild(D), this._pInst.canvas = D, this.canvas = D), new u.default.RendererGL(this._pInst.canvas, this._pInst, !J));\n          this._pInst._setProperty(\"_renderer\", te), te.resize(B, Y), te._applyDefaults(), J || this._pInst._elements.push(te), typeof O == \"function\" && setTimeout(function() {\n            O.apply(window._renderer, b);\n          }, 0);\n        } }, { key: \"_update\", value: function() {\n          this.uMVMatrix.set(this._curCamera.cameraMatrix), this.ambientLightColors.length = 0, this.specularColors = [1, 1, 1], this.directionalLightDirections.length = 0, this.directionalLightDiffuseColors.length = 0, this.directionalLightSpecularColors.length = 0, this.pointLightPositions.length = 0, this.pointLightDiffuseColors.length = 0, this.pointLightSpecularColors.length = 0, this.spotLightPositions.length = 0, this.spotLightDirections.length = 0, this.spotLightDiffuseColors.length = 0, this.spotLightSpecularColors.length = 0, this.spotLightAngle.length = 0, this.spotLightConc.length = 0, this._enableLighting = !1, this._tint = [255, 255, 255, 255], this.GL.clearStencil(0), this.GL.clear(this.GL.DEPTH_BUFFER_BIT | this.GL.STENCIL_BUFFER_BIT), this.GL.disable(this.GL.STENCIL_TEST);\n        } }, { key: \"background\", value: function() {\n          var B = (B = this._pInst).color.apply(B, arguments), b = B.levels[0] / 255, O = B.levels[1] / 255, D = B.levels[2] / 255, B = B.levels[3] / 255;\n          this.clear(b, O, D, B);\n        } }, { key: \"fill\", value: function(b, O, D, B) {\n          var Y = u.default.prototype.color.apply(this._pInst, arguments);\n          this.curFillColor = Y._array, this.drawMode = h.FILL, this._useNormalMaterial = !1, this._tex = null;\n        } }, { key: \"stroke\", value: function(b, O, D, B) {\n          var Y = u.default.prototype.color.apply(this._pInst, arguments);\n          this.curStrokeColor = Y._array;\n        } }, { key: \"strokeCap\", value: function(b) {\n          this.curStrokeCap = b;\n        } }, { key: \"strokeJoin\", value: function(b) {\n          this.curStrokeJoin = b;\n        } }, { key: \"getFilterLayer\", value: function() {\n          return this.filterLayer || (this.filterLayer = this._pInst.createFramebuffer()), this.filterLayer;\n        } }, { key: \"getFilterLayerTemp\", value: function() {\n          return this.filterLayerTemp || (this.filterLayerTemp = this._pInst.createFramebuffer()), this.filterLayerTemp;\n        } }, { key: \"matchSize\", value: function(b, O) {\n          b.width === O.width && b.height === O.height || b.resize(O.width, O.height), b.pixelDensity() !== O.pixelDensity() && b.pixelDensity(O.pixelDensity());\n        } }, { key: \"filter\", value: function() {\n          var b, O, D = this, B = this.getFilterLayer(), Y = void 0, J = void 0, te = (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == \"string\" ? (J = arguments.length <= 0 ? void 0 : arguments[0], T(b = {}, h.BLUR, 3), T(b, h.POSTERIZE, 4), T(b, h.THRESHOLD, 0.5), Y = J in (b = b) && (arguments.length <= 1 ? void 0 : arguments[1]) === void 0 ? b[J] : arguments.length <= 1 ? void 0 : arguments[1], J in this.defaultFilterShaders || (this.defaultFilterShaders[J] = new u.default.Shader(B._renderer, `uniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nattribute vec3 aPosition;\n// texcoords only come from p5 to vertex shader\n// so pass texcoords on to the fragment shader in a varying variable\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n`, F[J])), this.filterShader = this.defaultFilterShaders[J]) : this.filterShader = arguments.length <= 0 ? void 0 : arguments[0], this.activeFramebuffer() || this), ce = (this.matchSize(B, te), B.draw(function() {\n            return D._pInst.clear();\n          }), [1 / (te.width * te.pixelDensity()), 1 / (te.height * te.pixelDensity())]);\n          J === h.BLUR ? (O = this.getFilterLayerTemp(), this.matchSize(O, te), this._pInst.push(), this._pInst.noStroke(), this._pInst.blendMode(h.BLEND), this._pInst.shader(this.filterShader), this.filterShader.setUniform(\"texelSize\", ce), this.filterShader.setUniform(\"canvasSize\", [te.width, te.height]), this.filterShader.setUniform(\"radius\", Math.max(1, Y)), O.draw(function() {\n            D.filterShader.setUniform(\"direction\", [1, 0]), D.filterShader.setUniform(\"tex0\", te), D._pInst.clear(), D._pInst.shader(D.filterShader), D._pInst.noLights(), D._pInst.plane(te.width, te.height);\n          }), B.draw(function() {\n            D.filterShader.setUniform(\"direction\", [0, 1]), D.filterShader.setUniform(\"tex0\", O), D._pInst.clear(), D._pInst.shader(D.filterShader), D._pInst.noLights(), D._pInst.plane(te.width, te.height);\n          }), this._pInst.pop()) : B.draw(function() {\n            D._pInst.noStroke(), D._pInst.blendMode(h.BLEND), D._pInst.shader(D.filterShader), D.filterShader.setUniform(\"tex0\", te), D.filterShader.setUniform(\"texelSize\", ce), D.filterShader.setUniform(\"canvasSize\", [te.width, te.height]), D.filterShader.setUniform(\"filterParameter\", Y), D._pInst.noLights(), D._pInst.plane(te.width, te.height);\n          }), this._pInst.push(), this._pInst.noStroke(), this.clear(), this._pInst.push(), this._pInst.imageMode(h.CORNER), this._pInst.blendMode(h.BLEND), te.filterCamera._resize(), this._pInst.setCamera(te.filterCamera), this._pInst.resetMatrix(), this._pInst.image(B, -te.width / 2, -te.height / 2, te.width, te.height), this._pInst.clearDepth(), this._pInst.pop(), this._pInst.pop();\n        } }, { key: \"pixelDensity\", value: function(b) {\n          return b ? this._pInst.pixelDensity(b) : this._pInst.pixelDensity();\n        } }, { key: \"blendMode\", value: function(b) {\n          b === h.DARKEST || b === h.LIGHTEST || b === h.ADD || b === h.BLEND || b === h.SUBTRACT || b === h.SCREEN || b === h.EXCLUSION || b === h.REPLACE || b === h.MULTIPLY || b === h.REMOVE ? this.curBlendMode = b : b !== h.BURN && b !== h.OVERLAY && b !== h.HARD_LIGHT && b !== h.SOFT_LIGHT && b !== h.DODGE || console.warn(\"BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.\");\n        } }, { key: \"erase\", value: function(b, O) {\n          this._isErasing || (this.preEraseBlend = this.curBlendMode, this._isErasing = !0, this.blendMode(h.REMOVE), this._cachedFillStyle = this.curFillColor.slice(), this.curFillColor = [1, 1, 1, b / 255], this._cachedStrokeStyle = this.curStrokeColor.slice(), this.curStrokeColor = [1, 1, 1, O / 255]);\n        } }, { key: \"noErase\", value: function() {\n          this._isErasing && (this.curFillColor = this._cachedFillStyle.slice(), this.curStrokeColor = this._cachedStrokeStyle.slice(), this.curBlendMode = this.preEraseBlend, this.blendMode(this.preEraseBlend), this._isErasing = !1, this._applyBlendMode());\n        } }, { key: \"drawTarget\", value: function() {\n          return this.activeFramebuffers[this.activeFramebuffers.length - 1] || this;\n        } }, { key: \"beginClip\", value: function() {\n          var b = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}, b = (n(j(ne.prototype), \"beginClip\", this).call(this, b), this.drawTarget()._isClipApplied = !0, this.GL);\n          b.clearStencil(0), b.clear(b.STENCIL_BUFFER_BIT), b.enable(b.STENCIL_TEST), this._stencilTestOn = !0, b.stencilFunc(b.ALWAYS, 1, 255), b.stencilOp(b.KEEP, b.KEEP, b.REPLACE), b.disable(b.DEPTH_TEST), this._pInst.push(), this._pInst.resetShader(), this._doFill && this._pInst.fill(0, 0), this._doStroke && this._pInst.stroke(0, 0);\n        } }, { key: \"endClip\", value: function() {\n          this._pInst.pop();\n          var b = this.GL;\n          b.stencilOp(b.KEEP, b.KEEP, b.KEEP), b.stencilFunc(this._clipInvert ? b.EQUAL : b.NOTEQUAL, 0, 255), b.enable(b.DEPTH_TEST), this._clipDepths.push(this._pushPopDepth), n(j(ne.prototype), \"endClip\", this).call(this);\n        } }, { key: \"_clearClip\", value: function() {\n          this.GL.clearStencil(1), this.GL.clear(this.GL.STENCIL_BUFFER_BIT), 0 < this._clipDepths.length && this._clipDepths.pop(), this.drawTarget()._isClipApplied = !1;\n        } }, { key: \"strokeWeight\", value: function(b) {\n          this.curStrokeWeight !== b && (this.pointSize = b, this.curStrokeWeight = b);\n        } }, { key: \"_getPixel\", value: function(b, O) {\n          var D = this.GL;\n          return G(D, null, b, O, D.RGBA, D.UNSIGNED_BYTE, this._pInst.height * this._pInst.pixelDensity());\n        } }, { key: \"loadPixels\", value: function() {\n          var b, O, D = this._pixelsState;\n          this._pInst._glAttributes.preserveDrawingBuffer !== !0 ? console.log(\"loadPixels only works in WebGL when preserveDrawingBuffer is true.\") : (b = this._pInst._pixelDensity, O = this.GL, D._setProperty(\"pixels\", V(D.pixels, O, null, 0, 0, this.width * b, this.height * b, O.RGBA, O.UNSIGNED_BYTE, this.height * b)));\n        } }, { key: \"updatePixels\", value: function() {\n          var b = this._getTempFramebuffer();\n          b.pixels = this._pixelsState.pixels, b.updatePixels(), this._pInst.push(), this._pInst.resetMatrix(), this._pInst.clear(), this._pInst.imageMode(h.CENTER), this._pInst.image(b, 0, 0), this._pInst.pop(), this.GL.clearDepth(1), this.GL.clear(this.GL.DEPTH_BUFFER_BIT);\n        } }, { key: \"_getTempFramebuffer\", value: function() {\n          return this._tempFramebuffer || (this._tempFramebuffer = this._pInst.createFramebuffer({ format: h.UNSIGNED_BYTE, useDepth: this._pInst._glAttributes.depth, depthFormat: h.UNSIGNED_INT, antialias: this._pInst._glAttributes.antialias })), this._tempFramebuffer;\n        } }, { key: \"geometryInHash\", value: function(b) {\n          return this.retainedMode.geometry[b] !== void 0;\n        } }, { key: \"viewport\", value: function(b, O) {\n          this._viewport = [0, 0, b, O], this.GL.viewport(0, 0, b, O);\n        } }, { key: \"resize\", value: function(Y, B) {\n          u.default.Renderer.prototype.resize.call(this, Y, B), this._origViewport = { width: this.GL.drawingBufferWidth, height: this.GL.drawingBufferHeight }, this.viewport(this._origViewport.width, this._origViewport.height), this._curCamera._resize();\n          var Y = this._pixelsState, D = (Y.pixels !== void 0 && Y._setProperty(\"pixels\", new Uint8Array(this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4)), !0), B = !1, Y = void 0;\n          try {\n            for (var J, te = this.framebuffers[Symbol.iterator](); !(D = (J = te.next()).done); D = !0)\n              J.value._canvasSizeChanged();\n          } catch (ce) {\n            B = !0, Y = ce;\n          } finally {\n            try {\n              D || te.return == null || te.return();\n            } finally {\n              if (B)\n                throw Y;\n            }\n          }\n        } }, { key: \"clear\", value: function() {\n          var b = (arguments.length <= 0 ? void 0 : arguments[0]) || 0, O = (arguments.length <= 1 ? void 0 : arguments[1]) || 0, D = (arguments.length <= 2 ? void 0 : arguments[2]) || 0, B = (arguments.length <= 3 ? void 0 : arguments[3]) || 0, Y = this.activeFramebuffer();\n          Y && Y.format === h.UNSIGNED_BYTE && !Y.antialias && B === 0 && (B = 1e-10), this.GL.clearColor(b * B, O * B, D * B, B), this.GL.clearDepth(1), this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);\n        } }, { key: \"clearDepth\", value: function() {\n          this.GL.clearDepth(0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 1), this.GL.clear(this.GL.DEPTH_BUFFER_BIT);\n        } }, { key: \"applyMatrix\", value: function(b, O, D, B, Y, J) {\n          arguments.length === 16 ? u.default.Matrix.prototype.apply.apply(this.uMVMatrix, arguments) : this.uMVMatrix.apply([b, O, 0, 0, D, B, 0, 0, 0, 0, 1, 0, Y, J, 0, 1]);\n        } }, { key: \"translate\", value: function(b, O, D) {\n          return b instanceof u.default.Vector && (D = b.z, O = b.y, b = b.x), this.uMVMatrix.translate([b, O, D]), this;\n        } }, { key: \"scale\", value: function(b, O, D) {\n          return this.uMVMatrix.scale(b, O, D), this;\n        } }, { key: \"rotate\", value: function(b, O) {\n          return O === void 0 ? this.rotateZ(b) : (u.default.Matrix.prototype.rotate.apply(this.uMVMatrix, arguments), this);\n        } }, { key: \"rotateX\", value: function(b) {\n          return this.rotate(b, 1, 0, 0), this;\n        } }, { key: \"rotateY\", value: function(b) {\n          return this.rotate(b, 0, 1, 0), this;\n        } }, { key: \"rotateZ\", value: function(b) {\n          return this.rotate(b, 0, 0, 1), this;\n        } }, { key: \"push\", value: function() {\n          var b = u.default.Renderer.prototype.push.apply(this), O = b.properties;\n          return O.uMVMatrix = this.uMVMatrix.copy(), O.uPMatrix = this.uPMatrix.copy(), O._curCamera = this._curCamera, this._curCamera = this._curCamera.copy(), O.ambientLightColors = this.ambientLightColors.slice(), O.specularColors = this.specularColors.slice(), O.directionalLightDirections = this.directionalLightDirections.slice(), O.directionalLightDiffuseColors = this.directionalLightDiffuseColors.slice(), O.directionalLightSpecularColors = this.directionalLightSpecularColors.slice(), O.pointLightPositions = this.pointLightPositions.slice(), O.pointLightDiffuseColors = this.pointLightDiffuseColors.slice(), O.pointLightSpecularColors = this.pointLightSpecularColors.slice(), O.spotLightPositions = this.spotLightPositions.slice(), O.spotLightDirections = this.spotLightDirections.slice(), O.spotLightDiffuseColors = this.spotLightDiffuseColors.slice(), O.spotLightSpecularColors = this.spotLightSpecularColors.slice(), O.spotLightAngle = this.spotLightAngle.slice(), O.spotLightConc = this.spotLightConc.slice(), O.userFillShader = this.userFillShader, O.userStrokeShader = this.userStrokeShader, O.userPointShader = this.userPointShader, O.pointSize = this.pointSize, O.curStrokeWeight = this.curStrokeWeight, O.curStrokeColor = this.curStrokeColor, O.curFillColor = this.curFillColor, O.curAmbientColor = this.curAmbientColor, O.curSpecularColor = this.curSpecularColor, O.curEmissiveColor = this.curEmissiveColor, O._hasSetAmbient = this._hasSetAmbient, O._useSpecularMaterial = this._useSpecularMaterial, O._useEmissiveMaterial = this._useEmissiveMaterial, O._useShininess = this._useShininess, O._useMetalness = this._useMetalness, O.constantAttenuation = this.constantAttenuation, O.linearAttenuation = this.linearAttenuation, O.quadraticAttenuation = this.quadraticAttenuation, O._enableLighting = this._enableLighting, O._useNormalMaterial = this._useNormalMaterial, O._tex = this._tex, O.drawMode = this.drawMode, O._currentNormal = this._currentNormal, O.curBlendMode = this.curBlendMode, O.activeImageLight = this.activeImageLight, b;\n        } }, { key: \"pop\", value: function() {\n          var b;\n          0 < this._clipDepths.length && this._pushPopDepth === this._clipDepths[this._clipDepths.length - 1] && this._clearClip();\n          for (var O = arguments.length, D = new Array(O), B = 0; B < O; B++)\n            D[B] = arguments[B];\n          (b = n(j(ne.prototype), \"pop\", this)).call.apply(b, [this].concat(D)), this._applyStencilTestIfClipping();\n        } }, { key: \"_applyStencilTestIfClipping\", value: function() {\n          var b = this.drawTarget();\n          b._isClipApplied !== this._stencilTestOn && (b._isClipApplied ? (this.GL.enable(this.GL.STENCIL_TEST), this._stencilTestOn = !0) : (this.GL.disable(this.GL.STENCIL_TEST), this._stencilTestOn = !1));\n        } }, { key: \"resetMatrix\", value: function() {\n          return this.uMVMatrix.set(this._curCamera.cameraMatrix), this;\n        } }, { key: \"_getImmediateStrokeShader\", value: function() {\n          var b = this.userStrokeShader;\n          return b && b.isStrokeShader() ? b : this._getLineShader();\n        } }, { key: \"_getRetainedStrokeShader\", value: function() {\n          return this._getImmediateStrokeShader();\n        } }, { key: \"_getSphereMapping\", value: function(b) {\n          return this.sphereMapping || (this.sphereMapping = this._pInst.createFilterShader(L)), this.uNMatrix.inverseTranspose(this.uMVMatrix), this.uNMatrix.invert3x3(this.uNMatrix), this.sphereMapping.setUniform(\"uFovY\", this._curCamera.cameraFOV), this.sphereMapping.setUniform(\"uAspect\", this._curCamera.aspectRatio), this.sphereMapping.setUniform(\"uNewNormalMatrix\", this.uNMatrix.mat3), this.sphereMapping.setUniform(\"uSampler\", b), this.sphereMapping;\n        } }, { key: \"_getImmediateFillShader\", value: function() {\n          var b = this.userFillShader;\n          if (this._useNormalMaterial && (!b || !b.isNormalShader()))\n            return this._getNormalShader();\n          if (this._enableLighting) {\n            if (!b || !b.isLightShader())\n              return this._getLightShader();\n          } else if (this._tex) {\n            if (!b || !b.isTextureShader())\n              return this._getLightShader();\n          } else if (!b)\n            return this._getImmediateModeShader();\n          return b;\n        } }, { key: \"_getRetainedFillShader\", value: function() {\n          if (this._useNormalMaterial)\n            return this._getNormalShader();\n          var b = this.userFillShader;\n          if (this._enableLighting) {\n            if (!b || !b.isLightShader())\n              return this._getLightShader();\n          } else if (this._tex) {\n            if (!b || !b.isTextureShader())\n              return this._getLightShader();\n          } else if (!b)\n            return this._getColorShader();\n          return b;\n        } }, { key: \"_getImmediatePointShader\", value: function() {\n          var b = this.userPointShader;\n          return b && b.isPointShader() ? b : this._getPointShader();\n        } }, { key: \"_getRetainedLineShader\", value: function() {\n          return this._getImmediateLineShader();\n        } }, { key: \"_getLightShader\", value: function() {\n          return this._defaultLightShader || (this._pInst._glAttributes.perPixelLighting ? this._defaultLightShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"highp\") + R.phongVert, this._webGL2CompatibilityPrefix(\"frag\", \"highp\") + R.phongFrag) : this._defaultLightShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"highp\") + R.lightVert, this._webGL2CompatibilityPrefix(\"frag\", \"highp\") + R.lightTextureFrag)), this._defaultLightShader;\n        } }, { key: \"_getImmediateModeShader\", value: function() {\n          return this._defaultImmediateModeShader || (this._defaultImmediateModeShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.immediateVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.vertexColorFrag)), this._defaultImmediateModeShader;\n        } }, { key: \"_getNormalShader\", value: function() {\n          return this._defaultNormalShader || (this._defaultNormalShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.normalVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.normalFrag)), this._defaultNormalShader;\n        } }, { key: \"_getColorShader\", value: function() {\n          return this._defaultColorShader || (this._defaultColorShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.normalVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.basicFrag)), this._defaultColorShader;\n        } }, { key: \"_getPointShader\", value: function() {\n          return this._defaultPointShader || (this._defaultPointShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.pointVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.pointFrag)), this._defaultPointShader;\n        } }, { key: \"_getLineShader\", value: function() {\n          return this._defaultLineShader || (this._defaultLineShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.lineVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.lineFrag)), this._defaultLineShader;\n        } }, { key: \"_getFontShader\", value: function() {\n          return this._defaultFontShader || (this.webglVersion === h.WEBGL && this.GL.getExtension(\"OES_standard_derivatives\"), this._defaultFontShader = new u.default.Shader(this, this._webGL2CompatibilityPrefix(\"vert\", \"mediump\") + R.fontVert, this._webGL2CompatibilityPrefix(\"frag\", \"mediump\") + R.fontFrag)), this._defaultFontShader;\n        } }, { key: \"_webGL2CompatibilityPrefix\", value: function(b, O) {\n          var D = \"\";\n          return this.webglVersion === h.WEBGL2 && (D += `#version 300 es\n#define WEBGL2\n`), b === \"vert\" ? D += `#define VERTEX_SHADER\n` : b === \"frag\" && (D += `#define FRAGMENT_SHADER\n`), O && (D += \"precision \".concat(O, ` float;\n`)), D;\n        } }, { key: \"_getEmptyTexture\", value: function() {\n          var b;\n          return this._emptyTexture || ((b = new u.default.Image(1, 1)).set(0, 0, 255), this._emptyTexture = new u.default.Texture(this, b)), this._emptyTexture;\n        } }, { key: \"getTexture\", value: function(b) {\n          b instanceof u.default.Framebuffer && (b = b.color);\n          var O = this.textures.get(b);\n          return O || (O = new u.default.Texture(this, b), this.textures.set(b, O), O);\n        } }, { key: \"getDiffusedTexture\", value: function(b) {\n          var O, D, B = this;\n          return this.diffusedTextures.get(b) != null ? this.diffusedTextures.get(b) : (O = Math.floor(b.height / b.width * 200), D = this._pInst.createFramebuffer({ width: 200, height: O, density: 1 }), this.diffusedShader || (this.diffusedShader = this._pInst.createShader(R.imageLightVert, R.imageLightDiffusedFrag)), D.draw(function() {\n            B._pInst.shader(B.diffusedShader), B.diffusedShader.setUniform(\"environmentMap\", b), B._pInst.noStroke(), B._pInst.rectMode(h.CENTER), B._pInst.noLights(), B._pInst.rect(0, 0, 200, O);\n          }), this.diffusedTextures.set(b, D), D);\n        } }, { key: \"getSpecularTexture\", value: function(b) {\n          var O = this;\n          if (this.specularTextures.get(b) != null)\n            return this.specularTextures.get(b);\n          for (var D, B = [], Y = this._pInst.createFramebuffer({ width: 512, height: 512, density: 1 }), J = Math.log(512) / Math.log(2), te = (this.specularShader || (this.specularShader = this._pInst.createShader(R.imageLightVert, R.imageLightSpecularFrag)), 512); 1 <= te; te /= 2)\n            (function(ce) {\n              Y.resize(ce, ce);\n              var re = 1 - Math.log(ce) / Math.log(2) / J;\n              Y.draw(function() {\n                O._pInst.shader(O.specularShader), O._pInst.clear(), O.specularShader.setUniform(\"environmentMap\", b), O.specularShader.setUniform(\"roughness\", re), O._pInst.noStroke(), O._pInst.noLights(), O._pInst.plane(ce, ce);\n              }), B.push(Y.get().drawingContext.getImageData(0, 0, ce, ce));\n            })(te);\n          return Y.remove(), D = new r.MipmapTexture(this, B, {}), this.specularTextures.set(b, D), D;\n        } }, { key: \"activeFramebuffer\", value: function() {\n          return this.activeFramebuffers[this.activeFramebuffers.length - 1] || null;\n        } }, { key: \"createFramebuffer\", value: function(b) {\n          return new u.default.Framebuffer(this, b);\n        } }, { key: \"_setStrokeUniforms\", value: function(b) {\n          b.bindShader(), b.setUniform(\"uUseLineColor\", this._useLineColor), b.setUniform(\"uMaterialColor\", this.curStrokeColor), b.setUniform(\"uStrokeWeight\", this.curStrokeWeight), b.setUniform(\"uStrokeCap\", A[this.curStrokeCap]), b.setUniform(\"uStrokeJoin\", x[this.curStrokeJoin]);\n        } }, { key: \"_setFillUniforms\", value: function(b) {\n          var O = this, D = (b.bindShader(), this.mixedSpecularColor = i(this.curSpecularColor), 0 < this._useMetalness && (this.mixedSpecularColor = this.mixedSpecularColor.map(function(B, Y) {\n            return O.curFillColor[Y] * O._useMetalness + B * (1 - O._useMetalness);\n          })), b.setUniform(\"uUseVertexColor\", this._useVertexColor), b.setUniform(\"uMaterialColor\", this.curFillColor), b.setUniform(\"isTexture\", !!this._tex), this._tex && b.setUniform(\"uSampler\", this._tex), b.setUniform(\"uTint\", this._tint), b.setUniform(\"uHasSetAmbient\", this._hasSetAmbient), b.setUniform(\"uAmbientMatColor\", this.curAmbientColor), b.setUniform(\"uSpecularMatColor\", this.mixedSpecularColor), b.setUniform(\"uEmissiveMatColor\", this.curEmissiveColor), b.setUniform(\"uSpecular\", this._useSpecularMaterial), b.setUniform(\"uEmissive\", this._useEmissiveMaterial), b.setUniform(\"uShininess\", this._useShininess), b.setUniform(\"metallic\", this._useMetalness), this._setImageLightUniforms(b), b.setUniform(\"uUseLighting\", this._enableLighting), this.pointLightDiffuseColors.length / 3), D = (b.setUniform(\"uPointLightCount\", D), b.setUniform(\"uPointLightLocation\", this.pointLightPositions), b.setUniform(\"uPointLightDiffuseColors\", this.pointLightDiffuseColors), b.setUniform(\"uPointLightSpecularColors\", this.pointLightSpecularColors), this.directionalLightDiffuseColors.length / 3), D = (b.setUniform(\"uDirectionalLightCount\", D), b.setUniform(\"uLightingDirection\", this.directionalLightDirections), b.setUniform(\"uDirectionalDiffuseColors\", this.directionalLightDiffuseColors), b.setUniform(\"uDirectionalSpecularColors\", this.directionalLightSpecularColors), this.ambientLightColors.length / 3), D = (this.mixedAmbientLight = i(this.ambientLightColors), 0 < this._useMetalness && (this.mixedAmbientLight = this.mixedAmbientLight.map(function(B) {\n            return B -= O._useMetalness, Math.max(0, B);\n          })), b.setUniform(\"uAmbientLightCount\", D), b.setUniform(\"uAmbientColor\", this.mixedAmbientLight), this.spotLightDiffuseColors.length / 3);\n          b.setUniform(\"uSpotLightCount\", D), b.setUniform(\"uSpotLightAngle\", this.spotLightAngle), b.setUniform(\"uSpotLightConc\", this.spotLightConc), b.setUniform(\"uSpotLightDiffuseColors\", this.spotLightDiffuseColors), b.setUniform(\"uSpotLightSpecularColors\", this.spotLightSpecularColors), b.setUniform(\"uSpotLightLocation\", this.spotLightPositions), b.setUniform(\"uSpotLightDirection\", this.spotLightDirections), b.setUniform(\"uConstantAttenuation\", this.constantAttenuation), b.setUniform(\"uLinearAttenuation\", this.linearAttenuation), b.setUniform(\"uQuadraticAttenuation\", this.quadraticAttenuation), b.bindTextures();\n        } }, { key: \"_setImageLightUniforms\", value: function(b) {\n          var O, D;\n          b.setUniform(\"uUseImageLight\", this.activeImageLight != null), this.activeImageLight && (O = this.getDiffusedTexture(this.activeImageLight), b.setUniform(\"environmentMapDiffused\", O), O = this.getSpecularTexture(this.activeImageLight), D = 20 / this._useShininess, b.setUniform(\"levelOfDetail\", 8 * D), b.setUniform(\"environmentMapSpecular\", O));\n        } }, { key: \"_setPointUniforms\", value: function(b) {\n          b.bindShader(), b.setUniform(\"uMaterialColor\", this.curStrokeColor), b.setUniform(\"uPointSize\", this.pointSize * this._pInst._pixelDensity);\n        } }, { key: \"_bindBuffer\", value: function(b, O, D, B, Y) {\n          O = O || this.GL.ARRAY_BUFFER, this.GL.bindBuffer(O, b), D !== void 0 && ((b = D) instanceof u.default.DataArray ? b = D.dataArray() : b instanceof (B || Float32Array) || (b = new (B || Float32Array)(b)), this.GL.bufferData(O, b, Y || this.GL.STATIC_DRAW));\n        } }, { key: \"_arraysEqual\", value: function(b, O) {\n          return b.length === O.length && b.every(function(D, B) {\n            return D === O[B];\n          });\n        } }, { key: \"_isTypedArray\", value: function(b) {\n          return [Float32Array, Float64Array, Int16Array, Uint16Array, Uint32Array].some(function(O) {\n            return b instanceof O;\n          });\n        } }, { key: \"_flatten\", value: function(b) {\n          return b.flat();\n        } }, { key: \"_vToNArray\", value: function(b) {\n          return b.flatMap(function(O) {\n            return [O.x, O.y, O.z];\n          });\n        } }, { key: \"_bezierCoefficients\", value: function(b) {\n          var O = b * b, D = 1 - b, B = D * D;\n          return [B * D, 3 * B * b, 3 * D * O, O * b];\n        } }, { key: \"_quadraticCoefficients\", value: function(b) {\n          var O = 1 - b;\n          return [O * O, 2 * O * b, b * b];\n        } }, { key: \"_bezierToCatmull\", value: function(b) {\n          return [b[1], b[1] + (b[2] - b[0]) / this._curveTightness, b[2] - (b[3] - b[1]) / this._curveTightness, b[2]];\n        } }, { key: \"_initTessy\", value: function() {\n          var b = new f.default.GluTesselator();\n          return b.gluTessCallback(f.default.gluEnum.GLU_TESS_VERTEX_DATA, function(O, D) {\n            var B = !0, Y = !1, J = void 0;\n            try {\n              for (var te, ce = O[Symbol.iterator](); !(B = (te = ce.next()).done); B = !0) {\n                var re = te.value;\n                D.push(re);\n              }\n            } catch (ue) {\n              Y = !0, J = ue;\n            } finally {\n              try {\n                B || ce.return == null || ce.return();\n              } finally {\n                if (Y)\n                  throw J;\n              }\n            }\n          }), b.gluTessCallback(f.default.gluEnum.GLU_TESS_BEGIN, function(O) {\n            O !== f.default.primitiveType.GL_TRIANGLES && console.log(\"expected TRIANGLES but got type: \".concat(O));\n          }), b.gluTessCallback(f.default.gluEnum.GLU_TESS_ERROR, function(O) {\n            console.log(\"error callback\"), console.log(\"error number: \".concat(O));\n          }), b.gluTessCallback(f.default.gluEnum.GLU_TESS_COMBINE, function(O, D, B) {\n            for (var Y = new Array(u.default.RendererGL.prototype.tessyVertexSize).fill(0), J = 0; J < B.length; J++)\n              for (var te = 0; te < Y.length; te++)\n                B[J] !== 0 && D[J] && (Y[te] += D[J][te] * B[J]);\n            return Y;\n          }), b.gluTessCallback(f.default.gluEnum.GLU_TESS_EDGE_FLAG, function(O) {\n          }), b.gluTessProperty(f.default.gluEnum.GLU_TESS_WINDING_RULE, f.default.windingRule.GLU_TESS_WINDING_NONZERO), b;\n        } }, { key: \"_triangulate\", value: function(b) {\n          var O = b[0] ? b[0][2] : void 0, D = !0, B = !0, re = !1, le = void 0;\n          try {\n            for (var Y, J = b[Symbol.iterator](); !(B = (Y = J.next()).done); B = !0)\n              for (var te = Y.value, ce = 0; ce < te.length; ce += u.default.RendererGL.prototype.tessyVertexSize)\n                if (te[ce + 2] !== O) {\n                  D = !1;\n                  break;\n                }\n          } catch (xe) {\n            re = !0, le = xe;\n          } finally {\n            try {\n              B || J.return == null || J.return();\n            } finally {\n              if (re)\n                throw le;\n            }\n          }\n          D ? this._tessy.gluTessNormal(0, 0, 1) : this._tessy.gluTessNormal(0, 0, 0);\n          var re = [], ue = (this._tessy.gluTessBeginPolygon(re), !0), le = !1, K = void 0;\n          try {\n            for (var ae, he = b[Symbol.iterator](); !(ue = (ae = he.next()).done); ue = !0) {\n              var _e = ae.value;\n              this._tessy.gluTessBeginContour();\n              for (var fe = 0; fe < _e.length; fe += u.default.RendererGL.prototype.tessyVertexSize) {\n                var ge = _e.slice(fe, fe + u.default.RendererGL.prototype.tessyVertexSize);\n                this._tessy.gluTessVertex(ge, ge);\n              }\n              this._tessy.gluTessEndContour();\n            }\n          } catch (xe) {\n            le = !0, K = xe;\n          } finally {\n            try {\n              ue || he.return == null || he.return();\n            } finally {\n              if (le)\n                throw K;\n            }\n          }\n          return this._tessy.gluTessEndPolygon(), re;\n        } }]) && l(W.prototype, U), ne;\n      }(u.default.Renderer), u.default.prototype._assert3d = function(U) {\n        if (!this._renderer.isP3D)\n          throw new Error(\"\".concat(U, \"() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.\"));\n      }, u.default.RendererGL.prototype.tessyVertexSize = 12, M = u.default.RendererGL, C.default = M;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"../core/p5.Renderer\": 283, \"./GeometryBuilder\": 324, \"./p5.Camera\": 329, \"./p5.Framebuffer\": 331, \"./p5.Matrix\": 333, \"./p5.Shader\": 338, \"./p5.Texture\": 339, \"core-js/modules/es.array.concat\": 152, \"core-js/modules/es.array.copy-within\": 153, \"core-js/modules/es.array.every\": 154, \"core-js/modules/es.array.fill\": 155, \"core-js/modules/es.array.flat\": 159, \"core-js/modules/es.array.flat-map\": 158, \"core-js/modules/es.array.from\": 161, \"core-js/modules/es.array.includes\": 162, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.map\": 167, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.some\": 169, \"core-js/modules/es.array.unscopables.flat\": 172, \"core-js/modules/es.array.unscopables.flat-map\": 171, \"core-js/modules/es.map\": 174, \"core-js/modules/es.object.assign\": 181, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.reflect.get\": 190, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.set\": 194, \"core-js/modules/es.string.includes\": 196, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.float32-array\": 216, \"core-js/modules/es.typed-array.float64-array\": 217, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.int16-array\": 221, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint16-array\": 237, \"core-js/modules/es.typed-array.uint32-array\": 238, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243, libtess: 252, path: 255 }], 338: [function(t, H, C) {\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.index-of\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.array.slice\"), t(\"core-js/modules/es.array.some\"), t(\"core-js/modules/es.function.name\"), t(\"core-js/modules/es.object.keys\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/web.dom-collections.iterator\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.default = void 0;\n      var m = (t = t(\"../core/main\")) && t.__esModule ? t : { default: t };\n      function y(u, h) {\n        for (var g = 0; g < h.length; g++) {\n          var f = h[g];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(u, f.key, f);\n        }\n      }\n      m.default.Shader = function() {\n        function u(f, r, s) {\n          if (!(this instanceof u))\n            throw new TypeError(\"Cannot call a class as a function\");\n          this._renderer = f, this._vertSrc = r, this._fragSrc = s, this._vertShader = -1, this._fragShader = -1, this._glProgram = 0, this._loadedAttributes = !1, this.attributes = {}, this._loadedUniforms = !1, this.uniforms = {}, this._bound = !1, this.samplers = [];\n        }\n        var h, g;\n        return h = u, (g = [{ key: \"init\", value: function() {\n          if (this._glProgram === 0) {\n            var f = this._renderer.GL;\n            if (this._vertShader = f.createShader(f.VERTEX_SHADER), f.shaderSource(this._vertShader, this._vertSrc), f.compileShader(this._vertShader), !f.getShaderParameter(this._vertShader, f.COMPILE_STATUS))\n              return m.default._friendlyError(\"Yikes! An error occurred compiling the vertex shader:\".concat(f.getShaderInfoLog(this._vertShader))), null;\n            if (this._fragShader = f.createShader(f.FRAGMENT_SHADER), f.shaderSource(this._fragShader, this._fragSrc), f.compileShader(this._fragShader), !f.getShaderParameter(this._fragShader, f.COMPILE_STATUS))\n              return m.default._friendlyError(\"Darn! An error occurred compiling the fragment shader:\".concat(f.getShaderInfoLog(this._fragShader))), null;\n            this._glProgram = f.createProgram(), f.attachShader(this._glProgram, this._vertShader), f.attachShader(this._glProgram, this._fragShader), f.linkProgram(this._glProgram), f.getProgramParameter(this._glProgram, f.LINK_STATUS) || m.default._friendlyError(\"Snap! Error linking shader program: \".concat(f.getProgramInfoLog(this._glProgram))), this._loadAttributes(), this._loadUniforms();\n          }\n          return this;\n        } }, { key: \"copyToContext\", value: function(f) {\n          var r = new m.default.Shader(f._renderer, this._vertSrc, this._fragSrc);\n          return r.ensureCompiledOnContext(f), r;\n        } }, { key: \"ensureCompiledOnContext\", value: function(f) {\n          if (this._glProgram !== 0 && this._renderer !== f._renderer)\n            throw new Error(\"The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?\");\n          this._glProgram === 0 && (this._renderer = f._renderer, this.init());\n        } }, { key: \"_loadAttributes\", value: function() {\n          if (!this._loadedAttributes) {\n            this.attributes = {};\n            for (var f = this._renderer.GL, r = f.getProgramParameter(this._glProgram, f.ACTIVE_ATTRIBUTES), s = 0; s < r; ++s) {\n              var o = f.getActiveAttrib(this._glProgram, s), i = o.name, l = f.getAttribLocation(this._glProgram, i), n = {};\n              n.name = i, n.location = l, n.index = s, n.type = o.type, n.size = o.size, this.attributes[i] = n;\n            }\n            this._loadedAttributes = !0;\n          }\n        } }, { key: \"_loadUniforms\", value: function() {\n          if (!this._loadedUniforms) {\n            for (var f = this._renderer.GL, r = f.getProgramParameter(this._glProgram, f.ACTIVE_UNIFORMS), s = 0, o = 0; o < r; ++o) {\n              var i = f.getActiveUniform(this._glProgram, o), l = {}, n = (l.location = f.getUniformLocation(this._glProgram, i.name), l.size = i.size, i.name);\n              1 < i.size && (n = n.substring(0, n.indexOf(\"[0]\"))), l.name = n, l.type = i.type, l._cachedData = void 0, l.type === f.SAMPLER_2D && (l.samplerIndex = s, s++, this.samplers.push(l)), l.isArray = 1 < i.size || l.type === f.FLOAT_MAT3 || l.type === f.FLOAT_MAT4 || l.type === f.FLOAT_VEC2 || l.type === f.FLOAT_VEC3 || l.type === f.FLOAT_VEC4 || l.type === f.INT_VEC2 || l.type === f.INT_VEC4 || l.type === f.INT_VEC3, this.uniforms[n] = l;\n            }\n            this._loadedUniforms = !0;\n          }\n        } }, { key: \"compile\", value: function() {\n        } }, { key: \"bindShader\", value: function() {\n          this.init(), this._bound || (this.useProgram(), this._bound = !0, this._setMatrixUniforms(), this.setUniform(\"uViewport\", this._renderer._viewport));\n        } }, { key: \"unbindShader\", value: function() {\n          return this._bound && (this.unbindTextures(), this._bound = !1), this;\n        } }, { key: \"bindTextures\", value: function() {\n          var f = this._renderer.GL, r = !0, s = !1, o = void 0;\n          try {\n            for (var i, l = this.samplers[Symbol.iterator](); !(r = (i = l.next()).done); r = !0) {\n              var n = i.value, a = n.texture;\n              a === void 0 && (a = this._renderer._getEmptyTexture()), f.activeTexture(f.TEXTURE0 + n.samplerIndex), a.bindTexture(), a.update(), f.uniform1i(n.location, n.samplerIndex);\n            }\n          } catch (c) {\n            s = !0, o = c;\n          } finally {\n            try {\n              r || l.return == null || l.return();\n            } finally {\n              if (s)\n                throw o;\n            }\n          }\n        } }, { key: \"updateTextures\", value: function() {\n          var f = !0, r = !1, s = void 0;\n          try {\n            for (var o, i = this.samplers[Symbol.iterator](); !(f = (o = i.next()).done); f = !0) {\n              var l = o.value.texture;\n              l && l.update();\n            }\n          } catch (n) {\n            r = !0, s = n;\n          } finally {\n            try {\n              f || i.return == null || i.return();\n            } finally {\n              if (r)\n                throw s;\n            }\n          }\n        } }, { key: \"unbindTextures\", value: function() {\n          var f = !0, r = !1, s = void 0;\n          try {\n            for (var o, i = this.samplers[Symbol.iterator](); !(f = (o = i.next()).done); f = !0) {\n              var l = o.value;\n              this.setUniform(l.name, this._renderer._getEmptyTexture());\n            }\n          } catch (n) {\n            r = !0, s = n;\n          } finally {\n            try {\n              f || i.return == null || i.return();\n            } finally {\n              if (r)\n                throw s;\n            }\n          }\n        } }, { key: \"_setMatrixUniforms\", value: function() {\n          var f = this._renderer._curCamera.cameraMatrix, r = this._renderer.uPMatrix, s = this._renderer.uMVMatrix, o = s.copy();\n          o.mult(r), this.isStrokeShader() && this.setUniform(\"uPerspective\", this._renderer._curCamera.useLinePerspective ? 1 : 0), this.setUniform(\"uViewMatrix\", f.mat4), this.setUniform(\"uProjectionMatrix\", r.mat4), this.setUniform(\"uModelViewMatrix\", s.mat4), this.setUniform(\"uModelViewProjectionMatrix\", o.mat4), this.uniforms.uNormalMatrix && (this._renderer.uNMatrix.inverseTranspose(this._renderer.uMVMatrix), this.setUniform(\"uNormalMatrix\", this._renderer.uNMatrix.mat3)), this.uniforms.uCameraRotation && (this._renderer.curMatrix.inverseTranspose(this._renderer._curCamera.cameraMatrix), this.setUniform(\"uCameraRotation\", this._renderer.curMatrix.mat3));\n        } }, { key: \"useProgram\", value: function() {\n          var f = this._renderer.GL;\n          return this._renderer._curShader !== this && (f.useProgram(this._glProgram), this._renderer._curShader = this), this;\n        } }, { key: \"setUniform\", value: function(f, r) {\n          var s = this.uniforms[f];\n          if (s) {\n            var o = this._renderer.GL;\n            if (s.isArray) {\n              if (s._cachedData && this._renderer._arraysEqual(s._cachedData, r))\n                return;\n              s._cachedData = r.slice(0);\n            } else {\n              if (s._cachedData && s._cachedData === r)\n                return;\n              Array.isArray(r) ? s._cachedData = r.slice(0) : s._cachedData = r;\n            }\n            var i = s.location;\n            switch (this.useProgram(), s.type) {\n              case o.BOOL:\n                r === !0 ? o.uniform1i(i, 1) : o.uniform1i(i, 0);\n                break;\n              case o.INT:\n                1 < s.size ? r.length && o.uniform1iv(i, r) : o.uniform1i(i, r);\n                break;\n              case o.FLOAT:\n                1 < s.size ? r.length && o.uniform1fv(i, r) : o.uniform1f(i, r);\n                break;\n              case o.FLOAT_MAT3:\n                o.uniformMatrix3fv(i, !1, r);\n                break;\n              case o.FLOAT_MAT4:\n                o.uniformMatrix4fv(i, !1, r);\n                break;\n              case o.FLOAT_VEC2:\n                1 < s.size ? r.length && o.uniform2fv(i, r) : o.uniform2f(i, r[0], r[1]);\n                break;\n              case o.FLOAT_VEC3:\n                1 < s.size ? r.length && o.uniform3fv(i, r) : o.uniform3f(i, r[0], r[1], r[2]);\n                break;\n              case o.FLOAT_VEC4:\n                1 < s.size ? r.length && o.uniform4fv(i, r) : o.uniform4f(i, r[0], r[1], r[2], r[3]);\n                break;\n              case o.INT_VEC2:\n                1 < s.size ? r.length && o.uniform2iv(i, r) : o.uniform2i(i, r[0], r[1]);\n                break;\n              case o.INT_VEC3:\n                1 < s.size ? r.length && o.uniform3iv(i, r) : o.uniform3i(i, r[0], r[1], r[2]);\n                break;\n              case o.INT_VEC4:\n                1 < s.size ? r.length && o.uniform4iv(i, r) : o.uniform4i(i, r[0], r[1], r[2], r[3]);\n                break;\n              case o.SAMPLER_2D:\n                o.activeTexture(o.TEXTURE0 + s.samplerIndex), s.texture = r instanceof m.default.Texture ? r : this._renderer.getTexture(r), o.uniform1i(i, s.samplerIndex), s.texture.src.gifProperties && s.texture.src._animateGif(this._renderer._pInst);\n            }\n            return this;\n          }\n        } }, { key: \"isLightShader\", value: function() {\n          return [this.attributes.aNormal, this.uniforms.uUseLighting, this.uniforms.uAmbientLightCount, this.uniforms.uDirectionalLightCount, this.uniforms.uPointLightCount, this.uniforms.uAmbientColor, this.uniforms.uDirectionalDiffuseColors, this.uniforms.uDirectionalSpecularColors, this.uniforms.uPointLightLocation, this.uniforms.uPointLightDiffuseColors, this.uniforms.uPointLightSpecularColors, this.uniforms.uLightingDirection, this.uniforms.uSpecular].some(function(f) {\n            return f !== void 0;\n          });\n        } }, { key: \"isNormalShader\", value: function() {\n          return this.attributes.aNormal !== void 0;\n        } }, { key: \"isTextureShader\", value: function() {\n          return 0 < this.samplers.length;\n        } }, { key: \"isColorShader\", value: function() {\n          return this.attributes.aVertexColor !== void 0 || this.uniforms.uMaterialColor !== void 0;\n        } }, { key: \"isTexLightShader\", value: function() {\n          return this.isLightShader() && this.isTextureShader();\n        } }, { key: \"isStrokeShader\", value: function() {\n          return this.uniforms.uStrokeWeight !== void 0;\n        } }, { key: \"enableAttrib\", value: function(f, r, s, o, i, l) {\n          var n;\n          return f && (f = f.location) !== -1 && (n = this._renderer.GL, this._renderer.registerEnabled.has(f) || (n.enableVertexAttribArray(f), this._renderer.registerEnabled.add(f)), this._renderer.GL.vertexAttribPointer(f, r, s || n.FLOAT, o || !1, i || 0, l || 0)), this;\n        } }, { key: \"disableRemainingAttributes\", value: function() {\n          var f = this, r = !0, s = !1, o = void 0;\n          try {\n            for (var i, l = this._renderer.registerEnabled.values()[Symbol.iterator](); !(r = (i = l.next()).done); r = !0)\n              (function() {\n                var n = i.value;\n                Object.keys(f.attributes).some(function(a) {\n                  return f.attributes[a].location === n;\n                }) || (f._renderer.GL.disableVertexAttribArray(n), f._renderer.registerEnabled.delete(n));\n              })();\n          } catch (n) {\n            s = !0, o = n;\n          } finally {\n            try {\n              r || l.return == null || l.return();\n            } finally {\n              if (s)\n                throw o;\n            }\n          }\n        } }]) && y(h.prototype, g), u;\n      }(), t = m.default.Shader, C.default = t;\n    }, { \"../core/main\": 280, \"core-js/modules/es.array.index-of\": 163, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.array.slice\": 168, \"core-js/modules/es.array.some\": 169, \"core-js/modules/es.function.name\": 173, \"core-js/modules/es.object.keys\": 186, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/web.dom-collections.iterator\": 243 }], 339: [function(t, H, C) {\n      function m(c) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(p) {\n          return typeof p;\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : typeof p;\n        })(c);\n      }\n      function y(c) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(p) {\n          return m(p);\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : m(p);\n        })(c);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.get-prototype-of\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.reflect.construct\"), t(\"core-js/modules/es.regexp.to-string\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.typed-array.uint8-array\"), t(\"core-js/modules/es.typed-array.copy-within\"), t(\"core-js/modules/es.typed-array.every\"), t(\"core-js/modules/es.typed-array.fill\"), t(\"core-js/modules/es.typed-array.filter\"), t(\"core-js/modules/es.typed-array.find\"), t(\"core-js/modules/es.typed-array.find-index\"), t(\"core-js/modules/es.typed-array.for-each\"), t(\"core-js/modules/es.typed-array.includes\"), t(\"core-js/modules/es.typed-array.index-of\"), t(\"core-js/modules/es.typed-array.iterator\"), t(\"core-js/modules/es.typed-array.join\"), t(\"core-js/modules/es.typed-array.last-index-of\"), t(\"core-js/modules/es.typed-array.map\"), t(\"core-js/modules/es.typed-array.reduce\"), t(\"core-js/modules/es.typed-array.reduce-right\"), t(\"core-js/modules/es.typed-array.reverse\"), t(\"core-js/modules/es.typed-array.set\"), t(\"core-js/modules/es.typed-array.slice\"), t(\"core-js/modules/es.typed-array.some\"), t(\"core-js/modules/es.typed-array.sort\"), t(\"core-js/modules/es.typed-array.subarray\"), t(\"core-js/modules/es.typed-array.to-locale-string\"), t(\"core-js/modules/es.typed-array.to-string\"), Object.defineProperty(C, \"__esModule\", { value: !0 }), C.checkWebGLCapabilities = a, C.default = C.MipmapTexture = void 0;\n      var u = (n = t(\"../core/main\")) && n.__esModule ? n : { default: n }, h = function(c) {\n        if (c && c.__esModule)\n          return c;\n        if (c === null || y(c) !== \"object\" && typeof c != \"function\")\n          return { default: c };\n        var p = g();\n        if (p && p.has(c))\n          return p.get(c);\n        var j, T = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (j in c) {\n          var S;\n          Object.prototype.hasOwnProperty.call(c, j) && ((S = _ ? Object.getOwnPropertyDescriptor(c, j) : null) && (S.get || S.set) ? Object.defineProperty(T, j, S) : T[j] = c[j]);\n        }\n        return T.default = c, p && p.set(c, T), T;\n      }(t(\"../core/constants\"));\n      function g() {\n        var c;\n        return typeof WeakMap != \"function\" ? null : (c = /* @__PURE__ */ new WeakMap(), g = function() {\n          return c;\n        }, c);\n      }\n      function f(c, p) {\n        return (f = Object.setPrototypeOf || function(j, T) {\n          return j.__proto__ = T, j;\n        })(c, p);\n      }\n      function r(c) {\n        return function() {\n          var p, j = s(c), j = (p = function() {\n            if (typeof Reflect < \"u\" && Reflect.construct && !Reflect.construct.sham) {\n              if (typeof Proxy == \"function\")\n                return 1;\n              try {\n                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n                })), 1;\n              } catch {\n              }\n            }\n          }() ? (p = s(this).constructor, Reflect.construct(j, arguments, p)) : j.apply(this, arguments), this);\n          if (!p || y(p) !== \"object\" && typeof p != \"function\") {\n            if (j !== void 0)\n              return j;\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n          return p;\n        };\n      }\n      function s(c) {\n        return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function(p) {\n          return p.__proto__ || Object.getPrototypeOf(p);\n        })(c);\n      }\n      function o(c, p) {\n        if (!(c instanceof p))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function i(c, p) {\n        for (var j = 0; j < p.length; j++) {\n          var T = p[j];\n          T.enumerable = T.enumerable || !1, T.configurable = !0, \"value\" in T && (T.writable = !0), Object.defineProperty(c, T.key, T);\n        }\n      }\n      function l(c, p, j) {\n        p && i(c.prototype, p);\n      }\n      u.default.Texture = function() {\n        function c(E, j, S) {\n          o(this, c), this._renderer = E;\n          var _ = this._renderer.GL, S = (S = S || {}, this.src = j, this.glTex = void 0, this.glTarget = _.TEXTURE_2D, this.glFormat = S.format || _.RGBA, this.mipmaps = !1, this.glMinFilter = S.minFilter || _.LINEAR, this.glMagFilter = S.magFilter || _.LINEAR, this.glWrapS = S.wrapS || _.CLAMP_TO_EDGE, this.glWrapT = S.wrapT || _.CLAMP_TO_EDGE, this.glDataType = S.dataType || _.UNSIGNED_BYTE, a(E)), E = (this.glFormat !== _.HALF_FLOAT || S.halfFloat || (console.log(\"This device does not support dataType HALF_FLOAT. Falling back to FLOAT.\"), this.glDataType = _.FLOAT), this.glFormat !== _.HALF_FLOAT || this.glMinFilter !== _.LINEAR && this.glMagFilter !== _.LINEAR || S.halfFloatLinear || (console.log(\"This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.\"), this.glMinFilter === _.LINEAR && (this.glMinFilter = _.NEAREST), this.glMagFilter === _.LINEAR && (this.glMagFilter = _.NEAREST)), this.glFormat !== _.FLOAT || S.float || (console.log(\"This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE.\"), this.glDataType = _.UNSIGNED_BYTE), this.glFormat !== _.FLOAT || this.glMinFilter !== _.LINEAR && this.glMagFilter !== _.LINEAR || S.floatLinear || (console.log(\"This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.\"), this.glMinFilter === _.LINEAR && (this.glMinFilter = _.NEAREST), this.glMagFilter === _.LINEAR && (this.glMagFilter = _.NEAREST)), this.isSrcMediaElement = u.default.MediaElement !== void 0 && j instanceof u.default.MediaElement, this._videoPrevUpdateTime = 0, this.isSrcHTMLElement = u.default.Element !== void 0 && j instanceof u.default.Element && !(j instanceof u.default.Graphics) && !(j instanceof u.default.Renderer), this.isSrcP5Image = j instanceof u.default.Image, this.isSrcP5Graphics = j instanceof u.default.Graphics, this.isSrcP5Renderer = j instanceof u.default.Renderer, this.isImageData = typeof ImageData < \"u\" && j instanceof ImageData, this.isFramebufferTexture = j instanceof u.default.FramebufferTexture, this._getTextureDataFromSource());\n          return this.width = E.width, this.height = E.height, this.init(E), this;\n        }\n        return l(c, [{ key: \"_getTextureDataFromSource\", value: function() {\n          var p;\n          return this.isFramebufferTexture ? p = this.src.rawTexture() : this.isSrcP5Image ? p = this.src.canvas : this.isSrcMediaElement || this.isSrcP5Graphics || this.isSrcP5Renderer || this.isSrcHTMLElement ? p = this.src.elt : this.isImageData && (p = this.src), p;\n        } }, { key: \"init\", value: function(p) {\n          var j, T = this._renderer.GL;\n          this.isFramebufferTexture || (this.glTex = T.createTexture()), this.glWrapS = this._renderer.textureWrapX, this.glWrapT = this._renderer.textureWrapY, this.setWrapMode(this.glWrapS, this.glWrapT), this.bindTexture(), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MAG_FILTER, this.glMagFilter), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MIN_FILTER, this.glMinFilter), this.isFramebufferTexture || (this.width === 0 || this.height === 0 || this.isSrcMediaElement && !this.src.loadedmetadata ? (j = new Uint8Array([1, 1, 1, 1]), T.texImage2D(this.glTarget, 0, T.RGBA, 1, 1, 0, this.glFormat, this.glDataType, j)) : T.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, p));\n        } }, { key: \"update\", value: function() {\n          var p, j, T, _ = this.src;\n          return _.width !== 0 && _.height !== 0 && !this.isFramebufferTexture && (p = this._getTextureDataFromSource(), j = !1, T = this._renderer.GL, p.width !== this.width || p.height !== this.height ? (j = !0, this.width = p.width || _.width, this.height = p.height || _.height, this.isSrcP5Image ? _.setModified(!1) : (this.isSrcMediaElement || this.isSrcHTMLElement) && _.setModified(!0)) : this.isSrcP5Image ? _.isModified() && _.setModified(!(j = !0)) : this.isSrcMediaElement ? _.isModified() ? _.setModified(!(j = !0)) : _.loadedmetadata && this._videoPrevUpdateTime !== _.time() && (this._videoPrevUpdateTime = _.time(), j = !0) : this.isImageData ? _._dirty && (j = !(_._dirty = !1)) : j = !0, j && (this.bindTexture(), T.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, p)), j);\n        } }, { key: \"bindTexture\", value: function() {\n          return this._renderer.GL.bindTexture(this.glTarget, this.getTexture()), this;\n        } }, { key: \"unbindTexture\", value: function() {\n          this._renderer.GL.bindTexture(this.glTarget, null);\n        } }, { key: \"getTexture\", value: function() {\n          return this.isFramebufferTexture ? this.src.rawTexture() : this.glTex;\n        } }, { key: \"setInterpolation\", value: function(p, j) {\n          var T = this._renderer.GL;\n          this.glMinFilter = this.glFilter(p), this.glMagFilter = this.glFilter(j), this.bindTexture(), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MIN_FILTER, this.glMinFilter), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MAG_FILTER, this.glMagFilter), this.unbindTexture();\n        } }, { key: \"glFilter\", value: function(p) {\n          var j = this._renderer.GL;\n          return p === h.NEAREST ? j.NEAREST : j.LINEAR;\n        } }, { key: \"setWrapMode\", value: function(p, j) {\n          function T(A) {\n            return (A & A - 1) == 0;\n          }\n          var _ = this._renderer.GL, E = this._getTextureDataFromSource(), E = E.naturalWidth && E.naturalHeight ? (S = E.naturalWidth, E.naturalHeight) : (S = this.width, this.height), S = T(S), E = T(E);\n          p === h.REPEAT ? this._renderer.webglVersion === h.WEBGL2 || S && E ? this.glWrapS = _.REPEAT : (console.warn(\"You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead\"), this.glWrapS = _.CLAMP_TO_EDGE) : p === h.MIRROR ? this._renderer.webglVersion === h.WEBGL2 || S && E ? this.glWrapS = _.MIRRORED_REPEAT : (console.warn(\"You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead\"), this.glWrapS = _.CLAMP_TO_EDGE) : this.glWrapS = _.CLAMP_TO_EDGE, j === h.REPEAT ? this._renderer.webglVersion === h.WEBGL2 || S && E ? this.glWrapT = _.REPEAT : (console.warn(\"You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead\"), this.glWrapT = _.CLAMP_TO_EDGE) : j === h.MIRROR ? this._renderer.webglVersion === h.WEBGL2 || S && E ? this.glWrapT = _.MIRRORED_REPEAT : (console.warn(\"You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead\"), this.glWrapT = _.CLAMP_TO_EDGE) : this.glWrapT = _.CLAMP_TO_EDGE, this.bindTexture(), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, this.glWrapS), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, this.glWrapT), this.unbindTexture();\n        } }]), c;\n      }();\n      var n = function(c) {\n        var p = T;\n        if (typeof c != \"function\" && c !== null)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        p.prototype = Object.create(c && c.prototype, { constructor: { value: p, writable: !0, configurable: !0 } }), c && f(p, c);\n        var j = r(T);\n        function T(_, S, E) {\n          return o(this, T), S = (_ = j.call(this, _, S, E))._renderer.GL, _.glMinFilter === S.LINEAR && (_.glMinFilter = S.LINEAR_MIPMAP_LINEAR), _;\n        }\n        return l(T, [{ key: \"glFilter\", value: function(_) {\n          return this._renderer.GL.LINEAR_MIPMAP_LINEAR;\n        } }, { key: \"_getTextureDataFromSource\", value: function() {\n          return this.src;\n        } }, { key: \"init\", value: function(_) {\n          var S = this._renderer.GL;\n          this.glTex = S.createTexture(), this.bindTexture();\n          for (var E = 0; E < _.length; E++)\n            S.texImage2D(this.glTarget, E, this.glFormat, this.glFormat, this.glDataType, _[E]);\n          this.glMinFilter = S.LINEAR_MIPMAP_LINEAR, S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MAG_FILTER, this.glMagFilter), S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MIN_FILTER, this.glMinFilter), this.unbindTexture();\n        } }, { key: \"update\", value: function() {\n        } }]), T;\n      }(u.default.Texture);\n      function a(_) {\n        var p = _.GL, _ = _.webglVersion, j = _ === h.WEBGL2 ? p.getExtension(\"EXT_color_buffer_float\") && p.getExtension(\"EXT_float_blend\") : p.getExtension(\"OES_texture_float\"), T = j && p.getExtension(\"OES_texture_float_linear\"), _ = _ === h.WEBGL2 ? p.getExtension(\"EXT_color_buffer_float\") : p.getExtension(\"OES_texture_half_float\");\n        return { float: j, floatLinear: T, halfFloat: _, halfFloatLinear: _ && p.getExtension(\"OES_texture_half_float_linear\") };\n      }\n      C.MipmapTexture = n, t = u.default.Texture, C.default = t;\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.get-prototype-of\": 185, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.reflect.construct\": 189, \"core-js/modules/es.regexp.to-string\": 193, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.typed-array.copy-within\": 210, \"core-js/modules/es.typed-array.every\": 211, \"core-js/modules/es.typed-array.fill\": 212, \"core-js/modules/es.typed-array.filter\": 213, \"core-js/modules/es.typed-array.find\": 215, \"core-js/modules/es.typed-array.find-index\": 214, \"core-js/modules/es.typed-array.for-each\": 218, \"core-js/modules/es.typed-array.includes\": 219, \"core-js/modules/es.typed-array.index-of\": 220, \"core-js/modules/es.typed-array.iterator\": 223, \"core-js/modules/es.typed-array.join\": 224, \"core-js/modules/es.typed-array.last-index-of\": 225, \"core-js/modules/es.typed-array.map\": 226, \"core-js/modules/es.typed-array.reduce\": 228, \"core-js/modules/es.typed-array.reduce-right\": 227, \"core-js/modules/es.typed-array.reverse\": 229, \"core-js/modules/es.typed-array.set\": 230, \"core-js/modules/es.typed-array.slice\": 231, \"core-js/modules/es.typed-array.some\": 232, \"core-js/modules/es.typed-array.sort\": 233, \"core-js/modules/es.typed-array.subarray\": 234, \"core-js/modules/es.typed-array.to-locale-string\": 235, \"core-js/modules/es.typed-array.to-string\": 236, \"core-js/modules/es.typed-array.uint8-array\": 239, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }], 340: [function(t, H, C) {\n      function m(c) {\n        return (m = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(p) {\n          return typeof p;\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : typeof p;\n        })(c);\n      }\n      function y(c) {\n        return (y = typeof Symbol == \"function\" && m(Symbol.iterator) === \"symbol\" ? function(p) {\n          return m(p);\n        } : function(p) {\n          return p && typeof Symbol == \"function\" && p.constructor === Symbol && p !== Symbol.prototype ? \"symbol\" : m(p);\n        })(c);\n      }\n      t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.get-own-property-descriptor\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/es.weak-map\"), t(\"core-js/modules/web.dom-collections.iterator\"), t(\"core-js/modules/es.symbol\"), t(\"core-js/modules/es.symbol.description\"), t(\"core-js/modules/es.symbol.iterator\"), t(\"core-js/modules/es.array.iterator\"), t(\"core-js/modules/es.object.to-string\"), t(\"core-js/modules/es.regexp.exec\"), t(\"core-js/modules/es.string.iterator\"), t(\"core-js/modules/es.string.split\"), t(\"core-js/modules/es.string.sub\"), t(\"core-js/modules/web.dom-collections.iterator\");\n      var u, h = (u = t(\"../core/main\")) && u.__esModule ? u : { default: u }, g = function(c) {\n        if (c && c.__esModule)\n          return c;\n        if (c === null || y(c) !== \"object\" && typeof c != \"function\")\n          return { default: c };\n        var p = f();\n        if (p && p.has(c))\n          return p.get(c);\n        var j, T = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (j in c) {\n          var S;\n          Object.prototype.hasOwnProperty.call(c, j) && ((S = _ ? Object.getOwnPropertyDescriptor(c, j) : null) && (S.get || S.set) ? Object.defineProperty(T, j, S) : T[j] = c[j]);\n        }\n        return T.default = c, p && p.set(c, T), T;\n      }(t(\"../core/constants\"));\n      function f() {\n        var c;\n        return typeof WeakMap != \"function\" ? null : (c = /* @__PURE__ */ new WeakMap(), f = function() {\n          return c;\n        }, c);\n      }\n      function r(c, p) {\n        if (!(c instanceof p))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function s(c, p) {\n        for (var j = 0; j < p.length; j++) {\n          var T = p[j];\n          T.enumerable = T.enumerable || !1, T.configurable = !0, \"value\" in T && (T.writable = !0), Object.defineProperty(c, T.key, T);\n        }\n      }\n      function o(c, p, j) {\n        p && s(c.prototype, p);\n      }\n      t(\"./p5.Shader\"), t(\"./p5.RendererGL.Retained\"), h.default.RendererGL.prototype._applyTextProperties = function() {\n      }, h.default.RendererGL.prototype.textWidth = function(c) {\n        return this._isOpenType() ? this._textFont._textWidth(c, this._textSize) : 0;\n      };\n      var i = function() {\n        function c(p, j) {\n          r(this, c), this.width = p, this.height = j, this.infos = [];\n        }\n        return o(c, [{ key: \"findImage\", value: function(p) {\n          var j, T, _ = this.width * this.height;\n          if (_ < p)\n            throw new Error(\"font is too complex to render in 3D\");\n          for (var S = this.infos.length - 1; 0 <= S; --S) {\n            var E = this.infos[S];\n            if (E.index + p < _) {\n              T = (j = E).imageData;\n              break;\n            }\n          }\n          if (!j) {\n            try {\n              T = new ImageData(this.width, this.height);\n            } catch {\n              var A = document.getElementsByTagName(\"canvas\")[0], x = !A, P = (A || ((A = document.createElement(\"canvas\")).style.display = \"none\", document.body.appendChild(A)), A.getContext(\"2d\"));\n              P && (T = P.createImageData(this.width, this.height)), x && document.body.removeChild(A);\n            }\n            this.infos.push(j = { index: 0, imageData: T });\n          }\n          return P = j.index, j.index += p, T._dirty = !0, { imageData: T, index: P };\n        } }]), c;\n      }();\n      function l(E, p, j, T, _) {\n        var S = E.imageData.data, E = 4 * E.index++;\n        S[E++] = p, S[E++] = j, S[E++] = T, S[+E] = _;\n      }\n      var n = Math.sqrt(3), a = function() {\n        function c(p) {\n          r(this, c), this.font = p, this.strokeImageInfos = new i(64, 64), this.colDimImageInfos = new i(64, 64), this.rowDimImageInfos = new i(64, 64), this.colCellImageInfos = new i(64, 64), this.rowCellImageInfos = new i(64, 64), this.glyphInfos = {};\n        }\n        return o(c, [{ key: \"getGlyphInfo\", value: function(p) {\n          var j = this.glyphInfos[p.index];\n          if (!j) {\n            var T = p.getBoundingBox(), _ = T.x1, S = T.y1, E = T.x2 - _, A = T.y2 - S, x = p.path.commands;\n            if (E == 0 || A == 0 || !x.length)\n              return this.glyphInfos[p.index] = {};\n            for (var P = [], M = [], R = [], L = 8; 0 <= L; --L)\n              R.push([]);\n            for (L = 8; 0 <= L; --L)\n              M.push([]);\n            var F, V, G, U, W = function() {\n              function ze(Ve, Xe, He, ve) {\n                r(this, ze), this.p0 = Ve, this.c0 = Xe, this.c1 = He, this.p1 = ve;\n              }\n              return o(ze, [{ key: \"toQuadratic\", value: function() {\n                return { x: this.p0.x, y: this.p0.y, x1: this.p1.x, y1: this.p1.y, cx: (3 * (this.c0.x + this.c1.x) - (this.p0.x + this.p1.x)) / 4, cy: (3 * (this.c0.y + this.c1.y) - (this.p0.y + this.p1.y)) / 4 };\n              } }, { key: \"quadError\", value: function() {\n                return h.default.Vector.sub(h.default.Vector.sub(this.p1, this.p0), h.default.Vector.mult(h.default.Vector.sub(this.c1, this.c0), 3)).mag() / 2;\n              } }, { key: \"split\", value: function(Re) {\n                var Xe = h.default.Vector.lerp(this.p0, this.c0, Re), ve = h.default.Vector.lerp(this.c0, this.c1, Re), He = h.default.Vector.lerp(Xe, ve, Re), ve = (this.c1 = h.default.Vector.lerp(this.c1, this.p1, Re), this.c0 = h.default.Vector.lerp(ve, this.c1, Re), h.default.Vector.lerp(He, this.c0, Re)), Re = new ze(this.p0, Xe, He, ve);\n                return this.p0 = ve, Re;\n              } }, { key: \"splitInflections\", value: function() {\n                var Ve = h.default.Vector.sub(this.c0, this.p0), Xe = h.default.Vector.sub(h.default.Vector.sub(this.c1, this.c0), Ve), He = h.default.Vector.sub(h.default.Vector.sub(h.default.Vector.sub(this.p1, this.c1), Ve), h.default.Vector.mult(Xe, 2)), ve = [], Re = Xe.x * He.y - Xe.y * He.x;\n                return Re !== 0 && 0 <= (Ve = (He = Ve.x * He.y - Ve.y * He.x) * He - 4 * Re * (Ve.x * Xe.y - Ve.y * Xe.x)) && (Re < 0 && (Re = -Re, He = -He), Ve = (-He + (Xe = Math.sqrt(Ve))) / (2 * Re), 0 < (He = (-He - Xe) / (2 * Re)) && He < 1 && (ve.push(this.split(He)), Ve = 1 - (1 - Ve) / (1 - He)), 0 < Ve && Ve < 1 && ve.push(this.split(Ve))), ve.push(this), ve;\n              } }]), ze;\n            }(), X = !0, ne = !1, b = void 0;\n            try {\n              for (var O, D = x[Symbol.iterator](); !(X = (O = D.next()).done); X = !0) {\n                var B = O.value, Y = (B.x - _) / E, J = (B.y - S) / A;\n                if (!Me(F, V, Y, J)) {\n                  switch (B.type) {\n                    case \"M\":\n                      G = Y, U = J;\n                      break;\n                    case \"L\":\n                      De(F, V, Y, J);\n                      break;\n                    case \"Q\":\n                      var te = (B.x1 - _) / E, ce = (B.y1 - S) / A;\n                      ge([F, Y, te], [V, J, ce], { x: F, y: V, cx: te, cy: ce });\n                      break;\n                    case \"Z\":\n                      Me(F, V, G, U) ? P.push({ x: F, y: V }) : (De(F, V, G, U), P.push({ x: G, y: U }));\n                      break;\n                    case \"C\":\n                      for (var re = function($, je, Ce, He, ve, Re, we, Z) {\n                        var $ = new W(new h.default.Vector($, je), new h.default.Vector(Ce, He), new h.default.Vector(ve, Re), new h.default.Vector(we, Z)).splitInflections(), q = [], ee = 30 / n, pe = !0, je = !1, Ce = void 0;\n                        try {\n                          for (var Fe, Ne = $[Symbol.iterator](); !(pe = (Fe = Ne.next()).done); pe = !0) {\n                            for (var Be = Fe.value, We = [], st = void 0; !(0.125 <= (st = ee / Be.quadError())); ) {\n                              var nt = Math.pow(st, 0.3333333333333333), Ke = Be.split(nt), at = Be.split(1 - nt / (1 - nt));\n                              q.push(Ke), We.push(Be), Be = at;\n                            }\n                            st < 1 && q.push(Be.split(0.5)), q.push(Be), Array.prototype.push.apply(q, We.reverse());\n                          }\n                        } catch (ot) {\n                          je = !0, Ce = ot;\n                        } finally {\n                          try {\n                            pe || Ne.return == null || Ne.return();\n                          } finally {\n                            if (je)\n                              throw Ce;\n                          }\n                        }\n                        return q;\n                      }(F, V, (B.x1 - _) / E, (B.y1 - S) / A, (B.x2 - _) / E, (B.y2 - S) / A, Y, J), ue = 0; ue < re.length; ue++) {\n                        var le = re[ue].toQuadratic();\n                        ge([le.x, le.x1, le.cx], [le.y, le.y1, le.cy], le);\n                      }\n                      break;\n                    default:\n                      throw new Error(\"unknown command type: \".concat(B.type));\n                  }\n                  F = Y, V = J;\n                }\n              }\n            } catch (ze) {\n              ne = !0, b = ze;\n            } finally {\n              try {\n                X || D.return == null || D.return();\n              } finally {\n                if (ne)\n                  throw b;\n              }\n            }\n            for (var K = P.length, ae = this.strokeImageInfos.findImage(K), he = ae.index, _e = 0; _e < K; ++_e) {\n              var fe = P[_e];\n              l(ae, xe(fe.x), xe(fe.y), xe(fe.cx), xe(fe.cy));\n            }\n            (j = this.glyphInfos[p.index] = { glyph: p, uGlyphRect: [T.x1, -T.y1, T.x2, -T.y2], strokeImageInfo: ae, strokes: P, colInfo: Qe(R, this.colDimImageInfos, this.colCellImageInfos), rowInfo: Qe(M, this.rowDimImageInfos, this.rowCellImageInfos) }).uGridOffset = [j.colInfo.dimOffset, j.rowInfo.dimOffset];\n          }\n          return j;\n          function ge(ze, Ve, Xe) {\n            var He = P.length;\n            function ve(q, ee, pe) {\n              for (var je = q.length; 0 < je--; ) {\n                var Ce = q[je];\n                Ce < ee && (ee = Ce), pe < Ce && (pe = Ce);\n              }\n              return { min: ee, max: pe };\n            }\n            P.push(Xe);\n            for (var Xe = ve(ze, 1, 0), ze = Math.max(Math.floor(9 * Xe.min - 0.5), 0), Re = Math.min(Math.ceil(9 * Xe.max + 0.5), 9), we = ze; we < Re; ++we)\n              R[we].push(He);\n            for (var Xe = ve(Ve, 1, 0), ze = Math.max(Math.floor(9 * Xe.min - 0.5), 0), Z = Math.min(Math.ceil(9 * Xe.max + 0.5), 9), $ = ze; $ < Z; ++$)\n              M[$].push(He);\n          }\n          function xe(ze) {\n            return (ze = (Xe = 255) * ze) < (Ve = 0) ? Ve : Xe < ze ? Xe : ze;\n            var Ve, Xe;\n          }\n          function De(ze, Ve, Xe, He) {\n            ge([ze, Xe], [Ve, He], { x: ze, y: Ve, cx: (ze + Xe) / 2, cy: (Ve + He) / 2 });\n          }\n          function Me(ze, Ve, Xe, He) {\n            return Math.abs(Xe - ze) < 1e-5 && Math.abs(He - Ve) < 1e-5;\n          }\n          function Qe(ze, Ve, Xe) {\n            for (var He = ze.length, ve = Ve.findImage(He), Ve = ve.index, Re = 0, we = 0; we < He; ++we)\n              Re += ze[we].length;\n            for (var Z = Xe.findImage(Re), $ = 0; $ < He; ++$) {\n              var q = ze[$], ee = q.length, pe = Z.index;\n              l(ve, pe >> 7, 127 & pe, ee >> 7, 127 & ee);\n              for (var je = 0; je < ee; ++je) {\n                var Ce = q[je] + he;\n                l(Z, Ce >> 7, 127 & Ce, 0, 0);\n              }\n            }\n            return { cellImageInfo: Z, dimOffset: Ve, dimImageInfo: ve };\n          }\n        } }]), c;\n      }();\n      h.default.RendererGL.prototype._renderText = function(c, p, j, T, _) {\n        if (this._textFont && typeof this._textFont != \"string\") {\n          if (!(_ <= T) && this._doFill) {\n            if (this._isOpenType()) {\n              c.push();\n              var _ = this._doStroke, S = this.drawMode, E = (this._doStroke = !1, this.drawMode = g.TEXTURE, this._textFont.font), A = (A = this._textFont._fontInfo) || (this._textFont._fontInfo = new a(E)), j = this._textFont._handleAlignment(this, p, j, T), T = this._textSize / E.unitsPerEm, x = (this.translate(j.x, j.y, 0), this.scale(T, T, 1), this.GL), j = !this._defaultFontShader, P = this._getFontShader(), M = (P.init(), P.bindShader(), j && (P.setUniform(\"uGridImageSize\", [64, 64]), P.setUniform(\"uCellsImageSize\", [64, 64]), P.setUniform(\"uStrokeImageSize\", [64, 64]), P.setUniform(\"uGridSize\", [9, 9])), this._applyColorBlend(this.curFillColor), this.retainedMode.geometry.glyph), R = (M || ((T = this._textGeom = new h.default.Geometry(1, 1, function() {\n                for (var ue = 0; ue <= 1; ue++)\n                  for (var le = 0; le <= 1; le++)\n                    this.vertices.push(new h.default.Vector(le, ue, 0)), this.uvs.push(le, ue);\n              })).computeFaces().computeNormals(), M = this.createBuffers(\"glyph\", T)), !0), j = !1, T = void 0;\n              try {\n                for (var L, F = this.retainedMode.buffers.text[Symbol.iterator](); !(R = (L = F.next()).done); R = !0)\n                  L.value._prepareBuffer(M, P);\n              } catch (ue) {\n                j = !0, T = ue;\n              } finally {\n                try {\n                  R || F.return == null || F.return();\n                } finally {\n                  if (j)\n                    throw T;\n                }\n              }\n              this._bindBuffer(M.indexBuffer, x.ELEMENT_ARRAY_BUFFER), P.setUniform(\"uMaterialColor\", this.curFillColor), x.pixelStorei(x.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);\n              try {\n                var V = 0, G = null, U = E.stringToGlyphs(p), W = !0, X = !1, ne = void 0;\n                try {\n                  for (var b, O = U[Symbol.iterator](); !(W = (b = O.next()).done); W = !0) {\n                    var D, B, Y = b.value, J = (G && (V += E.getKerningValue(G, Y)), A.getGlyphInfo(Y));\n                    J.uGlyphRect && (D = J.rowInfo, B = J.colInfo, P.setUniform(\"uSamplerStrokes\", J.strokeImageInfo.imageData), P.setUniform(\"uSamplerRowStrokes\", D.cellImageInfo.imageData), P.setUniform(\"uSamplerRows\", D.dimImageInfo.imageData), P.setUniform(\"uSamplerColStrokes\", B.cellImageInfo.imageData), P.setUniform(\"uSamplerCols\", B.dimImageInfo.imageData), P.setUniform(\"uGridOffset\", J.uGridOffset), P.setUniform(\"uGlyphRect\", J.uGlyphRect), P.setUniform(\"uGlyphOffset\", V), P.bindTextures(), x.drawElements(x.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0)), V += Y.advanceWidth, G = Y;\n                  }\n                } catch (ue) {\n                  X = !0, ne = ue;\n                } finally {\n                  try {\n                    W || O.return == null || O.return();\n                  } finally {\n                    if (X)\n                      throw ne;\n                  }\n                }\n              } finally {\n                P.unbindShader(), this._doStroke = _, this.drawMode = S, x.pixelStorei(x.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), c.pop();\n              }\n            } else\n              console.log(\"WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts are supported\");\n            return c;\n          }\n        } else\n          console.log(\"WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.\");\n      };\n    }, { \"../core/constants\": 269, \"../core/main\": 280, \"./p5.RendererGL.Retained\": 336, \"./p5.Shader\": 338, \"core-js/modules/es.array.iterator\": 164, \"core-js/modules/es.object.get-own-property-descriptor\": 183, \"core-js/modules/es.object.to-string\": 187, \"core-js/modules/es.regexp.exec\": 192, \"core-js/modules/es.string.iterator\": 197, \"core-js/modules/es.string.split\": 203, \"core-js/modules/es.string.sub\": 205, \"core-js/modules/es.symbol\": 209, \"core-js/modules/es.symbol.description\": 207, \"core-js/modules/es.symbol.iterator\": 208, \"core-js/modules/es.weak-map\": 241, \"core-js/modules/web.dom-collections.iterator\": 243 }] }, {}, [264])(264);\n  });\n})(wn);\nvar Qn = wn.exports;\nconst Kn = /* @__PURE__ */ qn(Qn);\nfunction Jn(yt, Et) {\n  return new Kn(yt, Et);\n}\nfunction jn(yt) {\n  var Et;\n  (Et = yt.current) == null || Et.remove(), yt.current = null;\n}\nfunction $n(yt) {\n  const { sketch: Et, children: Vt, ...t } = yt, H = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    H.current !== null && (jn(C), C.current = Jn(\n      Et,\n      H.current\n    ));\n  }, [Et]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var m, y;\n    (y = (m = C.current) == null ? void 0 : m.updateWithProps) == null || y.call(m, t);\n  }, [t, H]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => jn(C), []), /* @__PURE__ */ wr.jsx(\"div\", { ref: H, className: Zn, children: Vt });\n}\nfunction eo(yt) {\n  const { sketch: Et, fallback: Vt } = yt;\n  return Et === void 0 ? (console.error(\"[ReactP5Wrapper] The `sketch` prop is required.\"), Vt !== void 0 ? /* @__PURE__ */ wr.jsx(wr.Fragment, { children: Vt }) : null) : /* @__PURE__ */ wr.jsx(\n    $n,\n    {\n      ...yt\n    }\n  );\n}\nconst ro = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(eo, Wn);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHA1LXdyYXBwZXIvcmVhY3QvZGlzdC9jb21wb25lbnQvcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNFO0FBQ3RFLGFBQWE7QUFDYiwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBRSwrTEFBK0w7QUFDNU07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxhQUFhLGtDQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFNBQVM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdC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QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx5QkFBeUIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSx3QkFBd0IsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSx3QkFBd0IsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSw0QkFBNEIsSUFBSSw0QkFBNEIsSUFBSSw4QkFBOEIsSUFBSSwwQkFBMEIsSUFBSSw0QkFBNEIsSUFBSSx3QkFBd0IsSUFBSSx3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QSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFD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QUFJLDZDQUE2QyxJQUFJLDBDQUEwQyxJQUFJLG1DQUFtQyxJQUFJLDhDQUE4QyxJQUFJLDRDQUE0QyxJQUFJLGlEQUFpRCxJQUFJLDZDQUE2QyxJQUFJLGdEQUFnRCxJQUFJLHlDQUF5QyxJQUFJLGtEQUFrRCxJQUFJLDBDQUEwQyxJQUFJLHlDQUF5QyxJQUFJLGtDQUFrQyxJQUFJLDBDQUEwQyxJQUFJLHlDQUF5QyxJQUFJLGtDQUFrQyxJQUFJLDBDQUEwQyxJQUFJLDZDQUE2QyxJQUFJLDJDQUEyQyxJQUFJLDBDQUEwQyxJQUFJLDRDQUE0QyxJQUFJLHlDQUF5QyxJQUFJLGtDQUFrQyxJQUFJLDZDQUE2QyxJQUFJLDJDQUEyQyxJQUFJLDBDQUEwQyxJQUFJLHlDQUF5QyxJQUFJLGtDQUFrQyxJQUFJLDhDQUE4QyxJQUFJLDZDQUE2QyxJQUFJLHNDQUFzQyxJQUFJLDJDQUEyQyxJQUFJLDBDQUEwQyxJQUFJLHlDQUF5QyxJQUFJLHdDQUF3QyxJQUFJLGlDQUFpQyxJQUFJLDJDQUEyQyxJQUFJLDZDQUE2QyxJQUFJLHdDQUF3QyxJQUFJLHFDQUFxQyxJQUFJLG1DQUFtQyxJQUFJLDRDQUE0QyxJQUFJLHFDQUFxQyxJQUFJLHlDQUF5QyxJQUFJLHdDQUF3QyxJQUFJLGlDQUFpQyxJQUFJLHFDQUFxQyxJQUFJLDBDQUEwQyxJQUFJLDJDQUEyQyxJQUFJLDZDQUE2QyxJQUFJLGlDQUFpQyxJQUFJLHFDQUFxQyxJQUFJLDBDQUEwQyxJQUFJLDRDQUE0QyxJQUFJLDZDQUE2QyxJQUFJLGlDQUFpQyxJQUFJLHVDQUF1QyxJQUFJLDBDQUEwQyxJQUFJLG1DQUFtQyxJQUFJLDZDQUE2QyxJQUFJLDBDQUEwQyxJQUFJLG1DQUFtQyxJQUFJLHVDQUF1QyxJQUFJLHVDQUF1QyxJQUFJLDRDQUE0QyxJQUFJLDJDQUEyQyxJQUFJLG9DQUFvQyxJQUFJLDZDQUE2QyxJQUFJLHVDQUF1QyxJQUFJLDJDQUEyQyxJQUFJLG9DQUFvQyxJQUFJLGlDQUFpQyxJQUFJLHlDQUF5QyxJQUFJLDJDQUEyQyxJQUFJLG9DQUFvQztB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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4Qix5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QUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckMsa0pBQWtKLGNBQWM7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBRTtBQUlYIiwic291cmNlcyI6WyIvVXNlcnMvY3lydXNraGFsYXRiYXJpL0RvY3VtZW50cy8yIC0gV09SSy8wMi4gUE9PTCBOVU0vUE9PTCBXRUJTSVRFL3Bvb2wtd2Vic2l0ZS9mcm9udC1lbmQvbm9kZV9tb2R1bGVzL0BwNS13cmFwcGVyL3JlYWN0L2Rpc3QvY29tcG9uZW50L3JlYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbiwgeyB1c2VSZWYgYXMgZ24sIHVzZUVmZmVjdCBhcyBBciwgbWVtbyBhcyB6biB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgSG4gPSB7IERhdGU6ICEwLCBSZWdFeHA6ICEwLCBTdHJpbmc6ICEwLCBOdW1iZXI6ICEwIH07XG5mdW5jdGlvbiB4bih5dCwgRXQsIFZ0ID0geyBjeWNsZXNGaXg6ICEwIH0sIHQgPSBbXSkge1xuICB2YXIgeSwgdTtcbiAgbGV0IEggPSBbXTtcbiAgY29uc3QgQyA9IEFycmF5LmlzQXJyYXkoeXQpO1xuICBmb3IgKGNvbnN0IGggaW4geXQpIHtcbiAgICBjb25zdCBnID0geXRbaF0sIGYgPSBDID8gK2ggOiBoO1xuICAgIGlmICghKGggaW4gRXQpKSB7XG4gICAgICBILnB1c2goe1xuICAgICAgICB0eXBlOiBcIlJFTU9WRVwiLFxuICAgICAgICBwYXRoOiBbZl0sXG4gICAgICAgIG9sZFZhbHVlOiB5dFtoXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgciA9IEV0W2hdLCBzID0gdHlwZW9mIGcgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoZykgPT09IEFycmF5LmlzQXJyYXkocik7XG4gICAgaWYgKGcgJiYgciAmJiBzICYmICFIblsodSA9ICh5ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGcpKSA9PSBudWxsID8gdm9pZCAwIDogeS5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IHUubmFtZV0gJiYgKCFWdC5jeWNsZXNGaXggfHwgIXQuaW5jbHVkZXMoZykpKSB7XG4gICAgICBjb25zdCBvID0geG4oZywgciwgVnQsIFZ0LmN5Y2xlc0ZpeCA/IHQuY29uY2F0KFtnXSkgOiBbXSk7XG4gICAgICBILnB1c2guYXBwbHkoSCwgby5tYXAoKGkpID0+IChpLnBhdGgudW5zaGlmdChmKSwgaSkpKTtcbiAgICB9IGVsc2VcbiAgICAgIGcgIT09IHIgJiYgLy8gdHJlYXQgTmFOIHZhbHVlcyBhcyBlcXVpdmFsZW50XG4gICAgICAhKE51bWJlci5pc05hTihnKSAmJiBOdW1iZXIuaXNOYU4ocikpICYmICEocyAmJiAoaXNOYU4oZykgPyBnICsgXCJcIiA9PSByICsgXCJcIiA6ICtnID09ICtyKSkgJiYgSC5wdXNoKHtcbiAgICAgICAgcGF0aDogW2ZdLFxuICAgICAgICB0eXBlOiBcIkNIQU5HRVwiLFxuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgb2xkVmFsdWU6IGdcbiAgICAgIH0pO1xuICB9XG4gIGNvbnN0IG0gPSBBcnJheS5pc0FycmF5KEV0KTtcbiAgZm9yIChjb25zdCBoIGluIEV0KVxuICAgIGggaW4geXQgfHwgSC5wdXNoKHtcbiAgICAgIHR5cGU6IFwiQ1JFQVRFXCIsXG4gICAgICBwYXRoOiBbbSA/ICtoIDogaF0sXG4gICAgICB2YWx1ZTogRXRbaF1cbiAgICB9KTtcbiAgcmV0dXJuIEg7XG59XG5mdW5jdGlvbiBXbih5dCwgRXQpIHtcbiAgcmV0dXJuIHhuKHl0LCBFdCkubGVuZ3RoID09PSAwO1xufVxudmFyIF9yID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gcW4oeXQpIHtcbiAgcmV0dXJuIHl0ICYmIHl0Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHl0LCBcImRlZmF1bHRcIikgPyB5dC5kZWZhdWx0IDogeXQ7XG59XG52YXIgUHIgPSB7IGV4cG9ydHM6IHt9IH0sIHByID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgdm47XG5mdW5jdGlvbiBYbigpIHtcbiAgaWYgKHZuKVxuICAgIHJldHVybiBwcjtcbiAgdm4gPSAxO1xuICB2YXIgeXQgPSBfbiwgRXQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgVnQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBIID0geXQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIEMgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiBtKHksIHUsIGgpIHtcbiAgICB2YXIgZywgZiA9IHt9LCByID0gbnVsbCwgcyA9IG51bGw7XG4gICAgaCAhPT0gdm9pZCAwICYmIChyID0gXCJcIiArIGgpLCB1LmtleSAhPT0gdm9pZCAwICYmIChyID0gXCJcIiArIHUua2V5KSwgdS5yZWYgIT09IHZvaWQgMCAmJiAocyA9IHUucmVmKTtcbiAgICBmb3IgKGcgaW4gdSlcbiAgICAgIHQuY2FsbCh1LCBnKSAmJiAhQy5oYXNPd25Qcm9wZXJ0eShnKSAmJiAoZltnXSA9IHVbZ10pO1xuICAgIGlmICh5ICYmIHkuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChnIGluIHUgPSB5LmRlZmF1bHRQcm9wcywgdSlcbiAgICAgICAgZltnXSA9PT0gdm9pZCAwICYmIChmW2ddID0gdVtnXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEV0LCB0eXBlOiB5LCBrZXk6IHIsIHJlZjogcywgcHJvcHM6IGYsIF9vd25lcjogSC5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIHByLkZyYWdtZW50ID0gVnQsIHByLmpzeCA9IG0sIHByLmpzeHMgPSBtLCBwcjtcbn1cbnZhciBtciA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGJuO1xuZnVuY3Rpb24gWW4oKSB7XG4gIHJldHVybiBibiB8fCAoYm4gPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHl0ID0gX24sIEV0ID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIFZ0ID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgSCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgQyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgeSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgbyA9IFN5bWJvbC5pdGVyYXRvciwgaSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIGwobWUpIHtcbiAgICAgIGlmIChtZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgVWUgPSBvICYmIG1lW29dIHx8IG1lW2ldO1xuICAgICAgcmV0dXJuIHR5cGVvZiBVZSA9PSBcImZ1bmN0aW9uXCIgPyBVZSA6IG51bGw7XG4gICAgfVxuICAgIHZhciBuID0geXQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gYShtZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBVZSA9IGFyZ3VtZW50cy5sZW5ndGgsIFllID0gbmV3IEFycmF5KFVlID4gMSA/IFVlIC0gMSA6IDApLCBpdCA9IDE7IGl0IDwgVWU7IGl0KyspXG4gICAgICAgICAgWWVbaXQgLSAxXSA9IGFyZ3VtZW50c1tpdF07XG4gICAgICAgIGMoXCJlcnJvclwiLCBtZSwgWWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjKG1lLCBVZSwgWWUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGl0ID0gbi5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBmdCA9IGl0LmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgZnQgIT09IFwiXCIgJiYgKFVlICs9IFwiJXNcIiwgWWUgPSBZZS5jb25jYXQoW2Z0XSkpO1xuICAgICAgICB2YXIgcHQgPSBZZS5tYXAoZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGllKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHB0LnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIFVlKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVttZV0sIGNvbnNvbGUsIHB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHAgPSAhMSwgaiA9ICExLCBUID0gITEsIF8gPSAhMSwgUyA9ICExLCBFO1xuICAgIEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBBKG1lKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIG1lID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lID09IFwiZnVuY3Rpb25cIiB8fCBtZSA9PT0gdCB8fCBtZSA9PT0gQyB8fCBTIHx8IG1lID09PSBIIHx8IG1lID09PSBoIHx8IG1lID09PSBnIHx8IF8gfHwgbWUgPT09IHMgfHwgcCB8fCBqIHx8IFQgfHwgdHlwZW9mIG1lID09IFwib2JqZWN0XCIgJiYgbWUgIT09IG51bGwgJiYgKG1lLiQkdHlwZW9mID09PSByIHx8IG1lLiQkdHlwZW9mID09PSBmIHx8IG1lLiQkdHlwZW9mID09PSBtIHx8IG1lLiQkdHlwZW9mID09PSB5IHx8IG1lLiQkdHlwZW9mID09PSB1IHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIG1lLiQkdHlwZW9mID09PSBFIHx8IG1lLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geChtZSwgVWUsIFllKSB7XG4gICAgICB2YXIgaXQgPSBtZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChpdClcbiAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgdmFyIGZ0ID0gVWUuZGlzcGxheU5hbWUgfHwgVWUubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGZ0ICE9PSBcIlwiID8gWWUgKyBcIihcIiArIGZ0ICsgXCIpXCIgOiBZZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUChtZSkge1xuICAgICAgcmV0dXJuIG1lLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKG1lKSB7XG4gICAgICBpZiAobWUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIG1lLnRhZyA9PSBcIm51bWJlclwiICYmIGEoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIG1lID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIG1lLmRpc3BsYXlOYW1lIHx8IG1lLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgbWUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgc3dpdGNoIChtZSkge1xuICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBWdDpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBDOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgSDpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1lID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAobWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgICB2YXIgVWUgPSBtZTtcbiAgICAgICAgICAgIHJldHVybiBQKFVlKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgICAgdmFyIFllID0gbWU7XG4gICAgICAgICAgICByZXR1cm4gUChZZS5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiB4KG1lLCBtZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgICB2YXIgaXQgPSBtZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGl0ICE9PSBudWxsID8gaXQgOiBNKG1lLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2Ugcjoge1xuICAgICAgICAgICAgdmFyIGZ0ID0gbWUsIHB0ID0gZnQuX3BheWxvYWQsIGllID0gZnQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gTShpZShwdCkpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBSID0gT2JqZWN0LmFzc2lnbiwgTCA9IDAsIEYsIFYsIEcsIFUsIFcsIFgsIG5lO1xuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgfVxuICAgIGIuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gTygpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEwgPT09IDApIHtcbiAgICAgICAgICBGID0gY29uc29sZS5sb2csIFYgPSBjb25zb2xlLmluZm8sIEcgPSBjb25zb2xlLndhcm4sIFUgPSBjb25zb2xlLmVycm9yLCBXID0gY29uc29sZS5ncm91cCwgWCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIG5lID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgbWUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogYixcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogbWUsXG4gICAgICAgICAgICBsb2c6IG1lLFxuICAgICAgICAgICAgd2FybjogbWUsXG4gICAgICAgICAgICBlcnJvcjogbWUsXG4gICAgICAgICAgICBncm91cDogbWUsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogbWUsXG4gICAgICAgICAgICBncm91cEVuZDogbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBMKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEQoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChMLS0sIEwgPT09IDApIHtcbiAgICAgICAgICB2YXIgbWUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogUih7fSwgbWUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEZcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogUih7fSwgbWUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFZcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogUih7fSwgbWUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IFIoe30sIG1lLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBVXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBSKHt9LCBtZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogV1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogUih7fSwgbWUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IFIoe30sIG1lLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBMIDwgMCAmJiBhKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEIgPSBuLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIFk7XG4gICAgZnVuY3Rpb24gSihtZSwgVWUsIFllKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChZID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZnQpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGZ0LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgWSA9IGl0ICYmIGl0WzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIFkgKyBtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRlID0gITEsIGNlO1xuICAgIHtcbiAgICAgIHZhciByZSA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBjZSA9IG5ldyByZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1ZShtZSwgVWUpIHtcbiAgICAgIGlmICghbWUgfHwgdGUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgWWUgPSBjZS5nZXQobWUpO1xuICAgICAgICBpZiAoWWUgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gWWU7XG4gICAgICB9XG4gICAgICB2YXIgaXQ7XG4gICAgICB0ZSA9ICEwO1xuICAgICAgdmFyIGZ0ID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwdDtcbiAgICAgIHB0ID0gQi5jdXJyZW50LCBCLmN1cnJlbnQgPSBudWxsLCBPKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoVWUpIHtcbiAgICAgICAgICB2YXIgaWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KGllLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChpZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAodXQpIHtcbiAgICAgICAgICAgICAgaXQgPSB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KG1lLCBbXSwgaWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh1dCkge1xuICAgICAgICAgICAgICBpdCA9IHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWUuY2FsbChpZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh1dCkge1xuICAgICAgICAgICAgaXQgPSB1dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodXQpIHtcbiAgICAgICAgaWYgKHV0ICYmIGl0ICYmIHR5cGVvZiB1dC5zdGFjayA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yICh2YXIgT2UgPSB1dC5zdGFjay5zcGxpdChgXG5gKSwgR2UgPSBpdC5zdGFjay5zcGxpdChgXG5gKSwgTGUgPSBPZS5sZW5ndGggLSAxLCBydCA9IEdlLmxlbmd0aCAtIDE7IExlID49IDEgJiYgcnQgPj0gMCAmJiBPZVtMZV0gIT09IEdlW3J0XTsgKVxuICAgICAgICAgICAgcnQtLTtcbiAgICAgICAgICBmb3IgKDsgTGUgPj0gMSAmJiBydCA+PSAwOyBMZS0tLCBydC0tKVxuICAgICAgICAgICAgaWYgKE9lW0xlXSAhPT0gR2VbcnRdKSB7XG4gICAgICAgICAgICAgIGlmIChMZSAhPT0gMSB8fCBydCAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKExlLS0sIHJ0LS0sIHJ0IDwgMCB8fCBPZVtMZV0gIT09IEdlW3J0XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgUGUgPSBgXG5gICsgT2VbTGVdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5kaXNwbGF5TmFtZSAmJiBQZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChQZSA9IFBlLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBtZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgbWUgPT0gXCJmdW5jdGlvblwiICYmIGNlLnNldChtZSwgUGUpLCBQZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoTGUgPj0gMSAmJiBydCA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRlID0gITEsIEIuY3VycmVudCA9IHB0LCBEKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnQ7XG4gICAgICB9XG4gICAgICB2YXIgY3QgPSBtZSA/IG1lLmRpc3BsYXlOYW1lIHx8IG1lLm5hbWUgOiBcIlwiLCBxZSA9IGN0ID8gSihjdCkgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZSA9PSBcImZ1bmN0aW9uXCIgJiYgY2Uuc2V0KG1lLCBxZSksIHFlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZShtZSwgVWUsIFllKSB7XG4gICAgICByZXR1cm4gdWUobWUsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSyhtZSkge1xuICAgICAgdmFyIFVlID0gbWUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKFVlICYmIFVlLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZShtZSwgVWUsIFllKSB7XG4gICAgICBpZiAobWUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIG1lID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHVlKG1lLCBLKG1lKSk7XG4gICAgICBpZiAodHlwZW9mIG1lID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBKKG1lKTtcbiAgICAgIHN3aXRjaCAobWUpIHtcbiAgICAgICAgY2FzZSBoOlxuICAgICAgICAgIHJldHVybiBKKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgZzpcbiAgICAgICAgICByZXR1cm4gSihcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChtZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiBsZShtZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgIHJldHVybiBhZShtZS50eXBlLCBVZSwgWWUpO1xuICAgICAgICAgIGNhc2Ugcjoge1xuICAgICAgICAgICAgdmFyIGl0ID0gbWUsIGZ0ID0gaXQuX3BheWxvYWQsIHB0ID0gaXQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gYWUocHQoZnQpLCBVZSwgWWUpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGhlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX2UgPSB7fSwgZmUgPSBuLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gZ2UobWUpIHtcbiAgICAgIGlmIChtZSkge1xuICAgICAgICB2YXIgVWUgPSBtZS5fb3duZXIsIFllID0gYWUobWUudHlwZSwgbWUuX3NvdXJjZSwgVWUgPyBVZS50eXBlIDogbnVsbCk7XG4gICAgICAgIGZlLnNldEV4dHJhU3RhY2tGcmFtZShZZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZmUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShtZSwgVWUsIFllLCBpdCwgZnQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHB0ID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhlKTtcbiAgICAgICAgZm9yICh2YXIgaWUgaW4gbWUpXG4gICAgICAgICAgaWYgKHB0KG1lLCBpZSkpIHtcbiAgICAgICAgICAgIHZhciBPZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVbaWVdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBHZSA9IEVycm9yKChpdCB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgWWUgKyBcIiB0eXBlIGBcIiArIGllICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBtZVtpZV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IEdlLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgR2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgT2UgPSBtZVtpZV0oVWUsIGllLCBpdCwgWWUsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChMZSkge1xuICAgICAgICAgICAgICBPZSA9IExlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2UgJiYgIShPZSBpbnN0YW5jZW9mIEVycm9yKSAmJiAoZ2UoZnQpLCBhKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBpdCB8fCBcIlJlYWN0IGNsYXNzXCIsIFllLCBpZSwgdHlwZW9mIE9lKSwgZ2UobnVsbCkpLCBPZSBpbnN0YW5jZW9mIEVycm9yICYmICEoT2UubWVzc2FnZSBpbiBfZSkgJiYgKF9lW09lLm1lc3NhZ2VdID0gITAsIGdlKGZ0KSwgYShcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBZZSwgT2UubWVzc2FnZSksIGdlKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBEZSA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gTWUobWUpIHtcbiAgICAgIHJldHVybiBEZShtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFlKG1lKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBVZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgWWUgPSBVZSAmJiBtZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IG1lLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIFllO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB6ZShtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFZlKG1lKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBWZShtZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWGUobWUpIHtcbiAgICAgIGlmICh6ZShtZSkpXG4gICAgICAgIHJldHVybiBhKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIFFlKG1lKSksIFZlKG1lKTtcbiAgICB9XG4gICAgdmFyIEhlID0gbi5SZWFjdEN1cnJlbnRPd25lciwgdmUgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBSZSwgd2UsIFo7XG4gICAgWiA9IHt9O1xuICAgIGZ1bmN0aW9uICQobWUpIHtcbiAgICAgIGlmIChoZS5jYWxsKG1lLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgVWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1lLCBcInJlZlwiKS5nZXQ7XG4gICAgICAgIGlmIChVZSAmJiBVZS5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWUucmVmICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEobWUpIHtcbiAgICAgIGlmIChoZS5jYWxsKG1lLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgVWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1lLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChVZSAmJiBVZS5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWUua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVlKG1lLCBVZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZS5yZWYgPT0gXCJzdHJpbmdcIiAmJiBIZS5jdXJyZW50ICYmIFVlICYmIEhlLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBVZSkge1xuICAgICAgICB2YXIgWWUgPSBNKEhlLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIFpbWWVdIHx8IChhKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgTShIZS5jdXJyZW50LnR5cGUpLCBtZS5yZWYpLCBaW1llXSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGUobWUsIFVlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBZZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFJlIHx8IChSZSA9ICEwLCBhKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgVWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgWWUuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBZZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBqZShtZSwgVWUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2UgfHwgKHdlID0gITAsIGEoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBVZSkpO1xuICAgICAgICB9O1xuICAgICAgICBZZS5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IFllLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBDZSA9IGZ1bmN0aW9uKG1lLCBVZSwgWWUsIGl0LCBmdCwgcHQsIGllKSB7XG4gICAgICB2YXIgT2UgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogRXQsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogbWUsXG4gICAgICAgIGtleTogVWUsXG4gICAgICAgIHJlZjogWWUsXG4gICAgICAgIHByb3BzOiBpZSxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBwdFxuICAgICAgfTtcbiAgICAgIHJldHVybiBPZS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9lLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2UsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogaXRcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2UsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBmdFxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoT2UucHJvcHMpLCBPYmplY3QuZnJlZXplKE9lKSksIE9lO1xuICAgIH07XG4gICAgZnVuY3Rpb24gRmUobWUsIFVlLCBZZSwgaXQsIGZ0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBwdCwgaWUgPSB7fSwgT2UgPSBudWxsLCBHZSA9IG51bGw7XG4gICAgICAgIFllICE9PSB2b2lkIDAgJiYgKFhlKFllKSwgT2UgPSBcIlwiICsgWWUpLCBxKFVlKSAmJiAoWGUoVWUua2V5KSwgT2UgPSBcIlwiICsgVWUua2V5KSwgJChVZSkgJiYgKEdlID0gVWUucmVmLCBlZShVZSwgZnQpKTtcbiAgICAgICAgZm9yIChwdCBpbiBVZSlcbiAgICAgICAgICBoZS5jYWxsKFVlLCBwdCkgJiYgIXZlLmhhc093blByb3BlcnR5KHB0KSAmJiAoaWVbcHRdID0gVWVbcHRdKTtcbiAgICAgICAgaWYgKG1lICYmIG1lLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBMZSA9IG1lLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKHB0IGluIExlKVxuICAgICAgICAgICAgaWVbcHRdID09PSB2b2lkIDAgJiYgKGllW3B0XSA9IExlW3B0XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9lIHx8IEdlKSB7XG4gICAgICAgICAgdmFyIHJ0ID0gdHlwZW9mIG1lID09IFwiZnVuY3Rpb25cIiA/IG1lLmRpc3BsYXlOYW1lIHx8IG1lLm5hbWUgfHwgXCJVbmtub3duXCIgOiBtZTtcbiAgICAgICAgICBPZSAmJiBwZShpZSwgcnQpLCBHZSAmJiBqZShpZSwgcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDZShtZSwgT2UsIEdlLCBmdCwgaXQsIEhlLmN1cnJlbnQsIGllKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIE5lID0gbi5SZWFjdEN1cnJlbnRPd25lciwgQmUgPSBuLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gV2UobWUpIHtcbiAgICAgIGlmIChtZSkge1xuICAgICAgICB2YXIgVWUgPSBtZS5fb3duZXIsIFllID0gYWUobWUudHlwZSwgbWUuX3NvdXJjZSwgVWUgPyBVZS50eXBlIDogbnVsbCk7XG4gICAgICAgIEJlLnNldEV4dHJhU3RhY2tGcmFtZShZZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgQmUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgc3Q7XG4gICAgc3QgPSAhMTtcbiAgICBmdW5jdGlvbiBudChtZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZSA9PSBcIm9iamVjdFwiICYmIG1lICE9PSBudWxsICYmIG1lLiQkdHlwZW9mID09PSBFdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gS2UoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChOZS5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG1lID0gTShOZS5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChtZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBtZSArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXQobWUpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgb3QgPSB7fTtcbiAgICBmdW5jdGlvbiBidChtZSkge1xuICAgICAge1xuICAgICAgICB2YXIgVWUgPSBLZSgpO1xuICAgICAgICBpZiAoIVVlKSB7XG4gICAgICAgICAgdmFyIFllID0gdHlwZW9mIG1lID09IFwic3RyaW5nXCIgPyBtZSA6IG1lLmRpc3BsYXlOYW1lIHx8IG1lLm5hbWU7XG4gICAgICAgICAgWWUgJiYgKFVlID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgWWUgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSXQobWUsIFVlKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghbWUuX3N0b3JlIHx8IG1lLl9zdG9yZS52YWxpZGF0ZWQgfHwgbWUua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtZS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciBZZSA9IGJ0KFVlKTtcbiAgICAgICAgaWYgKG90W1llXSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG90W1llXSA9ICEwO1xuICAgICAgICB2YXIgaXQgPSBcIlwiO1xuICAgICAgICBtZSAmJiBtZS5fb3duZXIgJiYgbWUuX293bmVyICE9PSBOZS5jdXJyZW50ICYmIChpdCA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgTShtZS5fb3duZXIudHlwZSkgKyBcIi5cIiksIFdlKG1lKSwgYSgnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgWWUsIGl0KSwgV2UobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE10KG1lLCBVZSkge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIG1lICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoTWUobWUpKVxuICAgICAgICAgIGZvciAodmFyIFllID0gMDsgWWUgPCBtZS5sZW5ndGg7IFllKyspIHtcbiAgICAgICAgICAgIHZhciBpdCA9IG1lW1llXTtcbiAgICAgICAgICAgIG50KGl0KSAmJiBJdChpdCwgVWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnQobWUpKVxuICAgICAgICAgIG1lLl9zdG9yZSAmJiAobWUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAobWUpIHtcbiAgICAgICAgICB2YXIgZnQgPSBsKG1lKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ0ID09IFwiZnVuY3Rpb25cIiAmJiBmdCAhPT0gbWUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHB0ID0gZnQuY2FsbChtZSksIGllOyAhKGllID0gcHQubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIG50KGllLnZhbHVlKSAmJiBJdChpZS52YWx1ZSwgVWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG10KG1lKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBVZSA9IG1lLnR5cGU7XG4gICAgICAgIGlmIChVZSA9PSBudWxsIHx8IHR5cGVvZiBVZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIFllO1xuICAgICAgICBpZiAodHlwZW9mIFVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBZZSA9IFVlLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIFVlID09IFwib2JqZWN0XCIgJiYgKFVlLiQkdHlwZW9mID09PSB1IHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIFVlLiQkdHlwZW9mID09PSBmKSlcbiAgICAgICAgICBZZSA9IFVlLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKFllKSB7XG4gICAgICAgICAgdmFyIGl0ID0gTShVZSk7XG4gICAgICAgICAgeGUoWWUsIG1lLnByb3BzLCBcInByb3BcIiwgaXQsIG1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChVZS5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhc3QpIHtcbiAgICAgICAgICBzdCA9ICEwO1xuICAgICAgICAgIHZhciBmdCA9IE0oVWUpO1xuICAgICAgICAgIGEoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgZnQgfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBVZS5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFVZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgYShcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBqdChtZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBVZSA9IE9iamVjdC5rZXlzKG1lLnByb3BzKSwgWWUgPSAwOyBZZSA8IFVlLmxlbmd0aDsgWWUrKykge1xuICAgICAgICAgIHZhciBpdCA9IFVlW1llXTtcbiAgICAgICAgICBpZiAoaXQgIT09IFwiY2hpbGRyZW5cIiAmJiBpdCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgV2UobWUpLCBhKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgaXQpLCBXZShudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZS5yZWYgIT09IG51bGwgJiYgKFdlKG1lKSwgYShcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBXZShudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh0KG1lLCBVZSwgWWUsIGl0LCBmdCwgcHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGllID0gQShtZSk7XG4gICAgICAgIGlmICghaWUpIHtcbiAgICAgICAgICB2YXIgT2UgPSBcIlwiO1xuICAgICAgICAgIChtZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZSA9PSBcIm9iamVjdFwiICYmIG1lICE9PSBudWxsICYmIE9iamVjdC5rZXlzKG1lKS5sZW5ndGggPT09IDApICYmIChPZSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBHZSA9IGF0KCk7XG4gICAgICAgICAgR2UgPyBPZSArPSBHZSA6IE9lICs9IEtlKCk7XG4gICAgICAgICAgdmFyIExlO1xuICAgICAgICAgIG1lID09PSBudWxsID8gTGUgPSBcIm51bGxcIiA6IE1lKG1lKSA/IExlID0gXCJhcnJheVwiIDogbWUgIT09IHZvaWQgMCAmJiBtZS4kJHR5cGVvZiA9PT0gRXQgPyAoTGUgPSBcIjxcIiArIChNKG1lLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIE9lID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBMZSA9IHR5cGVvZiBtZSwgYShcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBMZSwgT2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydCA9IEZlKG1lLCBVZSwgWWUsIGZ0LCBwdCk7XG4gICAgICAgIGlmIChydCA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBydDtcbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgdmFyIFBlID0gVWUuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKFBlICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAoaXQpXG4gICAgICAgICAgICAgIGlmIChNZShQZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjdCA9IDA7IGN0IDwgUGUubGVuZ3RoOyBjdCsrKVxuICAgICAgICAgICAgICAgICAgTXQoUGVbY3RdLCBtZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKFBlKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYShcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIE10KFBlLCBtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lID09PSB0ID8ganQocnQpIDogbXQocnQpLCBydDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRHQobWUsIFVlLCBZZSkge1xuICAgICAgcmV0dXJuIGh0KG1lLCBVZSwgWWUsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUHQobWUsIFVlLCBZZSkge1xuICAgICAgcmV0dXJuIGh0KG1lLCBVZSwgWWUsICExKTtcbiAgICB9XG4gICAgdmFyIGd0ID0gUHQsIEZ0ID0gRHQ7XG4gICAgbXIuRnJhZ21lbnQgPSB0LCBtci5qc3ggPSBndCwgbXIuanN4cyA9IEZ0O1xuICB9KCkpLCBtcjtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IFByLmV4cG9ydHMgPSBYbigpIDogUHIuZXhwb3J0cyA9IFluKCk7XG52YXIgd3IgPSBQci5leHBvcnRzO1xuY29uc3QgWm4gPSBcInJlYWN0LXA1LXdyYXBwZXJcIjtcbmZ1bmN0aW9uIHhyKHl0KSB7XG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgeXQgKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO1xufVxudmFyIHduID0geyBleHBvcnRzOiB7fSB9O1xuLyohIHA1LmpzIHYxLjkuNCBNYXkgMjEsIDIwMjQgKi9cbihmdW5jdGlvbih5dCwgRXQpIHtcbiAgKGZ1bmN0aW9uKFZ0KSB7XG4gICAgeXQuZXhwb3J0cyA9IFZ0KCk7XG4gIH0pKGZ1bmN0aW9uKCkge1xuICAgIHZhciBWdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gdChILCBDLCBtKSB7XG4gICAgICBmdW5jdGlvbiB5KGcsIGYpIHtcbiAgICAgICAgaWYgKCFDW2ddKSB7XG4gICAgICAgICAgaWYgKCFIW2ddKSB7XG4gICAgICAgICAgICB2YXIgciA9IHR5cGVvZiB4ciA9PSBcImZ1bmN0aW9uXCIgJiYgeHI7XG4gICAgICAgICAgICBpZiAoIWYgJiYgcilcbiAgICAgICAgICAgICAgcmV0dXJuIHIoZywgITApO1xuICAgICAgICAgICAgaWYgKHUpXG4gICAgICAgICAgICAgIHJldHVybiB1KGcsICEwKTtcbiAgICAgICAgICAgIHRocm93IChmID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIGcgKyBcIidcIikpLmNvZGUgPSBcIk1PRFVMRV9OT1RfRk9VTkRcIiwgZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgciA9IENbZ10gPSB7IGV4cG9ydHM6IHt9IH0sIEhbZ11bMF0uY2FsbChyLmV4cG9ydHMsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB5KEhbZ11bMV1bc10gfHwgcyk7XG4gICAgICAgICAgfSwgciwgci5leHBvcnRzLCB0LCBILCBDLCBtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ1tnXS5leHBvcnRzO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdSA9IHR5cGVvZiB4ciA9PSBcImZ1bmN0aW9uXCIgJiYgeHIsIGggPSAwOyBoIDwgbS5sZW5ndGg7IGgrKylcbiAgICAgICAgeShtW2hdKTtcbiAgICAgIHJldHVybiB5O1xuICAgIH0oeyAxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgQy5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaSA9IHIoaSksIG8gPSBpWzBdLCBpID0gaVsxXTtcbiAgICAgICAgcmV0dXJuIDMgKiAobyArIGkpIC8gNCAtIGk7XG4gICAgICB9LCBDLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgbywgaSwgbiA9IHIocyksIGwgPSBuWzBdLCBuID0gblsxXSwgYSA9IG5ldyB1KGZ1bmN0aW9uKGosIFQpIHtcbiAgICAgICAgICByZXR1cm4gMyAqIChqICsgVCkgLyA0IC0gVDtcbiAgICAgICAgfShsLCBuKSksIGMgPSAwLCBwID0gMCA8IG4gPyBsIC0gNCA6IGw7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwOyBpICs9IDQpXG4gICAgICAgICAgbyA9IHlbcy5jaGFyQ29kZUF0KGkpXSA8PCAxOCB8IHlbcy5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIgfCB5W3MuY2hhckNvZGVBdChpICsgMildIDw8IDYgfCB5W3MuY2hhckNvZGVBdChpICsgMyldLCBhW2MrK10gPSBvID4+IDE2ICYgMjU1LCBhW2MrK10gPSBvID4+IDggJiAyNTUsIGFbYysrXSA9IDI1NSAmIG87XG4gICAgICAgIHJldHVybiBuID09PSAyICYmIChvID0geVtzLmNoYXJDb2RlQXQoaSldIDw8IDIgfCB5W3MuY2hhckNvZGVBdChpICsgMSldID4+IDQsIGFbYysrXSA9IDI1NSAmIG8pLCBuID09PSAxICYmIChvID0geVtzLmNoYXJDb2RlQXQoaSldIDw8IDEwIHwgeVtzLmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0IHwgeVtzLmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyLCBhW2MrK10gPSBvID4+IDggJiAyNTUsIGFbYysrXSA9IDI1NSAmIG8pLCBhO1xuICAgICAgfSwgQy5mcm9tQnl0ZUFycmF5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICBmb3IgKHZhciBvLCBpID0gcy5sZW5ndGgsIGwgPSBpICUgMywgbiA9IFtdLCBhID0gMCwgYyA9IGkgLSBsOyBhIDwgYzsgYSArPSAxNjM4MylcbiAgICAgICAgICBuLnB1c2goZnVuY3Rpb24ocCwgaiwgVCkge1xuICAgICAgICAgICAgZm9yICh2YXIgXywgUyA9IFtdLCBFID0gajsgRSA8IFQ7IEUgKz0gMylcbiAgICAgICAgICAgICAgXyA9IChwW0VdIDw8IDE2ICYgMTY3MTE2ODApICsgKHBbRSArIDFdIDw8IDggJiA2NTI4MCkgKyAoMjU1ICYgcFtFICsgMl0pLCBTLnB1c2goZnVuY3Rpb24oQSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtW0EgPj4gMTggJiA2M10gKyBtW0EgPj4gMTIgJiA2M10gKyBtW0EgPj4gNiAmIDYzXSArIG1bNjMgJiBBXTtcbiAgICAgICAgICAgICAgfShfKSk7XG4gICAgICAgICAgICByZXR1cm4gUy5qb2luKFwiXCIpO1xuICAgICAgICAgIH0ocywgYSwgYyA8IGEgKyAxNjM4MyA/IGMgOiBhICsgMTYzODMpKTtcbiAgICAgICAgcmV0dXJuIGwgPT0gMSA/IChvID0gc1tpIC0gMV0sIG4ucHVzaChtW28gPj4gMl0gKyBtW28gPDwgNCAmIDYzXSArIFwiPT1cIikpIDogbCA9PSAyICYmIChvID0gKHNbaSAtIDJdIDw8IDgpICsgc1tpIC0gMV0sIG4ucHVzaChtW28gPj4gMTBdICsgbVtvID4+IDQgJiA2M10gKyBtW28gPDwgMiAmIDYzXSArIFwiPVwiKSksIG4uam9pbihcIlwiKTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBtID0gW10sIHkgPSBbXSwgdSA9IHR5cGVvZiBVaW50OEFycmF5IDwgXCJ1XCIgPyBVaW50OEFycmF5IDogQXJyYXksIGggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIiwgZyA9IDAsIGYgPSBoLmxlbmd0aDsgZyA8IGY7ICsrZylcbiAgICAgICAgbVtnXSA9IGhbZ10sIHlbaC5jaGFyQ29kZUF0KGcpXSA9IGc7XG4gICAgICBmdW5jdGlvbiByKHMpIHtcbiAgICAgICAgdmFyIG8gPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKDAgPCBvICUgNClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO1xuICAgICAgICByZXR1cm4gcyA9IHMuaW5kZXhPZihcIj1cIiksIG8gPSAocyA9IHMgPT09IC0xID8gbyA6IHMpID09PSBvID8gMCA6IDQgLSBzICUgNCwgW3MsIG9dO1xuICAgICAgfVxuICAgICAgeVs0NV0gPSA2MiwgeVs5NV0gPSA2MztcbiAgICB9LCB7fV0sIDI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgfSwge31dLCAzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgIH0sIHt9XSwgNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIChmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciB5ID0gdChcImJhc2U2NC1qc1wiKSwgdSA9IHQoXCJpZWVlNzU0XCIpLCBoID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT0gXCJmdW5jdGlvblwiID8gU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpIDogbnVsbCwgZyA9IChDLkJ1ZmZlciA9IHIsIEMuU2xvd0J1ZmZlciA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gK2IgIT0gYiAmJiAoYiA9IDApLCByLmFsbG9jKCtiKTtcbiAgICAgICAgfSwgQy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwLCAyMTQ3NDgzNjQ3KTtcbiAgICAgICAgZnVuY3Rpb24gZihiKSB7XG4gICAgICAgICAgaWYgKGcgPCBiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBiICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO1xuICAgICAgICAgIHJldHVybiBiID0gbmV3IFVpbnQ4QXJyYXkoYiksIE9iamVjdC5zZXRQcm90b3R5cGVPZihiLCByLnByb3RvdHlwZSksIGI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcihiLCBPLCBEKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gcyhiLCBPLCBEKTtcbiAgICAgICAgICBpZiAodHlwZW9mIE8gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7XG4gICAgICAgICAgcmV0dXJuIGkoYik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcyhiLCBPLCBEKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBCID0gYiwgWSA9IE87XG4gICAgICAgICAgICBpZiAoci5pc0VuY29kaW5nKFkgPSB0eXBlb2YgWSA9PSBcInN0cmluZ1wiICYmIFkgIT09IFwiXCIgPyBZIDogXCJ1dGY4XCIpKVxuICAgICAgICAgICAgICByZXR1cm4gSiA9IDAgfCBhKEIsIFkpLCB0ZSA9IGYoSiksIHRlID0gKEIgPSB0ZS53cml0ZShCLCBZKSkgIT09IEogPyB0ZS5zbGljZSgwLCBCKSA6IHRlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgWSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYikpXG4gICAgICAgICAgICByZXR1cm4gbChiKTtcbiAgICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoVyhiLCBBcnJheUJ1ZmZlcikgfHwgYiAmJiBXKGIuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgdmFyIEogPSBiLCBCID0gTywgdGUgPSBEO1xuICAgICAgICAgICAgICBpZiAoQiA8IDAgfHwgSi5ieXRlTGVuZ3RoIDwgQilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtcbiAgICAgICAgICAgICAgaWYgKEouYnl0ZUxlbmd0aCA8IEIgKyAodGUgfHwgMCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7XG4gICAgICAgICAgICAgIHJldHVybiBKID0gQiA9PT0gdm9pZCAwICYmIHRlID09PSB2b2lkIDAgPyBuZXcgVWludDhBcnJheShKKSA6IHRlID09PSB2b2lkIDAgPyBuZXcgVWludDhBcnJheShKLCBCKSA6IG5ldyBVaW50OEFycmF5KEosIEIsIHRlKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKEosIHIucHJvdG90eXBlKSwgSjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpO1xuICAgICAgICAgICAgaWYgKFkgPSBiLnZhbHVlT2YgJiYgYi52YWx1ZU9mKCksIFkgIT0gbnVsbCAmJiBZICE9PSBiKVxuICAgICAgICAgICAgICByZXR1cm4gci5mcm9tKFksIE8sIEQpO1xuICAgICAgICAgICAgdmFyIGNlID0gZnVuY3Rpb24ocmUpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB1ZSwgbGU7XG4gICAgICAgICAgICAgICAgaWYgKHIuaXNCdWZmZXIocmUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVlID0gMCB8IG4ocmUubGVuZ3RoKSwgKGxlID0gZih1ZSkpLmxlbmd0aCAhPT0gMCAmJiByZS5jb3B5KGxlLCAwLCAwLCB1ZSksIGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZS5sZW5ndGggIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlLmxlbmd0aCAhPSBcIm51bWJlclwiIHx8IFgocmUubGVuZ3RoKSA/IGYoMCkgOiBsKHJlKTtcbiAgICAgICAgICAgICAgaWYgKHJlLnR5cGUgPT09IFwiQnVmZmVyXCIgJiYgQXJyYXkuaXNBcnJheShyZS5kYXRhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbChyZS5kYXRhKTtcbiAgICAgICAgICAgIH0oYik7XG4gICAgICAgICAgICBpZiAoY2UpXG4gICAgICAgICAgICAgIHJldHVybiBjZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIGJbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgIHJldHVybiByLmZyb20oYltTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLCBPLCBEKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIGIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG8oYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpO1xuICAgICAgICAgIGlmIChiIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgYiArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpKGIpIHtcbiAgICAgICAgICByZXR1cm4gbyhiKSwgZihiIDwgMCA/IDAgOiAwIHwgbihiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbChiKSB7XG4gICAgICAgICAgZm9yICh2YXIgTyA9IGIubGVuZ3RoIDwgMCA/IDAgOiAwIHwgbihiLmxlbmd0aCksIEQgPSBmKE8pLCBCID0gMDsgQiA8IE87IEIgKz0gMSlcbiAgICAgICAgICAgIERbQl0gPSAyNTUgJiBiW0JdO1xuICAgICAgICAgIHJldHVybiBEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG4oYikge1xuICAgICAgICAgIGlmIChnIDw9IGIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIiArIGcudG9TdHJpbmcoMTYpICsgXCIgYnl0ZXNcIik7XG4gICAgICAgICAgcmV0dXJuIDAgfCBiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGEoYiwgTykge1xuICAgICAgICAgIGlmIChyLmlzQnVmZmVyKGIpKVxuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoO1xuICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYikgfHwgVyhiLCBBcnJheUJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gYi5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBiKTtcbiAgICAgICAgICB2YXIgRCA9IGIubGVuZ3RoLCBCID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdID09PSAhMDtcbiAgICAgICAgICBpZiAoIUIgJiYgRCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGZvciAodmFyIFkgPSAhMTsgOyApXG4gICAgICAgICAgICBzd2l0Y2ggKE8pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBEO1xuICAgICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVihiKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAqIEQ7XG4gICAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRCA+Pj4gMTtcbiAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBHKGIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoWSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBCID8gLTEgOiBWKGIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBPID0gKFwiXCIgKyBPKS50b0xvd2VyQ2FzZSgpLCBZID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYyhiLCBPLCBEKSB7XG4gICAgICAgICAgdmFyIEIsIFkgPSAhMTtcbiAgICAgICAgICBpZiAoKE8gPSBPID09PSB2b2lkIDAgfHwgTyA8IDAgPyAwIDogTykgPiB0aGlzLmxlbmd0aCB8fCAoRCA9IEQgPT09IHZvaWQgMCB8fCBEID4gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aCA6IEQpIDw9IDAgfHwgKEQgPj4+PSAwKSA8PSAoTyA+Pj49IDApKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgZm9yIChiID0gYiB8fCBcInV0ZjhcIjsgOyApXG4gICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgICAgIHZhciBKID0gdGhpcywgZmUgPSBPLCB0ZSA9IEQsIGxlID0gSi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgKCF0ZSB8fCB0ZSA8IDAgfHwgbGUgPCB0ZSkgJiYgKHRlID0gbGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNlID0gXCJcIiwgcmUgPSBmZSA9ICFmZSB8fCBmZSA8IDAgPyAwIDogZmU7IHJlIDwgdGU7ICsrcmUpXG4gICAgICAgICAgICAgICAgICBjZSArPSBuZVtKW3JlXV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlO1xuICAgICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRSh0aGlzLCBPLCBEKTtcbiAgICAgICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgICAgICAgdmFyIHVlID0gdGhpcywgbGUgPSBPLCBLID0gRCwgYWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIEsgPSBNYXRoLm1pbih1ZS5sZW5ndGgsIEspO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGhlID0gbGU7IGhlIDwgSzsgKytoZSlcbiAgICAgICAgICAgICAgICAgIGFlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3ICYgdWVbaGVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWU7XG4gICAgICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgIHZhciBfZSA9IHRoaXMsIGZlID0gTywgZ2UgPSBELCB4ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZ2UgPSBNYXRoLm1pbihfZS5sZW5ndGgsIGdlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBEZSA9IGZlOyBEZSA8IGdlOyArK0RlKVxuICAgICAgICAgICAgICAgICAgeGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShfZVtEZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB4ZTtcbiAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNZSA9IHRoaXMsIEIgPSBELCAoUWUgPSBPKSA9PT0gMCAmJiBCID09PSBNZS5sZW5ndGggPyB5LmZyb21CeXRlQXJyYXkoTWUpIDogeS5mcm9tQnl0ZUFycmF5KE1lLnNsaWNlKFFlLCBCKSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBNZSA9IE8sIFFlID0gRCwgemUgPSB0aGlzLnNsaWNlKE1lLCBRZSksIFZlID0gXCJcIiwgWGUgPSAwOyBYZSA8IHplLmxlbmd0aDsgWGUgKz0gMilcbiAgICAgICAgICAgICAgICAgIFZlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoemVbWGVdICsgMjU2ICogemVbWGUgKyAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChZKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgYik7XG4gICAgICAgICAgICAgICAgYiA9IChiICsgXCJcIikudG9Mb3dlckNhc2UoKSwgWSA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHAoYiwgTywgRCkge1xuICAgICAgICAgIHZhciBCID0gYltPXTtcbiAgICAgICAgICBiW09dID0gYltEXSwgYltEXSA9IEI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaihiLCBPLCBELCBCLCBZKSB7XG4gICAgICAgICAgaWYgKGIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICh0eXBlb2YgRCA9PSBcInN0cmluZ1wiID8gKEIgPSBELCBEID0gMCkgOiAyMTQ3NDgzNjQ3IDwgRCA/IEQgPSAyMTQ3NDgzNjQ3IDogRCA8IC0yMTQ3NDgzNjQ4ICYmIChEID0gLTIxNDc0ODM2NDgpLCAoRCA9IChEID0gWChEID0gK0QpID8gWSA/IDAgOiBiLmxlbmd0aCAtIDEgOiBEKSA8IDAgPyBiLmxlbmd0aCArIEQgOiBEKSA+PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKFkpXG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIEQgPSBiLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChEIDwgMCkge1xuICAgICAgICAgICAgaWYgKCFZKVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBEID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBPID09IFwic3RyaW5nXCIgJiYgKE8gPSByLmZyb20oTywgQikpLCByLmlzQnVmZmVyKE8pKVxuICAgICAgICAgICAgcmV0dXJuIE8ubGVuZ3RoID09PSAwID8gLTEgOiBUKGIsIE8sIEQsIEIsIFkpO1xuICAgICAgICAgIGlmICh0eXBlb2YgTyA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIE8gJj0gMjU1LCB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PSBcImZ1bmN0aW9uXCIgPyAoWSA/IFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgOiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZikuY2FsbChiLCBPLCBEKSA6IFQoYiwgW09dLCBELCBCLCBZKTtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFQoYiwgTywgRCwgQiwgWSkge1xuICAgICAgICAgIHZhciBKID0gMSwgdGUgPSBiLmxlbmd0aCwgY2UgPSBPLmxlbmd0aDtcbiAgICAgICAgICBpZiAoQiAhPT0gdm9pZCAwICYmICgoQiA9IFN0cmluZyhCKS50b0xvd2VyQ2FzZSgpKSA9PT0gXCJ1Y3MyXCIgfHwgQiA9PT0gXCJ1Y3MtMlwiIHx8IEIgPT09IFwidXRmMTZsZVwiIHx8IEIgPT09IFwidXRmLTE2bGVcIikpIHtcbiAgICAgICAgICAgIGlmIChiLmxlbmd0aCA8IDIgfHwgTy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB0ZSAvPSBKID0gMiwgY2UgLz0gMiwgRCAvPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZShoZSwgX2UpIHtcbiAgICAgICAgICAgIHJldHVybiBKID09PSAxID8gaGVbX2VdIDogaGUucmVhZFVJbnQxNkJFKF9lICogSik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChZKVxuICAgICAgICAgICAgZm9yICh2YXIgdWUgPSAtMSwgbGUgPSBEOyBsZSA8IHRlOyBsZSsrKVxuICAgICAgICAgICAgICBpZiAocmUoYiwgbGUpID09PSByZShPLCB1ZSA9PT0gLTEgPyAwIDogbGUgLSB1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGUgLSAodWUgPSB1ZSA9PT0gLTEgPyBsZSA6IHVlKSArIDEgPT09IGNlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVlICogSjtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdWUgIT09IC0xICYmIChsZSAtPSBsZSAtIHVlKSwgdWUgPSAtMTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxlID0gRCA9IHRlIDwgRCArIGNlID8gdGUgLSBjZSA6IEQ7IDAgPD0gbGU7IGxlLS0pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgSyA9ICEwLCBhZSA9IDA7IGFlIDwgY2U7IGFlKyspXG4gICAgICAgICAgICAgICAgaWYgKHJlKGIsIGxlICsgYWUpICE9PSByZShPLCBhZSkpIHtcbiAgICAgICAgICAgICAgICAgIEsgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKEspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfKGIsIE8sIEQsIEIpIHtcbiAgICAgICAgICByZXR1cm4gVShmdW5jdGlvbihZKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBKID0gW10sIHRlID0gMDsgdGUgPCBZLmxlbmd0aDsgKyt0ZSlcbiAgICAgICAgICAgICAgSi5wdXNoKDI1NSAmIFkuY2hhckNvZGVBdCh0ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIEo7XG4gICAgICAgICAgfShPKSwgYiwgRCwgQik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gUyhiLCBPLCBELCBCKSB7XG4gICAgICAgICAgcmV0dXJuIFUoZnVuY3Rpb24oWSwgSikge1xuICAgICAgICAgICAgZm9yICh2YXIgdGUsIGNlLCByZSA9IFtdLCB1ZSA9IDA7IHVlIDwgWS5sZW5ndGggJiYgISgoSiAtPSAyKSA8IDApOyArK3VlKVxuICAgICAgICAgICAgICBjZSA9IFkuY2hhckNvZGVBdCh1ZSksIHRlID0gY2UgPj4gOCwgY2UgPSBjZSAlIDI1NiwgcmUucHVzaChjZSksIHJlLnB1c2godGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICAgIH0oTywgYi5sZW5ndGggLSBEKSwgYiwgRCwgQik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gRShiLCBPLCBEKSB7XG4gICAgICAgICAgRCA9IE1hdGgubWluKGIubGVuZ3RoLCBEKTtcbiAgICAgICAgICBmb3IgKHZhciBCID0gW10sIFkgPSBPOyBZIDwgRDsgKSB7XG4gICAgICAgICAgICB2YXIgSiwgdGUsIGNlLCByZSwgdWUgPSBiW1ldLCBsZSA9IG51bGwsIEsgPSAyMzkgPCB1ZSA/IDQgOiAyMjMgPCB1ZSA/IDMgOiAxOTEgPCB1ZSA/IDIgOiAxO1xuICAgICAgICAgICAgaWYgKFkgKyBLIDw9IEQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoSykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHVlIDwgMTI4ICYmIChsZSA9IHVlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICgxOTIgJiAoSiA9IGJbWSArIDFdKSkgPT0gMTI4ICYmIDEyNyA8IChyZSA9ICgzMSAmIHVlKSA8PCA2IHwgNjMgJiBKKSAmJiAobGUgPSByZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBKID0gYltZICsgMV0sIHRlID0gYltZICsgMl0sICgxOTIgJiBKKSA9PSAxMjggJiYgKDE5MiAmIHRlKSA9PSAxMjggJiYgMjA0NyA8IChyZSA9ICgxNSAmIHVlKSA8PCAxMiB8ICg2MyAmIEopIDw8IDYgfCA2MyAmIHRlKSAmJiAocmUgPCA1NTI5NiB8fCA1NzM0MyA8IHJlKSAmJiAobGUgPSByZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICBKID0gYltZICsgMV0sIHRlID0gYltZICsgMl0sIGNlID0gYltZICsgM10sICgxOTIgJiBKKSA9PSAxMjggJiYgKDE5MiAmIHRlKSA9PSAxMjggJiYgKDE5MiAmIGNlKSA9PSAxMjggJiYgNjU1MzUgPCAocmUgPSAoMTUgJiB1ZSkgPDwgMTggfCAoNjMgJiBKKSA8PCAxMiB8ICg2MyAmIHRlKSA8PCA2IHwgNjMgJiBjZSkgJiYgcmUgPCAxMTE0MTEyICYmIChsZSA9IHJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGUgPT09IG51bGwgPyAobGUgPSA2NTUzMywgSyA9IDEpIDogNjU1MzUgPCBsZSAmJiAobGUgLT0gNjU1MzYsIEIucHVzaChsZSA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpLCBsZSA9IDU2MzIwIHwgMTAyMyAmIGxlKSwgQi5wdXNoKGxlKSwgWSArPSBLO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWUgPSBCLCBoZSA9IGFlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaGUgPD0gQSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYWUpO1xuICAgICAgICAgIGZvciAodmFyIF9lID0gXCJcIiwgZmUgPSAwOyBmZSA8IGhlOyApXG4gICAgICAgICAgICBfZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYWUuc2xpY2UoZmUsIGZlICs9IEEpKTtcbiAgICAgICAgICByZXR1cm4gX2U7XG4gICAgICAgIH1cbiAgICAgICAgQy5rTWF4TGVuZ3RoID0gZywgKHIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KDEpLCBPID0geyBmb286IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gNDI7XG4gICAgICAgICAgICB9IH07XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKGIsIE8pLCBiLmZvbygpID09PSA0MjtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKSkgfHwgdHlwZW9mIGNvbnNvbGUgPiBcInVcIiB8fCB0eXBlb2YgY29uc29sZS5lcnJvciAhPSBcImZ1bmN0aW9uXCIgfHwgY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLCBcInBhcmVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChyLmlzQnVmZmVyKHRoaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgICB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHIuaXNCdWZmZXIodGhpcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICB9IH0pLCB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJiByW1N5bWJvbC5zcGVjaWVzXSA9PT0gciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgU3ltYm9sLnNwZWNpZXMsIHsgdmFsdWU6IG51bGwsIGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITEgfSksIHIucG9vbFNpemUgPSA4MTkyLCByLmZyb20gPSBzLCBPYmplY3Quc2V0UHJvdG90eXBlT2Yoci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsIFVpbnQ4QXJyYXkpLCByLmFsbG9jID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBPID0gTywgRCA9IEQsIG8oYiA9IGIpLCAhKGIgPD0gMCkgJiYgTyAhPT0gdm9pZCAwID8gdHlwZW9mIEQgPT0gXCJzdHJpbmdcIiA/IGYoYikuZmlsbChPLCBEKSA6IGYoYikuZmlsbChPKSA6IGYoYik7XG4gICAgICAgIH0sIHIuYWxsb2NVbnNhZmUgPSBpLCByLmFsbG9jVW5zYWZlU2xvdyA9IGksIHIuaXNCdWZmZXIgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gITAgJiYgYiAhPT0gci5wcm90b3R5cGU7XG4gICAgICAgIH0sIHIuY29tcGFyZSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICBpZiAoVyhiLCBVaW50OEFycmF5KSAmJiAoYiA9IHIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKSksIFcoTywgVWludDhBcnJheSkgJiYgKE8gPSByLmZyb20oTywgTy5vZmZzZXQsIE8uYnl0ZUxlbmd0aCkpLCAhci5pc0J1ZmZlcihiKSB8fCAhci5pc0J1ZmZlcihPKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICBpZiAoYiA9PT0gTylcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGZvciAodmFyIEQgPSBiLmxlbmd0aCwgQiA9IE8ubGVuZ3RoLCBZID0gMCwgSiA9IE1hdGgubWluKEQsIEIpOyBZIDwgSjsgKytZKVxuICAgICAgICAgICAgaWYgKGJbWV0gIT09IE9bWV0pIHtcbiAgICAgICAgICAgICAgRCA9IGJbWV0sIEIgPSBPW1ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gRCA8IEIgPyAtMSA6IEIgPCBEID8gMSA6IDA7XG4gICAgICAgIH0sIHIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBzd2l0Y2ggKFN0cmluZyhiKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgci5jb25jYXQgPSBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICAgICAgaWYgKGIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHIuYWxsb2MoMCk7XG4gICAgICAgICAgaWYgKE8gPT09IHZvaWQgMClcbiAgICAgICAgICAgIGZvciAoWSA9IE8gPSAwOyBZIDwgYi5sZW5ndGg7ICsrWSlcbiAgICAgICAgICAgICAgTyArPSBiW1ldLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBEID0gci5hbGxvY1Vuc2FmZShPKSwgQiA9IDAsIFkgPSAwOyBZIDwgYi5sZW5ndGg7ICsrWSkge1xuICAgICAgICAgICAgdmFyIEogPSBiW1ldO1xuICAgICAgICAgICAgaWYgKFcoSiwgVWludDhBcnJheSkgJiYgKEogPSByLmZyb20oSikpLCAhci5pc0J1ZmZlcihKKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICAgICAgICBKLmNvcHkoRCwgQiksIEIgKz0gSi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBEO1xuICAgICAgICB9LCByLmJ5dGVMZW5ndGggPSBhLCByLnByb3RvdHlwZS5faXNCdWZmZXIgPSAhMCwgci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYiAlIDIgIT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7XG4gICAgICAgICAgZm9yICh2YXIgTyA9IDA7IE8gPCBiOyBPICs9IDIpXG4gICAgICAgICAgICBwKHRoaXMsIE8sIE8gKyAxKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYiAlIDQgIT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7XG4gICAgICAgICAgZm9yICh2YXIgTyA9IDA7IE8gPCBiOyBPICs9IDQpXG4gICAgICAgICAgICBwKHRoaXMsIE8sIE8gKyAzKSwgcCh0aGlzLCBPICsgMSwgTyArIDIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChiICUgOCAhPSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtcbiAgICAgICAgICBmb3IgKHZhciBPID0gMDsgTyA8IGI7IE8gKz0gOClcbiAgICAgICAgICAgIHAodGhpcywgTywgTyArIDcpLCBwKHRoaXMsIE8gKyAxLCBPICsgNiksIHAodGhpcywgTyArIDIsIE8gKyA1KSwgcCh0aGlzLCBPICsgMywgTyArIDQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IHIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IFwiXCIgOiBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gRSh0aGlzLCAwLCBiKSA6IGMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgIGlmIChyLmlzQnVmZmVyKGIpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGIgfHwgci5jb21wYXJlKHRoaXMsIGIpID09PSAwO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIE8gPSBcIlwiLCBiID0gQy5JTlNQRUNUX01BWF9CWVRFUywgTyA9IHRoaXMudG9TdHJpbmcoXCJoZXhcIiwgMCwgYikucmVwbGFjZSgvKC57Mn0pL2csIFwiJDEgXCIpLnRyaW0oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBiICYmIChPICs9IFwiIC4uLiBcIiksIFwiPEJ1ZmZlciBcIiArIE8gKyBcIj5cIjtcbiAgICAgICAgfSwgaCAmJiAoci5wcm90b3R5cGVbaF0gPSByLnByb3RvdHlwZS5pbnNwZWN0KSwgci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKGIsIE8sIEQsIEIsIFkpIHtcbiAgICAgICAgICBpZiAoVyhiLCBVaW50OEFycmF5KSAmJiAoYiA9IHIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKSksICFyLmlzQnVmZmVyKGIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGIpO1xuICAgICAgICAgIGlmIChEID09PSB2b2lkIDAgJiYgKEQgPSBiID8gYi5sZW5ndGggOiAwKSwgQiA9PT0gdm9pZCAwICYmIChCID0gMCksIFkgPT09IHZvaWQgMCAmJiAoWSA9IHRoaXMubGVuZ3RoKSwgKE8gPSBPID09PSB2b2lkIDAgPyAwIDogTykgPCAwIHx8IEQgPiBiLmxlbmd0aCB8fCBCIDwgMCB8fCBZID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgICAgICBpZiAoWSA8PSBCICYmIEQgPD0gTylcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGlmIChZIDw9IEIpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKEQgPD0gTylcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIGlmICh0aGlzID09PSBiKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgZm9yICh2YXIgSiA9IChZID4+Pj0gMCkgLSAoQiA+Pj49IDApLCB0ZSA9IChEID4+Pj0gMCkgLSAoTyA+Pj49IDApLCBjZSA9IE1hdGgubWluKEosIHRlKSwgcmUgPSB0aGlzLnNsaWNlKEIsIFkpLCB1ZSA9IGIuc2xpY2UoTywgRCksIGxlID0gMDsgbGUgPCBjZTsgKytsZSlcbiAgICAgICAgICAgIGlmIChyZVtsZV0gIT09IHVlW2xlXSkge1xuICAgICAgICAgICAgICBKID0gcmVbbGVdLCB0ZSA9IHVlW2xlXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEogPCB0ZSA/IC0xIDogdGUgPCBKID8gMSA6IDA7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoYiwgTywgRCkgIT09IC0xO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBqKHRoaXMsIGIsIE8sIEQsICEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIGoodGhpcywgYiwgTywgRCwgITEpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGIsIE8sIEQsIEIpIHtcbiAgICAgICAgICBpZiAoTyA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgQiA9IFwidXRmOFwiLCBEID0gdGhpcy5sZW5ndGgsIE8gPSAwO1xuICAgICAgICAgIGVsc2UgaWYgKEQgPT09IHZvaWQgMCAmJiB0eXBlb2YgTyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgQiA9IE8sIEQgPSB0aGlzLmxlbmd0aCwgTyA9IDA7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKE8pKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIE8gPj4+PSAwLCBpc0Zpbml0ZShEKSA/IChEID4+Pj0gMCwgQiA9PT0gdm9pZCAwICYmIChCID0gXCJ1dGY4XCIpKSA6IChCID0gRCwgRCA9IHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBZID0gdGhpcy5sZW5ndGggLSBPO1xuICAgICAgICAgIGlmICgoRCA9PT0gdm9pZCAwIHx8IFkgPCBEKSAmJiAoRCA9IFkpLCAwIDwgYi5sZW5ndGggJiYgKEQgPCAwIHx8IE8gPCAwKSB8fCBPID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO1xuICAgICAgICAgIEIgPSBCIHx8IFwidXRmOFwiO1xuICAgICAgICAgIGZvciAodmFyIEosIHRlLCBjZSwgcmUgPSAhMTsgOyApXG4gICAgICAgICAgICBzd2l0Y2ggKEIpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgICAgIHZhciB1ZSA9IHRoaXMsIGxlID0gYiwgSyA9IE8sIGFlID0gRCwgaGUgPSAoSyA9IE51bWJlcihLKSB8fCAwLCB1ZS5sZW5ndGggLSBLKTtcbiAgICAgICAgICAgICAgICAoIWFlIHx8IGhlIDwgKGFlID0gTnVtYmVyKGFlKSkpICYmIChhZSA9IGhlKSwgKGhlID0gbGUubGVuZ3RoKSAvIDIgPCBhZSAmJiAoYWUgPSBoZSAvIDIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gMDsgX2UgPCBhZTsgKytfZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZlID0gcGFyc2VJbnQobGUuc3Vic3RyKDIgKiBfZSwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgIGlmIChYKGZlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lO1xuICAgICAgICAgICAgICAgICAgdWVbSyArIF9lXSA9IGZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2U7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBoZSA9IE8sIGNlID0gRCwgVShWKGIsICh0ZSA9IHRoaXMpLmxlbmd0aCAtIGhlKSwgdGUsIGhlLCBjZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfKHRoaXMsIGIsIE8sIEQpO1xuICAgICAgICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXyh0aGlzLCBiLCBPLCBEKTtcbiAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZSA9IHRoaXMsIGNlID0gTywgSiA9IEQsIFUoRyhiKSwgdGUsIGNlLCBKKTtcbiAgICAgICAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTKHRoaXMsIGIsIE8sIEQpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIEIpO1xuICAgICAgICAgICAgICAgIEIgPSAoXCJcIiArIEIpLnRvTG93ZXJDYXNlKCksIHJlID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQnVmZmVyXCIsIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgQSA9IDQwOTY7XG4gICAgICAgIGZ1bmN0aW9uIHgoYiwgTywgRCkge1xuICAgICAgICAgIGlmIChiICUgMSAhPSAwIHx8IGIgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7XG4gICAgICAgICAgaWYgKEQgPCBiICsgTylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBQKGIsIE8sIEQsIEIsIFksIEopIHtcbiAgICAgICAgICBpZiAoIXIuaXNCdWZmZXIoYikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICAgICAgICBpZiAoWSA8IE8gfHwgTyA8IEopXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgICBpZiAoRCArIEIgPiBiLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE0oYiwgTywgRCwgQikge1xuICAgICAgICAgIGlmIChEICsgQiA+IGIubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgICAgaWYgKEQgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gUihiLCBPLCBELCBCLCBZKSB7XG4gICAgICAgICAgcmV0dXJuIE8gPSArTywgRCA+Pj49IDAsIFkgfHwgTShiLCAwLCBELCA0KSwgdS53cml0ZShiLCBPLCBELCBCLCAyMywgNCksIEQgKyA0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEwoYiwgTywgRCwgQiwgWSkge1xuICAgICAgICAgIHJldHVybiBPID0gK08sIEQgPj4+PSAwLCBZIHx8IE0oYiwgMCwgRCwgOCksIHUud3JpdGUoYiwgTywgRCwgQiwgNTIsIDgpLCBEICsgODtcbiAgICAgICAgfVxuICAgICAgICByLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICB2YXIgRCA9IHRoaXMubGVuZ3RoLCBEID0gKChiID0gfn5iKSA8IDAgPyAoYiArPSBEKSA8IDAgJiYgKGIgPSAwKSA6IEQgPCBiICYmIChiID0gRCksIChPID0gTyA9PT0gdm9pZCAwID8gRCA6IH5+TykgPCAwID8gKE8gKz0gRCkgPCAwICYmIChPID0gMCkgOiBEIDwgTyAmJiAoTyA9IEQpLCBPIDwgYiAmJiAoTyA9IGIpLCB0aGlzLnN1YmFycmF5KGIsIE8pKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKEQsIHIucHJvdG90eXBlKSwgRDtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICBiID4+Pj0gMCwgTyA+Pj49IDAsIEQgfHwgeChiLCBPLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgQiA9IHRoaXNbYl0sIFkgPSAxLCBKID0gMDsgKytKIDwgTyAmJiAoWSAqPSAyNTYpOyApXG4gICAgICAgICAgICBCICs9IHRoaXNbYiArIEpdICogWTtcbiAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICBiID4+Pj0gMCwgTyA+Pj49IDAsIEQgfHwgeChiLCBPLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgQiA9IHRoaXNbYiArIC0tT10sIFkgPSAxOyAwIDwgTyAmJiAoWSAqPSAyNTYpOyApXG4gICAgICAgICAgICBCICs9IHRoaXNbYiArIC0tT10gKiBZO1xuICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPj4+PSAwLCBPIHx8IHgoYiwgMSwgdGhpcy5sZW5ndGgpLCB0aGlzW2JdO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPj4+PSAwLCBPIHx8IHgoYiwgMiwgdGhpcy5sZW5ndGgpLCB0aGlzW2JdIHwgdGhpc1tiICsgMV0gPDwgODtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDIsIHRoaXMubGVuZ3RoKSwgdGhpc1tiXSA8PCA4IHwgdGhpc1tiICsgMV07XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICByZXR1cm4gYiA+Pj49IDAsIE8gfHwgeChiLCA0LCB0aGlzLmxlbmd0aCksICh0aGlzW2JdIHwgdGhpc1tiICsgMV0gPDwgOCB8IHRoaXNbYiArIDJdIDw8IDE2KSArIDE2Nzc3MjE2ICogdGhpc1tiICsgM107XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICByZXR1cm4gYiA+Pj49IDAsIE8gfHwgeChiLCA0LCB0aGlzLmxlbmd0aCksIDE2Nzc3MjE2ICogdGhpc1tiXSArICh0aGlzW2IgKyAxXSA8PCAxNiB8IHRoaXNbYiArIDJdIDw8IDggfCB0aGlzW2IgKyAzXSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICBiID4+Pj0gMCwgTyA+Pj49IDAsIEQgfHwgeChiLCBPLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgQiA9IHRoaXNbYl0sIFkgPSAxLCBKID0gMDsgKytKIDwgTyAmJiAoWSAqPSAyNTYpOyApXG4gICAgICAgICAgICBCICs9IHRoaXNbYiArIEpdICogWTtcbiAgICAgICAgICByZXR1cm4gKFkgKj0gMTI4KSA8PSBCICYmIChCIC09IE1hdGgucG93KDIsIDggKiBPKSksIEI7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICBiID4+Pj0gMCwgTyA+Pj49IDAsIEQgfHwgeChiLCBPLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgQiA9IE8sIFkgPSAxLCBKID0gdGhpc1tiICsgLS1CXTsgMCA8IEIgJiYgKFkgKj0gMjU2KTsgKVxuICAgICAgICAgICAgSiArPSB0aGlzW2IgKyAtLUJdICogWTtcbiAgICAgICAgICByZXR1cm4gKFkgKj0gMTI4KSA8PSBKICYmIChKIC09IE1hdGgucG93KDIsIDggKiBPKSksIEo7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDEsIHRoaXMubGVuZ3RoKSwgMTI4ICYgdGhpc1tiXSA/IC0xICogKDI1NSAtIHRoaXNbYl0gKyAxKSA6IHRoaXNbYl07XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDIsIHRoaXMubGVuZ3RoKSwgTyA9IHRoaXNbYl0gfCB0aGlzW2IgKyAxXSA8PCA4LCAzMjc2OCAmIE8gPyA0Mjk0OTAxNzYwIHwgTyA6IE87XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDIsIHRoaXMubGVuZ3RoKSwgTyA9IHRoaXNbYiArIDFdIHwgdGhpc1tiXSA8PCA4LCAzMjc2OCAmIE8gPyA0Mjk0OTAxNzYwIHwgTyA6IE87XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDQsIHRoaXMubGVuZ3RoKSwgdGhpc1tiXSB8IHRoaXNbYiArIDFdIDw8IDggfCB0aGlzW2IgKyAyXSA8PCAxNiB8IHRoaXNbYiArIDNdIDw8IDI0O1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICByZXR1cm4gYiA+Pj49IDAsIE8gfHwgeChiLCA0LCB0aGlzLmxlbmd0aCksIHRoaXNbYl0gPDwgMjQgfCB0aGlzW2IgKyAxXSA8PCAxNiB8IHRoaXNbYiArIDJdIDw8IDggfCB0aGlzW2IgKyAzXTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPj4+PSAwLCBPIHx8IHgoYiwgNCwgdGhpcy5sZW5ndGgpLCB1LnJlYWQodGhpcywgYiwgITAsIDIzLCA0KTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPj4+PSAwLCBPIHx8IHgoYiwgNCwgdGhpcy5sZW5ndGgpLCB1LnJlYWQodGhpcywgYiwgITEsIDIzLCA0KTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiID4+Pj0gMCwgTyB8fCB4KGIsIDgsIHRoaXMubGVuZ3RoKSwgdS5yZWFkKHRoaXMsIGIsICEwLCA1MiwgOCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICByZXR1cm4gYiA+Pj49IDAsIE8gfHwgeChiLCA4LCB0aGlzLmxlbmd0aCksIHUucmVhZCh0aGlzLCBiLCAhMSwgNTIsIDgpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uKGIsIE8sIEQsIEIpIHtcbiAgICAgICAgICBiID0gK2IsIE8gPj4+PSAwLCBEID4+Pj0gMCwgQiB8fCBQKHRoaXMsIGIsIE8sIEQsIE1hdGgucG93KDIsIDggKiBEKSAtIDEsIDApO1xuICAgICAgICAgIHZhciBZID0gMSwgSiA9IDA7XG4gICAgICAgICAgZm9yICh0aGlzW09dID0gMjU1ICYgYjsgKytKIDwgRCAmJiAoWSAqPSAyNTYpOyApXG4gICAgICAgICAgICB0aGlzW08gKyBKXSA9IGIgLyBZICYgMjU1O1xuICAgICAgICAgIHJldHVybiBPICsgRDtcbiAgICAgICAgfSwgci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbihiLCBPLCBELCBCKSB7XG4gICAgICAgICAgYiA9ICtiLCBPID4+Pj0gMCwgRCA+Pj49IDAsIEIgfHwgUCh0aGlzLCBiLCBPLCBELCBNYXRoLnBvdygyLCA4ICogRCkgLSAxLCAwKTtcbiAgICAgICAgICB2YXIgWSA9IEQgLSAxLCBKID0gMTtcbiAgICAgICAgICBmb3IgKHRoaXNbTyArIFldID0gMjU1ICYgYjsgMCA8PSAtLVkgJiYgKEogKj0gMjU2KTsgKVxuICAgICAgICAgICAgdGhpc1tPICsgWV0gPSBiIC8gSiAmIDI1NTtcbiAgICAgICAgICByZXR1cm4gTyArIEQ7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPSArYiwgTyA+Pj49IDAsIEQgfHwgUCh0aGlzLCBiLCBPLCAxLCAyNTUsIDApLCB0aGlzW09dID0gMjU1ICYgYiwgTyArIDE7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPSArYiwgTyA+Pj49IDAsIEQgfHwgUCh0aGlzLCBiLCBPLCAyLCA2NTUzNSwgMCksIHRoaXNbT10gPSAyNTUgJiBiLCB0aGlzW08gKyAxXSA9IGIgPj4+IDgsIE8gKyAyO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBiID0gK2IsIE8gPj4+PSAwLCBEIHx8IFAodGhpcywgYiwgTywgMiwgNjU1MzUsIDApLCB0aGlzW09dID0gYiA+Pj4gOCwgdGhpc1tPICsgMV0gPSAyNTUgJiBiLCBPICsgMjtcbiAgICAgICAgfSwgci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gYiA9ICtiLCBPID4+Pj0gMCwgRCB8fCBQKHRoaXMsIGIsIE8sIDQsIDQyOTQ5NjcyOTUsIDApLCB0aGlzW08gKyAzXSA9IGIgPj4+IDI0LCB0aGlzW08gKyAyXSA9IGIgPj4+IDE2LCB0aGlzW08gKyAxXSA9IGIgPj4+IDgsIHRoaXNbT10gPSAyNTUgJiBiLCBPICsgNDtcbiAgICAgICAgfSwgci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gYiA9ICtiLCBPID4+Pj0gMCwgRCB8fCBQKHRoaXMsIGIsIE8sIDQsIDQyOTQ5NjcyOTUsIDApLCB0aGlzW09dID0gYiA+Pj4gMjQsIHRoaXNbTyArIDFdID0gYiA+Pj4gMTYsIHRoaXNbTyArIDJdID0gYiA+Pj4gOCwgdGhpc1tPICsgM10gPSAyNTUgJiBiLCBPICsgNDtcbiAgICAgICAgfSwgci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uKGIsIE8sIEQsIEIpIHtcbiAgICAgICAgICBiID0gK2IsIE8gPj4+PSAwLCBCIHx8IFAodGhpcywgYiwgTywgRCwgKEIgPSBNYXRoLnBvdygyLCA4ICogRCAtIDEpKSAtIDEsIC1CKTtcbiAgICAgICAgICB2YXIgWSA9IDAsIEogPSAxLCB0ZSA9IDA7XG4gICAgICAgICAgZm9yICh0aGlzW09dID0gMjU1ICYgYjsgKytZIDwgRCAmJiAoSiAqPSAyNTYpOyApXG4gICAgICAgICAgICBiIDwgMCAmJiB0ZSA9PT0gMCAmJiB0aGlzW08gKyBZIC0gMV0gIT09IDAgJiYgKHRlID0gMSksIHRoaXNbTyArIFldID0gKGIgLyBKID4+IDApIC0gdGUgJiAyNTU7XG4gICAgICAgICAgcmV0dXJuIE8gKyBEO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24oYiwgTywgRCwgQikge1xuICAgICAgICAgIGIgPSArYiwgTyA+Pj49IDAsIEIgfHwgUCh0aGlzLCBiLCBPLCBELCAoQiA9IE1hdGgucG93KDIsIDggKiBEIC0gMSkpIC0gMSwgLUIpO1xuICAgICAgICAgIHZhciBZID0gRCAtIDEsIEogPSAxLCB0ZSA9IDA7XG4gICAgICAgICAgZm9yICh0aGlzW08gKyBZXSA9IDI1NSAmIGI7IDAgPD0gLS1ZICYmIChKICo9IDI1Nik7IClcbiAgICAgICAgICAgIGIgPCAwICYmIHRlID09PSAwICYmIHRoaXNbTyArIFkgKyAxXSAhPT0gMCAmJiAodGUgPSAxKSwgdGhpc1tPICsgWV0gPSAoYiAvIEogPj4gMCkgLSB0ZSAmIDI1NTtcbiAgICAgICAgICByZXR1cm4gTyArIEQ7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gYiA9ICtiLCBPID4+Pj0gMCwgRCB8fCBQKHRoaXMsIGIsIE8sIDEsIDEyNywgLTEyOCksIHRoaXNbT10gPSAyNTUgJiAoYiA9IGIgPCAwID8gMjU1ICsgYiArIDEgOiBiKSwgTyArIDE7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gYiA9ICtiLCBPID4+Pj0gMCwgRCB8fCBQKHRoaXMsIGIsIE8sIDIsIDMyNzY3LCAtMzI3NjgpLCB0aGlzW09dID0gMjU1ICYgYiwgdGhpc1tPICsgMV0gPSBiID4+PiA4LCBPICsgMjtcbiAgICAgICAgfSwgci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBiID0gK2IsIE8gPj4+PSAwLCBEIHx8IFAodGhpcywgYiwgTywgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbT10gPSBiID4+PiA4LCB0aGlzW08gKyAxXSA9IDI1NSAmIGIsIE8gKyAyO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPSArYiwgTyA+Pj49IDAsIEQgfHwgUCh0aGlzLCBiLCBPLCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksIHRoaXNbT10gPSAyNTUgJiBiLCB0aGlzW08gKyAxXSA9IGIgPj4+IDgsIHRoaXNbTyArIDJdID0gYiA+Pj4gMTYsIHRoaXNbTyArIDNdID0gYiA+Pj4gMjQsIE8gKyA0O1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIGIgPSArYiwgTyA+Pj49IDAsIEQgfHwgUCh0aGlzLCBiLCBPLCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksIHRoaXNbT10gPSAoYiA9IGIgPCAwID8gNDI5NDk2NzI5NSArIGIgKyAxIDogYikgPj4+IDI0LCB0aGlzW08gKyAxXSA9IGIgPj4+IDE2LCB0aGlzW08gKyAyXSA9IGIgPj4+IDgsIHRoaXNbTyArIDNdID0gMjU1ICYgYiwgTyArIDQ7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gUih0aGlzLCBiLCBPLCAhMCwgRCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKGIsIE8sIEQpIHtcbiAgICAgICAgICByZXR1cm4gUih0aGlzLCBiLCBPLCAhMSwgRCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIEwodGhpcywgYiwgTywgITAsIEQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBMKHRoaXMsIGIsIE8sICExLCBEKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGIsIE8sIEQsIEIpIHtcbiAgICAgICAgICBpZiAoIXIuaXNCdWZmZXIoYikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO1xuICAgICAgICAgIGlmIChEID0gRCB8fCAwLCBCIHx8IEIgPT09IDAgfHwgKEIgPSB0aGlzLmxlbmd0aCksIE8gPj0gYi5sZW5ndGggJiYgKE8gPSBiLmxlbmd0aCksIChCID0gMCA8IEIgJiYgQiA8IEQgPyBEIDogQikgPT09IEQgfHwgYi5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBpZiAoKE8gPSBPIHx8IDApIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICBpZiAoRCA8IDAgfHwgRCA+PSB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICAgIGlmIChCIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgICAgQiA+IHRoaXMubGVuZ3RoICYmIChCID0gdGhpcy5sZW5ndGgpO1xuICAgICAgICAgIHZhciBZID0gKEIgPSBiLmxlbmd0aCAtIE8gPCBCIC0gRCA/IGIubGVuZ3RoIC0gTyArIEQgOiBCKSAtIEQ7XG4gICAgICAgICAgaWYgKHRoaXMgPT09IGIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdGhpcy5jb3B5V2l0aGluKE8sIEQsIEIpO1xuICAgICAgICAgIGVsc2UgaWYgKHRoaXMgPT09IGIgJiYgRCA8IE8gJiYgTyA8IEIpXG4gICAgICAgICAgICBmb3IgKHZhciBKID0gWSAtIDE7IDAgPD0gSjsgLS1KKVxuICAgICAgICAgICAgICBiW0ogKyBPXSA9IHRoaXNbSiArIERdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGIsIHRoaXMuc3ViYXJyYXkoRCwgQiksIE8pO1xuICAgICAgICAgIHJldHVybiBZO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oYiwgTywgRCwgQikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIE8gPT0gXCJzdHJpbmdcIiA/IChCID0gTywgTyA9IDAsIEQgPSB0aGlzLmxlbmd0aCkgOiB0eXBlb2YgRCA9PSBcInN0cmluZ1wiICYmIChCID0gRCwgRCA9IHRoaXMubGVuZ3RoKSwgQiAhPT0gdm9pZCAwICYmIHR5cGVvZiBCICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBCID09IFwic3RyaW5nXCIgJiYgIXIuaXNFbmNvZGluZyhCKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgQik7XG4gICAgICAgICAgICB2YXIgWTtcbiAgICAgICAgICAgIGIubGVuZ3RoID09PSAxICYmIChZID0gYi5jaGFyQ29kZUF0KDApLCAoQiA9PT0gXCJ1dGY4XCIgJiYgWSA8IDEyOCB8fCBCID09PSBcImxhdGluMVwiKSAmJiAoYiA9IFkpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHR5cGVvZiBiID09IFwibnVtYmVyXCIgPyBiICY9IDI1NSA6IHR5cGVvZiBiID09IFwiYm9vbGVhblwiICYmIChiID0gTnVtYmVyKGIpKTtcbiAgICAgICAgICBpZiAoTyA8IDAgfHwgdGhpcy5sZW5ndGggPCBPIHx8IHRoaXMubGVuZ3RoIDwgRClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO1xuICAgICAgICAgIHZhciBKO1xuICAgICAgICAgIGlmICghKEQgPD0gTykpXG4gICAgICAgICAgICBpZiAoTyA+Pj49IDAsIEQgPSBEID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IEQgPj4+IDAsIHR5cGVvZiAoYiA9IGIgfHwgMCkgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgZm9yIChKID0gTzsgSiA8IEQ7ICsrSilcbiAgICAgICAgICAgICAgICB0aGlzW0pdID0gYjtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGUgPSByLmlzQnVmZmVyKGIpID8gYiA6IHIuZnJvbShiLCBCKSwgY2UgPSB0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChjZSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgYiArICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKTtcbiAgICAgICAgICAgICAgZm9yIChKID0gMDsgSiA8IEQgLSBPOyArK0opXG4gICAgICAgICAgICAgICAgdGhpc1tKICsgT10gPSB0ZVtKICUgY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgRiA9IC9bXisvMC05QS1aYS16LV9dL2c7XG4gICAgICAgIGZ1bmN0aW9uIFYoYiwgTykge1xuICAgICAgICAgIE8gPSBPIHx8IDEgLyAwO1xuICAgICAgICAgIGZvciAodmFyIEQsIEIgPSBiLmxlbmd0aCwgWSA9IG51bGwsIEogPSBbXSwgdGUgPSAwOyB0ZSA8IEI7ICsrdGUpIHtcbiAgICAgICAgICAgIGlmICg1NTI5NSA8IChEID0gYi5jaGFyQ29kZUF0KHRlKSkgJiYgRCA8IDU3MzQ0KSB7XG4gICAgICAgICAgICAgIGlmICghWSkge1xuICAgICAgICAgICAgICAgIGlmICg1NjMxOSA8IEQpIHtcbiAgICAgICAgICAgICAgICAgIC0xIDwgKE8gLT0gMykgJiYgSi5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZSArIDEgPT09IEIpIHtcbiAgICAgICAgICAgICAgICAgIC0xIDwgKE8gLT0gMykgJiYgSi5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFkgPSBEO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChEIDwgNTYzMjApIHtcbiAgICAgICAgICAgICAgICAtMSA8IChPIC09IDMpICYmIEoucHVzaCgyMzksIDE5MSwgMTg5KSwgWSA9IEQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgRCA9IDY1NTM2ICsgKFkgLSA1NTI5NiA8PCAxMCB8IEQgLSA1NjMyMCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgWSAmJiAtMSA8IChPIC09IDMpICYmIEoucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgIGlmIChZID0gbnVsbCwgRCA8IDEyOCkge1xuICAgICAgICAgICAgICBpZiAoLS1PIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgSi5wdXNoKEQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChEIDwgMjA0OCkge1xuICAgICAgICAgICAgICBpZiAoKE8gLT0gMikgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBKLnB1c2goRCA+PiA2IHwgMTkyLCA2MyAmIEQgfCAxMjgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChEIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgaWYgKChPIC09IDMpIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgSi5wdXNoKEQgPj4gMTIgfCAyMjQsIEQgPj4gNiAmIDYzIHwgMTI4LCA2MyAmIEQgfCAxMjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCEoRCA8IDExMTQxMTIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtcbiAgICAgICAgICAgICAgaWYgKChPIC09IDQpIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgSi5wdXNoKEQgPj4gMTggfCAyNDAsIEQgPj4gMTIgJiA2MyB8IDEyOCwgRCA+PiA2ICYgNjMgfCAxMjgsIDYzICYgRCB8IDEyOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEcoYikge1xuICAgICAgICAgIHJldHVybiB5LnRvQnl0ZUFycmF5KGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIGlmICgoTyA9IChPID0gTy5zcGxpdChcIj1cIilbMF0pLnRyaW0oKS5yZXBsYWNlKEYsIFwiXCIpKS5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIGZvciAoOyBPLmxlbmd0aCAlIDQgIT0gMDsgKVxuICAgICAgICAgICAgICBPICs9IFwiPVwiO1xuICAgICAgICAgICAgcmV0dXJuIE87XG4gICAgICAgICAgfShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gVShiLCBPLCBELCBCKSB7XG4gICAgICAgICAgZm9yICh2YXIgWSA9IDA7IFkgPCBCICYmICEoWSArIEQgPj0gTy5sZW5ndGggfHwgWSA+PSBiLmxlbmd0aCk7ICsrWSlcbiAgICAgICAgICAgIE9bWSArIERdID0gYltZXTtcbiAgICAgICAgICByZXR1cm4gWTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBXKGIsIE8pIHtcbiAgICAgICAgICByZXR1cm4gYiBpbnN0YW5jZW9mIE8gfHwgYiAhPSBudWxsICYmIGIuY29uc3RydWN0b3IgIT0gbnVsbCAmJiBiLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBiLmNvbnN0cnVjdG9yLm5hbWUgPT09IE8ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBYKGIpIHtcbiAgICAgICAgICByZXR1cm4gYiAhPSBiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGIgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgTyA9IG5ldyBBcnJheSgyNTYpLCBEID0gMDsgRCA8IDE2OyArK0QpXG4gICAgICAgICAgICBmb3IgKHZhciBCID0gMTYgKiBELCBZID0gMDsgWSA8IDE2OyArK1kpXG4gICAgICAgICAgICAgIE9bQiArIFldID0gYltEXSArIGJbWV07XG4gICAgICAgICAgcmV0dXJuIE87XG4gICAgICAgIH0oKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdChcImJ1ZmZlclwiKS5CdWZmZXIpO1xuICAgIH0sIHsgXCJiYXNlNjQtanNcIjogMSwgYnVmZmVyOiA0LCBpZWVlNzU0OiAyNTEgfV0sIDU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhtKSArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH07XG4gICAgfSwge31dLCA2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKG0oeSkgfHwgeSA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKHkpICsgXCIgYXMgYSBwcm90b3R5cGVcIik7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1IH1dLCA3OiBbZnVuY3Rpb24odSwgSCwgQykge1xuICAgICAgdmFyIG0gPSB1KFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCB5ID0gdShcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCIpLCB1ID0gdShcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCIpLCBoID0gbShcInVuc2NvcGFibGVzXCIpLCBnID0gQXJyYXkucHJvdG90eXBlO1xuICAgICAgZ1toXSA9PSBudWxsICYmIHUuZihnLCBoLCB7IGNvbmZpZ3VyYWJsZTogITAsIHZhbHVlOiB5KG51bGwpIH0pLCBILmV4cG9ydHMgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGdbaF1bZl0gPSAhMDtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZVwiKS5jaGFyQXQ7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih5LCB1LCBoKSB7XG4gICAgICAgIHJldHVybiB1ICsgKGggPyBtKHksIHUpLmxlbmd0aCA6IDEpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGVcIjogMTI0IH1dLCA5OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24obSwgeSwgdSkge1xuICAgICAgICBpZiAobSBpbnN0YW5jZW9mIHkpXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIkluY29ycmVjdCBcIiArICh1ID8gdSArIFwiIFwiIDogXCJcIikgKyBcImludm9jYXRpb25cIik7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAobSh5KSlcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyh5KSArIFwiIGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1IH1dLCAxMTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IHR5cGVvZiBBcnJheUJ1ZmZlciA8IFwidVwiICYmIHR5cGVvZiBEYXRhVmlldyA8IFwidVwiO1xuICAgIH0sIHt9XSwgMTI6IFtmdW5jdGlvbihNLCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKEwpIHtcbiAgICAgICAgcmV0dXJuIGYoTCkgJiYgcihSLCBzKEwpKTtcbiAgICAgIH1cbiAgICAgIHZhciB5LCB1ID0gTShcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItbmF0aXZlXCIpLCBoID0gTShcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgZyA9IE0oXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCBmID0gTShcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIHIgPSBNKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgcyA9IE0oXCIuLi9pbnRlcm5hbHMvY2xhc3NvZlwiKSwgbyA9IE0oXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCIpLCBpID0gTShcIi4uL2ludGVybmFscy9yZWRlZmluZVwiKSwgbCA9IE0oXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCBuID0gTShcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZlwiKSwgYSA9IE0oXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2ZcIiksIEEgPSBNKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBNID0gTShcIi4uL2ludGVybmFscy91aWRcIiksIGMgPSBnLkludDhBcnJheSwgcCA9IGMgJiYgYy5wcm90b3R5cGUsIGogPSBnLlVpbnQ4Q2xhbXBlZEFycmF5LCBqID0gaiAmJiBqLnByb3RvdHlwZSwgVCA9IGMgJiYgbihjKSwgXyA9IHAgJiYgbihwKSwgUyA9IE9iamVjdC5wcm90b3R5cGUsIEUgPSBTLmlzUHJvdG90eXBlT2YsIEEgPSBBKFwidG9TdHJpbmdUYWdcIiksIHggPSBNKFwiVFlQRURfQVJSQVlfVEFHXCIpLCBQID0gdSAmJiAhIWEgJiYgcyhnLm9wZXJhKSAhPT0gXCJPcGVyYVwiLCBNID0gITEsIFIgPSB7IEludDhBcnJheTogMSwgVWludDhBcnJheTogMSwgVWludDhDbGFtcGVkQXJyYXk6IDEsIEludDE2QXJyYXk6IDIsIFVpbnQxNkFycmF5OiAyLCBJbnQzMkFycmF5OiA0LCBVaW50MzJBcnJheTogNCwgRmxvYXQzMkFycmF5OiA0LCBGbG9hdDY0QXJyYXk6IDggfTtcbiAgICAgIGZvciAoeSBpbiBSKVxuICAgICAgICBnW3ldIHx8IChQID0gITEpO1xuICAgICAgaWYgKCghUCB8fCB0eXBlb2YgVCAhPSBcImZ1bmN0aW9uXCIgfHwgVCA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSAmJiAoVCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbmNvcnJlY3QgaW52b2NhdGlvblwiKTtcbiAgICAgIH0sIFApKVxuICAgICAgICBmb3IgKHkgaW4gUilcbiAgICAgICAgICBnW3ldICYmIGEoZ1t5XSwgVCk7XG4gICAgICBpZiAoKCFQIHx8ICFfIHx8IF8gPT09IFMpICYmIChfID0gVC5wcm90b3R5cGUsIFApKVxuICAgICAgICBmb3IgKHkgaW4gUilcbiAgICAgICAgICBnW3ldICYmIGEoZ1t5XS5wcm90b3R5cGUsIF8pO1xuICAgICAgaWYgKFAgJiYgbihqKSAhPT0gXyAmJiBhKGosIF8pLCBoICYmICFyKF8sIEEpKVxuICAgICAgICBmb3IgKHkgaW4gTSA9ICEwLCBsKF8sIEEsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZih0aGlzKSA/IHRoaXNbeF0gOiB2b2lkIDA7XG4gICAgICAgIH0gfSksIFIpXG4gICAgICAgICAgZ1t5XSAmJiBvKGdbeV0sIHgsIHkpO1xuICAgICAgSC5leHBvcnRzID0geyBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBQLCBUWVBFRF9BUlJBWV9UQUc6IE0gJiYgeCwgYVR5cGVkQXJyYXk6IGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgaWYgKG0oTCkpXG4gICAgICAgICAgcmV0dXJuIEw7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIlRhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheVwiKTtcbiAgICAgIH0sIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICBpZiAoRS5jYWxsKFQsIEwpKVxuICAgICAgICAgICAgcmV0dXJuIEw7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZvciAodmFyIEYgaW4gUilcbiAgICAgICAgICAgIGlmIChyKFIsIHkpICYmIChGID0gZ1tGXSwgRiAmJiAoTCA9PT0gRiB8fCBFLmNhbGwoRiwgTCkpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIEw7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIlRhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH0sIGV4cG9ydFR5cGVkQXJyYXlNZXRob2Q6IGZ1bmN0aW9uKEwsIEYsIFYpIHtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBpZiAoVilcbiAgICAgICAgICAgIGZvciAodmFyIEcgaW4gUilcbiAgICAgICAgICAgICAgRyA9IGdbR10sIEcgJiYgcihHLnByb3RvdHlwZSwgTCkgJiYgZGVsZXRlIEcucHJvdG90eXBlW0xdO1xuICAgICAgICAgIF9bTF0gJiYgIVYgfHwgaShfLCBMLCAhViAmJiBQICYmIHBbTF0gfHwgRik7XG4gICAgICAgIH1cbiAgICAgIH0sIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGZ1bmN0aW9uKEwsIEYsIFYpIHtcbiAgICAgICAgdmFyIEcsIFU7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIGlmIChWKVxuICAgICAgICAgICAgICBmb3IgKEcgaW4gUilcbiAgICAgICAgICAgICAgICAoVSA9IGdbR10pICYmIHIoVSwgTCkgJiYgZGVsZXRlIFVbTF07XG4gICAgICAgICAgICBpZiAoVFtMXSAmJiAhVilcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkoVCwgTCwgIVYgJiYgUCAmJiBjW0xdIHx8IEYpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoRyBpbiBSKVxuICAgICAgICAgICAgIShVID0gZ1tHXSkgfHwgVVtMXSAmJiAhViB8fCBpKFUsIEwsIEYpO1xuICAgICAgICB9XG4gICAgICB9LCBpc1ZpZXc6IGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgcmV0dXJuIEwgPSBzKEwpLCBMID09PSBcIkRhdGFWaWV3XCIgfHwgcihSLCBMKTtcbiAgICAgIH0sIGlzVHlwZWRBcnJheTogbSwgVHlwZWRBcnJheTogVCwgVHlwZWRBcnJheVByb3RvdHlwZTogXyB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5hdGl2ZVwiOiAxMSwgXCIuLi9pbnRlcm5hbHMvY2xhc3NvZlwiOiAyOSwgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCI6IDM4LCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9oYXNcIjogNjEsIFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2ZcIjogOTgsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mXCI6IDEwMiwgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIjogMTA5LCBcIi4uL2ludGVybmFscy91aWRcIjogMTQ2LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDEzOiBbZnVuY3Rpb24oRCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShLKSB7XG4gICAgICAgIHJldHVybiBbMjU1ICYgS107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KEspIHtcbiAgICAgICAgcmV0dXJuIFsyNTUgJiBLLCBLID4+IDggJiAyNTVdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdShLKSB7XG4gICAgICAgIHJldHVybiBbMjU1ICYgSywgSyA+PiA4ICYgMjU1LCBLID4+IDE2ICYgMjU1LCBLID4+IDI0ICYgMjU1XTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgoSykge1xuICAgICAgICByZXR1cm4gS1szXSA8PCAyNCB8IEtbMl0gPDwgMTYgfCBLWzFdIDw8IDggfCBLWzBdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZyhLKSB7XG4gICAgICAgIHJldHVybiBKKEssIDIzLCA0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYoSykge1xuICAgICAgICByZXR1cm4gSihLLCA1MiwgOCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKEssIGFlKSB7XG4gICAgICAgIE0oS1tXXSwgYWUsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gRih0aGlzKVthZV07XG4gICAgICAgIH0gfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKHhlLCBhZSwgZ2UsIF9lKSB7XG4gICAgICAgIGlmIChnZSA9IFMoZ2UpLCB4ZSA9IEYoeGUpLCBnZSArIGFlID4geGUuYnl0ZUxlbmd0aClcbiAgICAgICAgICB0aHJvdyBZKFgpO1xuICAgICAgICB2YXIgZmUgPSBGKHhlLmJ1ZmZlcikuYnl0ZXMsIGdlID0gZ2UgKyB4ZS5ieXRlT2Zmc2V0LCB4ZSA9IGZlLnNsaWNlKGdlLCBnZSArIGFlKTtcbiAgICAgICAgcmV0dXJuIF9lID8geGUgOiB4ZS5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKEssIGFlLCBoZSwgX2UsIGZlLCBnZSkge1xuICAgICAgICBpZiAoaGUgPSBTKGhlKSwgSyA9IEYoSyksIGhlICsgYWUgPiBLLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgdGhyb3cgWShYKTtcbiAgICAgICAgZm9yICh2YXIgeGUgPSBGKEsuYnVmZmVyKS5ieXRlcywgRGUgPSBoZSArIEsuYnl0ZU9mZnNldCwgTWUgPSBfZSgrZmUpLCBRZSA9IDA7IFFlIDwgYWU7IFFlKyspXG4gICAgICAgICAgeGVbRGUgKyBRZV0gPSBNZVtnZSA/IFFlIDogYWUgLSBRZSAtIDFdO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSBEKFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgbCA9IEQoXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIiksIG4gPSBEKFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1uYXRpdmVcIiksIGEgPSBEKFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiKSwgYyA9IEQoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsXCIpLCBwID0gRChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgaiA9IEQoXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIiksIFQgPSBEKFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIiksIF8gPSBEKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgUyA9IEQoXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhcIiksIEUgPSBEKFwiLi4vaW50ZXJuYWxzL2llZWU3NTRcIiksIEEgPSBEKFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mXCIpLCB4ID0gRChcIi4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZlwiKSwgUCA9IEQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXNcIikuZiwgTSA9IEQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCBSID0gRChcIi4uL2ludGVybmFscy9hcnJheS1maWxsXCIpLCBMID0gRChcIi4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZ1wiKSwgRCA9IEQoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIiksIEYgPSBELmdldCwgViA9IEQuc2V0LCBHID0gXCJBcnJheUJ1ZmZlclwiLCBVID0gXCJEYXRhVmlld1wiLCBXID0gXCJwcm90b3R5cGVcIiwgWCA9IFwiV3JvbmcgaW5kZXhcIiwgbmUgPSBpW0ddLCBiID0gbmUsIE8gPSBpW1VdLCBEID0gTyAmJiBPW1ddLCBCID0gT2JqZWN0LnByb3RvdHlwZSwgWSA9IGkuUmFuZ2VFcnJvciwgSiA9IEUucGFjaywgdGUgPSBFLnVucGFjaztcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIGlmICghcChmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZSgxKTtcbiAgICAgICAgfSkgfHwgIXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3IG5lKC0xKTtcbiAgICAgICAgfSkgfHwgcChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG5lKCksIG5ldyBuZSgxLjUpLCBuZXcgbmUoTmFOKSwgbmUubmFtZSAhPSBHO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGZvciAodmFyIGNlLCBpID0gKGIgPSBmdW5jdGlvbihoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGoodGhpcywgYiksIG5ldyBuZShTKGhlKSk7XG4gICAgICAgICAgfSlbV10gPSBuZVtXXSwgcmUgPSBQKG5lKSwgdWUgPSAwOyByZS5sZW5ndGggPiB1ZTsgKVxuICAgICAgICAgICAgKGNlID0gcmVbdWUrK10pIGluIGIgfHwgYShiLCBjZSwgbmVbY2VdKTtcbiAgICAgICAgICBpLmNvbnN0cnVjdG9yID0gYjtcbiAgICAgICAgfVxuICAgICAgICB4ICYmIEEoRCkgIT09IEIgJiYgeChELCBCKTtcbiAgICAgICAgdmFyIEUgPSBuZXcgTyhuZXcgYigyKSksIGxlID0gRC5zZXRJbnQ4O1xuICAgICAgICBFLnNldEludDgoMCwgMjE0NzQ4MzY0OCksIEUuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KSwgIUUuZ2V0SW50OCgwKSAmJiBFLmdldEludDgoMSkgfHwgYyhELCB7IHNldEludDg6IGZ1bmN0aW9uKGFlLCBoZSkge1xuICAgICAgICAgIGxlLmNhbGwodGhpcywgYWUsIGhlIDw8IDI0ID4+IDI0KTtcbiAgICAgICAgfSwgc2V0VWludDg6IGZ1bmN0aW9uKGFlLCBoZSkge1xuICAgICAgICAgIGxlLmNhbGwodGhpcywgYWUsIGhlIDw8IDI0ID4+IDI0KTtcbiAgICAgICAgfSB9LCB7IHVuc2FmZTogITAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYiA9IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICBqKHRoaXMsIGIsIEcpLCBLID0gUyhLKSwgVih0aGlzLCB7IGJ5dGVzOiBSLmNhbGwobmV3IEFycmF5KEspLCAwKSwgYnl0ZUxlbmd0aDogSyB9KSwgbCB8fCAodGhpcy5ieXRlTGVuZ3RoID0gSyk7XG4gICAgICAgIH0sIE8gPSBmdW5jdGlvbihLLCBmZSwgaGUpIHtcbiAgICAgICAgICBqKHRoaXMsIE8sIFUpLCBqKEssIGIsIFUpO1xuICAgICAgICAgIHZhciBfZSA9IEYoSykuYnl0ZUxlbmd0aCwgZmUgPSBUKGZlKTtcbiAgICAgICAgICBpZiAoZmUgPCAwIHx8IF9lIDwgZmUpXG4gICAgICAgICAgICB0aHJvdyBZKFwiV3Jvbmcgb2Zmc2V0XCIpO1xuICAgICAgICAgIGlmIChfZSA8IGZlICsgKGhlID0gaGUgPT09IHZvaWQgMCA/IF9lIC0gZmUgOiBfKGhlKSkpXG4gICAgICAgICAgICB0aHJvdyBZKFwiV3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgIFYodGhpcywgeyBidWZmZXI6IEssIGJ5dGVMZW5ndGg6IGhlLCBieXRlT2Zmc2V0OiBmZSB9KSwgbCB8fCAodGhpcy5idWZmZXIgPSBLLCB0aGlzLmJ5dGVMZW5ndGggPSBoZSwgdGhpcy5ieXRlT2Zmc2V0ID0gZmUpO1xuICAgICAgICB9LCBsICYmIChyKGIsIFwiYnl0ZUxlbmd0aFwiKSwgcihPLCBcImJ1ZmZlclwiKSwgcihPLCBcImJ5dGVMZW5ndGhcIiksIHIoTywgXCJieXRlT2Zmc2V0XCIpKSwgYyhPW1ddLCB7IGdldEludDg6IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICByZXR1cm4gcyh0aGlzLCAxLCBLKVswXSA8PCAyNCA+PiAyNDtcbiAgICAgICAgfSwgZ2V0VWludDg6IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICByZXR1cm4gcyh0aGlzLCAxLCBLKVswXTtcbiAgICAgICAgfSwgZ2V0SW50MTY6IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICByZXR1cm4gSyA9IHModGhpcywgMiwgSywgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApLCAoS1sxXSA8PCA4IHwgS1swXSkgPDwgMTYgPj4gMTY7XG4gICAgICAgIH0sIGdldFVpbnQxNjogZnVuY3Rpb24oSykge1xuICAgICAgICAgIHJldHVybiBLID0gcyh0aGlzLCAyLCBLLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCksIEtbMV0gPDwgOCB8IEtbMF07XG4gICAgICAgIH0sIGdldEludDMyOiBmdW5jdGlvbihLKSB7XG4gICAgICAgICAgcmV0dXJuIGgocyh0aGlzLCA0LCBLLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCkpO1xuICAgICAgICB9LCBnZXRVaW50MzI6IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICByZXR1cm4gaChzKHRoaXMsIDQsIEssIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKSkgPj4+IDA7XG4gICAgICAgIH0sIGdldEZsb2F0MzI6IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICByZXR1cm4gdGUocyh0aGlzLCA0LCBLLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCksIDIzKTtcbiAgICAgICAgfSwgZ2V0RmxvYXQ2NDogZnVuY3Rpb24oSykge1xuICAgICAgICAgIHJldHVybiB0ZShzKHRoaXMsIDgsIEssIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKSwgNTIpO1xuICAgICAgICB9LCBzZXRJbnQ4OiBmdW5jdGlvbihLLCBhZSkge1xuICAgICAgICAgIG8odGhpcywgMSwgSywgbSwgYWUpO1xuICAgICAgICB9LCBzZXRVaW50ODogZnVuY3Rpb24oSywgYWUpIHtcbiAgICAgICAgICBvKHRoaXMsIDEsIEssIG0sIGFlKTtcbiAgICAgICAgfSwgc2V0SW50MTY6IGZ1bmN0aW9uKEssIGFlKSB7XG4gICAgICAgICAgbyh0aGlzLCAyLCBLLCB5LCBhZSwgMiA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMl0gOiB2b2lkIDApO1xuICAgICAgICB9LCBzZXRVaW50MTY6IGZ1bmN0aW9uKEssIGFlKSB7XG4gICAgICAgICAgbyh0aGlzLCAyLCBLLCB5LCBhZSwgMiA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMl0gOiB2b2lkIDApO1xuICAgICAgICB9LCBzZXRJbnQzMjogZnVuY3Rpb24oSywgYWUpIHtcbiAgICAgICAgICBvKHRoaXMsIDQsIEssIHUsIGFlLCAyIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMCk7XG4gICAgICAgIH0sIHNldFVpbnQzMjogZnVuY3Rpb24oSywgYWUpIHtcbiAgICAgICAgICBvKHRoaXMsIDQsIEssIHUsIGFlLCAyIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMCk7XG4gICAgICAgIH0sIHNldEZsb2F0MzI6IGZ1bmN0aW9uKEssIGFlKSB7XG4gICAgICAgICAgbyh0aGlzLCA0LCBLLCBnLCBhZSwgMiA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMl0gOiB2b2lkIDApO1xuICAgICAgICB9LCBzZXRGbG9hdDY0OiBmdW5jdGlvbihLLCBhZSkge1xuICAgICAgICAgIG8odGhpcywgOCwgSywgZiwgYWUsIDIgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzJdIDogdm9pZCAwKTtcbiAgICAgICAgfSB9KTtcbiAgICAgIEwoYiwgRyksIEwoTywgVSksIEguZXhwb3J0cyA9IHsgQXJyYXlCdWZmZXI6IGIsIERhdGFWaWV3OiBPIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1pbnN0YW5jZVwiOiA5LCBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItbmF0aXZlXCI6IDExLCBcIi4uL2ludGVybmFscy9hcnJheS1maWxsXCI6IDE1LCBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCI6IDQzLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9pZWVlNzU0XCI6IDY2LCBcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiOiA3MSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXNcIjogOTYsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mXCI6IDk4LCBcIi4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZlwiOiAxMDIsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbFwiOiAxMDgsIFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCI6IDExOCwgXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhcIjogMTM0LCBcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCI6IDEzNiwgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNyB9XSwgMTQ6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCBoID0gTWF0aC5taW47XG4gICAgICBILmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgdmFyIHIgPSBtKHRoaXMpLCBzID0gdShyLmxlbmd0aCksIG8gPSB5KGwsIHMpLCBpID0geShmLCBzKSwgbCA9IDIgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzJdIDogdm9pZCAwLCBuID0gaCgobCA9PT0gdm9pZCAwID8gcyA6IHkobCwgcykpIC0gaSwgcyAtIG8pLCBhID0gMTtcbiAgICAgICAgZm9yIChpIDwgbyAmJiBvIDwgaSArIG4gJiYgKGEgPSAtMSwgaSArPSBuIC0gMSwgbyArPSBuIC0gMSk7IDAgPCBuLS07IClcbiAgICAgICAgICBpIGluIHIgPyByW29dID0gcltpXSA6IGRlbGV0ZSByW29dLCBvICs9IGEsIGkgKz0gYTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXhcIjogMTMzLCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4IH1dLCAxNTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIGZvciAodmFyIGcgPSBtKHRoaXMpLCBmID0gdShnLmxlbmd0aCksIHMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0geSgxIDwgcyA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCwgZiksIHMgPSAyIDwgcyA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMCwgbyA9IHMgPT09IHZvaWQgMCA/IGYgOiB5KHMsIGYpOyByIDwgbzsgKVxuICAgICAgICAgIGdbcisrXSA9IGg7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4XCI6IDEzMywgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNywgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCB9XSwgMTY6IFtmdW5jdGlvbih1LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHUoXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCIpLmZvckVhY2gsIHkgPSB1KFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3RcIiksIHUgPSB1KFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiKSwgeSA9IHkoXCJmb3JFYWNoXCIpLCB1ID0gdShcImZvckVhY2hcIik7XG4gICAgICBILmV4cG9ydHMgPSB5ICYmIHUgPyBbXS5mb3JFYWNoIDogZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gbSh0aGlzLCBoLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0XCI6IDIyLCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIjogMjMgfV0sIDE3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZ1wiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kXCIpLCBnID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIGYgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiKSwgciA9IHQoXCIuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGopIHtcbiAgICAgICAgdmFyIG8sIGksIGwsIG4sIGEsIGMsIHAgPSB5KGopLCBqID0gdHlwZW9mIHRoaXMgPT0gXCJmdW5jdGlvblwiID8gdGhpcyA6IEFycmF5LCBUID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IDEgPCBUID8gYXJndW1lbnRzWzFdIDogdm9pZCAwLCBTID0gXyAhPT0gdm9pZCAwLCBFID0gcihwKSwgQSA9IDA7XG4gICAgICAgIGlmIChTICYmIChfID0gbShfLCAyIDwgVCA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMCwgMikpLCBFID09IG51bGwgfHwgaiA9PSBBcnJheSAmJiBoKEUpKVxuICAgICAgICAgIGZvciAoaSA9IG5ldyBqKG8gPSBnKHAubGVuZ3RoKSk7IEEgPCBvOyBBKyspXG4gICAgICAgICAgICBjID0gUyA/IF8ocFtBXSwgQSkgOiBwW0FdLCBmKGksIEEsIGMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChhID0gKG4gPSBFLmNhbGwocCkpLm5leHQsIGkgPSBuZXcgaigpOyAhKGwgPSBhLmNhbGwobikpLmRvbmU7IEErKylcbiAgICAgICAgICAgIGMgPSBTID8gdShuLCBfLCBbbC52YWx1ZSwgQV0sICEwKSA6IGwudmFsdWUsIGYoaSwgQSwgYyk7XG4gICAgICAgIHJldHVybiBpLmxlbmd0aCA9IEEsIGk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmdcIjogMjYsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiOiA0MCwgXCIuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0XCI6IDU1LCBcIi4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kXCI6IDU4LCBcIi4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2RcIjogNzIsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcsIFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiOiAxMzggfV0sIDE4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgICAgdmFyIG8sIGkgPSB5KGYpLCBsID0gdShpLmxlbmd0aCksIG4gPSBoKHMsIGwpO1xuICAgICAgICAgIGlmIChnICYmIHIgIT0gcikge1xuICAgICAgICAgICAgZm9yICg7IG4gPCBsOyApXG4gICAgICAgICAgICAgIGlmICgobyA9IGlbbisrXSkgIT0gbylcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBmb3IgKDsgbiA8IGw7IG4rKylcbiAgICAgICAgICAgICAgaWYgKChnIHx8IG4gaW4gaSkgJiYgaVtuXSA9PT0gcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZyB8fCBuIHx8IDA7XG4gICAgICAgICAgcmV0dXJuICFnICYmIC0xO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4XCIpO1xuICAgICAgSC5leHBvcnRzID0geyBpbmNsdWRlczogbSghMCksIGluZGV4T2Y6IG0oITEpIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleFwiOiAxMzMsIFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCI6IDEzNSwgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNyB9XSwgMTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHMpIHtcbiAgICAgICAgdmFyIG8gPSBzID09IDEsIGkgPSBzID09IDIsIGwgPSBzID09IDMsIG4gPSBzID09IDQsIGEgPSBzID09IDYsIGMgPSBzID09IDUgfHwgYTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHAsIGosIFQsIF8pIHtcbiAgICAgICAgICBmb3IgKHZhciBTLCBFLCBBID0gaChwKSwgeCA9IHUoQSksIFAgPSB5KGosIFQsIDMpLCBNID0gZyh4Lmxlbmd0aCksIFIgPSAwLCBqID0gXyB8fCBmLCBMID0gbyA/IGoocCwgTSkgOiBpID8gaihwLCAwKSA6IHZvaWQgMDsgUiA8IE07IFIrKylcbiAgICAgICAgICAgIGlmICgoYyB8fCBSIGluIHgpICYmIChFID0gUChTID0geFtSXSwgUiwgQSksIHMpKSB7XG4gICAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICAgIExbUl0gPSBFO1xuICAgICAgICAgICAgICBlbHNlIGlmIChFKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTO1xuICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgci5jYWxsKEwsIFMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGEgPyAtMSA6IGwgfHwgbiA/IG4gOiBMO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3RcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZVwiKSwgciA9IFtdLnB1c2g7XG4gICAgICBILmV4cG9ydHMgPSB7IGZvckVhY2g6IG0oMCksIG1hcDogbSgxKSwgZmlsdGVyOiBtKDIpLCBzb21lOiBtKDMpLCBldmVyeTogbSg0KSwgZmluZDogbSg1KSwgZmluZEluZGV4OiBtKDYpIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZVwiOiAyNSwgXCIuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0XCI6IDU1LCBcIi4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdFwiOiA2NywgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNywgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCB9XSwgMjA6IFtmdW5jdGlvbihzLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHMoXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3RcIiksIHkgPSBzKFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIiksIHUgPSBzKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgciA9IHMoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdFwiKSwgcyA9IHMoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCBoID0gTWF0aC5taW4sIGcgPSBbXS5sYXN0SW5kZXhPZiwgZiA9ICEhZyAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDAsIHIgPSByKFwibGFzdEluZGV4T2ZcIiksIHMgPSBzKFwiaW5kZXhPZlwiLCB7IEFDQ0VTU09SUzogITAsIDE6IDAgfSk7XG4gICAgICBILmV4cG9ydHMgPSBmIHx8ICFyIHx8ICFzID8gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICByZXR1cm4gZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgICAgIHZhciBpID0gbSh0aGlzKSwgbCA9IHUoaS5sZW5ndGgpLCBuID0gbCAtIDE7XG4gICAgICAgIGZvciAoKG4gPSAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGgobiwgeShhcmd1bWVudHNbMV0pKSA6IG4pIDwgMCAmJiAobiA9IGwgKyBuKTsgMCA8PSBuOyBuLS0pXG4gICAgICAgICAgaWYgKG4gaW4gaSAmJiBpW25dID09PSBvKVxuICAgICAgICAgICAgcmV0dXJuIG4gfHwgMDtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSA6IGc7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0XCI6IDIyLCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIjogMjMsIFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCI6IDEzNSwgXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiOiAxMzYsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcgfV0sIDIxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb25cIiksIGggPSB5KFwic3BlY2llc1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIDUxIDw9IHUgfHwgIW0oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSBbXTtcbiAgICAgICAgICByZXR1cm4gKGYuY29uc3RydWN0b3IgPSB7fSlbaF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgICAgICAgIH0sIGZbZ10oQm9vbGVhbikuZm9vICE9PSAxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvblwiOiA0OCwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgMjI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih5LCB1KSB7XG4gICAgICAgIHZhciBoID0gW11beV07XG4gICAgICAgIHJldHVybiAhIWggJiYgbShmdW5jdGlvbigpIHtcbiAgICAgICAgICBoLmNhbGwobnVsbCwgdSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IDE7XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxIH1dLCAyMzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocikge1xuICAgICAgICB0aHJvdyByO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCBnID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBmID0ge307XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgIHZhciBvLCBpLCBsLCBuO1xuICAgICAgICByZXR1cm4gaChmLCByKSA/IGZbcl0gOiAobyA9IFtdW3JdLCBpID0gISFoKHMgPSBzIHx8IHt9LCBcIkFDQ0VTU09SU1wiKSAmJiBzLkFDQ0VTU09SUywgbCA9IGgocywgMCkgPyBzWzBdIDogbSwgbiA9IGgocywgMSkgPyBzWzFdIDogdm9pZCAwLCBmW3JdID0gISFvICYmICF1KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpICYmICF5KVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIHZhciBhID0geyBsZW5ndGg6IC0xIH07XG4gICAgICAgICAgaSA/IGcoYSwgMSwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBtIH0pIDogYVsxXSA9IDEsIG8uY2FsbChhLCBsLCBuKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCI6IDQzLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxIH1dLCAyNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ociwgcywgbywgaSkge1xuICAgICAgICAgIHkocyk7XG4gICAgICAgICAgdmFyIGwgPSB1KHIpLCBuID0gaChsKSwgYSA9IGcobC5sZW5ndGgpLCBjID0gZiA/IGEgLSAxIDogMCwgcCA9IGYgPyAtMSA6IDE7XG4gICAgICAgICAgaWYgKG8gPCAyKVxuICAgICAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgICAgIGlmIChjIGluIG4pIHtcbiAgICAgICAgICAgICAgICBpID0gbltjXSwgYyArPSBwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjICs9IHAsIGYgPyBjIDwgMCA6IGEgPD0gYylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBmID8gMCA8PSBjIDogYyA8IGE7IGMgKz0gcClcbiAgICAgICAgICAgIGMgaW4gbiAmJiAoaSA9IHMoaSwgbltjXSwgYywgbCkpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3RcIiksIGcgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IHsgbGVmdDogbSghMSksIHJpZ2h0OiBtKCEwKSB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiOiA1LCBcIi4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdFwiOiA2NywgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNywgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCB9XSwgMjU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9pcy1hcnJheVwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIikoXCJzcGVjaWVzXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oaCwgZykge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgcmV0dXJuIG5ldyAoKGYgPSB5KGgpICYmICh0eXBlb2YgKGYgPSBoLmNvbnN0cnVjdG9yKSA9PSBcImZ1bmN0aW9uXCIgJiYgKGYgPT09IEFycmF5IHx8IHkoZi5wcm90b3R5cGUpKSB8fCBtKGYpICYmIChmID0gZlt1XSkgPT09IG51bGwpID8gdm9pZCAwIDogZikgPT09IHZvaWQgMCA/IEFycmF5IDogZikoZyA9PT0gMCA/IDAgOiBnKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9pcy1hcnJheVwiOiA3MywgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDI2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHksIHUsIGgsIGcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZyA/IHUobShoKVswXSwgaFsxXSkgOiB1KGgpO1xuICAgICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgICAgdGhyb3cgZyA9IHkucmV0dXJuLCBnICE9PSB2b2lkIDAgJiYgbShnLmNhbGwoeSkpLCBmO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwIH1dLCAyNzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcIml0ZXJhdG9yXCIpLCB5ID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdSA9IDAsIGggPSB7IG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6ICEhdSsrIH07XG4gICAgICAgIH0sIHJldHVybjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgeSA9ICEwO1xuICAgICAgICB9IH07XG4gICAgICAgIGhbbV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgQXJyYXkuZnJvbShoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyAyO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oZywgZikge1xuICAgICAgICBpZiAoIWYgJiYgIXkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB2YXIgciA9ICExO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzID0ge307XG4gICAgICAgICAgc1ttXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHIgPSAhMCB9O1xuICAgICAgICAgICAgfSB9O1xuICAgICAgICAgIH0sIGcocyk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgMjg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHt9LnRvU3RyaW5nO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gbS5jYWxsKHkpLnNsaWNlKDgsIC0xKTtcbiAgICAgIH07XG4gICAgfSwge31dLCAyOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnRcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcInRvU3RyaW5nVGFnXCIpLCBoID0geSgvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgICB9KCkpID09IFwiQXJndW1lbnRzXCI7XG4gICAgICBILmV4cG9ydHMgPSBtID8geSA6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiBnID09PSB2b2lkIDAgPyBcIlVuZGVmaW5lZFwiIDogZyA9PT0gbnVsbCA/IFwiTnVsbFwiIDogdHlwZW9mIChmID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcltzXTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0oZyA9IE9iamVjdChnKSwgdSkpID09IFwic3RyaW5nXCIgPyBmIDogaCA/IHkoZykgOiAoZiA9IHkoZykpID09IFwiT2JqZWN0XCIgJiYgdHlwZW9mIGcuY2FsbGVlID09IFwiZnVuY3Rpb25cIiA/IFwiQXJndW1lbnRzXCIgOiBmO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCI6IDI4LCBcIi4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnRcIjogMTQyLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDMwOiBbZnVuY3Rpb24obCwgSCwgQykge1xuICAgICAgdmFyIG0gPSBsKFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIikuZiwgeSA9IGwoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZVwiKSwgdSA9IGwoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsXCIpLCBoID0gbChcIi4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHRcIiksIGcgPSBsKFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCIpLCBmID0gbChcIi4uL2ludGVybmFscy9pdGVyYXRlXCIpLCByID0gbChcIi4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3JcIiksIHMgPSBsKFwiLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzXCIpLCBvID0gbChcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgaSA9IGwoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGFcIikuZmFzdEtleSwgbCA9IGwoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIiksIG4gPSBsLnNldCwgYSA9IGwuZ2V0dGVyRm9yO1xuICAgICAgSC5leHBvcnRzID0geyBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oYywgcCwgaiwgVCkge1xuICAgICAgICBmdW5jdGlvbiBfKHgsIFAsIE0pIHtcbiAgICAgICAgICB2YXIgUiwgTCA9IEEoeCksIEYgPSBTKHgsIFApO1xuICAgICAgICAgIHJldHVybiBGID8gRi52YWx1ZSA9IE0gOiAoTC5sYXN0ID0gRiA9IHsgaW5kZXg6IFIgPSBpKFAsICEwKSwga2V5OiBQLCB2YWx1ZTogTSwgcHJldmlvdXM6IFAgPSBMLmxhc3QsIG5leHQ6IHZvaWQgMCwgcmVtb3ZlZDogITEgfSwgTC5maXJzdCB8fCAoTC5maXJzdCA9IEYpLCBQICYmIChQLm5leHQgPSBGKSwgbyA/IEwuc2l6ZSsrIDogeC5zaXplKyssIFIgIT09IFwiRlwiICYmIChMLmluZGV4W1JdID0gRikpLCB4O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFMoUiwgUCkge1xuICAgICAgICAgIHZhciBNLCBSID0gQShSKSwgTCA9IGkoUCk7XG4gICAgICAgICAgaWYgKEwgIT09IFwiRlwiKVxuICAgICAgICAgICAgcmV0dXJuIFIuaW5kZXhbTF07XG4gICAgICAgICAgZm9yIChNID0gUi5maXJzdDsgTTsgTSA9IE0ubmV4dClcbiAgICAgICAgICAgIGlmIChNLmtleSA9PSBQKVxuICAgICAgICAgICAgICByZXR1cm4gTTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRSA9IGMoZnVuY3Rpb24oeCwgUCkge1xuICAgICAgICAgIGcoeCwgRSwgcCksIG4oeCwgeyB0eXBlOiBwLCBpbmRleDogeShudWxsKSwgZmlyc3Q6IHZvaWQgMCwgbGFzdDogdm9pZCAwLCBzaXplOiAwIH0pLCBvIHx8ICh4LnNpemUgPSAwKSwgUCAhPSBudWxsICYmIGYoUCwgeFtUXSwgeCwgaik7XG4gICAgICAgIH0pLCBBID0gYShwKTtcbiAgICAgICAgcmV0dXJuIHUoRS5wcm90b3R5cGUsIHsgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIHggPSBBKHRoaXMpLCBQID0geC5pbmRleCwgTSA9IHguZmlyc3Q7IE07IClcbiAgICAgICAgICAgIE0ucmVtb3ZlZCA9ICEwLCBNLnByZXZpb3VzICYmIChNLnByZXZpb3VzID0gTS5wcmV2aW91cy5uZXh0ID0gdm9pZCAwKSwgZGVsZXRlIFBbTS5pbmRleF0sIE0gPSBNLm5leHQ7XG4gICAgICAgICAgeC5maXJzdCA9IHgubGFzdCA9IHZvaWQgMCwgbyA/IHguc2l6ZSA9IDAgOiB0aGlzLnNpemUgPSAwO1xuICAgICAgICB9LCBkZWxldGU6IGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICB2YXIgUCwgTSwgUiA9IEEodGhpcyksIEwgPSBTKHRoaXMsIEwpO1xuICAgICAgICAgIHJldHVybiBMICYmIChQID0gTC5uZXh0LCBNID0gTC5wcmV2aW91cywgZGVsZXRlIFIuaW5kZXhbTC5pbmRleF0sIEwucmVtb3ZlZCA9ICEwLCBNICYmIChNLm5leHQgPSBQKSwgUCAmJiAoUC5wcmV2aW91cyA9IE0pLCBSLmZpcnN0ID09IEwgJiYgKFIuZmlyc3QgPSBQKSwgUi5sYXN0ID09IEwgJiYgKFIubGFzdCA9IE0pLCBvID8gUi5zaXplLS0gOiB0aGlzLnNpemUtLSksICEhTDtcbiAgICAgICAgfSwgZm9yRWFjaDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIGZvciAodmFyIFAsIE0gPSBBKHRoaXMpLCBSID0gaCh4LCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCwgMyk7IFAgPSBQID8gUC5uZXh0IDogTS5maXJzdDsgKVxuICAgICAgICAgICAgZm9yIChSKFAudmFsdWUsIFAua2V5LCB0aGlzKTsgUCAmJiBQLnJlbW92ZWQ7IClcbiAgICAgICAgICAgICAgUCA9IFAucHJldmlvdXM7XG4gICAgICAgIH0sIGhhczogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiAhIVModGhpcywgeCk7XG4gICAgICAgIH0gfSksIHUoRS5wcm90b3R5cGUsIGogPyB7IGdldDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiB4ID0gUyh0aGlzLCB4KSwgeCAmJiB4LnZhbHVlO1xuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uKHgsIFApIHtcbiAgICAgICAgICByZXR1cm4gXyh0aGlzLCB4ID09PSAwID8gMCA6IHgsIFApO1xuICAgICAgICB9IH0gOiB7IGFkZDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiBfKHRoaXMsIHggPSB4ID09PSAwID8gMCA6IHgsIHgpO1xuICAgICAgICB9IH0pLCBvICYmIG0oRS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEEodGhpcykuc2l6ZTtcbiAgICAgICAgfSB9KSwgRTtcbiAgICAgIH0sIHNldFN0cm9uZzogZnVuY3Rpb24oYywgcCwgaikge1xuICAgICAgICB2YXIgVCA9IHAgKyBcIiBJdGVyYXRvclwiLCBfID0gYShwKSwgUyA9IGEoVCk7XG4gICAgICAgIHIoYywgcCwgZnVuY3Rpb24oRSwgQSkge1xuICAgICAgICAgIG4odGhpcywgeyB0eXBlOiBULCB0YXJnZXQ6IEUsIHN0YXRlOiBfKEUpLCBraW5kOiBBLCBsYXN0OiB2b2lkIDAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIEUgPSBTKHRoaXMpLCBBID0gRS5raW5kLCB4ID0gRS5sYXN0OyB4ICYmIHgucmVtb3ZlZDsgKVxuICAgICAgICAgICAgeCA9IHgucHJldmlvdXM7XG4gICAgICAgICAgcmV0dXJuIEUudGFyZ2V0ICYmIChFLmxhc3QgPSB4ID0geCA/IHgubmV4dCA6IEUuc3RhdGUuZmlyc3QpID8gQSA9PSBcImtleXNcIiA/IHsgdmFsdWU6IHgua2V5LCBkb25lOiAhMSB9IDogQSA9PSBcInZhbHVlc1wiID8geyB2YWx1ZTogeC52YWx1ZSwgZG9uZTogITEgfSA6IHsgdmFsdWU6IFt4LmtleSwgeC52YWx1ZV0sIGRvbmU6ICExIH0gOiB7IHZhbHVlOiBFLnRhcmdldCA9IHZvaWQgMCwgZG9uZTogITAgfTtcbiAgICAgICAgfSwgaiA/IFwiZW50cmllc1wiIDogXCJ2YWx1ZXNcIiwgIWosICEwKSwgcyhwKTtcbiAgICAgIH0gfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCI6IDksIFwiLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvclwiOiA0MSwgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiOiA1NSwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGFcIjogNzAsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9pdGVyYXRlXCI6IDc4LCBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIjogMTA4LCBcIi4uL2ludGVybmFscy9zZXQtc3BlY2llc1wiOiAxMTcgfV0sIDMxOiBbZnVuY3Rpb24obiwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShfKSB7XG4gICAgICAgIHJldHVybiBfLmZyb3plbiB8fCAoXy5mcm96ZW4gPSBuZXcgeSgpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdShfLCBTKSB7XG4gICAgICAgIHJldHVybiBwKF8uZW50cmllcywgZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHJldHVybiBFWzBdID09PSBTO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBoID0gbihcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIiksIGcgPSBuKFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhXCIpLmdldFdlYWtEYXRhLCBmID0gbihcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIHIgPSBuKFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgcyA9IG4oXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIiksIG8gPSBuKFwiLi4vaW50ZXJuYWxzL2l0ZXJhdGVcIiksIGkgPSBuKFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKSwgbCA9IG4oXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCBuID0gbihcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiKSwgYSA9IG4uc2V0LCBjID0gbi5nZXR0ZXJGb3IsIHAgPSBpLmZpbmQsIGogPSBpLmZpbmRJbmRleCwgVCA9IDA7XG4gICAgICB5LnByb3RvdHlwZSA9IHsgZ2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmIChfID0gdSh0aGlzLCBfKSwgXylcbiAgICAgICAgICByZXR1cm4gX1sxXTtcbiAgICAgIH0sIGhhczogZnVuY3Rpb24oXykge1xuICAgICAgICByZXR1cm4gISF1KHRoaXMsIF8pO1xuICAgICAgfSwgc2V0OiBmdW5jdGlvbihfLCBTKSB7XG4gICAgICAgIHZhciBFID0gdSh0aGlzLCBfKTtcbiAgICAgICAgRSA/IEVbMV0gPSBTIDogdGhpcy5lbnRyaWVzLnB1c2goW18sIFNdKTtcbiAgICAgIH0sIGRlbGV0ZTogZnVuY3Rpb24oXykge1xuICAgICAgICB2YXIgUyA9IGoodGhpcy5lbnRyaWVzLCBmdW5jdGlvbihFKSB7XG4gICAgICAgICAgcmV0dXJuIEVbMF0gPT09IF87XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gflMgJiYgdGhpcy5lbnRyaWVzLnNwbGljZShTLCAxKSwgISF+UztcbiAgICAgIH0gfSwgSC5leHBvcnRzID0geyBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oXywgUywgRSwgQSkge1xuICAgICAgICBmdW5jdGlvbiB4KFIsIEwsIEYpIHtcbiAgICAgICAgICB2YXIgViA9IE0oUiksIEcgPSBnKGYoTCksICEwKTtcbiAgICAgICAgICByZXR1cm4gRyA9PT0gITAgPyBtKFYpLnNldChMLCBGKSA6IEdbVi5pZF0gPSBGLCBSO1xuICAgICAgICB9XG4gICAgICAgIHZhciBQID0gXyhmdW5jdGlvbihSLCBMKSB7XG4gICAgICAgICAgcyhSLCBQLCBTKSwgYShSLCB7IHR5cGU6IFMsIGlkOiBUKyssIGZyb3plbjogdm9pZCAwIH0pLCBMICE9IG51bGwgJiYgbyhMLCBSW0FdLCBSLCBFKTtcbiAgICAgICAgfSksIE0gPSBjKFMpO1xuICAgICAgICByZXR1cm4gaChQLnByb3RvdHlwZSwgeyBkZWxldGU6IGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICB2YXIgTCwgRiA9IE0odGhpcyk7XG4gICAgICAgICAgcmV0dXJuICEhcihSKSAmJiAoKEwgPSBnKFIpKSA9PT0gITAgPyBtKEYpLmRlbGV0ZShSKSA6IEwgJiYgbChMLCBGLmlkKSAmJiBkZWxldGUgTFtGLmlkXSk7XG4gICAgICAgIH0sIGhhczogZnVuY3Rpb24oUikge1xuICAgICAgICAgIHZhciBMLCBGID0gTSh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gISFyKFIpICYmICgoTCA9IGcoUikpID09PSAhMCA/IG0oRikuaGFzKFIpIDogTCAmJiBsKEwsIEYuaWQpKTtcbiAgICAgICAgfSB9KSwgaChQLnByb3RvdHlwZSwgRSA/IHsgZ2V0OiBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgdmFyIEwsIEYgPSBNKHRoaXMpO1xuICAgICAgICAgIGlmIChyKFIpKVxuICAgICAgICAgICAgcmV0dXJuIChMID0gZyhSKSkgPT09ICEwID8gbShGKS5nZXQoUikgOiBMID8gTFtGLmlkXSA6IHZvaWQgMDtcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbihSLCBMKSB7XG4gICAgICAgICAgcmV0dXJuIHgodGhpcywgUiwgTCk7XG4gICAgICAgIH0gfSA6IHsgYWRkOiBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgcmV0dXJuIHgodGhpcywgUiwgITApO1xuICAgICAgICB9IH0pLCBQO1xuICAgICAgfSB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIjogOSwgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIjogMTksIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGFcIjogNzAsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL2l0ZXJhdGVcIjogNzgsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbFwiOiAxMDggfV0sIDMyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9pcy1mb3JjZWRcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCIpLCBnID0gdChcIi4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YVwiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvaXRlcmF0ZVwiKSwgciA9IHQoXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIiksIHMgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgbyA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIGkgPSB0KFwiLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvblwiKSwgbCA9IHQoXCIuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWdcIiksIG4gPSB0KFwiLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWRcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihhLCBjLCBwKSB7XG4gICAgICAgIGZ1bmN0aW9uIGooRykge1xuICAgICAgICAgIHZhciBVID0gTFtHXTtcbiAgICAgICAgICBoKEwsIEcsIEcgPT0gXCJhZGRcIiA/IGZ1bmN0aW9uKFcpIHtcbiAgICAgICAgICAgIHJldHVybiBVLmNhbGwodGhpcywgVyA9PT0gMCA/IDAgOiBXKSwgdGhpcztcbiAgICAgICAgICB9IDogRyA9PSBcImRlbGV0ZVwiID8gZnVuY3Rpb24oVykge1xuICAgICAgICAgICAgcmV0dXJuICEoUCAmJiAhcyhXKSkgJiYgVS5jYWxsKHRoaXMsIFcgPT09IDAgPyAwIDogVyk7XG4gICAgICAgICAgfSA6IEcgPT0gXCJnZXRcIiA/IGZ1bmN0aW9uKFcpIHtcbiAgICAgICAgICAgIHJldHVybiBQICYmICFzKFcpID8gdm9pZCAwIDogVS5jYWxsKHRoaXMsIFcgPT09IDAgPyAwIDogVyk7XG4gICAgICAgICAgfSA6IEcgPT0gXCJoYXNcIiA/IGZ1bmN0aW9uKFcpIHtcbiAgICAgICAgICAgIHJldHVybiAhKFAgJiYgIXMoVykpICYmIFUuY2FsbCh0aGlzLCBXID09PSAwID8gMCA6IFcpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbihXLCBYKSB7XG4gICAgICAgICAgICByZXR1cm4gVS5jYWxsKHRoaXMsIFcgPT09IDAgPyAwIDogVywgWCksIHRoaXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFQsIF8sIFMsIEUsIEEsIHggPSBhLmluZGV4T2YoXCJNYXBcIikgIT09IC0xLCBQID0gYS5pbmRleE9mKFwiV2Vha1wiKSAhPT0gLTEsIE0gPSB4ID8gXCJzZXRcIiA6IFwiYWRkXCIsIFIgPSB5W2FdLCBMID0gUiAmJiBSLnByb3RvdHlwZSwgRiA9IFIsIFYgPSB7fTtcbiAgICAgICAgcmV0dXJuIHUoYSwgdHlwZW9mIFIgIT0gXCJmdW5jdGlvblwiIHx8ICEoUCB8fCBMLmZvckVhY2ggJiYgIW8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3IFIoKS5lbnRyaWVzKCkubmV4dCgpO1xuICAgICAgICB9KSkpID8gKEYgPSBwLmdldENvbnN0cnVjdG9yKGMsIGEsIHgsIE0pLCBnLlJFUVVJUkVEID0gITApIDogdShhLCAhMCkgJiYgKF8gPSAoVCA9IG5ldyBGKCkpW01dKFAgPyB7fSA6IC0wLCAxKSAhPSBULCBTID0gbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICBULmhhcygxKTtcbiAgICAgICAgfSksIEUgPSBpKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICBuZXcgUihHKTtcbiAgICAgICAgfSksIEEgPSAhUCAmJiBvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIEcgPSBuZXcgUigpLCBVID0gNTsgVS0tOyApXG4gICAgICAgICAgICBHW01dKFUsIFUpO1xuICAgICAgICAgIHJldHVybiAhRy5oYXMoLTApO1xuICAgICAgICB9KSwgRSB8fCAoKChGID0gYyhmdW5jdGlvbihHLCBVKSB7XG4gICAgICAgICAgcmV0dXJuIHIoRywgRiwgYSksIEcgPSBuKG5ldyBSKCksIEcsIEYpLCBVICE9IG51bGwgJiYgZihVLCBHW01dLCBHLCB4KSwgRztcbiAgICAgICAgfSkpLnByb3RvdHlwZSA9IEwpLmNvbnN0cnVjdG9yID0gRiksIChTIHx8IEEpICYmIChqKFwiZGVsZXRlXCIpLCBqKFwiaGFzXCIpLCB4ICYmIGooXCJnZXRcIikpLCAoQSB8fCBfKSAmJiBqKE0pLCBQICYmIEwuY2xlYXIgJiYgZGVsZXRlIEwuY2xlYXIpLCBWW2FdID0gRiwgbSh7IGdsb2JhbDogITAsIGZvcmNlZDogRiAhPSBSIH0sIFYpLCBsKEYsIGEpLCBQIHx8IHAuc2V0U3Ryb25nKEYsIGEsIHgpLCBGO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCI6IDksIFwiLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvblwiOiAyNywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkXCI6IDY4LCBcIi4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YVwiOiA3MCwgXCIuLi9pbnRlcm5hbHMvaXMtZm9yY2VkXCI6IDc0LCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL2l0ZXJhdGVcIjogNzgsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWdcIjogMTE4IH1dLCAzMzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9oYXNcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL293bi1rZXlzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBoID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oZywgZikge1xuICAgICAgICBmb3IgKHZhciByID0geShmKSwgcyA9IGguZiwgbyA9IHUuZiwgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGwgPSByW2ldO1xuICAgICAgICAgIG0oZywgbCkgfHwgcyhnLCBsLCBvKGYsIGwpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiA5NCwgXCIuLi9pbnRlcm5hbHMvb3duLWtleXNcIjogMTA0IH1dLCAzNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcIm1hdGNoXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgdSA9IC8uLztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBcIi8uL1wiW3ldKHUpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHVbbV0gPSAhMSwgXCIvLi9cIlt5XSh1KTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgMzU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0ID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgSC5leHBvcnRzID0gIXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIG0oKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBtKCkpICE9PSBtLnByb3RvdHlwZTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEgfV0sIDM2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiKSwgeSA9IC9cIi9nO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24ociwgaCwgZywgZikge1xuICAgICAgICB2YXIgciA9IFN0cmluZyhtKHIpKSwgcyA9IFwiPFwiICsgaDtcbiAgICAgICAgcmV0dXJuIGcgIT09IFwiXCIgJiYgKHMgKz0gXCIgXCIgKyBnICsgJz1cIicgKyBTdHJpbmcoZikucmVwbGFjZSh5LCBcIiZxdW90O1wiKSArICdcIicpLCBzICsgXCI+XCIgKyByICsgXCI8L1wiICsgaCArIFwiPlwiO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQgfV0sIDM3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgeSA9IHQoXCIuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmVcIikuSXRlcmF0b3JQcm90b3R5cGUsIHUgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGVcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBnID0gdChcIi4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZ1wiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvaXRlcmF0b3JzXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24ociwgcywgbykge1xuICAgICAgICByZXR1cm4gcyArPSBcIiBJdGVyYXRvclwiLCByLnByb3RvdHlwZSA9IHUoeSwgeyBuZXh0OiBoKDEsIG8pIH0pLCBnKHIsIHMsICExLCAhMCksIGZbc10gPSBtLCByO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDM5LCBcIi4uL2ludGVybmFscy9pdGVyYXRvcnNcIjogODAsIFwiLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlXCI6IDc5LCBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxLCBcIi4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZ1wiOiAxMTggfV0sIDM4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvclwiKTtcbiAgICAgIEguZXhwb3J0cyA9IG0gPyBmdW5jdGlvbihoLCBnLCBmKSB7XG4gICAgICAgIHJldHVybiB5LmYoaCwgZywgdSgxLCBmKSk7XG4gICAgICB9IDogZnVuY3Rpb24oaCwgZywgZikge1xuICAgICAgICByZXR1cm4gaFtnXSA9IGYsIGg7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMzksIFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCI6IDQzLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzIH1dLCAzOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgICAgcmV0dXJuIHsgZW51bWVyYWJsZTogISgxICYgbSksIGNvbmZpZ3VyYWJsZTogISgyICYgbSksIHdyaXRhYmxlOiAhKDQgJiBtKSwgdmFsdWU6IHkgfTtcbiAgICAgIH07XG4gICAgfSwge31dLCA0MDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1wcmltaXRpdmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oaCwgZywgZikge1xuICAgICAgICBnID0gbShnKSwgZyBpbiBoID8geS5mKGgsIGcsIHUoMCwgZikpIDogaFtnXSA9IGY7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMzksIFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIjogOTMsIFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiOiAxNDEgfV0sIDQxOiBbZnVuY3Rpb24obiwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgeSA9IG4oXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB1ID0gbihcIi4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3JcIiksIGggPSBuKFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mXCIpLCBnID0gbihcIi4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZlwiKSwgZiA9IG4oXCIuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWdcIiksIHIgPSBuKFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiKSwgcyA9IG4oXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIG8gPSBuKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBpID0gbihcIi4uL2ludGVybmFscy9pcy1wdXJlXCIpLCBsID0gbihcIi4uL2ludGVybmFscy9pdGVyYXRvcnNcIiksIG4gPSBuKFwiLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlXCIpLCBhID0gbi5JdGVyYXRvclByb3RvdHlwZSwgYyA9IG4uQlVHR1lfU0FGQVJJX0lURVJBVE9SUywgcCA9IG8oXCJpdGVyYXRvclwiKSwgaiA9IFwidmFsdWVzXCIsIFQgPSBcImVudHJpZXNcIjtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKF8sIFMsIEUsIFYsIHgsIFAsIE0pIHtcbiAgICAgICAgdShFLCBTLCBWKTtcbiAgICAgICAgZnVuY3Rpb24gUihiKSB7XG4gICAgICAgICAgaWYgKGIgPT09IHggJiYgWClcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICAgIGlmICghYyAmJiBiIGluIFUpXG4gICAgICAgICAgICByZXR1cm4gVVtiXTtcbiAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJrZXlzXCI6XG4gICAgICAgICAgICBjYXNlIGo6XG4gICAgICAgICAgICBjYXNlIFQ6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEUodGhpcywgYik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRSh0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBMLCBGLCBWID0gUyArIFwiIEl0ZXJhdG9yXCIsIEcgPSAhMSwgVSA9IF8ucHJvdG90eXBlLCBXID0gVVtwXSB8fCBVW1wiQEBpdGVyYXRvclwiXSB8fCB4ICYmIFVbeF0sIFggPSAhYyAmJiBXIHx8IFIoeCksIG5lID0gUyA9PSBcIkFycmF5XCIgJiYgVS5lbnRyaWVzIHx8IFc7XG4gICAgICAgIGlmIChuZSAmJiAobmUgPSBoKG5lLmNhbGwobmV3IF8oKSkpLCBhICE9PSBPYmplY3QucHJvdG90eXBlICYmIG5lLm5leHQgJiYgKGkgfHwgaChuZSkgPT09IGEgfHwgKGcgPyBnKG5lLCBhKSA6IHR5cGVvZiBuZVtwXSAhPSBcImZ1bmN0aW9uXCIgJiYgcihuZSwgcCwgbSkpLCBmKG5lLCBWLCAhMCwgITApLCBpICYmIChsW1ZdID0gbSkpKSwgeCA9PSBqICYmIFcgJiYgVy5uYW1lICE9PSBqICYmIChHID0gITAsIFggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gVy5jYWxsKHRoaXMpO1xuICAgICAgICB9KSwgaSAmJiAhTSB8fCBVW3BdID09PSBYIHx8IHIoVSwgcCwgWCksIGxbU10gPSBYLCB4KVxuICAgICAgICAgIGlmIChMID0geyB2YWx1ZXM6IFIoaiksIGtleXM6IFAgPyBYIDogUihcImtleXNcIiksIGVudHJpZXM6IFIoVCkgfSwgTSlcbiAgICAgICAgICAgIGZvciAoRiBpbiBMKVxuICAgICAgICAgICAgICAhYyAmJiAhRyAmJiBGIGluIFUgfHwgcyhVLCBGLCBMW0ZdKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB5KHsgdGFyZ2V0OiBTLCBwcm90bzogITAsIGZvcmNlZDogYyB8fCBHIH0sIEwpO1xuICAgICAgICByZXR1cm4gTDtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3JcIjogMzcsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiOiAzOCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9pcy1wdXJlXCI6IDc2LCBcIi4uL2ludGVybmFscy9pdGVyYXRvcnNcIjogODAsIFwiLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlXCI6IDc5LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZlwiOiA5OCwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2ZcIjogMTAyLCBcIi4uL2ludGVybmFscy9yZWRlZmluZVwiOiAxMDksIFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCI6IDExOCwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5IH1dLCA0MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9wYXRoXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9oYXNcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWRcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIikuZjtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIGYgPSBtLlN5bWJvbCB8fCAobS5TeW1ib2wgPSB7fSk7XG4gICAgICAgIHkoZiwgZykgfHwgaChmLCBnLCB7IHZhbHVlOiB1LmYoZykgfSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy9wYXRoXCI6IDEwNSwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZFwiOiAxNDggfV0sIDQzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdCA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIEguZXhwb3J0cyA9ICF0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH0gfSlbMV0gIT0gNztcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEgfV0sIDQ0OiBbZnVuY3Rpb24oeSwgSCwgQykge1xuICAgICAgdmFyIG0gPSB5KFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgeSA9IHkoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCB1ID0gbS5kb2N1bWVudCwgaCA9IHkodSkgJiYgeSh1LmNyZWF0ZUVsZW1lbnQpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gaCA/IHUuY3JlYXRlRWxlbWVudChnKSA6IHt9O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1IH1dLCA0NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IHsgQ1NTUnVsZUxpc3Q6IDAsIENTU1N0eWxlRGVjbGFyYXRpb246IDAsIENTU1ZhbHVlTGlzdDogMCwgQ2xpZW50UmVjdExpc3Q6IDAsIERPTVJlY3RMaXN0OiAwLCBET01TdHJpbmdMaXN0OiAwLCBET01Ub2tlbkxpc3Q6IDEsIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLCBGaWxlTGlzdDogMCwgSFRNTEFsbENvbGxlY3Rpb246IDAsIEhUTUxDb2xsZWN0aW9uOiAwLCBIVE1MRm9ybUVsZW1lbnQ6IDAsIEhUTUxTZWxlY3RFbGVtZW50OiAwLCBNZWRpYUxpc3Q6IDAsIE1pbWVUeXBlQXJyYXk6IDAsIE5hbWVkTm9kZU1hcDogMCwgTm9kZUxpc3Q6IDEsIFBhaW50UmVxdWVzdExpc3Q6IDAsIFBsdWdpbjogMCwgUGx1Z2luQXJyYXk6IDAsIFNWR0xlbmd0aExpc3Q6IDAsIFNWR051bWJlckxpc3Q6IDAsIFNWR1BhdGhTZWdMaXN0OiAwLCBTVkdQb2ludExpc3Q6IDAsIFNWR1N0cmluZ0xpc3Q6IDAsIFNWR1RyYW5zZm9ybUxpc3Q6IDAsIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsIFN0eWxlU2hlZXRMaXN0OiAwLCBUZXh0VHJhY2tDdWVMaXN0OiAwLCBUZXh0VHJhY2tMaXN0OiAwLCBUb3VjaExpc3Q6IDAgfTtcbiAgICB9LCB7fV0sIDQ2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdCA9IHQoXCIuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnRcIiksIEguZXhwb3J0cyA9IC8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh0KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50XCI6IDQ3IH1dLCA0NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQgPSB0KFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgSC5leHBvcnRzID0gdChcIm5hdmlnYXRvclwiLCBcInVzZXJBZ2VudFwiKSB8fCBcIlwiO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluXCI6IDU3IH1dLCA0ODogW2Z1bmN0aW9uKHUsIEgsIEMpIHtcbiAgICAgIHZhciBtLCB5LCBoID0gdShcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIHUgPSB1KFwiLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50XCIpLCBoID0gaC5wcm9jZXNzLCBoID0gaCAmJiBoLnZlcnNpb25zLCBoID0gaCAmJiBoLnY4O1xuICAgICAgaCA/IHkgPSAobSA9IGguc3BsaXQoXCIuXCIpKVswXSArIG1bMV0gOiB1ICYmICghKG0gPSB1Lm1hdGNoKC9FZGdlXFwvKFxcZCspLykpIHx8IDc0IDw9IG1bMV0pICYmIChtID0gdS5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLykpICYmICh5ID0gbVsxXSksIEguZXhwb3J0cyA9IHkgJiYgK3k7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudFwiOiA0NywgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwIH1dLCA0OTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IFtcImNvbnN0cnVjdG9yXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXTtcbiAgICB9LCB7fV0sIDUwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKS5mLCB1ID0gdChcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCIpLCBnID0gdChcIi4uL2ludGVybmFscy9zZXQtZ2xvYmFsXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXNcIiksIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLWZvcmNlZFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgdmFyIGksIGwsIG4sIGEgPSBzLnRhcmdldCwgYyA9IHMuZ2xvYmFsLCBwID0gcy5zdGF0LCBqID0gYyA/IG0gOiBwID8gbVthXSB8fCBnKGEsIHt9KSA6IChtW2FdIHx8IHt9KS5wcm90b3R5cGU7XG4gICAgICAgIGlmIChqKVxuICAgICAgICAgIGZvciAoaSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAobCA9IG9baV0sIG4gPSBzLm5vVGFyZ2V0R2V0ID8gKG4gPSB5KGosIGkpKSAmJiBuLnZhbHVlIDogaltpXSwgIXIoYyA/IGkgOiBhICsgKHAgPyBcIi5cIiA6IFwiI1wiKSArIGksIHMuZm9yY2VkKSAmJiBuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsID09IHR5cGVvZiBuKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBmKGwsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHMuc2hhbSB8fCBuICYmIG4uc2hhbSkgJiYgdShsLCBcInNoYW1cIiwgITApLCBoKGosIGksIGwsIHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXNcIjogMzMsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiOiAzOCwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9pcy1mb3JjZWRcIjogNzQsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogOTQsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbFwiOiAxMTYgfV0sIDUxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24obSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAhIW0oKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHt9XSwgNTI6IFtmdW5jdGlvbihvLCBILCBDKSB7XG4gICAgICBvKFwiLi4vbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKTtcbiAgICAgIHZhciBtID0gbyhcIi4uL2ludGVybmFscy9yZWRlZmluZVwiKSwgeSA9IG8oXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHUgPSBvKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBoID0gbyhcIi4uL2ludGVybmFscy9yZWdleHAtZXhlY1wiKSwgZyA9IG8oXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCIpLCBmID0gdShcInNwZWNpZXNcIiksIHIgPSAheShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG4gPSAvLi87XG4gICAgICAgIHJldHVybiBuLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgIHJldHVybiBhLmdyb3VwcyA9IHsgYTogXCI3XCIgfSwgYTtcbiAgICAgICAgfSwgXCJcIi5yZXBsYWNlKG4sIFwiJDxhPlwiKSAhPT0gXCI3XCI7XG4gICAgICB9KSwgcyA9IFwiYVwiLnJlcGxhY2UoLy4vLCBcIiQwXCIpID09PSBcIiQwXCIsIG8gPSB1KFwicmVwbGFjZVwiKSwgaSA9ICEhLy4vW29dICYmIC8uL1tvXShcImFcIiwgXCIkMFwiKSA9PT0gXCJcIiwgbCA9ICF5KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IC8oPzopLywgbiA9IGEuZXhlYywgYSA9IChhLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBcImFiXCIuc3BsaXQoYSkpO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggIT09IDIgfHwgYVswXSAhPT0gXCJhXCIgfHwgYVsxXSAhPT0gXCJiXCI7XG4gICAgICB9KTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKG4sIGEsIGMsIHApIHtcbiAgICAgICAgdmFyIGosIFQsIF8gPSB1KG4pLCBTID0gIXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIEEgPSB7fTtcbiAgICAgICAgICByZXR1cm4gQVtfXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgfSwgXCJcIltuXShBKSAhPSA3O1xuICAgICAgICB9KSwgRSA9IFMgJiYgIXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIEEgPSAhMSwgeCA9IC9hLztcbiAgICAgICAgICByZXR1cm4gbiA9PT0gXCJzcGxpdFwiICYmICgoeCA9IHsgY29uc3RydWN0b3I6IHt9IH0pLmNvbnN0cnVjdG9yW2ZdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICB9LCB4LmZsYWdzID0gXCJcIiwgeFtfXSA9IC8uL1tfXSksIHguZXhlYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEEgPSAhMCwgbnVsbDtcbiAgICAgICAgICB9LCB4W19dKFwiXCIpLCAhQTtcbiAgICAgICAgfSk7XG4gICAgICAgIFMgJiYgRSAmJiAobiAhPT0gXCJyZXBsYWNlXCIgfHwgciAmJiBzICYmICFpKSAmJiAobiAhPT0gXCJzcGxpdFwiIHx8IGwpIHx8IChqID0gLy4vW19dLCBjID0gKEUgPSBjKF8sIFwiXCJbbl0sIGZ1bmN0aW9uKEEsIHgsIFAsIE0sIFIpIHtcbiAgICAgICAgICByZXR1cm4geC5leGVjID09PSBoID8gUyAmJiAhUiA/IHsgZG9uZTogITAsIHZhbHVlOiBqLmNhbGwoeCwgUCwgTSkgfSA6IHsgZG9uZTogITAsIHZhbHVlOiBBLmNhbGwoUCwgeCwgTSkgfSA6IHsgZG9uZTogITEgfTtcbiAgICAgICAgfSwgeyBSRVBMQUNFX0tFRVBTXyQwOiBzLCBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRTogaSB9KSlbMF0sIFQgPSBFWzFdLCBtKFN0cmluZy5wcm90b3R5cGUsIG4sIGMpLCBtKFJlZ0V4cC5wcm90b3R5cGUsIF8sIGEgPT0gMiA/IGZ1bmN0aW9uKEEsIHgpIHtcbiAgICAgICAgICByZXR1cm4gVC5jYWxsKEEsIHRoaXMsIHgpO1xuICAgICAgICB9IDogZnVuY3Rpb24oQSkge1xuICAgICAgICAgIHJldHVybiBULmNhbGwoQSwgdGhpcyk7XG4gICAgICAgIH0pKSwgcCAmJiBnKFJlZ0V4cC5wcm90b3R5cGVbX10sIFwic2hhbVwiLCAhMCk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCI6IDM4LCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIjogMTA5LCBcIi4uL2ludGVybmFscy9yZWdleHAtZXhlY1wiOiAxMTEsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSwgXCIuLi9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiB9XSwgNTM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGcsIGYsIHIsIHMsIG8sIGksIGwsIG4pIHtcbiAgICAgICAgZm9yICh2YXIgYSwgYyA9IG8sIHAgPSAwLCBqID0gISFsICYmIGgobCwgbiwgMyk7IHAgPCBzOyApIHtcbiAgICAgICAgICBpZiAocCBpbiByKSB7XG4gICAgICAgICAgICBpZiAoYSA9IGogPyBqKHJbcF0sIHAsIGYpIDogcltwXSwgMCA8IGkgJiYgeShhKSlcbiAgICAgICAgICAgICAgYyA9IG0oZywgZiwgYSwgdShhLmxlbmd0aCksIGMsIGkgLSAxKSAtIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKDkwMDcxOTkyNTQ3NDA5OTEgPD0gYylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJFeGNlZWQgdGhlIGFjY2VwdGFibGUgYXJyYXkgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICBnW2NdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLWFycmF5XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IG07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHRcIjogNTUsIFwiLi4vaW50ZXJuYWxzL2lzLWFycmF5XCI6IDczLCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3IH1dLCA1NDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQgPSB0KFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCBILmV4cG9ydHMgPSAhdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxIH1dLCA1NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hLWZ1bmN0aW9uXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSwgdSwgaCkge1xuICAgICAgICBpZiAobSh5KSwgdSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICBzd2l0Y2ggKGgpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5LmNhbGwodSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5LmNhbGwodSwgZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihnLCBmKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5LmNhbGwodSwgZywgZik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihnLCBmLCByKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5LmNhbGwodSwgZywgZiwgcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geS5hcHBseSh1LCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIjogNSB9XSwgNTY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCB1ID0gW10uc2xpY2UsIGggPSB7fTtcbiAgICAgIEguZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgZiA9IG0odGhpcyksIHIgPSB1LmNhbGwoYXJndW1lbnRzLCAxKSwgcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvID0gci5jb25jYXQodS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2Ygcykge1xuICAgICAgICAgICAgdmFyIGkgPSBmLCBsID0gby5sZW5ndGgsIG4gPSBvO1xuICAgICAgICAgICAgaWYgKCEobCBpbiBoKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBhID0gW10sIGMgPSAwOyBjIDwgbDsgYysrKVxuICAgICAgICAgICAgICAgIGFbY10gPSBcImFbXCIgKyBjICsgXCJdXCI7XG4gICAgICAgICAgICAgIGhbbF0gPSBGdW5jdGlvbihcIkMsYVwiLCBcInJldHVybiBuZXcgQyhcIiArIGEuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaFtsXShpLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkoZywgbyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB5KGYucHJvdG90eXBlKSAmJiAocy5wcm90b3R5cGUgPSBmLnByb3RvdHlwZSksIHM7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiOiA1LCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUgfV0sIDU3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyBoIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3BhdGhcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gbSh5W2hdKSB8fCBtKHVbaF0pIDogeVtoXSAmJiB5W2hdW2ddIHx8IHVbaF0gJiYgdVtoXVtnXTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL3BhdGhcIjogMTA1IH1dLCA1ODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9jbGFzc29mXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9pdGVyYXRvcnNcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpKFwiaXRlcmF0b3JcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIGlmIChoICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuIGhbdV0gfHwgaFtcIkBAaXRlcmF0b3JcIl0gfHwgeVttKGgpXTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jbGFzc29mXCI6IDI5LCBcIi4uL2ludGVybmFscy9pdGVyYXRvcnNcIjogODAsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgNTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24odSkge1xuICAgICAgICB2YXIgaCA9IHkodSk7XG4gICAgICAgIGlmICh0eXBlb2YgaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyh1KSArIFwiIGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgICAgICAgcmV0dXJuIG0oaC5jYWxsKHUpKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2RcIjogNTggfV0sIDYwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgZnVuY3Rpb24geSh1KSB7XG4gICAgICAgICAgcmV0dXJuIHUgJiYgdS5NYXRoID09IE1hdGggJiYgdTtcbiAgICAgICAgfVxuICAgICAgICBILmV4cG9ydHMgPSB5KHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsVGhpcykgfHwgeSh0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgd2luZG93KSB8fCB5KHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZikgfHwgeSh0eXBlb2YgbSA9PSBcIm9iamVjdFwiICYmIG0pIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIF9yIDwgXCJ1XCIgPyBfciA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHt9XSwgNjE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSwgdSkge1xuICAgICAgICByZXR1cm4gbS5jYWxsKHksIHUpO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDYyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgSC5leHBvcnRzID0ge307XG4gICAgfSwge31dLCA2MzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih5LCB1KSB7XG4gICAgICAgIHZhciBoID0gbS5jb25zb2xlO1xuICAgICAgICBoICYmIGguZXJyb3IgJiYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoLmVycm9yKHkpIDogaC5lcnJvcih5LCB1KSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwIH1dLCA2NDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQgPSB0KFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgSC5leHBvcnRzID0gdChcImRvY3VtZW50XCIsIFwiZG9jdW1lbnRFbGVtZW50XCIpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluXCI6IDU3IH1dLCA2NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50XCIpO1xuICAgICAgSC5leHBvcnRzID0gIW0gJiYgIXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodShcImRpdlwiKSwgXCJhXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfSB9KS5hICE9IDc7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCI6IDQzLCBcIi4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudFwiOiA0NCwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEgfV0sIDY2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSBNYXRoLmFicywgeSA9IE1hdGgucG93LCB1ID0gTWF0aC5mbG9vciwgaCA9IE1hdGgubG9nLCBnID0gTWF0aC5MTjI7XG4gICAgICBILmV4cG9ydHMgPSB7IHBhY2s6IGZ1bmN0aW9uKGYsIHIsIGMpIHtcbiAgICAgICAgdmFyIG8sIGksIGwsIG4gPSBuZXcgQXJyYXkoYyksIGEgPSA4ICogYyAtIHIgLSAxLCBjID0gKDEgPDwgYSkgLSAxLCBwID0gYyA+PiAxLCBqID0gciA9PT0gMjMgPyB5KDIsIC0yNCkgLSB5KDIsIC03NykgOiAwLCBUID0gZiA8IDAgfHwgZiA9PT0gMCAmJiAxIC8gZiA8IDAgPyAxIDogMCwgXyA9IDA7XG4gICAgICAgIGZvciAoKGYgPSBtKGYpKSAhPSBmIHx8IGYgPT09IDEgLyAwID8gKGkgPSBmICE9IGYgPyAxIDogMCwgbyA9IGMpIDogKG8gPSB1KGgoZikgLyBnKSwgZiAqIChsID0geSgyLCAtbykpIDwgMSAmJiAoby0tLCBsICo9IDIpLCAyIDw9IChmICs9IDEgPD0gbyArIHAgPyBqIC8gbCA6IGogKiB5KDIsIDEgLSBwKSkgKiBsICYmIChvKyssIGwgLz0gMiksIGMgPD0gbyArIHAgPyAoaSA9IDAsIG8gPSBjKSA6IDEgPD0gbyArIHAgPyAoaSA9IChmICogbCAtIDEpICogeSgyLCByKSwgbyArPSBwKSA6IChpID0gZiAqIHkoMiwgcCAtIDEpICogeSgyLCByKSwgbyA9IDApKTsgOCA8PSByOyBuW18rK10gPSAyNTUgJiBpLCBpIC89IDI1NiwgciAtPSA4KVxuICAgICAgICAgIDtcbiAgICAgICAgZm9yIChvID0gbyA8PCByIHwgaSwgYSArPSByOyAwIDwgYTsgbltfKytdID0gMjU1ICYgbywgbyAvPSAyNTYsIGEgLT0gOClcbiAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBuWy0tX10gfD0gMTI4ICogVCwgbjtcbiAgICAgIH0sIHVucGFjazogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICB2YXIgcywgbyA9IGYubGVuZ3RoLCBjID0gOCAqIG8gLSByIC0gMSwgaSA9ICgxIDw8IGMpIC0gMSwgbCA9IGkgPj4gMSwgbiA9IGMgLSA3LCBhID0gbyAtIDEsIGMgPSBmW2EtLV0sIHAgPSAxMjcgJiBjO1xuICAgICAgICBmb3IgKGMgPj49IDc7IDAgPCBuOyBwID0gMjU2ICogcCArIGZbYV0sIGEtLSwgbiAtPSA4KVxuICAgICAgICAgIDtcbiAgICAgICAgZm9yIChzID0gcCAmICgxIDw8IC1uKSAtIDEsIHAgPj49IC1uLCBuICs9IHI7IDAgPCBuOyBzID0gMjU2ICogcyArIGZbYV0sIGEtLSwgbiAtPSA4KVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKHAgPT09IDApXG4gICAgICAgICAgcCA9IDEgLSBsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAocCA9PT0gaSlcbiAgICAgICAgICAgIHJldHVybiBzID8gTmFOIDogYyA/IC0xIC8gMCA6IDEgLyAwO1xuICAgICAgICAgIHMgKz0geSgyLCByKSwgcCAtPSBsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYyA/IC0xIDogMSkgKiBzICogeSgyLCBwIC0gcik7XG4gICAgICB9IH07XG4gICAgfSwge31dLCA2NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIiksIHUgPSBcIlwiLnNwbGl0O1xuICAgICAgSC5leHBvcnRzID0gbShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFPYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xuICAgICAgfSkgPyBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB5KGgpID09IFwiU3RyaW5nXCIgPyB1LmNhbGwoaCwgXCJcIikgOiBPYmplY3QoaCk7XG4gICAgICB9IDogT2JqZWN0O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIjogMjgsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxIH1dLCA2ODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24odSwgaCwgZykge1xuICAgICAgICByZXR1cm4geSAmJiB0eXBlb2YgKGggPSBoLmNvbnN0cnVjdG9yKSA9PSBcImZ1bmN0aW9uXCIgJiYgaCAhPT0gZyAmJiBtKGggPSBoLnByb3RvdHlwZSkgJiYgaCAhPT0gZy5wcm90b3R5cGUgJiYgeSh1LCBoKSwgdTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mXCI6IDEwMiB9XSwgNjk6IFtmdW5jdGlvbihtLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IG0oXCIuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlXCIpLCB5ID0gRnVuY3Rpb24udG9TdHJpbmc7XG4gICAgICB0eXBlb2YgbS5pbnNwZWN0U291cmNlICE9IFwiZnVuY3Rpb25cIiAmJiAobS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4geS5jYWxsKHUpO1xuICAgICAgfSksIEguZXhwb3J0cyA9IG0uaW5zcGVjdFNvdXJjZTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZVwiOiAxMjAgfV0sIDcwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShuKSB7XG4gICAgICAgIGcobiwgcywgeyB2YWx1ZTogeyBvYmplY3RJRDogXCJPXCIgKyArK28sIHdlYWtEYXRhOiB7fSB9IH0pO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCBmID0gdChcIi4uL2ludGVybmFscy91aWRcIiksIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2ZyZWV6aW5nXCIpLCBzID0gZihcIm1ldGFcIiksIG8gPSAwLCBpID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgbCA9IEguZXhwb3J0cyA9IHsgUkVRVUlSRUQ6ICExLCBmYXN0S2V5OiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgIGlmICghdShuKSlcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT0gXCJzeW1ib2xcIiA/IG4gOiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IFwiU1wiIDogXCJQXCIpICsgbjtcbiAgICAgICAgaWYgKCFoKG4sIHMpKSB7XG4gICAgICAgICAgaWYgKCFpKG4pKVxuICAgICAgICAgICAgcmV0dXJuIFwiRlwiO1xuICAgICAgICAgIGlmICghYSlcbiAgICAgICAgICAgIHJldHVybiBcIkVcIjtcbiAgICAgICAgICBtKG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuW3NdLm9iamVjdElEO1xuICAgICAgfSwgZ2V0V2Vha0RhdGE6IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgaWYgKCFoKG4sIHMpKSB7XG4gICAgICAgICAgaWYgKCFpKG4pKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGlmICghYSlcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBtKG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuW3NdLndlYWtEYXRhO1xuICAgICAgfSwgb25GcmVlemU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHIgJiYgbC5SRVFVSVJFRCAmJiBpKG4pICYmICFoKG4sIHMpICYmIG0obiksIG47XG4gICAgICB9IH07XG4gICAgICB5W3NdID0gITA7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9mcmVlemluZ1wiOiA1NCwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9oaWRkZW4ta2V5c1wiOiA2MiwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy91aWRcIjogMTQ2IH1dLCA3MTogW2Z1bmN0aW9uKGMsIEgsIEMpIHtcbiAgICAgIHZhciBtLCB5LCB1LCBoLCBnLCBmLCByLCBzLCBvID0gYyhcIi4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXBcIiksIHAgPSBjKFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgaSA9IGMoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCBsID0gYyhcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIiksIG4gPSBjKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgYSA9IGMoXCIuLi9pbnRlcm5hbHMvc2hhcmVkLWtleVwiKSwgYyA9IGMoXCIuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXNcIiksIHAgPSBwLldlYWtNYXA7XG4gICAgICByID0gbyA/IChtID0gbmV3IHAoKSwgeSA9IG0uZ2V0LCB1ID0gbS5oYXMsIGggPSBtLnNldCwgZyA9IGZ1bmN0aW9uKGosIFQpIHtcbiAgICAgICAgcmV0dXJuIGguY2FsbChtLCBqLCBUKSwgVDtcbiAgICAgIH0sIGYgPSBmdW5jdGlvbihqKSB7XG4gICAgICAgIHJldHVybiB5LmNhbGwobSwgaikgfHwge307XG4gICAgICB9LCBmdW5jdGlvbihqKSB7XG4gICAgICAgIHJldHVybiB1LmNhbGwobSwgaik7XG4gICAgICB9KSA6IChjW3MgPSBhKFwic3RhdGVcIildID0gITAsIGcgPSBmdW5jdGlvbihqLCBUKSB7XG4gICAgICAgIHJldHVybiBsKGosIHMsIFQpLCBUO1xuICAgICAgfSwgZiA9IGZ1bmN0aW9uKGopIHtcbiAgICAgICAgcmV0dXJuIG4oaiwgcykgPyBqW3NdIDoge307XG4gICAgICB9LCBmdW5jdGlvbihqKSB7XG4gICAgICAgIHJldHVybiBuKGosIHMpO1xuICAgICAgfSksIEguZXhwb3J0cyA9IHsgc2V0OiBnLCBnZXQ6IGYsIGhhczogciwgZW5mb3JjZTogZnVuY3Rpb24oaikge1xuICAgICAgICByZXR1cm4gcihqKSA/IGYoaikgOiBnKGosIHt9KTtcbiAgICAgIH0sIGdldHRlckZvcjogZnVuY3Rpb24oaikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oVCkge1xuICAgICAgICAgIGlmIChpKFQpICYmIChUID0gZihUKSkudHlwZSA9PT0gailcbiAgICAgICAgICAgIHJldHVybiBUO1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkluY29tcGF0aWJsZSByZWNlaXZlciwgXCIgKyBqICsgXCIgcmVxdWlyZWRcIik7XG4gICAgICAgIH07XG4gICAgICB9IH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9oaWRkZW4ta2V5c1wiOiA2MiwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXBcIjogODYsIFwiLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXlcIjogMTE5IH1dLCA3MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvaXRlcmF0b3JzXCIpLCB1ID0gbShcIml0ZXJhdG9yXCIpLCBoID0gQXJyYXkucHJvdG90eXBlO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gZyAhPT0gdm9pZCAwICYmICh5LkFycmF5ID09PSBnIHx8IGhbdV0gPT09IGcpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2l0ZXJhdG9yc1wiOiA4MCwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5IH1dLCA3MzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9jbGFzc29mLXJhd1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gbSh5KSA9PSBcIkFycmF5XCI7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIjogMjggfV0sIDc0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShzLCBvKSB7XG4gICAgICAgIHJldHVybiAocyA9IGdbaChzKV0pID09IHIgfHwgcyAhPSBmICYmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyB5KG8pIDogISFvKTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgdSA9IC8jfFxcLnByb3RvdHlwZVxcLi8sIGggPSBtLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKHUsIFwiLlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSwgZyA9IG0uZGF0YSA9IHt9LCBmID0gbS5OQVRJVkUgPSBcIk5cIiwgciA9IG0uUE9MWUZJTEwgPSBcIlBcIjtcbiAgICAgIEguZXhwb3J0cyA9IG07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSB9XSwgNzU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbSA9PSBcIm9iamVjdFwiID8gbSAhPT0gbnVsbCA6IHR5cGVvZiBtID09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH07XG4gICAgfSwge31dLCA3NjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9ICExO1xuICAgIH0sIHt9XSwgNzc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9jbGFzc29mLXJhd1wiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIikoXCJtYXRjaFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIHJldHVybiBtKGgpICYmICgoZyA9IGhbdV0pICE9PSB2b2lkIDAgPyAhIWcgOiB5KGgpID09IFwiUmVnRXhwXCIpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCI6IDI4LCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgNzg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHMsIG8pIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gcywgdGhpcy5yZXN1bHQgPSBvO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kXCIpLCBoID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIGcgPSB0KFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZFwiKSwgciA9IHQoXCIuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmdcIik7XG4gICAgICAoSC5leHBvcnRzID0gZnVuY3Rpb24ocywgbywgaSwgbCwgbikge1xuICAgICAgICB2YXIgYSwgYywgcCwgaiwgVCwgXywgUyA9IGcobywgaSwgbCA/IDIgOiAxKTtcbiAgICAgICAgaWYgKG4pXG4gICAgICAgICAgYSA9IHM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgKG8gPSBmKHMpKSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJUYXJnZXQgaXMgbm90IGl0ZXJhYmxlXCIpO1xuICAgICAgICAgIGlmICh1KG8pKSB7XG4gICAgICAgICAgICBmb3IgKGMgPSAwLCBwID0gaChzLmxlbmd0aCk7IGMgPCBwOyBjKyspXG4gICAgICAgICAgICAgIGlmICgoaiA9IGwgPyBTKHkoXyA9IHNbY10pWzBdLCBfWzFdKSA6IFMoc1tjXSkpICYmIGogaW5zdGFuY2VvZiBtKVxuICAgICAgICAgICAgICAgIHJldHVybiBqO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYSA9IG8uY2FsbChzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFQgPSBhLm5leHQ7ICEoXyA9IFQuY2FsbChhKSkuZG9uZTsgKVxuICAgICAgICAgIGlmICh0eXBlb2YgKGogPSByKGEsIFMsIF8udmFsdWUsIGwpKSA9PSBcIm9iamVjdFwiICYmIGogJiYgaiBpbnN0YW5jZW9mIG0pXG4gICAgICAgICAgICByZXR1cm4gajtcbiAgICAgICAgcmV0dXJuIG5ldyBtKCExKTtcbiAgICAgIH0pLnN0b3AgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuZXcgbSghMCwgcyk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZ1wiOiAyNiwgXCIuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0XCI6IDU1LCBcIi4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kXCI6IDU4LCBcIi4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2RcIjogNzIsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcgfV0sIDc5OiBbZnVuY3Rpb24oZiwgSCwgQykge1xuICAgICAgdmFyIG0sIHksIHUgPSBmKFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mXCIpLCBoID0gZihcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIiksIGcgPSBmKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgciA9IGYoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIGYgPSBmKFwiLi4vaW50ZXJuYWxzL2lzLXB1cmVcIiksIHIgPSByKFwiaXRlcmF0b3JcIiksIHMgPSAhMTtcbiAgICAgIFtdLmtleXMgJiYgKFwibmV4dFwiIGluICh5ID0gW10ua2V5cygpKSA/ICh1ID0gdSh1KHkpKSkgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgKG0gPSB1KSA6IHMgPSAhMCksIG0gPT0gbnVsbCAmJiAobSA9IHt9KSwgZiB8fCBnKG0sIHIpIHx8IGgobSwgciwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSksIEguZXhwb3J0cyA9IHsgSXRlcmF0b3JQcm90b3R5cGU6IG0sIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IHMgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiOiAzOCwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9pcy1wdXJlXCI6IDc2LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZlwiOiA5OCwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5IH1dLCA4MDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IHt9O1xuICAgIH0sIHt9XSwgODE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gKG0gPSArbSkgPT0gMCB8fCBtICE9IG0gPyBtIDogbSA8IDAgPyAtMSA6IDE7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgODI6IFtmdW5jdGlvbihsLCBILCBDKSB7XG4gICAgICB2YXIgbSwgeSwgdSwgaCwgZywgZiwgciwgcywgbyA9IGwoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCBUID0gbChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLmYsIGogPSBsKFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCIpLCBpID0gbChcIi4uL2ludGVybmFscy90YXNrXCIpLnNldCwgbCA9IGwoXCIuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvc1wiKSwgbiA9IG8uTXV0YXRpb25PYnNlcnZlciB8fCBvLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsIGEgPSBvLnByb2Nlc3MsIGMgPSBvLlByb21pc2UsIHAgPSBqKGEpID09IFwicHJvY2Vzc1wiLCBqID0gVChvLCBcInF1ZXVlTWljcm90YXNrXCIpLCBUID0gaiAmJiBqLnZhbHVlO1xuICAgICAgVCB8fCAobSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXywgUztcbiAgICAgICAgZm9yIChwICYmIChfID0gYS5kb21haW4pICYmIF8uZXhpdCgpOyB5OyApIHtcbiAgICAgICAgICBTID0geS5mbiwgeSA9IHkubmV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUygpO1xuICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIHRocm93IHkgPyBoKCkgOiB1ID0gdm9pZCAwLCBFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1ID0gdm9pZCAwLCBfICYmIF8uZW50ZXIoKTtcbiAgICAgIH0sIGggPSBwID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIGEubmV4dFRpY2sobSk7XG4gICAgICB9IDogbiAmJiAhbCA/IChnID0gITAsIGYgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSwgbmV3IG4obSkub2JzZXJ2ZShmLCB7IGNoYXJhY3RlckRhdGE6ICEwIH0pLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZi5kYXRhID0gZyA9ICFnO1xuICAgICAgfSkgOiBjICYmIGMucmVzb2x2ZSA/IChyID0gYy5yZXNvbHZlKHZvaWQgMCksIHMgPSByLnRoZW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICBzLmNhbGwociwgbSk7XG4gICAgICB9KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpLmNhbGwobywgbSk7XG4gICAgICB9KSwgSC5leHBvcnRzID0gVCB8fCBmdW5jdGlvbihfKSB7XG4gICAgICAgIF8gPSB7IGZuOiBfLCBuZXh0OiB2b2lkIDAgfSwgdSAmJiAodS5uZXh0ID0gXyksIHkgfHwgKHkgPSBfLCBoKCkpLCB1ID0gXztcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jbGFzc29mLXJhd1wiOiAyOCwgXCIuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvc1wiOiA0NiwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDk0LCBcIi4uL2ludGVybmFscy90YXNrXCI6IDEzMSB9XSwgODM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0ID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIEguZXhwb3J0cyA9IHQuUHJvbWlzZTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCB9XSwgODQ6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0ID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgSC5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICF0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxIH1dLCA4NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLXB1cmVcIiksIGggPSB5KFwiaXRlcmF0b3JcIik7XG4gICAgICBILmV4cG9ydHMgPSAhbShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBuZXcgVVJMKFwiYj9hPTEmYj0yJmM9M1wiLCBcImh0dHA6Ly9hXCIpLCBmID0gZy5zZWFyY2hQYXJhbXMsIHIgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZy5wYXRobmFtZSA9IFwiYyUyMGRcIiwgZi5mb3JFYWNoKGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgICBmLmRlbGV0ZShcImJcIiksIHIgKz0gbyArIHM7XG4gICAgICAgIH0pLCB1ICYmICFnLnRvSlNPTiB8fCAhZi5zb3J0IHx8IGcuaHJlZiAhPT0gXCJodHRwOi8vYS9jJTIwZD9hPTEmYz0zXCIgfHwgZi5nZXQoXCJjXCIpICE9PSBcIjNcIiB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcyhcIj9hPTFcIikpICE9PSBcImE9MVwiIHx8ICFmW2hdIHx8IG5ldyBVUkwoXCJodHRwczovL2FAYlwiKS51c2VybmFtZSAhPT0gXCJhXCIgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKFwiYT1iXCIpKS5nZXQoXCJhXCIpICE9PSBcImJcIiB8fCBuZXcgVVJMKFwiaHR0cDovL9GC0LXRgdGCXCIpLmhvc3QgIT09IFwieG4tLWUxYXliY1wiIHx8IG5ldyBVUkwoXCJodHRwOi8vYSPQsVwiKS5oYXNoICE9PSBcIiMlRDAlQjFcIiB8fCByICE9PSBcImExYzNcIiB8fCBuZXcgVVJMKFwiaHR0cDovL3hcIiwgdm9pZCAwKS5ob3N0ICE9PSBcInhcIjtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL2lzLXB1cmVcIjogNzYsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgODY6IFtmdW5jdGlvbihtLCBILCBDKSB7XG4gICAgICB2YXIgeSA9IG0oXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCBtID0gbShcIi4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZVwiKSwgeSA9IHkuV2Vha01hcDtcbiAgICAgIEguZXhwb3J0cyA9IHR5cGVvZiB5ID09IFwiZnVuY3Rpb25cIiAmJiAvbmF0aXZlIGNvZGUvLnRlc3QobSh5KSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlXCI6IDY5IH1dLCA4NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0odSkge1xuICAgICAgICB2YXIgaCwgZztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IHUoZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIGlmIChoICE9PSB2b2lkIDAgfHwgZyAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgaCA9IGYsIGcgPSByO1xuICAgICAgICB9KSwgdGhpcy5yZXNvbHZlID0geShoKSwgdGhpcy5yZWplY3QgPSB5KGcpO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIik7XG4gICAgICBILmV4cG9ydHMuZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtKHUpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIjogNSB9XSwgODg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtcmVnZXhwXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAobSh5KSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cFwiOiA3NyB9XSwgODk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLmlzRmluaXRlO1xuICAgICAgSC5leHBvcnRzID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB5ID09IFwibnVtYmVyXCIgJiYgbSh5KTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAgfV0sIDkwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXNcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHNcIiksIGcgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlXCIpLCBmID0gdChcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0XCIpLCBzID0gT2JqZWN0LmFzc2lnbiwgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICAgIEguZXhwb3J0cyA9ICFzIHx8IHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBsLCBuLCBhO1xuICAgICAgICByZXR1cm4gISghbSB8fCBzKHsgYjogMSB9LCBzKG8oe30sIFwiYVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG8odGhpcywgXCJiXCIsIHsgdmFsdWU6IDMsIGVudW1lcmFibGU6ICExIH0pO1xuICAgICAgICB9IH0pLCB7IGI6IDIgfSkpLmIgPT09IDEpIHx8IChsID0ge30sIGEgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0XCIsIChpID0ge30pW24gPSBTeW1ib2woKV0gPSA3LCBhLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgIGxbY10gPSBjO1xuICAgICAgICB9KSwgcyh7fSwgaSlbbl0gIT0gNyB8fCB1KHMoe30sIGwpKS5qb2luKFwiXCIpICE9IGEpO1xuICAgICAgfSkgPyBmdW5jdGlvbihpLCBsKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSBmKGkpLCBhID0gYXJndW1lbnRzLmxlbmd0aCwgYyA9IDEsIHAgPSBoLmYsIGogPSBnLmY7IGMgPCBhOyApXG4gICAgICAgICAgZm9yICh2YXIgVCwgXyA9IHIoYXJndW1lbnRzW2MrK10pLCBTID0gcCA/IHUoXykuY29uY2F0KHAoXykpIDogdShfKSwgRSA9IFMubGVuZ3RoLCBBID0gMDsgQSA8IEU7IClcbiAgICAgICAgICAgIFQgPSBTW0ErK10sIG0gJiYgIWouY2FsbChfLCBUKSB8fCAobltUXSA9IF9bVF0pO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0gOiBzO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdFwiOiA2NywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9sc1wiOiA5NywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXNcIjogMTAwLCBcIi4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZVwiOiAxMDEsIFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiOiAxMzggfV0sIDkxOiBbZnVuY3Rpb24obywgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgIH1cbiAgICAgIHZhciB5LCB1ID0gbyhcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIGggPSBvKFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllc1wiKSwgZyA9IG8oXCIuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5c1wiKSwgZiA9IG8oXCIuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXNcIiksIHIgPSBvKFwiLi4vaW50ZXJuYWxzL2h0bWxcIiksIHMgPSBvKFwiLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50XCIpLCBvID0gbyhcIi4uL2ludGVybmFscy9zaGFyZWQta2V5XCIpLCBpID0gXCJwcm90b3R5cGVcIiwgbCA9IFwic2NyaXB0XCIsIG4gPSBvKFwiSUVfUFJPVE9cIiksIGEgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBcIjxcIiArIGwgKyBcIj5cIiArIHAgKyBcIjwvXCIgKyBsICsgXCI+XCI7XG4gICAgICB9LCBjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeSA9IGRvY3VtZW50LmRvbWFpbiAmJiBuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBjID0geSA/ICgocCA9IHkpLndyaXRlKGEoXCJcIikpLCBwLmNsb3NlKCksIGogPSBwLnBhcmVudFdpbmRvdy5PYmplY3QsIHAgPSBudWxsLCBqKSA6IChwID0gcyhcImlmcmFtZVwiKSwgaiA9IFwiamF2YVwiICsgbCArIFwiOlwiLCBwLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgci5hcHBlbmRDaGlsZChwKSwgcC5zcmMgPSBTdHJpbmcoaiksIChqID0gcC5jb250ZW50V2luZG93LmRvY3VtZW50KS5vcGVuKCksIGoud3JpdGUoYShcImRvY3VtZW50LkY9T2JqZWN0XCIpKSwgai5jbG9zZSgpLCBqLkYpO1xuICAgICAgICBmb3IgKHZhciBwLCBqLCBUID0gZy5sZW5ndGg7IFQtLTsgKVxuICAgICAgICAgIGRlbGV0ZSBjW2ldW2dbVF1dO1xuICAgICAgICByZXR1cm4gYygpO1xuICAgICAgfTtcbiAgICAgIGZbbl0gPSAhMCwgSC5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihwLCBqKSB7XG4gICAgICAgIHZhciBUO1xuICAgICAgICByZXR1cm4gcCAhPT0gbnVsbCA/IChtW2ldID0gdShwKSwgVCA9IG5ldyBtKCksIG1baV0gPSBudWxsLCBUW25dID0gcCkgOiBUID0gYygpLCBqID09PSB2b2lkIDAgPyBUIDogaChULCBqKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50XCI6IDQ0LCBcIi4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzXCI6IDQ5LCBcIi4uL2ludGVybmFscy9oaWRkZW4ta2V5c1wiOiA2MiwgXCIuLi9pbnRlcm5hbHMvaHRtbFwiOiA2NCwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzXCI6IDkyLCBcIi4uL2ludGVybmFscy9zaGFyZWQta2V5XCI6IDExOSB9XSwgOTI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXNcIik7XG4gICAgICBILmV4cG9ydHMgPSBtID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbihnLCBmKSB7XG4gICAgICAgIHUoZyk7XG4gICAgICAgIGZvciAodmFyIHIsIHMgPSBoKGYpLCBvID0gcy5sZW5ndGgsIGkgPSAwOyBpIDwgbzsgKVxuICAgICAgICAgIHkuZihnLCByID0gc1tpKytdLCBmW3JdKTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXNcIjogMTAwIH1dLCA5MzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmVcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlXCIpLCBnID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgICAgQy5mID0gbSA/IGcgOiBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgIGlmICh1KGYpLCByID0gaChyLCAhMCksIHUocyksIHkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnKGYsIHIsIHMpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKFwiZ2V0XCIgaW4gcyB8fCBcInNldFwiIGluIHMpXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIHJldHVybiBcInZhbHVlXCIgaW4gcyAmJiAoZltyXSA9IHMudmFsdWUpLCBmO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiOiAxMCwgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lXCI6IDY1LCBcIi4uL2ludGVybmFscy90by1wcmltaXRpdmVcIjogMTQxIH1dLCA5NDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGVcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBoID0gdChcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9oYXNcIiksIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lXCIpLCBzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIEMuZiA9IG0gPyBzIDogZnVuY3Rpb24obywgaSkge1xuICAgICAgICBpZiAobyA9IGgobyksIGkgPSBnKGksICEwKSwgcilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHMobywgaSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoZihvLCBpKSlcbiAgICAgICAgICByZXR1cm4gdSgheS5mLmNhbGwobywgaSksIG9baV0pO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDM5LCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZVwiOiA2NSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGVcIjogMTAxLCBcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiOiAxMzUsIFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiOiAxNDEgfV0sIDk1OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKS5mLCB1ID0ge30udG9TdHJpbmcsIGggPSB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuICAgICAgSC5leHBvcnRzLmYgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmICghaCB8fCB1LmNhbGwoZykgIT0gXCJbb2JqZWN0IFdpbmRvd11cIilcbiAgICAgICAgICByZXR1cm4geShtKGcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4geShnKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIGguc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzXCI6IDk2LCBcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiOiAxMzUgfV0sIDk2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzXCIpLmNvbmNhdChcImxlbmd0aFwiLCBcInByb3RvdHlwZVwiKTtcbiAgICAgIEMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG0odSwgeSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5c1wiOiA0OSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWxcIjogOTkgfV0sIDk3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgQy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiAgICB9LCB7fV0sIDk4OiBbZnVuY3Rpb24oaCwgSCwgQykge1xuICAgICAgdmFyIG0gPSBoKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgeSA9IGgoXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCIpLCB1ID0gaChcIi4uL2ludGVybmFscy9zaGFyZWQta2V5XCIpLCBoID0gaChcIi4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXJcIiksIGcgPSB1KFwiSUVfUFJPVE9cIiksIGYgPSBPYmplY3QucHJvdG90eXBlO1xuICAgICAgSC5leHBvcnRzID0gaCA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgPSB5KHIpLCBtKHIsIGcpID8gcltnXSA6IHR5cGVvZiByLmNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIiAmJiByIGluc3RhbmNlb2Ygci5jb25zdHJ1Y3RvciA/IHIuY29uc3RydWN0b3IucHJvdG90eXBlIDogciBpbnN0YW5jZW9mIE9iamVjdCA/IGYgOiBudWxsO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlclwiOiAzNSwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9zaGFyZWQta2V5XCI6IDExOSwgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCB9XSwgOTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIikuaW5kZXhPZiwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXNcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihnLCBmKSB7XG4gICAgICAgIHZhciByLCBzID0geShnKSwgbyA9IDAsIGkgPSBbXTtcbiAgICAgICAgZm9yIChyIGluIHMpXG4gICAgICAgICAgIW0oaCwgcikgJiYgbShzLCByKSAmJiBpLnB1c2gocik7XG4gICAgICAgIGZvciAoOyBmLmxlbmd0aCA+IG87IClcbiAgICAgICAgICAhbShzLCByID0gZltvKytdKSB8fCB+dShpLCByKSB8fCBpLnB1c2gocik7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzXCI6IDE4LCBcIi4uL2ludGVybmFscy9oYXNcIjogNjEsIFwiLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzXCI6IDYyLCBcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiOiAxMzUgfV0sIDEwMDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5c1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG0odSwgeSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5c1wiOiA0OSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWxcIjogOTkgfV0sIDEwMTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGUsIHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCB1ID0geSAmJiAhbS5jYWxsKHsgMTogMiB9LCAxKTtcbiAgICAgIEMuZiA9IHUgPyBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiBoID0geSh0aGlzLCBoKSwgISFoICYmIGguZW51bWVyYWJsZTtcbiAgICAgIH0gOiBtO1xuICAgIH0sIHt9XSwgMTAyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGVcIik7XG4gICAgICBILmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKFwiX19wcm90b19fXCIgaW4ge30gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHUsIGggPSAhMSwgZyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICh1ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCBcIl9fcHJvdG9fX1wiKS5zZXQpLmNhbGwoZywgW10pLCBoID0gZyBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIHJldHVybiBtKGYpLCB5KHIpLCBoID8gdS5jYWxsKGYsIHIpIDogZi5fX3Byb3RvX18gPSByLCBmO1xuICAgICAgICB9O1xuICAgICAgfSgpIDogdm9pZCAwKTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlXCI6IDYsIFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiOiAxMCB9XSwgMTAzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvY2xhc3NvZlwiKTtcbiAgICAgIEguZXhwb3J0cyA9IG0gPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFwiICsgeSh0aGlzKSArIFwiXVwiO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NsYXNzb2ZcIjogMjksIFwiLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydFwiOiAxNDIgfV0sIDEwNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9nZXQtYnVpbHQtaW5cIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzXCIpLCBoID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIik7XG4gICAgICBILmV4cG9ydHMgPSBtKFwiUmVmbGVjdFwiLCBcIm93bktleXNcIikgfHwgZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgZiA9IHkuZihoKGcpKSwgciA9IHUuZjtcbiAgICAgICAgcmV0dXJuIHIgPyBmLmNvbmNhdChyKGcpKSA6IGY7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9nZXQtYnVpbHQtaW5cIjogNTcsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzXCI6IDk2LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzXCI6IDk3IH1dLCAxMDU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0ID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIEguZXhwb3J0cyA9IHQ7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAgfV0sIDEwNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogITEsIHZhbHVlOiBtKCkgfTtcbiAgICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICAgIHJldHVybiB7IGVycm9yOiAhMCwgdmFsdWU6IHkgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7fV0sIDEwNzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eVwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgcmV0dXJuIG0oaCksIHkoZykgJiYgZy5jb25zdHJ1Y3RvciA9PT0gaCA/IGcgOiAoKDAsIChoID0gdS5mKGgpKS5yZXNvbHZlKShnKSwgaC5wcm9taXNlKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSwgXCIuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eVwiOiA4NyB9XSwgMTA4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSwgdSwgaCkge1xuICAgICAgICBmb3IgKHZhciBnIGluIHUpXG4gICAgICAgICAgbSh5LCBnLCB1W2ddLCBoKTtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIjogMTA5IH1dLCAxMDk6IFtmdW5jdGlvbihmLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGYoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCB5ID0gZihcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIiksIHUgPSBmKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgaCA9IGYoXCIuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbFwiKSwgZyA9IGYoXCIuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2VcIiksIGYgPSBmKFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCIpLCByID0gZi5nZXQsIHMgPSBmLmVuZm9yY2UsIG8gPSBTdHJpbmcoU3RyaW5nKS5zcGxpdChcIlN0cmluZ1wiKTtcbiAgICAgIChILmV4cG9ydHMgPSBmdW5jdGlvbihpLCBsLCBuLCBqKSB7XG4gICAgICAgIHZhciBjID0gISFqICYmICEhai51bnNhZmUsIHAgPSAhIWogJiYgISFqLmVudW1lcmFibGUsIGogPSAhIWogJiYgISFqLm5vVGFyZ2V0R2V0O1xuICAgICAgICB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBsICE9IFwic3RyaW5nXCIgfHwgdShuLCBcIm5hbWVcIikgfHwgeShuLCBcIm5hbWVcIiwgbCksIHMobikuc291cmNlID0gby5qb2luKHR5cGVvZiBsID09IFwic3RyaW5nXCIgPyBsIDogXCJcIikpLCBpID09PSBtID8gcCA/IGlbbF0gPSBuIDogaChsLCBuKSA6IChjID8gIWogJiYgaVtsXSAmJiAocCA9ICEwKSA6IGRlbGV0ZSBpW2xdLCBwID8gaVtsXSA9IG4gOiB5KGksIGwsIG4pKTtcbiAgICAgIH0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzID09IFwiZnVuY3Rpb25cIiAmJiByKHRoaXMpLnNvdXJjZSB8fCBnKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZVwiOiA2OSwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIjogNzEsIFwiLi4vaW50ZXJuYWxzL3NldC1nbG9iYWxcIjogMTE2IH1dLCAxMTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuL2NsYXNzb2YtcmF3XCIpLCB5ID0gdChcIi4vcmVnZXhwLWV4ZWNcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIHZhciBnID0gdS5leGVjO1xuICAgICAgICBpZiAodHlwZW9mIGcgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKGcgPSBnLmNhbGwodSwgaCksIHR5cGVvZiBnICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGxcIik7XG4gICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0odSkgIT09IFwiUmVnRXhwXCIpXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlclwiKTtcbiAgICAgICAgcmV0dXJuIHkuY2FsbCh1LCBoKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4vY2xhc3NvZi1yYXdcIjogMjgsIFwiLi9yZWdleHAtZXhlY1wiOiAxMTEgfV0sIDExMTogW2Z1bmN0aW9uKGgsIEgsIEMpIHtcbiAgICAgIHZhciBtLCB5LCB1ID0gaChcIi4vcmVnZXhwLWZsYWdzXCIpLCBoID0gaChcIi4vcmVnZXhwLXN0aWNreS1oZWxwZXJzXCIpLCBnID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLCBmID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLCByID0gZywgcyA9IChtID0gL2EvLCB5ID0gL2IqL2csIGcuY2FsbChtLCBcImFcIiksIGcuY2FsbCh5LCBcImFcIiksIG0ubGFzdEluZGV4ICE9PSAwIHx8IHkubGFzdEluZGV4ICE9PSAwKSwgbyA9IGguVU5TVVBQT1JURURfWSB8fCBoLkJST0tFTl9DQVJFVCwgaSA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdICE9PSB2b2lkIDA7XG4gICAgICBILmV4cG9ydHMgPSByID0gcyB8fCBpIHx8IG8gPyBmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBuLCBhLCBjLCBwLCBqID0gdGhpcywgVCA9IG8gJiYgai5zdGlja3ksIF8gPSB1LmNhbGwoaiksIFMgPSBqLnNvdXJjZSwgRSA9IDAsIEEgPSBsO1xuICAgICAgICByZXR1cm4gVCAmJiAoKF8gPSBfLnJlcGxhY2UoXCJ5XCIsIFwiXCIpKS5pbmRleE9mKFwiZ1wiKSA9PT0gLTEgJiYgKF8gKz0gXCJnXCIpLCBBID0gU3RyaW5nKGwpLnNsaWNlKGoubGFzdEluZGV4KSwgMCA8IGoubGFzdEluZGV4ICYmICghai5tdWx0aWxpbmUgfHwgai5tdWx0aWxpbmUgJiYgbFtqLmxhc3RJbmRleCAtIDFdICE9PSBgXG5gKSAmJiAoUyA9IFwiKD86IFwiICsgUyArIFwiKVwiLCBBID0gXCIgXCIgKyBBLCBFKyspLCBhID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIFMgKyBcIilcIiwgXykpLCBpICYmIChhID0gbmV3IFJlZ0V4cChcIl5cIiArIFMgKyBcIiQoPyFcXFxccylcIiwgXykpLCBzICYmIChuID0gai5sYXN0SW5kZXgpLCBjID0gZy5jYWxsKFQgPyBhIDogaiwgQSksIFQgPyBjID8gKGMuaW5wdXQgPSBjLmlucHV0LnNsaWNlKEUpLCBjWzBdID0gY1swXS5zbGljZShFKSwgYy5pbmRleCA9IGoubGFzdEluZGV4LCBqLmxhc3RJbmRleCArPSBjWzBdLmxlbmd0aCkgOiBqLmxhc3RJbmRleCA9IDAgOiBzICYmIGMgJiYgKGoubGFzdEluZGV4ID0gai5nbG9iYWwgPyBjLmluZGV4ICsgY1swXS5sZW5ndGggOiBuKSwgaSAmJiBjICYmIDEgPCBjLmxlbmd0aCAmJiBmLmNhbGwoY1swXSwgYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yIChwID0gMTsgcCA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBwKyspXG4gICAgICAgICAgICBhcmd1bWVudHNbcF0gPT09IHZvaWQgMCAmJiAoY1twXSA9IHZvaWQgMCk7XG4gICAgICAgIH0pLCBjO1xuICAgICAgfSA6IHI7XG4gICAgfSwgeyBcIi4vcmVnZXhwLWZsYWdzXCI6IDExMiwgXCIuL3JlZ2V4cC1zdGlja3ktaGVscGVyc1wiOiAxMTMgfV0sIDExMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSBtKHRoaXMpLCB1ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHkuZ2xvYmFsICYmICh1ICs9IFwiZ1wiKSwgeS5pZ25vcmVDYXNlICYmICh1ICs9IFwiaVwiKSwgeS5tdWx0aWxpbmUgJiYgKHUgKz0gXCJtXCIpLCB5LmRvdEFsbCAmJiAodSArPSBcInNcIiksIHkudW5pY29kZSAmJiAodSArPSBcInVcIiksIHkuc3RpY2t5ICYmICh1ICs9IFwieVwiKSwgdTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAgfV0sIDExMzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQgPSB0KFwiLi9mYWlsc1wiKTtcbiAgICAgIGZ1bmN0aW9uIG0oeSwgdSkge1xuICAgICAgICByZXR1cm4gUmVnRXhwKHksIHUpO1xuICAgICAgfVxuICAgICAgQy5VTlNVUFBPUlRFRF9ZID0gdChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSBtKFwiYVwiLCBcInlcIik7XG4gICAgICAgIHJldHVybiB5Lmxhc3RJbmRleCA9IDIsIHkuZXhlYyhcImFiY2RcIikgIT0gbnVsbDtcbiAgICAgIH0pLCBDLkJST0tFTl9DQVJFVCA9IHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gbShcIl5yXCIsIFwiZ3lcIik7XG4gICAgICAgIHJldHVybiB5Lmxhc3RJbmRleCA9IDIsIHkuZXhlYyhcInN0clwiKSAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4vZmFpbHNcIjogNTEgfV0sIDExNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgaWYgKG0gPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIG0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH07XG4gICAgfSwge31dLCAxMTU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24obSwgeSkge1xuICAgICAgICByZXR1cm4gbSA9PT0geSA/IG0gIT09IDAgfHwgMSAvIG0gPT0gMSAvIHkgOiBtICE9IG0gJiYgeSAhPSB5O1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDExNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5KG0sIHUsIGgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBtW3VdID0gaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCB9XSwgMTE3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCBnID0gdShcInNwZWNpZXNcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciByID0gbShyKSwgcyA9IHkuZjtcbiAgICAgICAgaCAmJiByICYmICFyW2ddICYmIHMociwgZywgeyBjb25maWd1cmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0pO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCI6IDQzLCBcIi4uL2ludGVybmFscy9nZXQtYnVpbHQtaW5cIjogNTcsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIjogOTMsIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCI6IDE0OSB9XSwgMTE4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIikuZiwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcInRvU3RyaW5nVGFnXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oaCwgZywgZikge1xuICAgICAgICBoICYmICF5KGggPSBmID8gaCA6IGgucHJvdG90eXBlLCB1KSAmJiBtKGgsIHUsIHsgY29uZmlndXJhYmxlOiAhMCwgdmFsdWU6IGcgfSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvaGFzXCI6IDYxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDExOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9zaGFyZWRcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3VpZFwiKSwgdSA9IG0oXCJrZXlzXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gdVtoXSB8fCAodVtoXSA9IHkoaCkpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3NoYXJlZFwiOiAxMjEsIFwiLi4vaW50ZXJuYWxzL3VpZFwiOiAxNDYgfV0sIDEyMDogW2Z1bmN0aW9uKG0sIEgsIEMpIHtcbiAgICAgIHZhciB1ID0gbShcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIG0gPSBtKFwiLi4vaW50ZXJuYWxzL3NldC1nbG9iYWxcIiksIHkgPSBcIl9fY29yZS1qc19zaGFyZWRfX1wiLCB1ID0gdVt5XSB8fCBtKHksIHt9KTtcbiAgICAgIEguZXhwb3J0cyA9IHU7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL3NldC1nbG9iYWxcIjogMTE2IH1dLCAxMjE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaXMtcHVyZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlXCIpO1xuICAgICAgKEguZXhwb3J0cyA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgICAgcmV0dXJuIHlbdV0gfHwgKHlbdV0gPSBoICE9PSB2b2lkIDAgPyBoIDoge30pO1xuICAgICAgfSkoXCJ2ZXJzaW9uc1wiLCBbXSkucHVzaCh7IHZlcnNpb246IFwiMy42LjVcIiwgbW9kZTogbSA/IFwicHVyZVwiIDogXCJnbG9iYWxcIiwgY29weXJpZ2h0OiBcIsKpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSlcIiB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2lzLXB1cmVcIjogNzYsIFwiLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZVwiOiAxMjAgfV0sIDEyMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpKFwic3BlY2llc1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKGYsIGcpIHtcbiAgICAgICAgdmFyIGYgPSBtKGYpLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gZiA9PT0gdm9pZCAwIHx8IChmID0gbShmKVt1XSkgPT0gbnVsbCA/IGcgOiB5KGYpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIjogNSwgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDEyMzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9mYWlsc1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIG0oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHUgPSBcIlwiW3ldKCdcIicpO1xuICAgICAgICAgIHJldHVybiB1ICE9PSB1LnRvTG93ZXJDYXNlKCkgfHwgMyA8IHUuc3BsaXQoJ1wiJykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSB9XSwgMTI0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgICAgdmFyIHIsIHMgPSBTdHJpbmcodShzKSksIG8gPSB5KG8pLCBpID0gcy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIG8gPCAwIHx8IGkgPD0gbyA/IGggPyBcIlwiIDogdm9pZCAwIDogKHIgPSBzLmNoYXJDb2RlQXQobykpIDwgNTUyOTYgfHwgNTYzMTkgPCByIHx8IG8gKyAxID09PSBpIHx8IChpID0gcy5jaGFyQ29kZUF0KG8gKyAxKSkgPCA1NjMyMCB8fCA1NzM0MyA8IGkgPyBoID8gcy5jaGFyQXQobykgOiByIDogaCA/IHMuc2xpY2UobywgbyArIDIpIDogaSAtIDU2MzIwICsgKHIgLSA1NTI5NiA8PCAxMCkgKyA2NTUzNjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gdChcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIik7XG4gICAgICBILmV4cG9ydHMgPSB7IGNvZGVBdDogbSghMSksIGNoYXJBdDogbSghMCkgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2IH1dLCAxMjU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0ID0gdChcIi4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudFwiKSwgSC5leHBvcnRzID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHQpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnRcIjogNDcgfV0sIDEyNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgYSwgbikge1xuICAgICAgICAgIHZhciBpID0gU3RyaW5nKGgoaSkpLCBsID0gaS5sZW5ndGgsIG4gPSBuID09PSB2b2lkIDAgPyBcIiBcIiA6IFN0cmluZyhuKSwgYSA9IHkoYSk7XG4gICAgICAgICAgcmV0dXJuIGEgPD0gbCB8fCBuID09IFwiXCIgPyBpIDogKChsID0gdS5jYWxsKG4sIGcoKGEgPSBhIC0gbCkgLyBuLmxlbmd0aCkpKS5sZW5ndGggPiBhICYmIChsID0gbC5zbGljZSgwLCBhKSksIGYgPyBpICsgbCA6IGwgKyBpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXRcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiKSwgZyA9IE1hdGguY2VpbDtcbiAgICAgIEguZXhwb3J0cyA9IHsgc3RhcnQ6IG0oITEpLCBlbmQ6IG0oITApIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIjogMTE0LCBcIi4uL2ludGVybmFscy9zdHJpbmctcmVwZWF0XCI6IDEyOCwgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNyB9XSwgMTI3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShjKSB7XG4gICAgICAgIHJldHVybiBjICsgMjIgKyA3NSAqIChjIDwgMjYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShjKSB7XG4gICAgICAgIHZhciBwLCBqID0gW10sIFQgPSAoYyA9IGZ1bmN0aW9uKFcpIHtcbiAgICAgICAgICBmb3IgKHZhciBYID0gW10sIG5lID0gMCwgYiA9IFcubGVuZ3RoOyBuZSA8IGI7ICkge1xuICAgICAgICAgICAgdmFyIE8sIEQgPSBXLmNoYXJDb2RlQXQobmUrKyk7XG4gICAgICAgICAgICA1NTI5NiA8PSBEICYmIEQgPD0gNTYzMTkgJiYgbmUgPCBiID8gKDY0NTEyICYgKE8gPSBXLmNoYXJDb2RlQXQobmUrKykpKSA9PSA1NjMyMCA/IFgucHVzaCgoKDEwMjMgJiBEKSA8PCAxMCkgKyAoMTAyMyAmIE8pICsgNjU1MzYpIDogKFgucHVzaChEKSwgbmUtLSkgOiBYLnB1c2goRCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9KGMpKS5sZW5ndGgsIF8gPSAxMjgsIFMgPSAwLCBFID0gNzI7XG4gICAgICAgIGZvciAoTSA9IDA7IE0gPCBjLmxlbmd0aDsgTSsrKVxuICAgICAgICAgIChwID0gY1tNXSkgPCAxMjggJiYgai5wdXNoKGEocCkpO1xuICAgICAgICB2YXIgQSA9IGoubGVuZ3RoLCB4ID0gQTtcbiAgICAgICAgZm9yIChBICYmIGoucHVzaChcIi1cIik7IHggPCBUOyApIHtcbiAgICAgICAgICBmb3IgKHZhciBQID0gdSwgTSA9IDA7IE0gPCBjLmxlbmd0aDsgTSsrKVxuICAgICAgICAgICAgXyA8PSAocCA9IGNbTV0pICYmIHAgPCBQICYmIChQID0gcCk7XG4gICAgICAgICAgdmFyIFIgPSB4ICsgMTtcbiAgICAgICAgICBpZiAoUCAtIF8gPiBuKCh1IC0gUykgLyBSKSlcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoaSk7XG4gICAgICAgICAgZm9yIChTICs9IChQIC0gXykgKiBSLCBfID0gUCwgTSA9IDA7IE0gPCBjLmxlbmd0aDsgTSsrKSB7XG4gICAgICAgICAgICBpZiAoKHAgPSBjW01dKSA8IF8gJiYgKytTID4gdSlcbiAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihpKTtcbiAgICAgICAgICAgIGlmIChwID09IF8pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgTCA9IFMsIEYgPSBoOyA7IEYgKz0gaCkge1xuICAgICAgICAgICAgICAgIHZhciBWID0gRiA8PSBFID8gMSA6IEUgKyBnIDw9IEYgPyBnIDogRiAtIEU7XG4gICAgICAgICAgICAgICAgaWYgKEwgPCBWKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdmFyIEcgPSBMIC0gViwgVSA9IGggLSBWO1xuICAgICAgICAgICAgICAgIGoucHVzaChhKG0oViArIEcgJSBVKSkpLCBMID0gbihHIC8gVSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgai5wdXNoKGEobShMKSkpLCBFID0gZnVuY3Rpb24oVywgWCwgbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChXID0gbmUgPyBuKFcgLyByKSA6IFcgPj4gMSwgVyArPSBuKFcgLyBYKTsgbCAqIGcgPj4gMSA8IFc7IGIgKz0gaClcbiAgICAgICAgICAgICAgICAgIFcgPSBuKFcgLyBsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbihiICsgKGwgKyAxKSAqIFcgLyAoVyArIGYpKTtcbiAgICAgICAgICAgICAgfShTLCBSLCB4ID09IEEpLCBTID0gMCwgKyt4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK1MsICsrXztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gai5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSAyMTQ3NDgzNjQ3LCBoID0gMzYsIGcgPSAyNiwgZiA9IDM4LCByID0gNzAwLCBzID0gL1teXFwwLVxcdTAwN0VdLywgbyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgaSA9IFwiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3NcIiwgbCA9IGggLSAxLCBuID0gTWF0aC5mbG9vciwgYSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGZvciAodmFyIHAsIGogPSBbXSwgVCA9IGMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG8sIFwiLlwiKS5zcGxpdChcIi5cIiksIF8gPSAwOyBfIDwgVC5sZW5ndGg7IF8rKylcbiAgICAgICAgICBwID0gVFtfXSwgai5wdXNoKHMudGVzdChwKSA/IFwieG4tLVwiICsgeShwKSA6IHApO1xuICAgICAgICByZXR1cm4gai5qb2luKFwiLlwiKTtcbiAgICAgIH07XG4gICAgfSwge31dLCAxMjg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlXCIpO1xuICAgICAgSC5leHBvcnRzID0gXCJcIi5yZXBlYXQgfHwgZnVuY3Rpb24odSkge1xuICAgICAgICB2YXIgaCA9IFN0cmluZyh5KHRoaXMpKSwgZyA9IFwiXCIsIGYgPSBtKHUpO1xuICAgICAgICBpZiAoZiA8IDAgfHwgZiA9PSAxIC8gMClcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiV3JvbmcgbnVtYmVyIG9mIHJlcGV0aXRpb25zXCIpO1xuICAgICAgICBmb3IgKDsgMCA8IGY7IChmID4+Pj0gMSkgJiYgKGggKz0gaCkpXG4gICAgICAgICAgMSAmIGYgJiYgKGcgKz0gaCk7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2IH1dLCAxMjk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gbShmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gISF5W3VdKCkgfHwgXCLigIvCheGgjlwiW3VdKCkgIT0gXCLigIvCheGgjlwiIHx8IHlbdV0ubmFtZSAhPT0gdTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzXCI6IDE1MCB9XSwgMTMwOiBbZnVuY3Rpb24odSwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHIgPSBTdHJpbmcoeShyKSksIDEgJiBmICYmIChyID0gci5yZXBsYWNlKGgsIFwiXCIpKSwgciA9IDIgJiBmID8gci5yZXBsYWNlKGcsIFwiXCIpIDogcjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gdShcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIiksIHUgPSBcIltcIiArIHUoXCIuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXNcIikgKyBcIl1cIiwgaCA9IFJlZ0V4cChcIl5cIiArIHUgKyB1ICsgXCIqXCIpLCBnID0gUmVnRXhwKHUgKyB1ICsgXCIqJFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IHsgc3RhcnQ6IG0oMSksIGVuZDogbSgyKSwgdHJpbTogbSgzKSB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlXCI6IDExNCwgXCIuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXNcIjogMTUwIH1dLCAxMzE6IFtmdW5jdGlvbihsLCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEEoeCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHgpIHtcbiAgICAgICAgQSh4LmRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdSh4KSB7XG4gICAgICAgIGcucG9zdE1lc3NhZ2UoeCArIFwiXCIsIG4ucHJvdG9jb2wgKyBcIi8vXCIgKyBuLmhvc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGgsIGcgPSBsKFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgZiA9IGwoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHIgPSBsKFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCIpLCBzID0gbChcIi4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHRcIiksIG8gPSBsKFwiLi4vaW50ZXJuYWxzL2h0bWxcIiksIGkgPSBsKFwiLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50XCIpLCBsID0gbChcIi4uL2ludGVybmFscy9lbmdpbmUtaXMtaW9zXCIpLCBuID0gZy5sb2NhdGlvbiwgYSA9IGcuc2V0SW1tZWRpYXRlLCBjID0gZy5jbGVhckltbWVkaWF0ZSwgcCA9IGcucHJvY2VzcywgaiA9IGcuTWVzc2FnZUNoYW5uZWwsIFQgPSBnLkRpc3BhdGNoLCBfID0gMCwgUyA9IHt9LCBFID0gXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgQSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIFA7XG4gICAgICAgIFMuaGFzT3duUHJvcGVydHkoeCkgJiYgKFAgPSBTW3hdLCBkZWxldGUgU1t4XSwgUCgpKTtcbiAgICAgIH07XG4gICAgICBhICYmIGMgfHwgKGEgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIGZvciAodmFyIFAgPSBbXSwgTSA9IDE7IE0gPCBhcmd1bWVudHMubGVuZ3RoOyApXG4gICAgICAgICAgUC5wdXNoKGFyZ3VtZW50c1tNKytdKTtcbiAgICAgICAgcmV0dXJuIFNbKytfXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICh0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIgPyB4IDogRnVuY3Rpb24oeCkpLmFwcGx5KHZvaWQgMCwgUCk7XG4gICAgICAgIH0sIGgoXyksIF87XG4gICAgICB9LCBjID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBkZWxldGUgU1t4XTtcbiAgICAgIH0sIHIocCkgPT0gXCJwcm9jZXNzXCIgPyBoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBwLm5leHRUaWNrKG0oeCkpO1xuICAgICAgfSA6IFQgJiYgVC5ub3cgPyBoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBULm5vdyhtKHgpKTtcbiAgICAgIH0gOiBqICYmICFsID8gKGwgPSAociA9IG5ldyBqKCkpLnBvcnQyLCByLnBvcnQxLm9ubWVzc2FnZSA9IHksIGggPSBzKGwucG9zdE1lc3NhZ2UsIGwsIDEpKSA6ICFnLmFkZEV2ZW50TGlzdGVuZXIgfHwgdHlwZW9mIHBvc3RNZXNzYWdlICE9IFwiZnVuY3Rpb25cIiB8fCBnLmltcG9ydFNjcmlwdHMgfHwgZih1KSB8fCBuLnByb3RvY29sID09PSBcImZpbGU6XCIgPyBoID0gRSBpbiBpKFwic2NyaXB0XCIpID8gZnVuY3Rpb24oeCkge1xuICAgICAgICBvLmFwcGVuZENoaWxkKGkoXCJzY3JpcHRcIikpW0VdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgby5yZW1vdmVDaGlsZCh0aGlzKSwgQSh4KTtcbiAgICAgICAgfTtcbiAgICAgIH0gOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHNldFRpbWVvdXQobSh4KSwgMCk7XG4gICAgICB9IDogKGggPSB1LCBnLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHksICExKSkpLCBILmV4cG9ydHMgPSB7IHNldDogYSwgY2xlYXI6IGMgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCI6IDI4LCBcIi4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudFwiOiA0NCwgXCIuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvc1wiOiA0NiwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiOiA1NSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9odG1sXCI6IDY0IH1dLCAxMzI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeSAhPSBcIm51bWJlclwiICYmIG0oeSkgIT0gXCJOdW1iZXJcIilcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbmNvcnJlY3QgaW52b2NhdGlvblwiKTtcbiAgICAgICAgcmV0dXJuICt5O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCI6IDI4IH1dLCAxMzM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiKSwgeSA9IE1hdGgubWF4LCB1ID0gTWF0aC5taW47XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihoLCBnKSB7XG4gICAgICAgIHJldHVybiBoID0gbShoKSwgaCA8IDAgPyB5KGggKyBnLCAwKSA6IHUoaCwgZyk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiOiAxMzYgfV0sIDEzNDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy90by1sZW5ndGhcIik7XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIGlmIChoID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZhciBoID0gbShoKSwgZyA9IHkoaCk7XG4gICAgICAgIGlmIChoICE9PSBnKVxuICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJXcm9uZyBsZW5ndGggb3IgaW5kZXhcIik7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3IH1dLCAxMzU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3RcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG0oeSh1KSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3RcIjogNjcsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQgfV0sIDEzNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gTWF0aC5jZWlsLCB5ID0gTWF0aC5mbG9vcjtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHUgPSArdSkgPyAwIDogKDAgPCB1ID8geSA6IG0pKHUpO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDEzNzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCIpLCB5ID0gTWF0aC5taW47XG4gICAgICBILmV4cG9ydHMgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiAwIDwgdSA/IHkobSh1KSwgOTAwNzE5OTI1NDc0MDk5MSkgOiAwO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2IH1dLCAxMzg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KG0oeSkpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQgfV0sIDEzOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy90by1wb3NpdGl2ZS1pbnRlZ2VyXCIpO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oeSwgdSkge1xuICAgICAgICBpZiAoeSA9IG0oeSksIHkgJSB1KVxuICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJXcm9uZyBvZmZzZXRcIik7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3RvLXBvc2l0aXZlLWludGVnZXJcIjogMTQwIH1dLCAxNDA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKHkgPSBtKHkpLCB5IDwgMClcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCI6IDEzNiB9XSwgMTQxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHksIHUpIHtcbiAgICAgICAgaWYgKCFtKHkpKVxuICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICB2YXIgaCwgZztcbiAgICAgICAgaWYgKHUgJiYgdHlwZW9mIChoID0geS50b1N0cmluZykgPT0gXCJmdW5jdGlvblwiICYmICFtKGcgPSBoLmNhbGwoeSkpIHx8IHR5cGVvZiAoaCA9IHkudmFsdWVPZikgPT0gXCJmdW5jdGlvblwiICYmICFtKGcgPSBoLmNhbGwoeSkpIHx8ICF1ICYmIHR5cGVvZiAoaCA9IHkudG9TdHJpbmcpID09IFwiZnVuY3Rpb25cIiAmJiAhbShnID0gaC5jYWxsKHkpKSlcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSB9XSwgMTQyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB7fTtcbiAgICAgIG1bdChcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcInRvU3RyaW5nVGFnXCIpXSA9IFwielwiLCBILmV4cG9ydHMgPSBTdHJpbmcobSkgPT09IFwiW29iamVjdCB6XVwiO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5IH1dLCAxNDM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGZlLCBnZSkge1xuICAgICAgICBmb3IgKHZhciB4ZSA9IDAsIERlID0gZ2UubGVuZ3RoLCBNZSA9IG5ldyAoSyhmZSkpKERlKTsgeGUgPCBEZTsgKVxuICAgICAgICAgIE1lW3hlXSA9IGdlW3hlKytdO1xuICAgICAgICByZXR1cm4gTWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KGZlLCBnZSkge1xuICAgICAgICBPKGZlLCBnZSwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZSh0aGlzKVtnZV07XG4gICAgICAgIH0gfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KGZlKSB7XG4gICAgICAgIHJldHVybiBmZSBpbnN0YW5jZW9mIEogfHwgKGZlID0gQShmZSkpID09IFwiQXJyYXlCdWZmZXJcIiB8fCBmZSA9PSBcIlNoYXJlZEFycmF5QnVmZmVyXCI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoKGZlLCBnZSkge1xuICAgICAgICByZXR1cm4gYWUoZmUpICYmIHR5cGVvZiBnZSAhPSBcInN5bWJvbFwiICYmIGdlIGluIGZlICYmIFN0cmluZygrZ2UpID09IFN0cmluZyhnZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKGZlLCBnZSkge1xuICAgICAgICByZXR1cm4gaChmZSwgZ2UgPSBTKGdlLCAhMCkpID8gYygyLCBmZVtnZV0pIDogRChmZSwgZ2UpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihmZSwgZ2UsIHhlKSB7XG4gICAgICAgIHJldHVybiAhKGgoZmUsIGdlID0gUyhnZSwgITApKSAmJiB4KHhlKSAmJiBFKHhlLCBcInZhbHVlXCIpKSB8fCBFKHhlLCBcImdldFwiKSB8fCBFKHhlLCBcInNldFwiKSB8fCB4ZS5jb25maWd1cmFibGUgfHwgRSh4ZSwgXCJ3cml0YWJsZVwiKSAmJiAheGUud3JpdGFibGUgfHwgRSh4ZSwgXCJlbnVtZXJhYmxlXCIpICYmICF4ZS5lbnVtZXJhYmxlID8gTyhmZSwgZ2UsIHhlKSA6IChmZVtnZV0gPSB4ZS52YWx1ZSwgZmUpO1xuICAgICAgfVxuICAgICAgdmFyIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgcyA9IHQoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCBvID0gdChcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgaSA9IHQoXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JzLXJlcXVpcmUtd3JhcHBlcnNcIiksIGwgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIG4gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlclwiKSwgYSA9IHQoXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIiksIGMgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBwID0gdChcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIiksIGogPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgVCA9IHQoXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhcIiksIF8gPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9mZnNldFwiKSwgUyA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlXCIpLCBFID0gdChcIi4uL2ludGVybmFscy9oYXNcIiksIEEgPSB0KFwiLi4vaW50ZXJuYWxzL2NsYXNzb2ZcIiksIHggPSB0KFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgUCA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZVwiKSwgTSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2ZcIiksIFIgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzXCIpLmYsIEwgPSB0KFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb21cIiksIEYgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5mb3JFYWNoLCBWID0gdChcIi4uL2ludGVybmFscy9zZXQtc3BlY2llc1wiKSwgRyA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKSwgVSA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgVyA9IHQoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIiksIFggPSB0KFwiLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWRcIiksIG5lID0gVy5nZXQsIGIgPSBXLnNldCwgTyA9IEcuZiwgRCA9IFUuZiwgQiA9IE1hdGgucm91bmQsIFkgPSBzLlJhbmdlRXJyb3IsIEogPSBuLkFycmF5QnVmZmVyLCB0ZSA9IG4uRGF0YVZpZXcsIGNlID0gbC5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLCByZSA9IGwuVFlQRURfQVJSQVlfVEFHLCB1ZSA9IGwuVHlwZWRBcnJheSwgbGUgPSBsLlR5cGVkQXJyYXlQcm90b3R5cGUsIEsgPSBsLmFUeXBlZEFycmF5Q29uc3RydWN0b3IsIGFlID0gbC5pc1R5cGVkQXJyYXksIGhlID0gXCJCWVRFU19QRVJfRUxFTUVOVFwiLCBfZSA9IFwiV3JvbmcgbGVuZ3RoXCI7XG4gICAgICBvID8gKGNlIHx8IChVLmYgPSBnLCBHLmYgPSBmLCB5KGxlLCBcImJ1ZmZlclwiKSwgeShsZSwgXCJieXRlT2Zmc2V0XCIpLCB5KGxlLCBcImJ5dGVMZW5ndGhcIiksIHkobGUsIFwibGVuZ3RoXCIpKSwgcih7IHRhcmdldDogXCJPYmplY3RcIiwgc3RhdDogITAsIGZvcmNlZDogIWNlIH0sIHsgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBnLCBkZWZpbmVQcm9wZXJ0eTogZiB9KSwgSC5leHBvcnRzID0gZnVuY3Rpb24odmUsIGdlLCB4ZSkge1xuICAgICAgICBmdW5jdGlvbiBEZSh3ZSwgWikge1xuICAgICAgICAgIE8od2UsIFosIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkID0gdGhpcywgcSA9IFo7XG4gICAgICAgICAgICByZXR1cm4gKCQgPSBuZSgkKSkudmlld1t6ZV0ocSAqIE1lICsgJC5ieXRlT2Zmc2V0LCAhMCk7XG4gICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbigkKSB7XG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMsIGVlID0gWjtcbiAgICAgICAgICAgIHEgPSBuZShxKSwgeGUgJiYgKCQgPSAoJCA9IEIoJCkpIDwgMCA/IDAgOiAyNTUgPCAkID8gMjU1IDogMjU1ICYgJCksIHEudmlld1tWZV0oZWUgKiBNZSArIHEuYnl0ZU9mZnNldCwgJCwgITApO1xuICAgICAgICAgIH0sIGVudW1lcmFibGU6ICEwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNZSA9IHZlLm1hdGNoKC9cXGQrJC8pWzBdIC8gOCwgUWUgPSB2ZSArICh4ZSA/IFwiQ2xhbXBlZFwiIDogXCJcIikgKyBcIkFycmF5XCIsIHplID0gXCJnZXRcIiArIHZlLCBWZSA9IFwic2V0XCIgKyB2ZSwgWGUgPSBzW1FlXSwgSGUgPSBYZSwgdmUgPSBIZSAmJiBIZS5wcm90b3R5cGUsIFJlID0ge307XG4gICAgICAgIGNlID8gaSAmJiAoSGUgPSBnZShmdW5jdGlvbih3ZSwgWiwgJCwgcSkge1xuICAgICAgICAgIHJldHVybiBhKHdlLCBIZSwgUWUpLCBYKHgoWikgPyB1KFopID8gcSAhPT0gdm9pZCAwID8gbmV3IFhlKFosIF8oJCwgTWUpLCBxKSA6ICQgIT09IHZvaWQgMCA/IG5ldyBYZShaLCBfKCQsIE1lKSkgOiBuZXcgWGUoWikgOiBhZShaKSA/IG0oSGUsIFopIDogTC5jYWxsKEhlLCBaKSA6IG5ldyBYZShUKFopKSwgd2UsIEhlKTtcbiAgICAgICAgfSksIE0gJiYgTShIZSwgdWUpLCBGKFIoWGUpLCBmdW5jdGlvbih3ZSkge1xuICAgICAgICAgIHdlIGluIEhlIHx8IHAoSGUsIHdlLCBYZVt3ZV0pO1xuICAgICAgICB9KSwgSGUucHJvdG90eXBlID0gdmUpIDogKEhlID0gZ2UoZnVuY3Rpb24od2UsIFosICQsIHEpIHtcbiAgICAgICAgICBhKHdlLCBIZSwgUWUpO1xuICAgICAgICAgIHZhciBlZSwgcGUsIGplID0gMCwgQ2UgPSAwO1xuICAgICAgICAgIGlmICh4KFopKSB7XG4gICAgICAgICAgICBpZiAoIXUoWikpXG4gICAgICAgICAgICAgIHJldHVybiBhZShaKSA/IG0oSGUsIFopIDogTC5jYWxsKEhlLCBaKTtcbiAgICAgICAgICAgIHZhciBGZSA9IFosIENlID0gXygkLCBNZSksICQgPSBaLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAocSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICgkICUgTWUgfHwgKGVlID0gJCAtIENlKSA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgWShfZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQgPCAoZWUgPSBqKHEpICogTWUpICsgQ2UpXG4gICAgICAgICAgICAgIHRocm93IFkoX2UpO1xuICAgICAgICAgICAgcGUgPSBlZSAvIE1lO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcGUgPSBUKFopLCBGZSA9IG5ldyBKKGVlID0gcGUgKiBNZSk7XG4gICAgICAgICAgZm9yIChiKHdlLCB7IGJ1ZmZlcjogRmUsIGJ5dGVPZmZzZXQ6IENlLCBieXRlTGVuZ3RoOiBlZSwgbGVuZ3RoOiBwZSwgdmlldzogbmV3IHRlKEZlKSB9KTsgamUgPCBwZTsgKVxuICAgICAgICAgICAgRGUod2UsIGplKyspO1xuICAgICAgICB9KSwgTSAmJiBNKEhlLCB1ZSksIHZlID0gSGUucHJvdG90eXBlID0gUChsZSkpLCB2ZS5jb25zdHJ1Y3RvciAhPT0gSGUgJiYgcCh2ZSwgXCJjb25zdHJ1Y3RvclwiLCBIZSksIHJlICYmIHAodmUsIHJlLCBRZSksIFJlW1FlXSA9IEhlLCByKHsgZ2xvYmFsOiAhMCwgZm9yY2VkOiBIZSAhPSBYZSwgc2hhbTogIWNlIH0sIFJlKSwgaGUgaW4gSGUgfHwgcChIZSwgaGUsIE1lKSwgaGUgaW4gdmUgfHwgcCh2ZSwgaGUsIE1lKSwgVihRZSk7XG4gICAgICB9KSA6IEguZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCI6IDksIFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlclwiOiAxMywgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9jbGFzc29mXCI6IDI5LCBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDM5LCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZFwiOiA2OCwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIjogNzEsIFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZVwiOiA5MSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiA5NCwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXNcIjogOTYsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mXCI6IDEwMiwgXCIuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXNcIjogMTE3LCBcIi4uL2ludGVybmFscy90by1pbmRleFwiOiAxMzQsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcsIFwiLi4vaW50ZXJuYWxzL3RvLW9mZnNldFwiOiAxMzksIFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiOiAxNDEsIFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9ycy1yZXF1aXJlLXdyYXBwZXJzXCI6IDE0NCwgXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktZnJvbVwiOiAxNDUgfV0sIDE0NDogW2Z1bmN0aW9uKGgsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gaChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIHkgPSBoKFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCB1ID0gaChcIi4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb25cIiksIGggPSBoKFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIikuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUywgZyA9IG0uQXJyYXlCdWZmZXIsIGYgPSBtLkludDhBcnJheTtcbiAgICAgIEguZXhwb3J0cyA9ICFoIHx8ICF5KGZ1bmN0aW9uKCkge1xuICAgICAgICBmKDEpO1xuICAgICAgfSkgfHwgIXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIG5ldyBmKC0xKTtcbiAgICAgIH0pIHx8ICF1KGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgbmV3IGYoKSwgbmV3IGYobnVsbCksIG5ldyBmKDEuNSksIG5ldyBmKHIpO1xuICAgICAgfSwgITApIHx8IHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgZihuZXcgZygyKSwgMSwgdm9pZCAwKS5sZW5ndGggIT09IDE7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvblwiOiAyNywgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCB9XSwgMTQ1OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kXCIpLCBoID0gdChcIi4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2RcIiksIGcgPSB0KFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dFwiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24ocikge1xuICAgICAgICB2YXIgcywgbywgaSwgbCwgbiwgYSwgYyA9IG0ociksIHAgPSBhcmd1bWVudHMubGVuZ3RoLCBqID0gMSA8IHAgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsIFQgPSBqICE9PSB2b2lkIDAsIF8gPSB1KGMpO1xuICAgICAgICBpZiAoXyAhPSBudWxsICYmICFoKF8pKVxuICAgICAgICAgIGZvciAoYSA9IChuID0gXy5jYWxsKGMpKS5uZXh0LCBjID0gW107ICEobCA9IGEuY2FsbChuKSkuZG9uZTsgKVxuICAgICAgICAgICAgYy5wdXNoKGwudmFsdWUpO1xuICAgICAgICBmb3IgKFQgJiYgMiA8IHAgJiYgKGogPSBnKGosIGFyZ3VtZW50c1syXSwgMikpLCBvID0geShjLmxlbmd0aCksIGkgPSBuZXcgKGYodGhpcykpKG8pLCBzID0gMDsgcyA8IG87IHMrKylcbiAgICAgICAgICBpW3NdID0gVCA/IGooY1tzXSwgcykgOiBjW3NdO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHRcIjogNTUsIFwiLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2RcIjogNTgsIFwiLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZFwiOiA3MiwgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNywgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCB9XSwgMTQ2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSAwLCB5ID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIEguZXhwb3J0cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIFwiU3ltYm9sKFwiICsgU3RyaW5nKHUgPT09IHZvaWQgMCA/IFwiXCIgOiB1KSArIFwiKV9cIiArICgrK20gKyB5KS50b1N0cmluZygzNik7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMTQ3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdCA9IHQoXCIuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbFwiKSwgSC5leHBvcnRzID0gdCAmJiAhU3ltYm9sLnNoYW0gJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbFwiOiA4NCB9XSwgMTQ4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdCA9IHQoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIEMuZiA9IHQ7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDE0OTogW2Z1bmN0aW9uKGYsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gZihcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIHkgPSBmKFwiLi4vaW50ZXJuYWxzL3NoYXJlZFwiKSwgdSA9IGYoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCBoID0gZihcIi4uL2ludGVybmFscy91aWRcIiksIGcgPSBmKFwiLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2xcIiksIGYgPSBmKFwiLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkXCIpLCByID0geShcIndrc1wiKSwgcyA9IG0uU3ltYm9sLCBvID0gZiA/IHMgOiBzICYmIHMud2l0aG91dFNldHRlciB8fCBoO1xuICAgICAgSC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gdShyLCBpKSB8fCAoZyAmJiB1KHMsIGkpID8gcltpXSA9IHNbaV0gOiByW2ldID0gbyhcIlN5bWJvbC5cIiArIGkpKSwgcltpXTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbFwiOiA4NCwgXCIuLi9pbnRlcm5hbHMvc2hhcmVkXCI6IDEyMSwgXCIuLi9pbnRlcm5hbHMvdWlkXCI6IDE0NiwgXCIuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWRcIjogMTQ3IH1dLCAxNTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSBgXHRcblxcdlxcZlxcciDCoOGagOKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XFx1RkVGRmA7XG4gICAgfSwge31dLCAxNTE6IFtmdW5jdGlvbih1LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHUoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdShcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIGcgPSB1KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlclwiKSwgdSA9IHUoXCIuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXNcIiksIGggPSBcIkFycmF5QnVmZmVyXCIsIGcgPSBnW2hdO1xuICAgICAgbSh7IGdsb2JhbDogITAsIGZvcmNlZDogeVtoXSAhPT0gZyB9LCB7IEFycmF5QnVmZmVyOiBnIH0pLCB1KGgpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyXCI6IDEzLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXNcIjogMTE3IH1dLCAxNTI6IFtmdW5jdGlvbihjLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGMoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gYyhcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgdSA9IGMoXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXlcIiksIGggPSBjKFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgZyA9IGMoXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCIpLCBmID0gYyhcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIHIgPSBjKFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiKSwgcyA9IGMoXCIuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGVcIiksIG8gPSBjKFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0XCIpLCBhID0gYyhcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKSwgYyA9IGMoXCIuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb25cIiksIGkgPSBhKFwiaXNDb25jYXRTcHJlYWRhYmxlXCIpLCBsID0gOTAwNzE5OTI1NDc0MDk5MSwgbiA9IFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIsIGEgPSA1MSA8PSBjIHx8ICF5KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICByZXR1cm4gcFtpXSA9ICExLCBwLmNvbmNhdCgpWzBdICE9PSBwO1xuICAgICAgfSksIGMgPSBvKFwiY29uY2F0XCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAsIGZvcmNlZDogIWEgfHwgIWMgfSwgeyBjb25jYXQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgZm9yICh2YXIgaiwgVCwgXywgUywgRSwgQSA9IGcodGhpcyksIHggPSBzKEEsIDApLCBQID0gMCwgTSA9IC0xLCBSID0gYXJndW1lbnRzLmxlbmd0aDsgTSA8IFI7IE0rKylcbiAgICAgICAgICBpZiAoRSA9IHZvaWQgMCwgIWgoUyA9IF8gPSBNID09PSAtMSA/IEEgOiBhcmd1bWVudHNbTV0pIHx8ICgoRSA9IFNbaV0pICE9PSB2b2lkIDAgPyAhRSA6ICF1KFMpKSkge1xuICAgICAgICAgICAgaWYgKGwgPD0gUClcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKG4pO1xuICAgICAgICAgICAgcih4LCBQKyssIF8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoVCA9IGYoXy5sZW5ndGgpLCBsIDwgUCArIFQpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihuKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBUOyBqKyssIFArKylcbiAgICAgICAgICAgICAgaiBpbiBfICYmIHIoeCwgUCwgX1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4geC5sZW5ndGggPSBQLCB4O1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0XCI6IDIxLCBcIi4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZVwiOiAyNSwgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5XCI6IDQwLCBcIi4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvblwiOiA0OCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXlcIjogNzMsIFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSwgXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCI6IDEzNywgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5IH1dLCAxNTM6IFtmdW5jdGlvbih1LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHUoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdShcIi4uL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpblwiKSwgdSA9IHUoXCIuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAgfSwgeyBjb3B5V2l0aGluOiB5IH0pLCB1KFwiY29weVdpdGhpblwiKTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlc1wiOiA3LCBcIi4uL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpblwiOiAxNCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwIH1dLCAxNTQ6IFtmdW5jdGlvbihoLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGgoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIikuZXZlcnksIHUgPSBoKFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3RcIiksIGggPSBoKFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiKSwgdSA9IHUoXCJldmVyeVwiKSwgaCA9IGgoXCJldmVyeVwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwLCBmb3JjZWQ6ICF1IHx8ICFoIH0sIHsgZXZlcnk6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHkodGhpcywgZywgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiOiAxOSwgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdFwiOiAyMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCI6IDIzLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAgfV0sIDE1NTogW2Z1bmN0aW9uKHUsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdShcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB1KFwiLi4vaW50ZXJuYWxzL2FycmF5LWZpbGxcIiksIHUgPSB1KFwiLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlc1wiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwIH0sIHsgZmlsbDogeSB9KSwgdShcImZpbGxcIik7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIjogNywgXCIuLi9pbnRlcm5hbHMvYXJyYXktZmlsbFwiOiAxNSwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwIH1dLCAxNTY6IFtmdW5jdGlvbihoLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGgoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIikuZmlsdGVyLCB1ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydFwiKSwgaCA9IGgoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCB1ID0gdShcImZpbHRlclwiKSwgaCA9IGgoXCJmaWx0ZXJcIik7XG4gICAgICBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHByb3RvOiAhMCwgZm9yY2VkOiAhdSB8fCAhaCB9LCB7IGZpbHRlcjogZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4geSh0aGlzLCBnLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydFwiOiAyMSwgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCI6IDIzLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAgfV0sIDE1NzogW2Z1bmN0aW9uKGYsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gZihcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSBmKFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5maW5kSW5kZXgsIHUgPSBmKFwiLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlc1wiKSwgZiA9IGYoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCBoID0gXCJmaW5kSW5kZXhcIiwgZyA9ICEwLCBmID0gZihoKTtcbiAgICAgIGggaW4gW10gJiYgQXJyYXkoMSlbaF0oZnVuY3Rpb24oKSB7XG4gICAgICAgIGcgPSAhMTtcbiAgICAgIH0pLCBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHByb3RvOiAhMCwgZm9yY2VkOiBnIHx8ICFmIH0sIHsgZmluZEluZGV4OiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB5KHRoaXMsIHIsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0gfSksIHUoaCk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIjogNywgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIjogMjMsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCB9XSwgMTU4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvZmxhdHRlbi1pbnRvLWFycmF5XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGVcIik7XG4gICAgICBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHByb3RvOiAhMCB9LCB7IGZsYXRNYXA6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgdmFyIHMsIG8gPSB1KHRoaXMpLCBpID0gaChvLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBnKHIpLCAocyA9IGYobywgMCkpLmxlbmd0aCA9IHkocywgbywgbywgaSwgMCwgMSwgciwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApLCBzO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb25cIjogNSwgXCIuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGVcIjogMjUsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvZmxhdHRlbi1pbnRvLWFycmF5XCI6IDUzLCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4IH1dLCAxNTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9mbGF0dGVuLWludG8tYXJyYXlcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCBnID0gdChcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZVwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwIH0sIHsgZmxhdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCwgcyA9IHUodGhpcyksIG8gPSBoKHMubGVuZ3RoKSwgaSA9IGYocywgMCk7XG4gICAgICAgIHJldHVybiBpLmxlbmd0aCA9IHkoaSwgcywgcywgbywgMCwgciA9PT0gdm9pZCAwID8gMSA6IGcocikpLCBpO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlXCI6IDI1LCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2ZsYXR0ZW4taW50by1hcnJheVwiOiA1MywgXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiOiAxMzYsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcsIFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiOiAxMzggfV0sIDE2MDogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB5KFwiLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAsIGZvcmNlZDogW10uZm9yRWFjaCAhPSB5IH0sIHsgZm9yRWFjaDogeSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoXCI6IDE2LCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAgfV0sIDE2MTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWZyb21cIik7XG4gICAgICBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHN0YXQ6ICEwLCBmb3JjZWQ6ICF0KFwiLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvblwiKShmdW5jdGlvbih1KSB7XG4gICAgICAgIEFycmF5LmZyb20odSk7XG4gICAgICB9KSB9LCB7IGZyb206IHkgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1mcm9tXCI6IDE3LCBcIi4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb25cIjogMjcsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCB9XSwgMTYyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIikuaW5jbHVkZXMsIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlc1wiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwLCBmb3JjZWQ6ICF0KFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiKShcImluZGV4T2ZcIiwgeyBBQ0NFU1NPUlM6ICEwLCAxOiAwIH0pIH0sIHsgaW5jbHVkZXM6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHkodGhpcywgaCwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApO1xuICAgICAgfSB9KSwgdShcImluY2x1ZGVzXCIpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzXCI6IDcsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzXCI6IDE4LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIjogMjMsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCB9XSwgMTYzOiBbZnVuY3Rpb24oZiwgSCwgQykge1xuICAgICAgdmFyIG0gPSBmKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IGYoXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIikuaW5kZXhPZiwgZyA9IGYoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdFwiKSwgZiA9IGYoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCB1ID0gW10uaW5kZXhPZiwgaCA9ICEhdSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMCwgZyA9IGcoXCJpbmRleE9mXCIpLCBmID0gZihcImluZGV4T2ZcIiwgeyBBQ0NFU1NPUlM6ICEwLCAxOiAwIH0pO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAsIGZvcmNlZDogaCB8fCAhZyB8fCAhZiB9LCB7IGluZGV4T2Y6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIGggPyB1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMCA6IHkodGhpcywgciwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzXCI6IDE4LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0XCI6IDIyLCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIjogMjMsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCB9XSwgMTY0OiBbZnVuY3Rpb24oZywgSCwgQykge1xuICAgICAgdmFyIG0gPSBnKFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCIpLCB5ID0gZyhcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIiksIHUgPSBnKFwiLi4vaW50ZXJuYWxzL2l0ZXJhdG9yc1wiKSwgaCA9IGcoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIiksIGcgPSBnKFwiLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvclwiKSwgZiA9IFwiQXJyYXkgSXRlcmF0b3JcIiwgciA9IGguc2V0LCBzID0gaC5nZXR0ZXJGb3IoZik7XG4gICAgICBILmV4cG9ydHMgPSBnKEFycmF5LCBcIkFycmF5XCIsIGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgICAgcih0aGlzLCB7IHR5cGU6IGYsIHRhcmdldDogbShvKSwgaW5kZXg6IDAsIGtpbmQ6IGkgfSk7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG8gPSBzKHRoaXMpLCBpID0gby50YXJnZXQsIGwgPSBvLmtpbmQsIG4gPSBvLmluZGV4Kys7XG4gICAgICAgIHJldHVybiAhaSB8fCBuID49IGkubGVuZ3RoID8geyB2YWx1ZTogby50YXJnZXQgPSB2b2lkIDAsIGRvbmU6ICEwIH0gOiBsID09IFwia2V5c1wiID8geyB2YWx1ZTogbiwgZG9uZTogITEgfSA6IGwgPT0gXCJ2YWx1ZXNcIiA/IHsgdmFsdWU6IGlbbl0sIGRvbmU6ICExIH0gOiB7IHZhbHVlOiBbbiwgaVtuXV0sIGRvbmU6ICExIH07XG4gICAgICB9LCBcInZhbHVlc1wiKSwgdS5Bcmd1bWVudHMgPSB1LkFycmF5LCB5KFwia2V5c1wiKSwgeShcInZhbHVlc1wiKSwgeShcImVudHJpZXNcIik7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIjogNywgXCIuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yXCI6IDQxLCBcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiOiA3MSwgXCIuLi9pbnRlcm5hbHMvaXRlcmF0b3JzXCI6IDgwLCBcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiOiAxMzUgfV0sIDE2NTogW2Z1bmN0aW9uKGcsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gZyhcIi4uL2ludGVybmFscy9leHBvcnRcIiksIGggPSBnKFwiLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0XCIpLCB5ID0gZyhcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiKSwgZyA9IGcoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdFwiKSwgdSA9IFtdLmpvaW4sIGggPSBoICE9IE9iamVjdCwgZyA9IGcoXCJqb2luXCIsIFwiLFwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwLCBmb3JjZWQ6IGggfHwgIWcgfSwgeyBqb2luOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiB1LmNhbGwoeSh0aGlzKSwgZiA9PT0gdm9pZCAwID8gXCIsXCIgOiBmKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0XCI6IDIyLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0XCI6IDY3LCBcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiOiAxMzUgfV0sIDE2NjogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB5KFwiLi4vaW50ZXJuYWxzL2FycmF5LWxhc3QtaW5kZXgtb2ZcIik7XG4gICAgICBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHByb3RvOiAhMCwgZm9yY2VkOiB5ICE9PSBbXS5sYXN0SW5kZXhPZiB9LCB7IGxhc3RJbmRleE9mOiB5IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZlwiOiAyMCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwIH1dLCAxNjc6IFtmdW5jdGlvbihoLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGgoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIikubWFwLCB1ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydFwiKSwgaCA9IGgoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCB1ID0gdShcIm1hcFwiKSwgaCA9IGgoXCJtYXBcIik7XG4gICAgICBtKHsgdGFyZ2V0OiBcIkFycmF5XCIsIHByb3RvOiAhMCwgZm9yY2VkOiAhdSB8fCAhaCB9LCB7IG1hcDogZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4geSh0aGlzLCBnLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydFwiOiAyMSwgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCI6IDIzLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAgfV0sIDE2ODogW2Z1bmN0aW9uKGksIEgsIEMpIHtcbiAgICAgIHZhciBtID0gaShcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSBpKFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgdSA9IGkoXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXlcIiksIGggPSBpKFwiLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4XCIpLCBnID0gaShcIi4uL2ludGVybmFscy90by1sZW5ndGhcIiksIGYgPSBpKFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCIpLCByID0gaShcIi4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHlcIiksIHMgPSBpKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBvID0gaShcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydFwiKSwgaSA9IGkoXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoXCIpLCBvID0gbyhcInNsaWNlXCIpLCBpID0gaShcInNsaWNlXCIsIHsgQUNDRVNTT1JTOiAhMCwgMDogMCwgMTogMiB9KSwgbCA9IHMoXCJzcGVjaWVzXCIpLCBuID0gW10uc2xpY2UsIGEgPSBNYXRoLm1heDtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86ICEwLCBmb3JjZWQ6ICFvIHx8ICFpIH0sIHsgc2xpY2U6IGZ1bmN0aW9uKGMsIHApIHtcbiAgICAgICAgdmFyIGosIFQsIF8sIFMgPSBmKHRoaXMpLCBFID0gZyhTLmxlbmd0aCksIEEgPSBoKGMsIEUpLCB4ID0gaChwID09PSB2b2lkIDAgPyBFIDogcCwgRSk7XG4gICAgICAgIGlmICh1KFMpICYmICgoaiA9IHR5cGVvZiAoaiA9IFMuY29uc3RydWN0b3IpID09IFwiZnVuY3Rpb25cIiAmJiAoaiA9PT0gQXJyYXkgfHwgdShqLnByb3RvdHlwZSkpIHx8IHkoaikgJiYgKGogPSBqW2xdKSA9PT0gbnVsbCA/IHZvaWQgMCA6IGopID09PSBBcnJheSB8fCBqID09PSB2b2lkIDApKVxuICAgICAgICAgIHJldHVybiBuLmNhbGwoUywgQSwgeCk7XG4gICAgICAgIGZvciAoVCA9IG5ldyAoaiA9PT0gdm9pZCAwID8gQXJyYXkgOiBqKShhKHggLSBBLCAwKSksIF8gPSAwOyBBIDwgeDsgQSsrLCBfKyspXG4gICAgICAgICAgQSBpbiBTICYmIHIoVCwgXywgU1tBXSk7XG4gICAgICAgIHJldHVybiBULmxlbmd0aCA9IF8sIFQ7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnRcIjogMjEsIFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiOiAyMywgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5XCI6IDQwLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2lzLWFycmF5XCI6IDczLCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4XCI6IDEzMywgXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3RcIjogMTM1LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDE2OTogW2Z1bmN0aW9uKGgsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gaChcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSBoKFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5zb21lLCB1ID0gaChcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0XCIpLCBoID0gaChcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIiksIHUgPSB1KFwic29tZVwiKSwgaCA9IGgoXCJzb21lXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAsIGZvcmNlZDogIXUgfHwgIWggfSwgeyBzb21lOiBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB5KHRoaXMsIGcsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIjogMTksIFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3RcIjogMjIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiOiAyMywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwIH1dLCAxNzA6IFtmdW5jdGlvbihvLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IG8oXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gbyhcIi4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleFwiKSwgdSA9IG8oXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiKSwgaCA9IG8oXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCBnID0gbyhcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIGYgPSBvKFwiLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlXCIpLCByID0gbyhcIi4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHlcIiksIHMgPSBvKFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0XCIpLCBvID0gbyhcIi4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGhcIiksIHMgPSBzKFwic3BsaWNlXCIpLCBvID0gbyhcInNwbGljZVwiLCB7IEFDQ0VTU09SUzogITAsIDA6IDAsIDE6IDIgfSksIGkgPSBNYXRoLm1heCwgbCA9IE1hdGgubWluO1xuICAgICAgbSh7IHRhcmdldDogXCJBcnJheVwiLCBwcm90bzogITAsIGZvcmNlZDogIXMgfHwgIW8gfSwgeyBzcGxpY2U6IGZ1bmN0aW9uKFAsIGEpIHtcbiAgICAgICAgdmFyIGMsIHAsIGosIFQsIF8sIFMsIEUgPSBnKHRoaXMpLCBBID0gaChFLmxlbmd0aCksIHggPSB5KFAsIEEpLCBQID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKFAgPT09IDAgPyBjID0gcCA9IDAgOiBwID0gUCA9PT0gMSA/IChjID0gMCwgQSAtIHgpIDogKGMgPSBQIC0gMiwgbChpKHUoYSksIDApLCBBIC0geCkpLCA5MDA3MTk5MjU0NzQwOTkxIDwgQSArIGMgLSBwKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk1heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWRcIik7XG4gICAgICAgIGZvciAoaiA9IGYoRSwgcCksIFQgPSAwOyBUIDwgcDsgVCsrKVxuICAgICAgICAgIChfID0geCArIFQpIGluIEUgJiYgcihqLCBULCBFW19dKTtcbiAgICAgICAgaWYgKGMgPCAoai5sZW5ndGggPSBwKSkge1xuICAgICAgICAgIGZvciAoVCA9IHg7IFQgPCBBIC0gcDsgVCsrKVxuICAgICAgICAgICAgUyA9IFQgKyBjLCAoXyA9IFQgKyBwKSBpbiBFID8gRVtTXSA9IEVbX10gOiBkZWxldGUgRVtTXTtcbiAgICAgICAgICBmb3IgKFQgPSBBOyBBIC0gcCArIGMgPCBUOyBULS0pXG4gICAgICAgICAgICBkZWxldGUgRVtUIC0gMV07XG4gICAgICAgIH0gZWxzZSBpZiAocCA8IGMpXG4gICAgICAgICAgZm9yIChUID0gQSAtIHA7IHggPCBUOyBULS0pXG4gICAgICAgICAgICBTID0gVCArIGMgLSAxLCAoXyA9IFQgKyBwIC0gMSkgaW4gRSA/IEVbU10gPSBFW19dIDogZGVsZXRlIEVbU107XG4gICAgICAgIGZvciAoVCA9IDA7IFQgPCBjOyBUKyspXG4gICAgICAgICAgRVtUICsgeF0gPSBhcmd1bWVudHNbVCArIDJdO1xuICAgICAgICByZXR1cm4gRS5sZW5ndGggPSBBIC0gcCArIGMsIGo7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnRcIjogMjEsIFwiLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aFwiOiAyMywgXCIuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGVcIjogMjUsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiOiA0MCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleFwiOiAxMzMsIFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4IH1dLCAxNzE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlc1wiKShcImZsYXRNYXBcIik7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIjogNyB9XSwgMTcyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcIi4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXNcIikoXCJmbGF0XCIpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzXCI6IDcgfV0sIDE3MzogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgeSA9IHkoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCB1ID0gRnVuY3Rpb24ucHJvdG90eXBlLCBoID0gdS50b1N0cmluZywgZyA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbiAgICAgICFtIHx8IFwibmFtZVwiIGluIHUgfHwgeSh1LCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBoLmNhbGwodGhpcykubWF0Y2goZylbMV07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHlcIjogOTMgfV0sIDE3NDogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uXCIpLCB5ID0geShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZ1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IG0oXCJNYXBcIiwgZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHUodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCk7XG4gICAgICAgIH07XG4gICAgICB9LCB5KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb25cIjogMzIsIFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nXCI6IDMwIH1dLCAxNzU6IFtmdW5jdGlvbihtLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IG0oXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gTWF0aC5oeXBvdCwgdSA9IE1hdGguYWJzLCBoID0gTWF0aC5zcXJ0O1xuICAgICAgbSh7IHRhcmdldDogXCJNYXRoXCIsIHN0YXQ6ICEwLCBmb3JjZWQ6ICEheSAmJiB5KDEgLyAwLCBOYU4pICE9PSAxIC8gMCB9LCB7IGh5cG90OiBmdW5jdGlvbihnLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHIsIHMsIG8gPSAwLCBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIG4gPSAwOyBpIDwgbDsgKVxuICAgICAgICAgIG4gPCAociA9IHUoYXJndW1lbnRzW2krK10pKSA/IChvID0gbyAqIChzID0gbiAvIHIpICogcyArIDEsIG4gPSByKSA6IG8gKz0gMCA8IHIgPyAocyA9IHIgLyBuKSAqIHMgOiByO1xuICAgICAgICByZXR1cm4gbiA9PT0gMSAvIDAgPyAxIC8gMCA6IG4gKiBoKG8pO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCB9XSwgMTc2OiBbZnVuY3Rpb24obSwgSCwgQykge1xuICAgICAgdmFyIG0gPSBtKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IE1hdGgubG9nLCB1ID0gTWF0aC5MTjI7XG4gICAgICBtKHsgdGFyZ2V0OiBcIk1hdGhcIiwgc3RhdDogITAgfSwgeyBsb2cyOiBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB5KGgpIC8gdTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAgfV0sIDE3NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpKHsgdGFyZ2V0OiBcIk1hdGhcIiwgc3RhdDogITAgfSwgeyBzaWduOiB0KFwiLi4vaW50ZXJuYWxzL21hdGgtc2lnblwiKSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvbWF0aC1zaWduXCI6IDgxIH1dLCAxNzg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKE0pIHtcbiAgICAgICAgdmFyIFIsIEwsIEYsIFYsIEcsIFUsIFcsIFggPSBvKE0sICExKTtcbiAgICAgICAgaWYgKHR5cGVvZiBYID09IFwic3RyaW5nXCIgJiYgMiA8IFgubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChNID0gKFggPSBwKFgpKS5jaGFyQ29kZUF0KDApKSA9PT0gNDMgfHwgTSA9PT0gNDUpIHtcbiAgICAgICAgICAgIGlmICgoUiA9IFguY2hhckNvZGVBdCgyKSkgPT09IDg4IHx8IFIgPT09IDEyMClcbiAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICB9IGVsc2UgaWYgKE0gPT09IDQ4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKFguY2hhckNvZGVBdCgxKSkge1xuICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgIEwgPSAyLCBGID0gNDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAgIEwgPSA4LCBGID0gNTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICtYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChHID0gKFYgPSBYLnNsaWNlKDIpKS5sZW5ndGgsIFUgPSAwOyBVIDwgRzsgVSsrKVxuICAgICAgICAgICAgICBpZiAoKFcgPSBWLmNoYXJDb2RlQXQoVSkpIDwgNDggfHwgRiA8IFcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChWLCBMKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICtYO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL2lzLWZvcmNlZFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIGYgPSB0KFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgciA9IHQoXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIiksIHMgPSB0KFwiLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWRcIiksIG8gPSB0KFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiKSwgaSA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIGwgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGVcIiksIG4gPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzXCIpLmYsIGEgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIikuZiwgYyA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCBwID0gdChcIi4uL2ludGVybmFscy9zdHJpbmctdHJpbVwiKS50cmltLCBqID0gXCJOdW1iZXJcIiwgVCA9IHVbal0sIF8gPSBULnByb3RvdHlwZSwgUyA9IHIobChfKSkgPT0gajtcbiAgICAgIGlmIChoKGosICFUKFwiIDBvMVwiKSB8fCAhVChcIjBiMVwiKSB8fCBUKFwiKzB4MVwiKSkpIHtcbiAgICAgICAgZm9yICh2YXIgRSwgQSA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICB2YXIgUiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IFIsIEwgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBMIGluc3RhbmNlb2YgQSAmJiAoUyA/IGkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfLnZhbHVlT2YuY2FsbChMKTtcbiAgICAgICAgICB9KSA6IHIoTCkgIT0gaikgPyBzKG5ldyBUKG0oUikpLCBMLCBBKSA6IG0oUik7XG4gICAgICAgIH0sIHggPSB5ID8gbihUKSA6IFwiTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLE1JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXJcIi5zcGxpdChcIixcIiksIFAgPSAwOyB4Lmxlbmd0aCA+IFA7IFArKylcbiAgICAgICAgICBmKFQsIEUgPSB4W1BdKSAmJiAhZihBLCBFKSAmJiBjKEEsIEUsIGEoVCwgRSkpO1xuICAgICAgICAoQS5wcm90b3R5cGUgPSBfKS5jb25zdHJ1Y3RvciA9IEEsIGcodSwgaiwgQSk7XG4gICAgICB9XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jbGFzc29mLXJhd1wiOiAyOCwgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZFwiOiA2OCwgXCIuLi9pbnRlcm5hbHMvaXMtZm9yY2VkXCI6IDc0LCBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDk0LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiOiA5NiwgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIjogMTA5LCBcIi4uL2ludGVybmFscy9zdHJpbmctdHJpbVwiOiAxMzAsIFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiOiAxNDEgfV0sIDE3OTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpKHsgdGFyZ2V0OiBcIk51bWJlclwiLCBzdGF0OiAhMCB9LCB7IGlzRmluaXRlOiB0KFwiLi4vaW50ZXJuYWxzL251bWJlci1pcy1maW5pdGVcIikgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL251bWJlci1pcy1maW5pdGVcIjogODkgfV0sIDE4MDogW2Z1bmN0aW9uKGYsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obywgaSwgbCkge1xuICAgICAgICByZXR1cm4gaSA9PT0gMCA/IGwgOiBpICUgMiA9PSAxID8gbShvLCBpIC0gMSwgbCAqIG8pIDogbShvICogbywgaSAvIDIsIGwpO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSBmKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgdSA9IGYoXCIuLi9pbnRlcm5hbHMvdG8taW50ZWdlclwiKSwgaCA9IGYoXCIuLi9pbnRlcm5hbHMvdGhpcy1udW1iZXItdmFsdWVcIiksIGcgPSBmKFwiLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXRcIiksIGYgPSBmKFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCByID0gMSAudG9GaXhlZCwgcyA9IE1hdGguZmxvb3I7XG4gICAgICB5KHsgdGFyZ2V0OiBcIk51bWJlclwiLCBwcm90bzogITAsIGZvcmNlZDogciAmJiAoOGUtNS50b0ZpeGVkKDMpICE9PSBcIjAuMDAwXCIgfHwgMC45LnRvRml4ZWQoMCkgIT09IFwiMVwiIHx8IDEuMjU1LnRvRml4ZWQoMikgIT09IFwiMS4yNVwiIHx8IDEwMDAwMDAwMDAwMDAwMDAxMDAgLnRvRml4ZWQoMCkgIT09IFwiMTAwMDAwMDAwMDAwMDAwMDEyOFwiKSB8fCAhZihmdW5jdGlvbigpIHtcbiAgICAgICAgci5jYWxsKHt9KTtcbiAgICAgIH0pIH0sIHsgdG9GaXhlZDogZnVuY3Rpb24oaikge1xuICAgICAgICBmdW5jdGlvbiBpKEUsIEEpIHtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gLTEsIFAgPSBBOyArK3ggPCA2OyApXG4gICAgICAgICAgICBQICs9IEUgKiBUW3hdLCBUW3hdID0gUCAlIDFlNywgUCA9IHMoUCAvIDFlNyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbChFKSB7XG4gICAgICAgICAgZm9yICh2YXIgQSA9IDYsIHggPSAwOyAwIDw9IC0tQTsgKVxuICAgICAgICAgICAgeCArPSBUW0FdLCBUW0FdID0gcyh4IC8gRSksIHggPSB4ICUgRSAqIDFlNztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGZvciAodmFyIEUsIEEgPSA2LCB4ID0gXCJcIjsgMCA8PSAtLUE7IClcbiAgICAgICAgICAgIHggPT09IFwiXCIgJiYgQSAhPT0gMCAmJiBUW0FdID09PSAwIHx8IChFID0gU3RyaW5nKFRbQV0pLCB4ID0geCA9PT0gXCJcIiA/IEUgOiB4ICsgZy5jYWxsKFwiMFwiLCA3IC0gRS5sZW5ndGgpICsgRSk7XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEsIGMsIHAgPSBoKHRoaXMpLCBqID0gdShqKSwgVCA9IFswLCAwLCAwLCAwLCAwLCAwXSwgXyA9IFwiXCIsIFMgPSBcIjBcIjtcbiAgICAgICAgaWYgKGogPCAwIHx8IDIwIDwgailcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSW5jb3JyZWN0IGZyYWN0aW9uIGRpZ2l0c1wiKTtcbiAgICAgICAgaWYgKHAgIT0gcClcbiAgICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgICAgaWYgKHAgPD0gLTFlMjEgfHwgMWUyMSA8PSBwKVxuICAgICAgICAgIHJldHVybiBTdHJpbmcocCk7XG4gICAgICAgIGlmIChwIDwgMCAmJiAoXyA9IFwiLVwiLCBwID0gLXApLCAxZS0yMSA8IHApXG4gICAgICAgICAgaWYgKHAgPSAoYSA9IGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIEEgPSAwLCB4ID0gRTsgNDA5NiA8PSB4OyApXG4gICAgICAgICAgICAgIEEgKz0gMTIsIHggLz0gNDA5NjtcbiAgICAgICAgICAgIGZvciAoOyAyIDw9IHg7IClcbiAgICAgICAgICAgICAgQSArPSAxLCB4IC89IDI7XG4gICAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgICB9KHAgKiBtKDIsIDY5LCAxKSkgLSA2OSkgPCAwID8gcCAqIG0oMiwgLWEsIDEpIDogcCAvIG0oMiwgYSwgMSksIHAgKj0gNDUwMzU5OTYyNzM3MDQ5NiwgMCA8IChhID0gNTIgLSBhKSkge1xuICAgICAgICAgICAgZm9yIChpKDAsIHApLCBjID0gajsgNyA8PSBjOyApXG4gICAgICAgICAgICAgIGkoMWU3LCAwKSwgYyAtPSA3O1xuICAgICAgICAgICAgZm9yIChpKG0oMTAsIGMsIDEpLCAwKSwgYyA9IGEgLSAxOyAyMyA8PSBjOyApXG4gICAgICAgICAgICAgIGwoMSA8PCAyMyksIGMgLT0gMjM7XG4gICAgICAgICAgICBsKDEgPDwgYyksIGkoMSwgMSksIGwoMiksIFMgPSBuKCk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpKDAsIHApLCBpKDEgPDwgLWEsIDApLCBTID0gbigpICsgZy5jYWxsKFwiMFwiLCBqKTtcbiAgICAgICAgcmV0dXJuIFMgPSAwIDwgaiA/IF8gKyAoKHAgPSBTLmxlbmd0aCkgPD0gaiA/IFwiMC5cIiArIGcuY2FsbChcIjBcIiwgaiAtIHApICsgUyA6IFMuc2xpY2UoMCwgcCAtIGopICsgXCIuXCIgKyBTLnNsaWNlKHAgLSBqKSkgOiBfICsgUztcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9zdHJpbmctcmVwZWF0XCI6IDEyOCwgXCIuLi9pbnRlcm5hbHMvdGhpcy1udW1iZXItdmFsdWVcIjogMTMyLCBcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCI6IDEzNiB9XSwgMTgxOiBbZnVuY3Rpb24oeSwgSCwgQykge1xuICAgICAgdmFyIG0gPSB5KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IHkoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnblwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiT2JqZWN0XCIsIHN0YXQ6ICEwLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IHkgfSwgeyBhc3NpZ246IHkgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1hc3NpZ25cIjogOTAgfV0sIDE4MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2l0ZXJhdGVcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiT2JqZWN0XCIsIHN0YXQ6ICEwIH0sIHsgZnJvbUVudHJpZXM6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdmFyIGcgPSB7fTtcbiAgICAgICAgcmV0dXJuIHkoaCwgZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIHUoZywgZiwgcik7XG4gICAgICAgIH0sIHZvaWQgMCwgITApLCBnO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eVwiOiA0MCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9pdGVyYXRlXCI6IDc4IH1dLCAxODM6IFtmdW5jdGlvbihoLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGgoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCBnID0gaChcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgeSA9IGgoXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3RcIiksIHUgPSBoKFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIikuZiwgaCA9IGgoXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIiksIGcgPSBnKGZ1bmN0aW9uKCkge1xuICAgICAgICB1KDEpO1xuICAgICAgfSk7XG4gICAgICBtKHsgdGFyZ2V0OiBcIk9iamVjdFwiLCBzdGF0OiAhMCwgZm9yY2VkOiAhaCB8fCBnLCBzaGFtOiAhaCB9LCB7IGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICByZXR1cm4gdSh5KGYpLCByKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiA5NCwgXCIuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3RcIjogMTM1IH1dLCAxODQ6IFtmdW5jdGlvbih1LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHUoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdShcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgdSA9IHUoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWxcIikuZjtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiT2JqZWN0XCIsIHN0YXQ6ICEwLCBmb3JjZWQ6IHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoMSk7XG4gICAgICB9KSB9LCB7IGdldE93blByb3BlcnR5TmFtZXM6IHUgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbFwiOiA5NSB9XSwgMTg1OiBbZnVuY3Rpb24oZywgSCwgQykge1xuICAgICAgdmFyIG0gPSBnKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IGcoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHUgPSBnKFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgaCA9IGcoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2ZcIiksIGcgPSBnKFwiLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlclwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiT2JqZWN0XCIsIHN0YXQ6ICEwLCBmb3JjZWQ6IHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGgoMSk7XG4gICAgICB9KSwgc2hhbTogIWcgfSwgeyBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gaCh1KGYpKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXJcIjogMzUsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mXCI6IDk4LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4IH1dLCAxODY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJPYmplY3RcIiwgc3RhdDogITAsIGZvcmNlZDogdChcIi4uL2ludGVybmFscy9mYWlsc1wiKShmdW5jdGlvbigpIHtcbiAgICAgICAgdSgxKTtcbiAgICAgIH0pIH0sIHsga2V5czogZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gdSh5KGgpKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9vYmplY3Qta2V5c1wiOiAxMDAsIFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiOiAxMzggfV0sIDE4NzogW2Z1bmN0aW9uKHUsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdShcIi4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnRcIiksIHkgPSB1KFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCIpLCB1ID0gdShcIi4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nXCIpO1xuICAgICAgbSB8fCB5KE9iamVjdC5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgdSwgeyB1bnNhZmU6ICEwIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZ1wiOiAxMDMsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0XCI6IDE0MiB9XSwgMTg4OiBbZnVuY3Rpb24oeGUsIEgsIEMpIHtcbiAgICAgIHZhciBtLCB5LCB1LCBoLCBnID0geGUoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCBmID0geGUoXCIuLi9pbnRlcm5hbHMvaXMtcHVyZVwiKSwgciA9IHhlKFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgcyA9IHhlKFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgbyA9IHhlKFwiLi4vaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yXCIpLCBpID0geGUoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIGwgPSB4ZShcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIiksIG4gPSB4ZShcIi4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZ1wiKSwgYSA9IHhlKFwiLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzXCIpLCBjID0geGUoXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCBwID0geGUoXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiKSwgaiA9IHhlKFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCIpLCBUID0geGUoXCIuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXdcIiksIF8gPSB4ZShcIi4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZVwiKSwgUyA9IHhlKFwiLi4vaW50ZXJuYWxzL2l0ZXJhdGVcIiksIEUgPSB4ZShcIi4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb25cIiksIEEgPSB4ZShcIi4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yXCIpLCB4ID0geGUoXCIuLi9pbnRlcm5hbHMvdGFza1wiKS5zZXQsIFAgPSB4ZShcIi4uL2ludGVybmFscy9taWNyb3Rhc2tcIiksIE0gPSB4ZShcIi4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmVcIiksIFIgPSB4ZShcIi4uL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnNcIiksIEwgPSB4ZShcIi4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5XCIpLCBGID0geGUoXCIuLi9pbnRlcm5hbHMvcGVyZm9ybVwiKSwgViA9IHhlKFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCIpLCBHID0geGUoXCIuLi9pbnRlcm5hbHMvaXMtZm9yY2VkXCIpLCBEZSA9IHhlKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBVID0geGUoXCIuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb25cIiksIFcgPSBEZShcInNwZWNpZXNcIiksIFggPSBcIlByb21pc2VcIiwgbmUgPSBWLmdldCwgYiA9IFYuc2V0LCBPID0gVi5nZXR0ZXJGb3IoWCksIEQgPSBvLCBCID0gci5UeXBlRXJyb3IsIFkgPSByLmRvY3VtZW50LCBKID0gci5wcm9jZXNzLCB0ZSA9IHMoXCJmZXRjaFwiKSwgY2UgPSBMLmYsIHJlID0gY2UsIHVlID0gVChKKSA9PSBcInByb2Nlc3NcIiwgbGUgPSAhIShZICYmIFkuY3JlYXRlRXZlbnQgJiYgci5kaXNwYXRjaEV2ZW50KSwgSyA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIGFlID0gXCJyZWplY3Rpb25oYW5kbGVkXCIsIGhlID0gMSwgX2UgPSAyLCBmZSA9IDEsIGdlID0gMiwgeGUgPSBHKFgsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgUmUsIHdlO1xuICAgICAgICByZXR1cm4gXyhEKSA9PT0gU3RyaW5nKEQpICYmIChVID09PSA2NiB8fCAhdWUgJiYgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCAhPSBcImZ1bmN0aW9uXCIpID8gITAgOiAhKCFmIHx8IEQucHJvdG90eXBlLmZpbmFsbHkpIHx8ICEoNTEgPD0gVSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoRCkpICYmICh3ZSA9IGZ1bmN0aW9uKFopIHtcbiAgICAgICAgICBaKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoKFJlID0gRC5yZXNvbHZlKDEpKS5jb25zdHJ1Y3RvciA9IHt9KVtXXSA9IHdlLCAhKFJlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIH0pIGluc3RhbmNlb2Ygd2UpKTtcbiAgICAgIH0pLCBEZSA9IHhlIHx8ICFFKGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIEQuYWxsKFJlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgTWUgPSBmdW5jdGlvbihSZSkge1xuICAgICAgICB2YXIgd2U7XG4gICAgICAgIHJldHVybiAhKCFjKFJlKSB8fCB0eXBlb2YgKHdlID0gUmUudGhlbikgIT0gXCJmdW5jdGlvblwiKSAmJiB3ZTtcbiAgICAgIH0sIFFlID0gZnVuY3Rpb24oUmUsIHdlLCBaKSB7XG4gICAgICAgIHZhciAkO1xuICAgICAgICB3ZS5ub3RpZmllZCB8fCAod2Uubm90aWZpZWQgPSAhMCwgJCA9IHdlLnJlYWN0aW9ucywgUChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBxLCBlZSwgcGUgPSB3ZS52YWx1ZSwgamUgPSB3ZS5zdGF0ZSA9PSBoZSwgQ2UgPSAwOyAkLmxlbmd0aCA+IENlOyApIHtcbiAgICAgICAgICAgIHZhciBGZSwgTmUsIEJlLCBXZSA9ICRbQ2UrK10sIHN0ID0gamUgPyBXZS5vayA6IFdlLmZhaWwsIG50ID0gV2UucmVzb2x2ZSwgS2UgPSBXZS5yZWplY3QsIGF0ID0gV2UuZG9tYWluO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3QgPyAoamUgfHwgKHdlLnJlamVjdGlvbiA9PT0gZ2UgJiYgZnVuY3Rpb24ob3QsIGJ0KSB7XG4gICAgICAgICAgICAgICAgeC5jYWxsKHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdWUgPyBKLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIG90KSA6IHplKGFlLCBvdCwgYnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KFJlLCB3ZSksIHdlLnJlamVjdGlvbiA9IGZlKSwgc3QgPT09ICEwID8gRmUgPSBwZSA6IChhdCAmJiBhdC5lbnRlcigpLCBGZSA9IHN0KHBlKSwgYXQgJiYgKGF0LmV4aXQoKSwgQmUgPSAhMCkpLCBGZSA9PT0gV2UucHJvbWlzZSA/IEtlKEIoXCJQcm9taXNlLWNoYWluIGN5Y2xlXCIpKSA6IChOZSA9IE1lKEZlKSkgPyBOZS5jYWxsKEZlLCBudCwgS2UpIDogbnQoRmUpKSA6IEtlKHBlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG90KSB7XG4gICAgICAgICAgICAgIGF0ICYmICFCZSAmJiBhdC5leGl0KCksIEtlKG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2UucmVhY3Rpb25zID0gW10sIHdlLm5vdGlmaWVkID0gITEsIFogJiYgIXdlLnJlamVjdGlvbiAmJiAocSA9IFJlLCBlZSA9IHdlLCB4LmNhbGwociwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3QgPSBlZS52YWx1ZSwgYnQgPSBWZShlZSk7XG4gICAgICAgICAgICBpZiAoYnQgJiYgKGJ0ID0gRihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdWUgPyBKLmVtaXQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgb3QsIHEpIDogemUoSywgcSwgb3QpO1xuICAgICAgICAgICAgfSksIGVlLnJlamVjdGlvbiA9IHVlIHx8IFZlKGVlKSA/IGdlIDogZmUsIGJ0LmVycm9yKSlcbiAgICAgICAgICAgICAgdGhyb3cgYnQudmFsdWU7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9LCB6ZSA9IGZ1bmN0aW9uKFJlLCB3ZSwgWikge1xuICAgICAgICB2YXIgJDtcbiAgICAgICAgbGUgPyAoKCQgPSBZLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpLnByb21pc2UgPSB3ZSwgJC5yZWFzb24gPSBaLCAkLmluaXRFdmVudChSZSwgITEsICEwKSwgci5kaXNwYXRjaEV2ZW50KCQpKSA6ICQgPSB7IHByb21pc2U6IHdlLCByZWFzb246IFogfSwgKHdlID0gcltcIm9uXCIgKyBSZV0pID8gd2UoJCkgOiBSZSA9PT0gSyAmJiBSKFwiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uXCIsIFopO1xuICAgICAgfSwgVmUgPSBmdW5jdGlvbihSZSkge1xuICAgICAgICByZXR1cm4gUmUucmVqZWN0aW9uICE9PSBmZSAmJiAhUmUucGFyZW50O1xuICAgICAgfSwgWGUgPSBmdW5jdGlvbihSZSwgd2UsIFosICQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICBSZSh3ZSwgWiwgcSwgJCk7XG4gICAgICAgIH07XG4gICAgICB9LCBIZSA9IGZ1bmN0aW9uKFJlLCB3ZSwgWiwgJCkge1xuICAgICAgICB3ZS5kb25lIHx8ICh3ZS5kb25lID0gITAsICh3ZSA9ICQgfHwgd2UpLnZhbHVlID0gWiwgd2Uuc3RhdGUgPSBfZSwgUWUoUmUsIHdlLCAhMCkpO1xuICAgICAgfSwgdmUgPSBmdW5jdGlvbihSZSwgd2UsIFosICQpIHtcbiAgICAgICAgaWYgKCF3ZS5kb25lKSB7XG4gICAgICAgICAgd2UuZG9uZSA9ICEwLCAkICYmICh3ZSA9ICQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoUmUgPT09IFopXG4gICAgICAgICAgICAgIHRocm93IEIoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICAgICAgICAgIHZhciBxID0gTWUoWik7XG4gICAgICAgICAgICBxID8gUChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGVlID0geyBkb25lOiAhMSB9O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHEuY2FsbChaLCBYZSh2ZSwgUmUsIGVlLCB3ZSksIFhlKEhlLCBSZSwgZWUsIHdlKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHBlKSB7XG4gICAgICAgICAgICAgICAgSGUoUmUsIGVlLCBwZSwgd2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSA6ICh3ZS52YWx1ZSA9IFosIHdlLnN0YXRlID0gaGUsIFFlKFJlLCB3ZSwgITEpKTtcbiAgICAgICAgICB9IGNhdGNoIChlZSkge1xuICAgICAgICAgICAgSGUoUmUsIHsgZG9uZTogITEgfSwgZWUsIHdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4ZSAmJiAoRCA9IGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIGoodGhpcywgRCwgWCksIHAoUmUpLCBtLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciB3ZSA9IG5lKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlKFhlKHZlLCB0aGlzLCB3ZSksIFhlKEhlLCB0aGlzLCB3ZSkpO1xuICAgICAgICB9IGNhdGNoIChaKSB7XG4gICAgICAgICAgSGUodGhpcywgd2UsIFopO1xuICAgICAgICB9XG4gICAgICB9LCAobSA9IGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIGIodGhpcywgeyB0eXBlOiBYLCBkb25lOiAhMSwgbm90aWZpZWQ6ICExLCBwYXJlbnQ6ICExLCByZWFjdGlvbnM6IFtdLCByZWplY3Rpb246ICExLCBzdGF0ZTogMCwgdmFsdWU6IHZvaWQgMCB9KTtcbiAgICAgIH0pLnByb3RvdHlwZSA9IGwoRC5wcm90b3R5cGUsIHsgdGhlbjogZnVuY3Rpb24oUmUsIHdlKSB7XG4gICAgICAgIHZhciBaID0gTyh0aGlzKSwgJCA9IGNlKEEodGhpcywgRCkpO1xuICAgICAgICByZXR1cm4gJC5vayA9IHR5cGVvZiBSZSAhPSBcImZ1bmN0aW9uXCIgfHwgUmUsICQuZmFpbCA9IHR5cGVvZiB3ZSA9PSBcImZ1bmN0aW9uXCIgJiYgd2UsICQuZG9tYWluID0gdWUgPyBKLmRvbWFpbiA6IHZvaWQgMCwgWi5wYXJlbnQgPSAhMCwgWi5yZWFjdGlvbnMucHVzaCgkKSwgWi5zdGF0ZSAhPSAwICYmIFFlKHRoaXMsIFosICExKSwgJC5wcm9taXNlO1xuICAgICAgfSwgY2F0Y2g6IGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBSZSk7XG4gICAgICB9IH0pLCB5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBSZSA9IG5ldyBtKCksIHdlID0gbmUoUmUpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBSZSwgdGhpcy5yZXNvbHZlID0gWGUodmUsIFJlLCB3ZSksIHRoaXMucmVqZWN0ID0gWGUoSGUsIFJlLCB3ZSk7XG4gICAgICB9LCBMLmYgPSBjZSA9IGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIHJldHVybiBSZSA9PT0gRCB8fCBSZSA9PT0gdSA/IG5ldyB5KCkgOiByZShSZSk7XG4gICAgICB9LCBmIHx8IHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIiB8fCAoaCA9IG8ucHJvdG90eXBlLnRoZW4sIGkoby5wcm90b3R5cGUsIFwidGhlblwiLCBmdW5jdGlvbihSZSwgd2UpIHtcbiAgICAgICAgdmFyIFogPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEQoZnVuY3Rpb24oJCwgcSkge1xuICAgICAgICAgIGguY2FsbChaLCAkLCBxKTtcbiAgICAgICAgfSkudGhlbihSZSwgd2UpO1xuICAgICAgfSwgeyB1bnNhZmU6ICEwIH0pLCB0eXBlb2YgdGUgPT0gXCJmdW5jdGlvblwiICYmIGcoeyBnbG9iYWw6ICEwLCBlbnVtZXJhYmxlOiAhMCwgZm9yY2VkOiAhMCB9LCB7IGZldGNoOiBmdW5jdGlvbihSZSkge1xuICAgICAgICByZXR1cm4gTShELCB0ZS5hcHBseShyLCBhcmd1bWVudHMpKTtcbiAgICAgIH0gfSkpKSwgZyh7IGdsb2JhbDogITAsIHdyYXA6ICEwLCBmb3JjZWQ6IHhlIH0sIHsgUHJvbWlzZTogRCB9KSwgbihELCBYLCAhMSwgITApLCBhKFgpLCB1ID0gcyhYKSwgZyh7IHRhcmdldDogWCwgc3RhdDogITAsIGZvcmNlZDogeGUgfSwgeyByZWplY3Q6IGZ1bmN0aW9uKFJlKSB7XG4gICAgICAgIHZhciB3ZSA9IGNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gd2UucmVqZWN0LmNhbGwodm9pZCAwLCBSZSksIHdlLnByb21pc2U7XG4gICAgICB9IH0pLCBnKHsgdGFyZ2V0OiBYLCBzdGF0OiAhMCwgZm9yY2VkOiBmIHx8IHhlIH0sIHsgcmVzb2x2ZTogZnVuY3Rpb24oUmUpIHtcbiAgICAgICAgcmV0dXJuIE0oZiAmJiB0aGlzID09PSB1ID8gRCA6IHRoaXMsIFJlKTtcbiAgICAgIH0gfSksIGcoeyB0YXJnZXQ6IFgsIHN0YXQ6ICEwLCBmb3JjZWQ6IERlIH0sIHsgYWxsOiBmdW5jdGlvbihSZSkge1xuICAgICAgICB2YXIgd2UgPSB0aGlzLCBaID0gY2Uod2UpLCAkID0gWi5yZXNvbHZlLCBxID0gWi5yZWplY3QsIGVlID0gRihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGUgPSBwKHdlLnJlc29sdmUpLCBqZSA9IFtdLCBDZSA9IDAsIEZlID0gMTtcbiAgICAgICAgICBTKFJlLCBmdW5jdGlvbihOZSkge1xuICAgICAgICAgICAgdmFyIEJlID0gQ2UrKywgV2UgPSAhMTtcbiAgICAgICAgICAgIGplLnB1c2godm9pZCAwKSwgRmUrKywgcGUuY2FsbCh3ZSwgTmUpLnRoZW4oZnVuY3Rpb24oc3QpIHtcbiAgICAgICAgICAgICAgV2UgfHwgKFdlID0gITAsIGplW0JlXSA9IHN0LCAtLUZlIHx8ICQoamUpKTtcbiAgICAgICAgICAgIH0sIHEpO1xuICAgICAgICAgIH0pLCAtLUZlIHx8ICQoamUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVlLmVycm9yICYmIHEoZWUudmFsdWUpLCBaLnByb21pc2U7XG4gICAgICB9LCByYWNlOiBmdW5jdGlvbihSZSkge1xuICAgICAgICB2YXIgd2UgPSB0aGlzLCBaID0gY2Uod2UpLCAkID0gWi5yZWplY3QsIHEgPSBGKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlZSA9IHAod2UucmVzb2x2ZSk7XG4gICAgICAgICAgUyhSZSwgZnVuY3Rpb24ocGUpIHtcbiAgICAgICAgICAgIGVlLmNhbGwod2UsIHBlKS50aGVuKFoucmVzb2x2ZSwgJCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcS5lcnJvciAmJiAkKHEudmFsdWUpLCBaLnByb21pc2U7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiOiA1LCBcIi4uL2ludGVybmFscy9hbi1pbnN0YW5jZVwiOiA5LCBcIi4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb25cIjogMjcsIFwiLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3XCI6IDI4LCBcIi4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvblwiOiA0OCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9nZXQtYnVpbHQtaW5cIjogNTcsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzXCI6IDYzLCBcIi4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZVwiOiA2OSwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIjogNzEsIFwiLi4vaW50ZXJuYWxzL2lzLWZvcmNlZFwiOiA3NCwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9pcy1wdXJlXCI6IDc2LCBcIi4uL2ludGVybmFscy9pdGVyYXRlXCI6IDc4LCBcIi4uL2ludGVybmFscy9taWNyb3Rhc2tcIjogODIsIFwiLi4vaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yXCI6IDgzLCBcIi4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5XCI6IDg3LCBcIi4uL2ludGVybmFscy9wZXJmb3JtXCI6IDEwNiwgXCIuLi9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlXCI6IDEwNywgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIjogMTA5LCBcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIjogMTA4LCBcIi4uL2ludGVybmFscy9zZXQtc3BlY2llc1wiOiAxMTcsIFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCI6IDExOCwgXCIuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvclwiOiAxMjIsIFwiLi4vaW50ZXJuYWxzL3Rhc2tcIjogMTMxLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDE4OTogW2Z1bmN0aW9uKHIsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gcihcIi4uL2ludGVybmFscy9leHBvcnRcIiksIGwgPSByKFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgeSA9IHIoXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiKSwgdSA9IHIoXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCIpLCBoID0gcihcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIGcgPSByKFwiLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGVcIiksIGYgPSByKFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmRcIiksIHIgPSByKFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCBzID0gbChcIlJlZmxlY3RcIiwgXCJjb25zdHJ1Y3RcIiksIG8gPSByKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhKHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIFtdLCBuKSBpbnN0YW5jZW9mIG4pO1xuICAgICAgfSksIGkgPSAhcihmdW5jdGlvbigpIHtcbiAgICAgICAgcyhmdW5jdGlvbigpIHtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgbCA9IG8gfHwgaTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiUmVmbGVjdFwiLCBzdGF0OiAhMCwgZm9yY2VkOiBsLCBzaGFtOiBsIH0sIHsgY29uc3RydWN0OiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgIHkobiksIHUoYSk7XG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBuIDogeShhcmd1bWVudHNbMl0pO1xuICAgICAgICBpZiAoaSAmJiAhbylcbiAgICAgICAgICByZXR1cm4gcyhuLCBhLCBjKTtcbiAgICAgICAgaWYgKG4gPT0gYykge1xuICAgICAgICAgIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBuKCk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgbihhWzBdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBuKGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IG4oYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgbihhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHAgPSBbbnVsbF07XG4gICAgICAgICAgcmV0dXJuIHAucHVzaC5hcHBseShwLCBhKSwgbmV3IChmLmFwcGx5KG4sIHApKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwID0gYy5wcm90b3R5cGUsIGMgPSBnKGgocCkgPyBwIDogT2JqZWN0LnByb3RvdHlwZSksIHAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKG4sIGMsIGEpLCBoKHApID8gcCA6IGM7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYS1mdW5jdGlvblwiOiA1LCBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmRcIjogNTYsIFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiOiA1NywgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxIH1dLCAxOTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCBnID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZlwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiUmVmbGVjdFwiLCBzdGF0OiAhMCB9LCB7IGdldDogZnVuY3Rpb24gcihzLCBvKSB7XG4gICAgICAgIHZhciBpLCBsID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBzIDogYXJndW1lbnRzWzJdO1xuICAgICAgICByZXR1cm4gdShzKSA9PT0gbCA/IHNbb10gOiAoaSA9IGcuZihzLCBvKSkgPyBoKGksIFwidmFsdWVcIikgPyBpLnZhbHVlIDogaS5nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGkuZ2V0LmNhbGwobCkgOiB5KGkgPSBmKHMpKSA/IHIoaSwgbywgbCkgOiB2b2lkIDA7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9leHBvcnRcIjogNTAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDk0LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZlwiOiA5OCB9XSwgMTkxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL2lzLWZvcmNlZFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKS5mLCBmID0gdChcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKS5mLCByID0gdChcIi4uL2ludGVybmFscy9pcy1yZWdleHBcIiksIHMgPSB0KFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFnc1wiKSwgbyA9IHQoXCIuLi9pbnRlcm5hbHMvcmVnZXhwLXN0aWNreS1oZWxwZXJzXCIpLCBpID0gdChcIi4uL2ludGVybmFscy9yZWRlZmluZVwiKSwgbCA9IHQoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIG4gPSB0KFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCIpLnNldCwgYSA9IHQoXCIuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXNcIiksIGMgPSB0KFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpKFwibWF0Y2hcIiksIHAgPSB5LlJlZ0V4cCwgaiA9IHAucHJvdG90eXBlLCBUID0gL2EvZywgXyA9IC9hL2csIFMgPSBuZXcgcChUKSAhPT0gVCwgRSA9IG8uVU5TVVBQT1JURURfWTtcbiAgICAgIGlmIChtICYmIHUoXCJSZWdFeHBcIiwgIVMgfHwgRSB8fCBsKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1tjXSA9ICExLCBwKFQpICE9IFQgfHwgcChfKSA9PSBfIHx8IHAoVCwgXCJpXCIpICE9IFwiL2EvaVwiO1xuICAgICAgfSkpKSB7XG4gICAgICAgIGZvciAodmFyIEEgPSBmdW5jdGlvbihNLCBSKSB7XG4gICAgICAgICAgdmFyIEwsIEYgPSB0aGlzIGluc3RhbmNlb2YgQSwgViA9IHIoTSksIEcgPSBSID09PSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuICFGICYmIFYgJiYgTS5jb25zdHJ1Y3RvciA9PT0gQSAmJiBHID8gTSA6IChTID8gViAmJiAhRyAmJiAoTSA9IE0uc291cmNlKSA6IE0gaW5zdGFuY2VvZiBBICYmIChHICYmIChSID0gcy5jYWxsKE0pKSwgTSA9IE0uc291cmNlKSwgRSAmJiAoTCA9ICEhUiAmJiAtMSA8IFIuaW5kZXhPZihcInlcIikpICYmIChSID0gUi5yZXBsYWNlKC95L2csIFwiXCIpKSwgViA9IGgoUyA/IG5ldyBwKE0sIFIpIDogcChNLCBSKSwgRiA/IHRoaXMgOiBqLCBBKSwgRSAmJiBMICYmIG4oViwgeyBzdGlja3k6IEwgfSksIFYpO1xuICAgICAgICB9LCB4ID0gZihwKSwgUCA9IDA7IHgubGVuZ3RoID4gUDsgKVxuICAgICAgICAgIChmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBNIGluIEEgfHwgZyhBLCBNLCB7IGNvbmZpZ3VyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwW01dO1xuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICAgIHBbTV0gPSBSO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICB9KSh4W1ArK10pO1xuICAgICAgICAoai5jb25zdHJ1Y3RvciA9IEEpLnByb3RvdHlwZSA9IGosIGkoeSwgXCJSZWdFeHBcIiwgQSk7XG4gICAgICB9XG4gICAgICBhKFwiUmVnRXhwXCIpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWRcIjogNjgsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9pcy1mb3JjZWRcIjogNzQsIFwiLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cFwiOiA3NywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiOiA5MywgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXNcIjogOTYsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzXCI6IDExMiwgXCIuLi9pbnRlcm5hbHMvcmVnZXhwLXN0aWNreS1oZWxwZXJzXCI6IDExMywgXCIuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXNcIjogMTE3LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDkgfV0sIDE5MjogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB5KFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJSZWdFeHBcIiwgcHJvdG86ICEwLCBmb3JjZWQ6IC8uLy5leGVjICE9PSB5IH0sIHsgZXhlYzogeSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWNcIjogMTExIH1dLCAxOTM6IFtmdW5jdGlvbihoLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGgoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIHkgPSBoKFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiKSwgciA9IGgoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHUgPSBoKFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFnc1wiKSwgaCA9IFwidG9TdHJpbmdcIiwgZyA9IFJlZ0V4cC5wcm90b3R5cGUsIGYgPSBnW2hdLCByID0gcihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGYuY2FsbCh7IHNvdXJjZTogXCJhXCIsIGZsYWdzOiBcImJcIiB9KSAhPSBcIi9hL2JcIjtcbiAgICAgIH0pLCBzID0gZi5uYW1lICE9IGg7XG4gICAgICAociB8fCBzKSAmJiBtKFJlZ0V4cC5wcm90b3R5cGUsIGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbyA9IHkodGhpcyksIGkgPSBTdHJpbmcoby5zb3VyY2UpLCBsID0gby5mbGFncztcbiAgICAgICAgcmV0dXJuIFwiL1wiICsgaSArIFwiL1wiICsgU3RyaW5nKGwgPT09IHZvaWQgMCAmJiBvIGluc3RhbmNlb2YgUmVnRXhwICYmICEoXCJmbGFnc1wiIGluIGcpID8gdS5jYWxsKG8pIDogbCk7XG4gICAgICB9LCB7IHVuc2FmZTogITAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy9yZWRlZmluZVwiOiAxMDksIFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFnc1wiOiAxMTIgfV0sIDE5NDogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBtID0geShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uXCIpLCB5ID0geShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZ1wiKTtcbiAgICAgIEguZXhwb3J0cyA9IG0oXCJTZXRcIiwgZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHUodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCk7XG4gICAgICAgIH07XG4gICAgICB9LCB5KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb25cIjogMzIsIFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nXCI6IDMwIH1dLCAxOTU6IFtmdW5jdGlvbihmLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGYoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gZihcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLmYsIHUgPSBmKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgaCA9IGYoXCIuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwXCIpLCBnID0gZihcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIiksIG8gPSBmKFwiLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljXCIpLCBmID0gZihcIi4uL2ludGVybmFscy9pcy1wdXJlXCIpLCByID0gXCJcIi5lbmRzV2l0aCwgcyA9IE1hdGgubWluLCBvID0gbyhcImVuZHNXaXRoXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJTdHJpbmdcIiwgcHJvdG86ICEwLCBmb3JjZWQ6ICEhKGYgfHwgbyB8fCAhKG0gPSB5KFN0cmluZy5wcm90b3R5cGUsIFwiZW5kc1dpdGhcIikpIHx8IG0ud3JpdGFibGUpICYmICFvIH0sIHsgZW5kc1dpdGg6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGwgPSBTdHJpbmcoZyh0aGlzKSksIG4gPSAoaChpKSwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApLCBhID0gdShsLmxlbmd0aCksIG4gPSBuID09PSB2b2lkIDAgPyBhIDogcyh1KG4pLCBhKSwgYSA9IFN0cmluZyhpKTtcbiAgICAgICAgcmV0dXJuIHIgPyByLmNhbGwobCwgYSwgbikgOiBsLnNsaWNlKG4gLSBhLmxlbmd0aCwgbikgPT09IGE7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWNcIjogMzQsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvaXMtcHVyZVwiOiA3NiwgXCIuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwXCI6IDg4LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDk0LCBcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIjogMTE0LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3IH1dLCAxOTY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9ub3QtYS1yZWdleHBcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiU3RyaW5nXCIsIHByb3RvOiAhMCwgZm9yY2VkOiAhdChcIi4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpY1wiKShcImluY2x1ZGVzXCIpIH0sIHsgaW5jbHVkZXM6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuICEhflN0cmluZyh1KHRoaXMpKS5pbmRleE9mKHkoaCksIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpY1wiOiAzNCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9ub3QtYS1yZWdleHBcIjogODgsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQgfV0sIDE5NzogW2Z1bmN0aW9uKHUsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdShcIi4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlXCIpLmNoYXJBdCwgeSA9IHUoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIiksIHUgPSB1KFwiLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvclwiKSwgaCA9IFwiU3RyaW5nIEl0ZXJhdG9yXCIsIGcgPSB5LnNldCwgZiA9IHkuZ2V0dGVyRm9yKGgpO1xuICAgICAgdShTdHJpbmcsIFwiU3RyaW5nXCIsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgZyh0aGlzLCB7IHR5cGU6IGgsIHN0cmluZzogU3RyaW5nKHIpLCBpbmRleDogMCB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgciA9IGYodGhpcyksIHMgPSByLnN0cmluZywgbyA9IHIuaW5kZXg7XG4gICAgICAgIHJldHVybiBvID49IHMubGVuZ3RoID8geyB2YWx1ZTogdm9pZCAwLCBkb25lOiAhMCB9IDogKHMgPSBtKHMsIG8pLCByLmluZGV4ICs9IHMubGVuZ3RoLCB7IHZhbHVlOiBzLCBkb25lOiAhMSB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yXCI6IDQxLCBcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiOiA3MSwgXCIuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZVwiOiAxMjQgfV0sIDE5ODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlXCIpLCBnID0gdChcIi4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleFwiKSwgZiA9IHQoXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3RcIik7XG4gICAgICBtKFwibWF0Y2hcIiwgMSwgZnVuY3Rpb24ociwgcywgbykge1xuICAgICAgICByZXR1cm4gW2Z1bmN0aW9uKGkpIHtcbiAgICAgICAgICB2YXIgbCA9IGgodGhpcyksIG4gPSBpID09IG51bGwgPyB2b2lkIDAgOiBpW3JdO1xuICAgICAgICAgIHJldHVybiBuICE9PSB2b2lkIDAgPyBuLmNhbGwoaSwgbCkgOiBuZXcgUmVnRXhwKGkpW3JdKFN0cmluZyhsKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICB2YXIgbCA9IG8ocywgaSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGwuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBsLnZhbHVlO1xuICAgICAgICAgIHZhciBuID0geShpKSwgYSA9IFN0cmluZyh0aGlzKTtcbiAgICAgICAgICBpZiAoIW4uZ2xvYmFsKVxuICAgICAgICAgICAgcmV0dXJuIGYobiwgYSk7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IG4udW5pY29kZSwgcCA9IFtdLCBqID0gbi5sYXN0SW5kZXggPSAwOyAoVCA9IGYobiwgYSkpICE9PSBudWxsOyApIHtcbiAgICAgICAgICAgIHZhciBUID0gU3RyaW5nKFRbMF0pO1xuICAgICAgICAgICAgKHBbal0gPSBUKSA9PT0gXCJcIiAmJiAobi5sYXN0SW5kZXggPSBnKGEsIHUobi5sYXN0SW5kZXgpLCBjKSksIGorKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGogPT09IDAgPyBudWxsIDogcDtcbiAgICAgICAgfV07XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4XCI6IDgsIFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiOiAxMCwgXCIuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpY1wiOiA1MiwgXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3RcIjogMTEwLCBcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIjogMTE0LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3IH1dLCAxOTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9zdHJpbmctcGFkXCIpLnN0YXJ0O1xuICAgICAgbSh7IHRhcmdldDogXCJTdHJpbmdcIiwgcHJvdG86ICEwLCBmb3JjZWQ6IHQoXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXBhZC13ZWJraXQtYnVnXCIpIH0sIHsgcGFkU3RhcnQ6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHkodGhpcywgdSwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApO1xuICAgICAgfSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXBhZFwiOiAxMjYsIFwiLi4vaW50ZXJuYWxzL3N0cmluZy1wYWQtd2Via2l0LWJ1Z1wiOiAxMjUgfV0sIDIwMDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpKHsgdGFyZ2V0OiBcIlN0cmluZ1wiLCBwcm90bzogITAgfSwgeyByZXBlYXQ6IHQoXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdFwiKSB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdFwiOiAxMjggfV0sIDIwMTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLW9iamVjdFwiKSwgaCA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoXCIpLCBnID0gdChcIi4uL2ludGVybmFscy90by1pbnRlZ2VyXCIpLCBmID0gdChcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIiksIHIgPSB0KFwiLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4XCIpLCBzID0gdChcIi4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdFwiKSwgbyA9IE1hdGgubWF4LCBpID0gTWF0aC5taW4sIGwgPSBNYXRoLmZsb29yLCBuID0gL1xcJChbJCYnYF18XFxkXFxkP3w8W14+XSo+KS9nLCBhID0gL1xcJChbJCYnYF18XFxkXFxkPykvZztcbiAgICAgIG0oXCJyZXBsYWNlXCIsIDIsIGZ1bmN0aW9uKGMsIHAsIGosIFQpIHtcbiAgICAgICAgdmFyIF8gPSBULlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFLCBTID0gVC5SRVBMQUNFX0tFRVBTXyQwLCBFID0gXyA/IFwiJFwiIDogXCIkMFwiO1xuICAgICAgICByZXR1cm4gW2Z1bmN0aW9uKEEsIHgpIHtcbiAgICAgICAgICB2YXIgUCA9IGYodGhpcyksIE0gPSBBID09IG51bGwgPyB2b2lkIDAgOiBBW2NdO1xuICAgICAgICAgIHJldHVybiBNICE9PSB2b2lkIDAgPyBNLmNhbGwoQSwgUCwgeCkgOiBwLmNhbGwoU3RyaW5nKFApLCBBLCB4KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oQSwgeCkge1xuICAgICAgICAgIGlmICghXyAmJiBTIHx8IHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYgeC5pbmRleE9mKEUpID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIFAgPSBqKHAsIEEsIHRoaXMsIHgpO1xuICAgICAgICAgICAgaWYgKFAuZG9uZSlcbiAgICAgICAgICAgICAgcmV0dXJuIFAudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIE0sIFIgPSB5KEEpLCBMID0gU3RyaW5nKHRoaXMpLCBGID0gdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiLCBWID0gKEYgfHwgKHggPSBTdHJpbmcoeCkpLCBSLmdsb2JhbCksIEcgPSAoViAmJiAoTSA9IFIudW5pY29kZSwgUi5sYXN0SW5kZXggPSAwKSwgW10pOyAoYiA9IHMoUiwgTCkpICE9PSBudWxsICYmIChHLnB1c2goYiksIFYpOyApXG4gICAgICAgICAgICBTdHJpbmcoYlswXSkgPT09IFwiXCIgJiYgKFIubGFzdEluZGV4ID0gcihMLCBoKFIubGFzdEluZGV4KSwgTSkpO1xuICAgICAgICAgIGZvciAodmFyIFUsIFcgPSBcIlwiLCBYID0gMCwgbmUgPSAwOyBuZSA8IEcubGVuZ3RoOyBuZSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gR1tuZV0sIE8gPSBTdHJpbmcoYlswXSksIEQgPSBvKGkoZyhiLmluZGV4KSwgTC5sZW5ndGgpLCAwKSwgQiA9IFtdLCBZID0gMTsgWSA8IGIubGVuZ3RoOyBZKyspXG4gICAgICAgICAgICAgIEIucHVzaCgoVSA9IGJbWV0pID09PSB2b2lkIDAgPyBVIDogU3RyaW5nKFUpKTtcbiAgICAgICAgICAgIHZhciBKID0gYi5ncm91cHMsIHRlID0gRiA/ICh0ZSA9IFtPXS5jb25jYXQoQiwgRCwgTCksIEogIT09IHZvaWQgMCAmJiB0ZS5wdXNoKEopLCBTdHJpbmcoeC5hcHBseSh2b2lkIDAsIHRlKSkpIDogZnVuY3Rpb24oY2UsIHJlLCB1ZSwgbGUsIEssIGFlKSB7XG4gICAgICAgICAgICAgIHZhciBoZSA9IHVlICsgY2UubGVuZ3RoLCBfZSA9IGxlLmxlbmd0aCwgZmUgPSBhO1xuICAgICAgICAgICAgICByZXR1cm4gSyAhPT0gdm9pZCAwICYmIChLID0gdShLKSwgZmUgPSBuKSwgcC5jYWxsKGFlLCBmZSwgZnVuY3Rpb24oZ2UsIHhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIERlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoeGUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2U7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiYFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmUuc2xpY2UoMCwgdWUpO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlLnNsaWNlKGhlKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIERlID0gS1t4ZS5zbGljZSgxLCAtMSldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBNZSwgUWUgPSAreGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChRZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lIDwgUWUpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChNZSA9IGwoUWUgLyAxMCkpICE9PSAwICYmIE1lIDw9IF9lID8gbGVbTWUgLSAxXSA9PT0gdm9pZCAwID8geGUuY2hhckF0KDEpIDogbGVbTWUgLSAxXSArIHhlLmNoYXJBdCgxKSA6IGdlO1xuICAgICAgICAgICAgICAgICAgICBEZSA9IGxlW1FlIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBEZSA9PT0gdm9pZCAwID8gXCJcIiA6IERlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oTywgTCwgRCwgQiwgSiwgeCk7XG4gICAgICAgICAgICBYIDw9IEQgJiYgKFcgKz0gTC5zbGljZShYLCBEKSArIHRlLCBYID0gRCArIE8ubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFcgKyBMLnNsaWNlKFgpO1xuICAgICAgICB9XTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXhcIjogOCwgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljXCI6IDUyLCBcIi4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdFwiOiAxMTAsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3RvLWludGVnZXJcIjogMTM2LCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4IH1dLCAyMDI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpY1wiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3NhbWUtdmFsdWVcIiksIGcgPSB0KFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0XCIpO1xuICAgICAgbShcInNlYXJjaFwiLCAxLCBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgIHJldHVybiBbZnVuY3Rpb24obykge1xuICAgICAgICAgIHZhciBpID0gdSh0aGlzKSwgbCA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG9bZl07XG4gICAgICAgICAgcmV0dXJuIGwgIT09IHZvaWQgMCA/IGwuY2FsbChvLCBpKSA6IG5ldyBSZWdFeHAobylbZl0oU3RyaW5nKGkpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24obykge1xuICAgICAgICAgIHZhciBpLCBsID0gcyhyLCBvLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbC5kb25lID8gbC52YWx1ZSA6IChsID0geShvKSwgbyA9IFN0cmluZyh0aGlzKSwgaSA9IGwubGFzdEluZGV4LCBoKGksIDApIHx8IChsLmxhc3RJbmRleCA9IDApLCBvID0gZyhsLCBvKSwgaChsLmxhc3RJbmRleCwgaSkgfHwgKGwubGFzdEluZGV4ID0gaSksIG8gPT09IG51bGwgPyAtMSA6IG8uaW5kZXgpO1xuICAgICAgICB9XTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4tb2JqZWN0XCI6IDEwLCBcIi4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljXCI6IDUyLCBcIi4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdFwiOiAxMTAsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3NhbWUtdmFsdWVcIjogMTE1IH1dLCAyMDM6IFtmdW5jdGlvbihpLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGkoXCIuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpY1wiKSwgeSA9IGkoXCIuLi9pbnRlcm5hbHMvaXMtcmVnZXhwXCIpLCB1ID0gaShcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIGggPSBpKFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiKSwgZyA9IGkoXCIuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvclwiKSwgZiA9IGkoXCIuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXhcIiksIHIgPSBpKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgcyA9IGkoXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3RcIiksIG8gPSBpKFwiLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjXCIpLCBpID0gaShcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgbCA9IFtdLnB1c2gsIG4gPSBNYXRoLm1pbiwgYSA9IDQyOTQ5NjcyOTUsIGMgPSAhaShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFSZWdFeHAoYSwgXCJ5XCIpO1xuICAgICAgfSk7XG4gICAgICBtKFwic3BsaXRcIiwgMiwgZnVuY3Rpb24ocCwgaiwgVCkge1xuICAgICAgICB2YXIgXyA9IFwiYWJiY1wiLnNwbGl0KC8oYikqLylbMV0gPT0gXCJjXCIgfHwgXCJ0ZXN0XCIuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9IDQgfHwgXCJhYlwiLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9IDIgfHwgXCIuXCIuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9IDQgfHwgMSA8IFwiLlwiLnNwbGl0KC8oKSgpLykubGVuZ3RoIHx8IFwiXCIuc3BsaXQoLy4/LykubGVuZ3RoID8gZnVuY3Rpb24oUywgRSkge1xuICAgICAgICAgIHZhciBBID0gU3RyaW5nKGgodGhpcykpLCB4ID0gRSA9PT0gdm9pZCAwID8gYSA6IEUgPj4+IDA7XG4gICAgICAgICAgaWYgKHggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICBpZiAoUyA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIFtBXTtcbiAgICAgICAgICBpZiAoIXkoUykpXG4gICAgICAgICAgICByZXR1cm4gai5jYWxsKEEsIFMsIHgpO1xuICAgICAgICAgIGZvciAodmFyIFAsIE0sIFIsIEwgPSBbXSwgRSA9IChTLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKFMubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChTLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpICsgKFMuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSwgRiA9IDAsIFYgPSBuZXcgUmVnRXhwKFMuc291cmNlLCBFICsgXCJnXCIpOyAoUCA9IG8uY2FsbChWLCBBKSkgJiYgIShGIDwgKE0gPSBWLmxhc3RJbmRleCkgJiYgKEwucHVzaChBLnNsaWNlKEYsIFAuaW5kZXgpKSwgMSA8IFAubGVuZ3RoICYmIFAuaW5kZXggPCBBLmxlbmd0aCAmJiBsLmFwcGx5KEwsIFAuc2xpY2UoMSkpLCBSID0gUFswXS5sZW5ndGgsIEYgPSBNLCBMLmxlbmd0aCA+PSB4KSk7IClcbiAgICAgICAgICAgIFYubGFzdEluZGV4ID09PSBQLmluZGV4ICYmIFYubGFzdEluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIEYgPT09IEEubGVuZ3RoID8gIVIgJiYgVi50ZXN0KFwiXCIpIHx8IEwucHVzaChcIlwiKSA6IEwucHVzaChBLnNsaWNlKEYpKSwgTC5sZW5ndGggPiB4ID8gTC5zbGljZSgwLCB4KSA6IEw7XG4gICAgICAgIH0gOiBcIjBcIi5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCA/IGZ1bmN0aW9uKFMsIEUpIHtcbiAgICAgICAgICByZXR1cm4gUyA9PT0gdm9pZCAwICYmIEUgPT09IDAgPyBbXSA6IGouY2FsbCh0aGlzLCBTLCBFKTtcbiAgICAgICAgfSA6IGo7XG4gICAgICAgIHJldHVybiBbZnVuY3Rpb24oUywgRSkge1xuICAgICAgICAgIHZhciBBID0gaCh0aGlzKSwgeCA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbcF07XG4gICAgICAgICAgcmV0dXJuIHggIT09IHZvaWQgMCA/IHguY2FsbChTLCBBLCBFKSA6IF8uY2FsbChTdHJpbmcoQSksIFMsIEUpO1xuICAgICAgICB9LCBmdW5jdGlvbihQLCBFKSB7XG4gICAgICAgICAgdmFyIEEgPSBUKF8sIFAsIHRoaXMsIEUsIF8gIT09IGopO1xuICAgICAgICAgIGlmIChBLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gQS52YWx1ZTtcbiAgICAgICAgICB2YXIgQSA9IHUoUCksIHggPSBTdHJpbmcodGhpcyksIFAgPSBnKEEsIFJlZ0V4cCksIE0gPSBBLnVuaWNvZGUsIFIgPSAoQS5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChBLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoQS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKSArIChjID8gXCJ5XCIgOiBcImdcIiksIEwgPSBuZXcgUChjID8gQSA6IFwiXig/OlwiICsgQS5zb3VyY2UgKyBcIilcIiwgUiksIEYgPSBFID09PSB2b2lkIDAgPyBhIDogRSA+Pj4gMDtcbiAgICAgICAgICBpZiAoRiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBzKEwsIHgpID09PSBudWxsID8gW3hdIDogW107XG4gICAgICAgICAgZm9yICh2YXIgViA9IDAsIEcgPSAwLCBVID0gW107IEcgPCB4Lmxlbmd0aDsgKSB7XG4gICAgICAgICAgICBMLmxhc3RJbmRleCA9IGMgPyBHIDogMDtcbiAgICAgICAgICAgIHZhciBXLCBYID0gcyhMLCBjID8geCA6IHguc2xpY2UoRykpO1xuICAgICAgICAgICAgaWYgKFggPT09IG51bGwgfHwgKFcgPSBuKHIoTC5sYXN0SW5kZXggKyAoYyA/IDAgOiBHKSksIHgubGVuZ3RoKSkgPT09IFYpXG4gICAgICAgICAgICAgIEcgPSBmKHgsIEcsIE0pO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChVLnB1c2goeC5zbGljZShWLCBHKSksIFUubGVuZ3RoID09PSBGKVxuICAgICAgICAgICAgICAgIHJldHVybiBVO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZSA9IDE7IG5lIDw9IFgubGVuZ3RoIC0gMTsgbmUrKylcbiAgICAgICAgICAgICAgICBpZiAoVS5wdXNoKFhbbmVdKSwgVS5sZW5ndGggPT09IEYpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gVTtcbiAgICAgICAgICAgICAgRyA9IFYgPSBXO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVS5wdXNoKHguc2xpY2UoVikpLCBVO1xuICAgICAgICB9XTtcbiAgICAgIH0sICFjKTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4XCI6IDgsIFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiOiAxMCwgXCIuLi9pbnRlcm5hbHMvZmFpbHNcIjogNTEsIFwiLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWNcIjogNTIsIFwiLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cFwiOiA3NywgXCIuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWNcIjogMTExLCBcIi4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdFwiOiAxMTAsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3JcIjogMTIyLCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3IH1dLCAyMDQ6IFtmdW5jdGlvbihmLCBILCBDKSB7XG4gICAgICB2YXIgbSA9IGYoXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCIpLCB5ID0gZihcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLmYsIHUgPSBmKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgaCA9IGYoXCIuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwXCIpLCBnID0gZihcIi4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGVcIiksIG8gPSBmKFwiLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljXCIpLCBmID0gZihcIi4uL2ludGVybmFscy9pcy1wdXJlXCIpLCByID0gXCJcIi5zdGFydHNXaXRoLCBzID0gTWF0aC5taW4sIG8gPSBvKFwic3RhcnRzV2l0aFwiKTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiU3RyaW5nXCIsIHByb3RvOiAhMCwgZm9yY2VkOiAhIShmIHx8IG8gfHwgIShtID0geShTdHJpbmcucHJvdG90eXBlLCBcInN0YXJ0c1dpdGhcIikpIHx8IG0ud3JpdGFibGUpICYmICFvIH0sIHsgc3RhcnRzV2l0aDogZnVuY3Rpb24oYSkge1xuICAgICAgICB2YXIgbCA9IFN0cmluZyhnKHRoaXMpKSwgbiA9IChoKGEpLCB1KHMoMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsIGwubGVuZ3RoKSkpLCBhID0gU3RyaW5nKGEpO1xuICAgICAgICByZXR1cm4gciA/IHIuY2FsbChsLCBhLCBuKSA6IGwuc2xpY2UobiwgbiArIGEubGVuZ3RoKSA9PT0gYTtcbiAgICAgIH0gfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpY1wiOiAzNCwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9pcy1wdXJlXCI6IDc2LCBcIi4uL2ludGVybmFscy9ub3QtYS1yZWdleHBcIjogODgsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogOTQsIFwiLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZVwiOiAxMTQsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcgfV0sIDIwNTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sXCIpO1xuICAgICAgbSh7IHRhcmdldDogXCJTdHJpbmdcIiwgcHJvdG86ICEwLCBmb3JjZWQ6IHQoXCIuLi9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkXCIpKFwic3ViXCIpIH0sIHsgc3ViOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHkodGhpcywgXCJzdWJcIiwgXCJcIiwgXCJcIik7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLWh0bWxcIjogMzYsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkXCI6IDEyMyB9XSwgMjA2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW1cIikudHJpbTtcbiAgICAgIG0oeyB0YXJnZXQ6IFwiU3RyaW5nXCIsIHByb3RvOiAhMCwgZm9yY2VkOiB0KFwiLi4vaW50ZXJuYWxzL3N0cmluZy10cmltLWZvcmNlZFwiKShcInRyaW1cIikgfSwgeyB0cmltOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHkodGhpcyk7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9zdHJpbmctdHJpbVwiOiAxMzAsIFwiLi4vaW50ZXJuYWxzL3N0cmluZy10cmltLWZvcmNlZFwiOiAxMjkgfV0sIDIwNzogW2Z1bmN0aW9uKG4sIEgsIEMpIHtcbiAgICAgIHZhciBtLCB5LCB1LCBoLCBnLCBmID0gbihcIi4uL2ludGVybmFscy9leHBvcnRcIiksIHIgPSBuKFwiLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzXCIpLCBzID0gbihcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIG8gPSBuKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgaSA9IG4oXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCIpLCBsID0gbihcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCIpLmYsIG4gPSBuKFwiLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllc1wiKSwgYSA9IHMuU3ltYm9sO1xuICAgICAgIXIgfHwgdHlwZW9mIGEgIT0gXCJmdW5jdGlvblwiIHx8IFwiZGVzY3JpcHRpb25cIiBpbiBhLnByb3RvdHlwZSAmJiBhKCkuZGVzY3JpcHRpb24gPT09IHZvaWQgMCB8fCAobSA9IHt9LCBuKHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IFN0cmluZyhhcmd1bWVudHNbMF0pLCBwID0gdGhpcyBpbnN0YW5jZW9mIHkgPyBuZXcgYShjKSA6IGMgPT09IHZvaWQgMCA/IGEoKSA6IGEoYyk7XG4gICAgICAgIHJldHVybiBjID09PSBcIlwiICYmIChtW3BdID0gITApLCBwO1xuICAgICAgfSwgYSksIChzID0geS5wcm90b3R5cGUgPSBhLnByb3RvdHlwZSkuY29uc3RydWN0b3IgPSB5LCB1ID0gcy50b1N0cmluZywgaCA9IFN0cmluZyhhKFwidGVzdFwiKSkgPT0gXCJTeW1ib2wodGVzdClcIiwgZyA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC8sIGwocywgXCJkZXNjcmlwdGlvblwiLCB7IGNvbmZpZ3VyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gaSh0aGlzKSA/IHRoaXMudmFsdWVPZigpIDogdGhpcywgcCA9IHUuY2FsbChjKTtcbiAgICAgICAgcmV0dXJuIG8obSwgYykgPyBcIlwiIDogKGMgPSBoID8gcC5zbGljZSg3LCAtMSkgOiBwLnJlcGxhY2UoZywgXCIkMVwiKSkgPT09IFwiXCIgPyB2b2lkIDAgOiBjO1xuICAgICAgfSB9KSwgZih7IGdsb2JhbDogITAsIGZvcmNlZDogITAgfSwgeyBTeW1ib2w6IHkgfSkpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzXCI6IDMzLCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzIH1dLCAyMDg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbFwiKShcIml0ZXJhdG9yXCIpO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sXCI6IDQyIH1dLCAyMDk6IFtmdW5jdGlvbihyZSwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShxLCBlZSkge1xuICAgICAgICB2YXIgcGUgPSBEZVtxXSA9IEEoYWVbY2VdKTtcbiAgICAgICAgcmV0dXJuIHVlKHBlLCB7IHR5cGU6IHRlLCB0YWc6IHEsIGRlc2NyaXB0aW9uOiBlZSB9KSwgbyB8fCAocGUuZGVzY3JpcHRpb24gPSBlZSksIHBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShxLCBqZSkge1xuICAgICAgICBqKHEpO1xuICAgICAgICB2YXIgcGUgPSBfKGplKSwgamUgPSB4KHBlKS5jb25jYXQoJChwZSkpO1xuICAgICAgICByZXR1cm4gWShqZSwgZnVuY3Rpb24oQ2UpIHtcbiAgICAgICAgICBvICYmICFaLmNhbGwocGUsIENlKSB8fCB3ZShxLCBDZSwgcGVbQ2VdKTtcbiAgICAgICAgfSksIHE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KGplLCBDZSkge1xuICAgICAgICB2YXIgcGUsIGplID0gXyhqZSksIENlID0gUyhDZSwgITApO1xuICAgICAgICBpZiAoamUgIT09IEsgfHwgIWEoRGUsIENlKSB8fCBhKE1lLCBDZSkpXG4gICAgICAgICAgcmV0dXJuICEocGUgPSBfZShqZSwgQ2UpKSB8fCAhYShEZSwgQ2UpIHx8IGEoamUsIEopICYmIGplW0pdW0NlXSB8fCAocGUuZW51bWVyYWJsZSA9ICEwKSwgcGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoKGVlKSB7XG4gICAgICAgIHZhciBlZSA9IGdlKF8oZWUpKSwgcGUgPSBbXTtcbiAgICAgICAgcmV0dXJuIFkoZWUsIGZ1bmN0aW9uKGplKSB7XG4gICAgICAgICAgYShEZSwgamUpIHx8IGEoWCwgamUpIHx8IHBlLnB1c2goamUpO1xuICAgICAgICB9KSwgcGU7XG4gICAgICB9XG4gICAgICB2YXIgZyA9IHJlKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgZiA9IHJlKFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgciA9IHJlKFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiKSwgcyA9IHJlKFwiLi4vaW50ZXJuYWxzL2lzLXB1cmVcIiksIG8gPSByZShcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiKSwgaSA9IHJlKFwiLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2xcIiksIGwgPSByZShcIi4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZFwiKSwgbiA9IHJlKFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCBhID0gcmUoXCIuLi9pbnRlcm5hbHMvaGFzXCIpLCBjID0gcmUoXCIuLi9pbnRlcm5hbHMvaXMtYXJyYXlcIiksIHAgPSByZShcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIiksIGogPSByZShcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIFQgPSByZShcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIF8gPSByZShcIi4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdFwiKSwgUyA9IHJlKFwiLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZVwiKSwgRSA9IHJlKFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBBID0gcmUoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZVwiKSwgeCA9IHJlKFwiLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzXCIpLCBQID0gcmUoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXNcIiksIE0gPSByZShcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbFwiKSwgUiA9IHJlKFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHNcIiksIEwgPSByZShcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBGID0gcmUoXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eVwiKSwgViA9IHJlKFwiLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlXCIpLCBHID0gcmUoXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCIpLCBVID0gcmUoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIFcgPSByZShcIi4uL2ludGVybmFscy9zaGFyZWRcIiksIFZlID0gcmUoXCIuLi9pbnRlcm5hbHMvc2hhcmVkLWtleVwiKSwgWCA9IHJlKFwiLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzXCIpLCBuZSA9IHJlKFwiLi4vaW50ZXJuYWxzL3VpZFwiKSwgYiA9IHJlKFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sXCIpLCBPID0gcmUoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZFwiKSwgRCA9IHJlKFwiLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbFwiKSwgQiA9IHJlKFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCIpLCBYZSA9IHJlKFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCIpLCBZID0gcmUoXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCIpLmZvckVhY2gsIEogPSBWZShcImhpZGRlblwiKSwgdGUgPSBcIlN5bWJvbFwiLCBjZSA9IFwicHJvdG90eXBlXCIsIHJlID0gYihcInRvUHJpbWl0aXZlXCIpLCB1ZSA9IFhlLnNldCwgbGUgPSBYZS5nZXR0ZXJGb3IodGUpLCBLID0gT2JqZWN0W2NlXSwgYWUgPSBmLlN5bWJvbCwgaGUgPSByKFwiSlNPTlwiLCBcInN0cmluZ2lmeVwiKSwgX2UgPSBMLmYsIGZlID0gRi5mLCBnZSA9IE0uZiwgeGUgPSBWLmYsIERlID0gVyhcInN5bWJvbHNcIiksIE1lID0gVyhcIm9wLXN5bWJvbHNcIiksIFFlID0gVyhcInN0cmluZy10by1zeW1ib2wtcmVnaXN0cnlcIiksIHplID0gVyhcInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnlcIiksIFZlID0gVyhcIndrc1wiKSwgWGUgPSBmLlFPYmplY3QsIEhlID0gIVhlIHx8ICFYZVtjZV0gfHwgIVhlW2NlXS5maW5kQ2hpbGQsIHZlID0gbyAmJiBuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQShmZSh7fSwgXCJhXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZmUodGhpcywgXCJhXCIsIHsgdmFsdWU6IDcgfSkuYTtcbiAgICAgICAgfSB9KSkuYSAhPSA3O1xuICAgICAgfSkgPyBmdW5jdGlvbihxLCBlZSwgcGUpIHtcbiAgICAgICAgdmFyIGplID0gX2UoSywgZWUpO1xuICAgICAgICBqZSAmJiBkZWxldGUgS1tlZV0sIGZlKHEsIGVlLCBwZSksIGplICYmIHEgIT09IEsgJiYgZmUoSywgZWUsIGplKTtcbiAgICAgIH0gOiBmZSwgUmUgPSBsID8gZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHEgPT0gXCJzeW1ib2xcIjtcbiAgICAgIH0gOiBmdW5jdGlvbihxKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QocSkgaW5zdGFuY2VvZiBhZTtcbiAgICAgIH0sIHdlID0gZnVuY3Rpb24ocSwgZWUsIHBlKSB7XG4gICAgICAgIHJldHVybiBxID09PSBLICYmIHdlKE1lLCBlZSwgcGUpLCBqKHEpLCBlZSA9IFMoZWUsICEwKSwgaihwZSksIChhKERlLCBlZSkgPyAocGUuZW51bWVyYWJsZSA/IChhKHEsIEopICYmIHFbSl1bZWVdICYmIChxW0pdW2VlXSA9ICExKSwgcGUgPSBBKHBlLCB7IGVudW1lcmFibGU6IEUoMCwgITEpIH0pKSA6IChhKHEsIEopIHx8IGZlKHEsIEosIEUoMSwge30pKSwgcVtKXVtlZV0gPSAhMCksIHZlKSA6IGZlKShxLCBlZSwgcGUpO1xuICAgICAgfSwgWiA9IGZ1bmN0aW9uKGVlKSB7XG4gICAgICAgIHZhciBlZSA9IFMoZWUsICEwKSwgcGUgPSB4ZS5jYWxsKHRoaXMsIGVlKTtcbiAgICAgICAgcmV0dXJuICEodGhpcyA9PT0gSyAmJiBhKERlLCBlZSkgJiYgIWEoTWUsIGVlKSkgJiYgKCEocGUgfHwgIWEodGhpcywgZWUpIHx8ICFhKERlLCBlZSkgfHwgYSh0aGlzLCBKKSAmJiB0aGlzW0pdW2VlXSkgfHwgcGUpO1xuICAgICAgfSwgJCA9IGZ1bmN0aW9uKHBlKSB7XG4gICAgICAgIHZhciBlZSA9IHBlID09PSBLLCBwZSA9IGdlKGVlID8gTWUgOiBfKHBlKSksIGplID0gW107XG4gICAgICAgIHJldHVybiBZKHBlLCBmdW5jdGlvbihDZSkge1xuICAgICAgICAgICFhKERlLCBDZSkgfHwgZWUgJiYgIWEoSywgQ2UpIHx8IGplLnB1c2goRGVbQ2VdKTtcbiAgICAgICAgfSksIGplO1xuICAgICAgfTtcbiAgICAgIGkgfHwgKFUoKGFlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYWUpXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB2YXIgcSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBTdHJpbmcoYXJndW1lbnRzWzBdKSA6IHZvaWQgMCwgZWUgPSBuZShxKSwgcGUgPSBmdW5jdGlvbihqZSkge1xuICAgICAgICAgIHRoaXMgPT09IEsgJiYgcGUuY2FsbChNZSwgamUpLCBhKHRoaXMsIEopICYmIGEodGhpc1tKXSwgZWUpICYmICh0aGlzW0pdW2VlXSA9ICExKSwgdmUodGhpcywgZWUsIEUoMSwgamUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG8gJiYgSGUgJiYgdmUoSywgZWUsIHsgY29uZmlndXJhYmxlOiAhMCwgc2V0OiBwZSB9KSwgbShlZSwgcSk7XG4gICAgICB9KVtjZV0sIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsZSh0aGlzKS50YWc7XG4gICAgICB9KSwgVShhZSwgXCJ3aXRob3V0U2V0dGVyXCIsIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgcmV0dXJuIG0obmUocSksIHEpO1xuICAgICAgfSksIFYuZiA9IFosIEYuZiA9IHdlLCBMLmYgPSB1LCBQLmYgPSBNLmYgPSBoLCBSLmYgPSAkLCBPLmYgPSBmdW5jdGlvbihxKSB7XG4gICAgICAgIHJldHVybiBtKGIocSksIHEpO1xuICAgICAgfSwgbyAmJiAoZmUoYWVbY2VdLCBcImRlc2NyaXB0aW9uXCIsIHsgY29uZmlndXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfSB9KSwgcyB8fCBVKEssIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgWiwgeyB1bnNhZmU6ICEwIH0pKSksIGcoeyBnbG9iYWw6ICEwLCB3cmFwOiAhMCwgZm9yY2VkOiAhaSwgc2hhbTogIWkgfSwgeyBTeW1ib2w6IGFlIH0pLCBZKHgoVmUpLCBmdW5jdGlvbihxKSB7XG4gICAgICAgIEQocSk7XG4gICAgICB9KSwgZyh7IHRhcmdldDogdGUsIHN0YXQ6ICEwLCBmb3JjZWQ6ICFpIH0sIHsgZm9yOiBmdW5jdGlvbihwZSkge1xuICAgICAgICB2YXIgZWUsIHBlID0gU3RyaW5nKHBlKTtcbiAgICAgICAgcmV0dXJuIGEoUWUsIHBlKSA/IFFlW3BlXSA6IChlZSA9IGFlKHBlKSwgUWVbcGVdID0gZWUsIHplW2VlXSA9IHBlLCBlZSk7XG4gICAgICB9LCBrZXlGb3I6IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgaWYgKCFSZShxKSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IocSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcbiAgICAgICAgaWYgKGEoemUsIHEpKVxuICAgICAgICAgIHJldHVybiB6ZVtxXTtcbiAgICAgIH0sIHVzZVNldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhlID0gITA7XG4gICAgICB9LCB1c2VTaW1wbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIZSA9ICExO1xuICAgICAgfSB9KSwgZyh7IHRhcmdldDogXCJPYmplY3RcIiwgc3RhdDogITAsIGZvcmNlZDogIWksIHNoYW06ICFvIH0sIHsgY3JlYXRlOiBmdW5jdGlvbihxLCBlZSkge1xuICAgICAgICByZXR1cm4gZWUgPT09IHZvaWQgMCA/IEEocSkgOiB5KEEocSksIGVlKTtcbiAgICAgIH0sIGRlZmluZVByb3BlcnR5OiB3ZSwgZGVmaW5lUHJvcGVydGllczogeSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB1IH0pLCBnKHsgdGFyZ2V0OiBcIk9iamVjdFwiLCBzdGF0OiAhMCwgZm9yY2VkOiAhaSB9LCB7IGdldE93blByb3BlcnR5TmFtZXM6IGgsIGdldE93blByb3BlcnR5U3ltYm9sczogJCB9KSwgZyh7IHRhcmdldDogXCJPYmplY3RcIiwgc3RhdDogITAsIGZvcmNlZDogbihmdW5jdGlvbigpIHtcbiAgICAgICAgUi5mKDEpO1xuICAgICAgfSkgfSwgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgcmV0dXJuIFIuZihUKHEpKTtcbiAgICAgIH0gfSksIGhlICYmIGcoeyB0YXJnZXQ6IFwiSlNPTlwiLCBzdGF0OiAhMCwgZm9yY2VkOiAhaSB8fCBuKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcSA9IGFlKCk7XG4gICAgICAgIHJldHVybiBoZShbcV0pICE9IFwiW251bGxdXCIgfHwgaGUoeyBhOiBxIH0pICE9IFwie31cIiB8fCBoZShPYmplY3QocSkpICE9IFwie31cIjtcbiAgICAgIH0pIH0sIHsgc3RyaW5naWZ5OiBmdW5jdGlvbihxLCBlZSwgcGUpIHtcbiAgICAgICAgZm9yICh2YXIgamUsIENlID0gW3FdLCBGZSA9IDE7IEZlIDwgYXJndW1lbnRzLmxlbmd0aDsgKVxuICAgICAgICAgIENlLnB1c2goYXJndW1lbnRzW0ZlKytdKTtcbiAgICAgICAgaWYgKChwKGplID0gZWUpIHx8IHEgIT09IHZvaWQgMCkgJiYgIVJlKHEpKVxuICAgICAgICAgIHJldHVybiBjKGVlKSB8fCAoZWUgPSBmdW5jdGlvbihOZSwgQmUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgamUgPT0gXCJmdW5jdGlvblwiICYmIChCZSA9IGplLmNhbGwodGhpcywgTmUsIEJlKSksICFSZShCZSkpXG4gICAgICAgICAgICAgIHJldHVybiBCZTtcbiAgICAgICAgICB9KSwgQ2VbMV0gPSBlZSwgaGUuYXBwbHkobnVsbCwgQ2UpO1xuICAgICAgfSB9KSwgYWVbY2VdW3JlXSB8fCBHKGFlW2NlXSwgcmUsIGFlW2NlXS52YWx1ZU9mKSwgQihhZSwgdGUpLCBYW0pdID0gITA7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIjogMTAsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiOiAxOSwgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCI6IDM4LCBcIi4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvclwiOiAzOSwgXCIuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sXCI6IDQyLCBcIi4uL2ludGVybmFscy9kZXNjcmlwdG9yc1wiOiA0MywgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluXCI6IDU3LCBcIi4uL2ludGVybmFscy9nbG9iYWxcIjogNjAsIFwiLi4vaW50ZXJuYWxzL2hhc1wiOiA2MSwgXCIuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXNcIjogNjIsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9pcy1hcnJheVwiOiA3MywgXCIuLi9pbnRlcm5hbHMvaXMtb2JqZWN0XCI6IDc1LCBcIi4uL2ludGVybmFscy9pcy1wdXJlXCI6IDc2LCBcIi4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sXCI6IDg0LCBcIi4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlXCI6IDkxLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5XCI6IDkzLCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDk0LCBcIi4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiOiA5NiwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWxcIjogOTUsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHNcIjogOTcsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzXCI6IDEwMCwgXCIuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGVcIjogMTAxLCBcIi4uL2ludGVybmFscy9yZWRlZmluZVwiOiAxMDksIFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCI6IDExOCwgXCIuLi9pbnRlcm5hbHMvc2hhcmVkXCI6IDEyMSwgXCIuLi9pbnRlcm5hbHMvc2hhcmVkLWtleVwiOiAxMTksIFwiLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0XCI6IDEzNSwgXCIuLi9pbnRlcm5hbHMvdG8tb2JqZWN0XCI6IDEzOCwgXCIuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlXCI6IDE0MSwgXCIuLi9pbnRlcm5hbHMvdWlkXCI6IDE0NiwgXCIuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWRcIjogMTQ3LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDksIFwiLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWRcIjogMTQ4IH1dLCAyMTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktY29weS13aXRoaW5cIiksIHUgPSBtLmFUeXBlZEFycmF5O1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJjb3B5V2l0aGluXCIsIGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgcmV0dXJuIHkuY2FsbCh1KHRoaXMpLCBoLCBnLCAyIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1syXSA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWNvcHktd2l0aGluXCI6IDE0IH1dLCAyMTE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCIpLmV2ZXJ5LCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwiZXZlcnlcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4geSh1KHRoaXMpLCBoLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiOiAxOSB9XSwgMjEyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWZpbGxcIiksIHUgPSBtLmFUeXBlZEFycmF5O1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJmaWxsXCIsIGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHkuYXBwbHkodSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktZmlsbFwiOiAxNSB9XSwgMjEzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5maWx0ZXIsIHUgPSB0KFwiLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3JcIiksIGggPSBtLmFUeXBlZEFycmF5LCBnID0gbS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJmaWx0ZXJcIiwgZnVuY3Rpb24oZikge1xuICAgICAgICBmb3IgKHZhciByID0geShoKHRoaXMpLCBmLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCksIGYgPSB1KHRoaXMsIHRoaXMuY29uc3RydWN0b3IpLCBzID0gMCwgbyA9IHIubGVuZ3RoLCBpID0gbmV3IChnKGYpKShvKTsgcyA8IG87IClcbiAgICAgICAgICBpW3NdID0gcltzKytdO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5LCBcIi4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yXCI6IDEyMiB9XSwgMjE0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5maW5kSW5kZXgsIHUgPSBtLmFUeXBlZEFycmF5O1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJmaW5kSW5kZXhcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4geSh1KHRoaXMpLCBoLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiOiAxOSB9XSwgMjE1OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiKS5maW5kLCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwiZmluZFwiLCBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB5KHUodGhpcyksIGgsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5IH1dLCAyMTY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCIpKFwiRmxvYXQzMlwiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5LCB1LCBoKSB7XG4gICAgICAgICAgcmV0dXJuIG0odGhpcywgeSwgdSwgaCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCI6IDE0MyB9XSwgMjE3OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcIi4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvclwiKShcIkZsb2F0NjRcIiwgZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSwgdSwgaCkge1xuICAgICAgICAgIHJldHVybiBtKHRoaXMsIHksIHUsIGgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvclwiOiAxNDMgfV0sIDIxODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIikuZm9yRWFjaCwgdSA9IG0uYVR5cGVkQXJyYXk7XG4gICAgICAoMCwgbS5leHBvcnRUeXBlZEFycmF5TWV0aG9kKShcImZvckVhY2hcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICB5KHUodGhpcyksIGgsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCI6IDE5IH1dLCAyMTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIikuaW5jbHVkZXMsIHUgPSBtLmFUeXBlZEFycmF5O1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJpbmNsdWRlc1wiLCBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB5KHUodGhpcyksIGgsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIjogMTggfV0sIDIyMDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlc1wiKS5pbmRleE9mLCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwiaW5kZXhPZlwiLCBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB5KHUodGhpcyksIGgsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXNcIjogMTggfV0sIDIyMTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JcIikoXCJJbnQxNlwiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5LCB1LCBoKSB7XG4gICAgICAgICAgcmV0dXJuIG0odGhpcywgeSwgdSwgaCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCI6IDE0MyB9XSwgMjIyOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcIi4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvclwiKShcIkludDMyXCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHksIHUsIGgpIHtcbiAgICAgICAgICByZXR1cm4gbSh0aGlzLCB5LCB1LCBoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JcIjogMTQzIH1dLCAyMjM6IFtmdW5jdGlvbih5LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICByZXR1cm4gdS5jYWxsKGYodGhpcykpO1xuICAgICAgfVxuICAgICAgdmFyIG8gPSB5KFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiKSwgcyA9IHkoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgciA9IHkoXCIuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB5ID0geShcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiKShcIml0ZXJhdG9yXCIpLCBvID0gby5VaW50OEFycmF5LCB1ID0gci52YWx1ZXMsIGggPSByLmtleXMsIGcgPSByLmVudHJpZXMsIGYgPSBzLmFUeXBlZEFycmF5LCByID0gcy5leHBvcnRUeXBlZEFycmF5TWV0aG9kLCBzID0gbyAmJiBvLnByb3RvdHlwZVt5XSwgbyA9ICEhcyAmJiAocy5uYW1lID09IFwidmFsdWVzXCIgfHwgcy5uYW1lID09IG51bGwpO1xuICAgICAgcihcImVudHJpZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnLmNhbGwoZih0aGlzKSk7XG4gICAgICB9KSwgcihcImtleXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoLmNhbGwoZih0aGlzKSk7XG4gICAgICB9KSwgcihcInZhbHVlc1wiLCBtLCAhbyksIHIoeSwgbSwgIW8pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDksIFwiLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQgfV0sIDIyNDogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciB5ID0geShcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCBtID0geS5hVHlwZWRBcnJheSwgeSA9IHkuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCwgdSA9IFtdLmpvaW47XG4gICAgICB5KFwiam9pblwiLCBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB1LmFwcGx5KG0odGhpcyksIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIgfV0sIDIyNTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hcnJheS1sYXN0LWluZGV4LW9mXCIpLCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwibGFzdEluZGV4T2ZcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4geS5hcHBseSh1KHRoaXMpLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9hcnJheS1sYXN0LWluZGV4LW9mXCI6IDIwIH1dLCAyMjY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uXCIpLm1hcCwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvclwiKSwgaCA9IG0uYVR5cGVkQXJyYXksIGcgPSBtLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgICAoMCwgbS5leHBvcnRUeXBlZEFycmF5TWV0aG9kKShcIm1hcFwiLCBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiB5KGgodGhpcyksIGYsIDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwLCBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyAoZyh1KHIsIHIuY29uc3RydWN0b3IpKSkocyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIjogMTksIFwiLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3JcIjogMTIyIH1dLCAyMjc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlXCIpLnJpZ2h0LCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwicmVkdWNlUmlnaHRcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4geSh1KHRoaXMpLCBoLCBhcmd1bWVudHMubGVuZ3RoLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LXJlZHVjZVwiOiAyNCB9XSwgMjI4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LXJlZHVjZVwiKS5sZWZ0LCB1ID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwicmVkdWNlXCIsIGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHkodSh0aGlzKSwgaCwgYXJndW1lbnRzLmxlbmd0aCwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApO1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9hcnJheS1yZWR1Y2VcIjogMjQgfV0sIDIyOTogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciB5ID0geShcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCBtID0geS5hVHlwZWRBcnJheSwgeSA9IHkuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCwgdSA9IE1hdGguZmxvb3I7XG4gICAgICB5KFwicmV2ZXJzZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaCwgZyA9IG0odGhpcykubGVuZ3RoLCBmID0gdShnIC8gMiksIHIgPSAwOyByIDwgZjsgKVxuICAgICAgICAgIGggPSB0aGlzW3JdLCB0aGlzW3IrK10gPSB0aGlzWy0tZ10sIHRoaXNbZ10gPSBoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiB9XSwgMjMwOiBbZnVuY3Rpb24oZywgSCwgQykge1xuICAgICAgdmFyIG0gPSBnKFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSBnKFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgdSA9IGcoXCIuLi9pbnRlcm5hbHMvdG8tb2Zmc2V0XCIpLCBoID0gZyhcIi4uL2ludGVybmFscy90by1vYmplY3RcIiksIGcgPSBnKFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCBmID0gbS5hVHlwZWRBcnJheTtcbiAgICAgICgwLCBtLmV4cG9ydFR5cGVkQXJyYXlNZXRob2QpKFwic2V0XCIsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgZih0aGlzKTtcbiAgICAgICAgdmFyIHMgPSB1KDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwLCAxKSwgbyA9IHRoaXMubGVuZ3RoLCBpID0gaChyKSwgbCA9IHkoaS5sZW5ndGgpLCBuID0gMDtcbiAgICAgICAgaWYgKG8gPCBsICsgcylcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiV3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBmb3IgKDsgbiA8IGw7IClcbiAgICAgICAgICB0aGlzW3MgKyBuXSA9IGlbbisrXTtcbiAgICAgIH0sIGcoZnVuY3Rpb24oKSB7XG4gICAgICAgIG5ldyBJbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgICAgIH0pKTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCI6IDUxLCBcIi4uL2ludGVybmFscy90by1sZW5ndGhcIjogMTM3LCBcIi4uL2ludGVybmFscy90by1vYmplY3RcIjogMTM4LCBcIi4uL2ludGVybmFscy90by1vZmZzZXRcIjogMTM5IH1dLCAyMzE6IFtmdW5jdGlvbih5LCBILCBDKSB7XG4gICAgICB2YXIgZyA9IHkoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKSwgbSA9IHkoXCIuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvclwiKSwgeSA9IHkoXCIuLi9pbnRlcm5hbHMvZmFpbHNcIiksIHUgPSBnLmFUeXBlZEFycmF5LCBoID0gZy5hVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBnID0gZy5leHBvcnRUeXBlZEFycmF5TWV0aG9kLCBmID0gW10uc2xpY2U7XG4gICAgICBnKFwic2xpY2VcIiwgZnVuY3Rpb24ociwgcykge1xuICAgICAgICBmb3IgKHZhciBvID0gZi5jYWxsKHUodGhpcyksIHIsIHMpLCByID0gbSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKSwgaSA9IDAsIGwgPSBvLmxlbmd0aCwgbiA9IG5ldyAoaChyKSkobCk7IGkgPCBsOyApXG4gICAgICAgICAgbltpXSA9IG9baSsrXTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LCB5KGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgSW50OEFycmF5KDEpLnNsaWNlKCk7XG4gICAgICB9KSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvclwiOiAxMjIgfV0sIDIzMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gdChcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCIpLCB5ID0gdChcIi4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb25cIikuc29tZSwgdSA9IG0uYVR5cGVkQXJyYXk7XG4gICAgICAoMCwgbS5leHBvcnRUeXBlZEFycmF5TWV0aG9kKShcInNvbWVcIiwgZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4geSh1KHRoaXMpLCBoLCAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvblwiOiAxOSB9XSwgMjMzOiBbZnVuY3Rpb24oeSwgSCwgQykge1xuICAgICAgdmFyIHkgPSB5KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIG0gPSB5LmFUeXBlZEFycmF5LCB5ID0geS5leHBvcnRUeXBlZEFycmF5TWV0aG9kLCB1ID0gW10uc29ydDtcbiAgICAgIHkoXCJzb3J0XCIsIGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHUuY2FsbChtKHRoaXMpLCBoKTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiOiAxMiB9XSwgMjM0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0gPSB0KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB0KFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiKSwgdSA9IHQoXCIuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXhcIiksIGggPSB0KFwiLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3JcIiksIGcgPSBtLmFUeXBlZEFycmF5O1xuICAgICAgKDAsIG0uZXhwb3J0VHlwZWRBcnJheU1ldGhvZCkoXCJzdWJhcnJheVwiLCBmdW5jdGlvbihpLCByKSB7XG4gICAgICAgIHZhciBzID0gZyh0aGlzKSwgbyA9IHMubGVuZ3RoLCBpID0gdShpLCBvKTtcbiAgICAgICAgcmV0dXJuIG5ldyAoaChzLCBzLmNvbnN0cnVjdG9yKSkocy5idWZmZXIsIHMuYnl0ZU9mZnNldCArIGkgKiBzLkJZVEVTX1BFUl9FTEVNRU5ULCB5KChyID09PSB2b2lkIDAgPyBvIDogdShyLCBvKSkgLSBpKSk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIjogMTIsIFwiLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3JcIjogMTIyLCBcIi4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleFwiOiAxMzMsIFwiLi4vaW50ZXJuYWxzL3RvLWxlbmd0aFwiOiAxMzcgfV0sIDIzNTogW2Z1bmN0aW9uKHksIEgsIEMpIHtcbiAgICAgIHZhciBnID0geShcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIG0gPSB5KFwiLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmVcIiksIHkgPSB5KFwiLi4vaW50ZXJuYWxzL2ZhaWxzXCIpLCB1ID0gZy5JbnQ4QXJyYXksIGggPSBtLmFUeXBlZEFycmF5LCBnID0gbS5leHBvcnRUeXBlZEFycmF5TWV0aG9kLCBmID0gW10udG9Mb2NhbGVTdHJpbmcsIHIgPSBbXS5zbGljZSwgcyA9ICEhdSAmJiB5KGZ1bmN0aW9uKCkge1xuICAgICAgICBmLmNhbGwobmV3IHUoMSkpO1xuICAgICAgfSk7XG4gICAgICBnKFwidG9Mb2NhbGVTdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHMgPyByLmNhbGwoaCh0aGlzKSkgOiBoKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgICAgfSwgeShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyB1KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgIH0pIHx8ICF5KGZ1bmN0aW9uKCkge1xuICAgICAgICB1LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgICB9KSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwIH1dLCAyMzY6IFtmdW5jdGlvbih5LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IHkoXCIuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZVwiKS5leHBvcnRUeXBlZEFycmF5TWV0aG9kLCBnID0geShcIi4uL2ludGVybmFscy9mYWlsc1wiKSwgeSA9IHkoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLlVpbnQ4QXJyYXksIHkgPSB5ICYmIHkucHJvdG90eXBlIHx8IHt9LCB1ID0gW10udG9TdHJpbmcsIGggPSBbXS5qb2luLCBnID0gKGcoZnVuY3Rpb24oKSB7XG4gICAgICAgIHUuY2FsbCh7fSk7XG4gICAgICB9KSAmJiAodSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaC5jYWxsKHRoaXMpO1xuICAgICAgfSksIHkudG9TdHJpbmcgIT0gdSk7XG4gICAgICBtKFwidG9TdHJpbmdcIiwgdSwgZyk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlXCI6IDEyLCBcIi4uL2ludGVybmFscy9mYWlsc1wiOiA1MSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwIH1dLCAyMzc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCIpKFwiVWludDE2XCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHksIHUsIGgpIHtcbiAgICAgICAgICByZXR1cm4gbSh0aGlzLCB5LCB1LCBoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JcIjogMTQzIH1dLCAyMzg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCIpKFwiVWludDMyXCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHksIHUsIGgpIHtcbiAgICAgICAgICByZXR1cm4gbSh0aGlzLCB5LCB1LCBoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JcIjogMTQzIH1dLCAyMzk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yXCIpKFwiVWludDhcIiwgZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSwgdSwgaCkge1xuICAgICAgICAgIHJldHVybiBtKHRoaXMsIHksIHUsIGgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvclwiOiAxNDMgfV0sIDI0MDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCIuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3JcIikoXCJVaW50OFwiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5LCB1LCBoKSB7XG4gICAgICAgICAgcmV0dXJuIG0odGhpcywgeSwgdSwgaCk7XG4gICAgICAgIH07XG4gICAgICB9LCAhMCk7XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvclwiOiAxNDMgfV0sIDI0MTogW2Z1bmN0aW9uKGEsIGosIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oVCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgeSwgdSwgaCwgZywgZiwgYyA9IGEoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCByID0gYShcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIiksIHMgPSBhKFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhXCIpLCBvID0gYShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uXCIpLCBpID0gYShcIi4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWtcIiksIGwgPSBhKFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgbiA9IGEoXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIikuZW5mb3JjZSwgYSA9IGEoXCIuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwXCIpLCBjID0gIWMuQWN0aXZlWE9iamVjdCAmJiBcIkFjdGl2ZVhPYmplY3RcIiBpbiBjLCBwID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSwgaiA9IGouZXhwb3J0cyA9IG8oXCJXZWFrTWFwXCIsIG0sIGkpO1xuICAgICAgYSAmJiBjICYmICh5ID0gaS5nZXRDb25zdHJ1Y3RvcihtLCBcIldlYWtNYXBcIiwgITApLCBzLlJFUVVJUkVEID0gITAsIG8gPSBqLnByb3RvdHlwZSwgdSA9IG8uZGVsZXRlLCBoID0gby5oYXMsIGcgPSBvLmdldCwgZiA9IG8uc2V0LCByKG8sIHsgZGVsZXRlOiBmdW5jdGlvbihUKSB7XG4gICAgICAgIHZhciBfO1xuICAgICAgICByZXR1cm4gbChUKSAmJiAhcChUKSA/ICgoXyA9IG4odGhpcykpLmZyb3plbiB8fCAoXy5mcm96ZW4gPSBuZXcgeSgpKSwgdS5jYWxsKHRoaXMsIFQpIHx8IF8uZnJvemVuLmRlbGV0ZShUKSkgOiB1LmNhbGwodGhpcywgVCk7XG4gICAgICB9LCBoYXM6IGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgdmFyIF87XG4gICAgICAgIHJldHVybiBsKFQpICYmICFwKFQpID8gKChfID0gbih0aGlzKSkuZnJvemVuIHx8IChfLmZyb3plbiA9IG5ldyB5KCkpLCBoLmNhbGwodGhpcywgVCkgfHwgXy5mcm96ZW4uaGFzKFQpKSA6IGguY2FsbCh0aGlzLCBUKTtcbiAgICAgIH0sIGdldDogZnVuY3Rpb24oVCkge1xuICAgICAgICB2YXIgXztcbiAgICAgICAgcmV0dXJuICFsKFQpIHx8IHAoVCkgfHwgKChfID0gbih0aGlzKSkuZnJvemVuIHx8IChfLmZyb3plbiA9IG5ldyB5KCkpLCBoLmNhbGwodGhpcywgVCkpID8gZy5jYWxsKHRoaXMsIFQpIDogXy5mcm96ZW4uZ2V0KFQpO1xuICAgICAgfSwgc2V0OiBmdW5jdGlvbihULCBfKSB7XG4gICAgICAgIHZhciBTO1xuICAgICAgICByZXR1cm4gIWwoVCkgfHwgcChUKSB8fCAoKFMgPSBuKHRoaXMpKS5mcm96ZW4gfHwgKFMuZnJvemVuID0gbmV3IHkoKSksIGguY2FsbCh0aGlzLCBUKSkgPyBmLmNhbGwodGhpcywgVCwgXykgOiBTLmZyb3plbi5zZXQoVCwgXyksIHRoaXM7XG4gICAgICB9IH0pKTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb25cIjogMzIsIFwiLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vha1wiOiAzMSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YVwiOiA3MCwgXCIuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGVcIjogNzEsIFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiOiA3NSwgXCIuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwXCI6IDg2LCBcIi4uL2ludGVybmFscy9yZWRlZmluZS1hbGxcIjogMTA4IH1dLCAyNDI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSwgeSA9IHQoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCB1ID0gdChcIi4uL2ludGVybmFscy9kb20taXRlcmFibGVzXCIpLCBoID0gdChcIi4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaFwiKSwgZyA9IHQoXCIuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5XCIpO1xuICAgICAgZm9yIChtIGluIHUpIHtcbiAgICAgICAgdmFyIGYgPSB5W21dLCBmID0gZiAmJiBmLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKGYgJiYgZi5mb3JFYWNoICE9PSBoKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnKGYsIFwiZm9yRWFjaFwiLCBoKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGYuZm9yRWFjaCA9IGg7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2hcIjogMTYsIFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiOiAzOCwgXCIuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlc1wiOiA0NSwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwIH1dLCAyNDM6IFtmdW5jdGlvbihmLCBILCBDKSB7XG4gICAgICB2YXIgbSwgeSA9IGYoXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCIpLCB1ID0gZihcIi4uL2ludGVybmFscy9kb20taXRlcmFibGVzXCIpLCBoID0gZihcIi4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIGcgPSBmKFwiLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eVwiKSwgZiA9IGYoXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIHIgPSBmKFwiaXRlcmF0b3JcIiksIHMgPSBmKFwidG9TdHJpbmdUYWdcIiksIG8gPSBoLnZhbHVlcztcbiAgICAgIGZvciAobSBpbiB1KSB7XG4gICAgICAgIHZhciBpID0geVttXSwgbCA9IGkgJiYgaS5wcm90b3R5cGU7XG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgaWYgKGxbcl0gIT09IG8pXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBnKGwsIHIsIG8pO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGxbcl0gPSBvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChsW3NdIHx8IGcobCwgcywgbSksIHVbbV0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gaClcbiAgICAgICAgICAgICAgaWYgKGxbbl0gIT09IGhbbl0pXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGcobCwgbiwgaFtuXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICBsW25dID0gaFtuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgeyBcIi4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHlcIjogMzgsIFwiLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXNcIjogNDUsIFwiLi4vaW50ZXJuYWxzL2dsb2JhbFwiOiA2MCwgXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIjogMTQ5LCBcIi4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0IH1dLCAyNDQ6IFtmdW5jdGlvbihKLCBILCBDKSB7XG4gICAgICBKKFwiLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKTtcbiAgICAgIGZ1bmN0aW9uIG0odGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHRlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHRlKSB7XG4gICAgICAgIHJldHVybiBEW3RlXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHUodGUpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0ZSkucmVwbGFjZShPLCB5KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgodGUpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDAsIEIodGhpcy5lbnRyaWVzLCB0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKHRlLCBjZSkge1xuICAgICAgICBpZiAodGUgPCBjZSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIGModGhpcywgZiwgRik7XG4gICAgICAgIHZhciB0ZSwgY2UsIHJlLCB1ZSwgbGUsIEssIGFlLCBoZSwgX2UgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCwgZmUgPSBbXTtcbiAgICAgICAgaWYgKEcodGhpcywgeyB0eXBlOiBGLCBlbnRyaWVzOiBmZSwgdXBkYXRlVVJMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSwgdXBkYXRlU2VhcmNoUGFyYW1zOiBoIH0pLCBfZSAhPT0gdm9pZCAwKVxuICAgICAgICAgIGlmIChTKF9lKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRlID0gUChfZSkpID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgZm9yIChyZSA9IChjZSA9IHRlLmNhbGwoX2UpKS5uZXh0OyAhKHVlID0gcmUuY2FsbChjZSkpLmRvbmU7ICkge1xuICAgICAgICAgICAgICAgIGlmICgoSyA9IChsZSA9ICh1ZSA9IHgoXyh1ZS52YWx1ZSkpKS5uZXh0KS5jYWxsKHVlKSkuZG9uZSB8fCAoYWUgPSBsZS5jYWxsKHVlKSkuZG9uZSB8fCAhbGUuY2FsbCh1ZSkuZG9uZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkV4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDJcIik7XG4gICAgICAgICAgICAgICAgZmUucHVzaCh7IGtleTogSy52YWx1ZSArIFwiXCIsIHZhbHVlOiBhZS52YWx1ZSArIFwiXCIgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yIChoZSBpbiBfZSlcbiAgICAgICAgICAgICAgICBwKF9lLCBoZSkgJiYgZmUucHVzaCh7IGtleTogaGUsIHZhbHVlOiBfZVtoZV0gKyBcIlwiIH0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEIoZmUsIHR5cGVvZiBfZSA9PSBcInN0cmluZ1wiID8gX2UuY2hhckF0KDApID09PSBcIj9cIiA/IF9lLnNsaWNlKDEpIDogX2UgOiBfZSArIFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHIgPSBKKFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgTCA9IEooXCIuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluXCIpLCBzID0gSihcIi4uL2ludGVybmFscy9uYXRpdmUtdXJsXCIpLCBvID0gSihcIi4uL2ludGVybmFscy9yZWRlZmluZVwiKSwgaSA9IEooXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsXCIpLCBsID0gSihcIi4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZ1wiKSwgbiA9IEooXCIuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yXCIpLCBhID0gSihcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiKSwgYyA9IEooXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIiksIHAgPSBKKFwiLi4vaW50ZXJuYWxzL2hhc1wiKSwgaiA9IEooXCIuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0XCIpLCBUID0gSihcIi4uL2ludGVybmFscy9jbGFzc29mXCIpLCBfID0gSihcIi4uL2ludGVybmFscy9hbi1vYmplY3RcIiksIFMgPSBKKFwiLi4vaW50ZXJuYWxzL2lzLW9iamVjdFwiKSwgRSA9IEooXCIuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZVwiKSwgQSA9IEooXCIuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHggPSBKKFwiLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvclwiKSwgUCA9IEooXCIuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZFwiKSwgSiA9IEooXCIuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2xcIiksIE0gPSBMKFwiZmV0Y2hcIiksIFIgPSBMKFwiSGVhZGVyc1wiKSwgTCA9IEooXCJpdGVyYXRvclwiKSwgRiA9IFwiVVJMU2VhcmNoUGFyYW1zXCIsIFYgPSBGICsgXCJJdGVyYXRvclwiLCBHID0gYS5zZXQsIFUgPSBhLmdldHRlckZvcihGKSwgVyA9IGEuZ2V0dGVyRm9yKFYpLCBYID0gL1xcKy9nLCBuZSA9IEFycmF5KDQpLCBiID0gZnVuY3Rpb24odGUpIHtcbiAgICAgICAgdmFyIGNlLCByZSA9IHRlLnJlcGxhY2UoWCwgXCIgXCIpLCB1ZSA9IDQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChyZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGZvciAoOyB1ZTsgKVxuICAgICAgICAgICAgcmUgPSByZS5yZXBsYWNlKChjZSA9IHVlLS0sIG5lW2NlIC0gMV0gfHwgKG5lW2NlIC0gMV0gPSBSZWdFeHAoXCIoKD86JVtcXFxcZGEtZl17Mn0pe1wiICsgY2UgKyBcIn0pXCIsIFwiZ2lcIikpKSwgbSk7XG4gICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICB9XG4gICAgICB9LCBPID0gL1shJygpfl18JTIwL2csIEQgPSB7IFwiIVwiOiBcIiUyMVwiLCBcIidcIjogXCIlMjdcIiwgXCIoXCI6IFwiJTI4XCIsIFwiKVwiOiBcIiUyOVwiLCBcIn5cIjogXCIlN0VcIiwgXCIlMjBcIjogXCIrXCIgfSwgQiA9IGZ1bmN0aW9uKHRlLCBjZSkge1xuICAgICAgICBpZiAoY2UpXG4gICAgICAgICAgZm9yICh2YXIgcmUsIHVlID0gY2Uuc3BsaXQoXCImXCIpLCBsZSA9IDA7IGxlIDwgdWUubGVuZ3RoOyApXG4gICAgICAgICAgICAocmUgPSB1ZVtsZSsrXSkubGVuZ3RoICYmIChyZSA9IHJlLnNwbGl0KFwiPVwiKSwgdGUucHVzaCh7IGtleTogYihyZS5zaGlmdCgpKSwgdmFsdWU6IGIocmUuam9pbihcIj1cIikpIH0pKTtcbiAgICAgIH0sIFkgPSBuKGZ1bmN0aW9uKHRlLCBjZSkge1xuICAgICAgICBHKHRoaXMsIHsgdHlwZTogViwgaXRlcmF0b3I6IHgoVSh0ZSkuZW50cmllcyksIGtpbmQ6IGNlIH0pO1xuICAgICAgfSwgXCJJdGVyYXRvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlID0gVyh0aGlzKSwgdGUgPSBjZS5raW5kLCBjZSA9IGNlLml0ZXJhdG9yLm5leHQoKSwgcmUgPSBjZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNlLmRvbmUgfHwgKGNlLnZhbHVlID0gdGUgPT09IFwia2V5c1wiID8gcmUua2V5IDogdGUgPT09IFwidmFsdWVzXCIgPyByZS52YWx1ZSA6IFtyZS5rZXksIHJlLnZhbHVlXSksIGNlO1xuICAgICAgfSksIEogPSBmLnByb3RvdHlwZTtcbiAgICAgIGkoSiwgeyBhcHBlbmQ6IGZ1bmN0aW9uKHRlLCBjZSkge1xuICAgICAgICBnKGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgICAgICB2YXIgcmUgPSBVKHRoaXMpO1xuICAgICAgICByZS5lbnRyaWVzLnB1c2goeyBrZXk6IHRlICsgXCJcIiwgdmFsdWU6IGNlICsgXCJcIiB9KSwgcmUudXBkYXRlVVJMKCk7XG4gICAgICB9LCBkZWxldGU6IGZ1bmN0aW9uKHRlKSB7XG4gICAgICAgIGcoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIGZvciAodmFyIGNlID0gVSh0aGlzKSwgcmUgPSBjZS5lbnRyaWVzLCB1ZSA9IHRlICsgXCJcIiwgbGUgPSAwOyBsZSA8IHJlLmxlbmd0aDsgKVxuICAgICAgICAgIHJlW2xlXS5rZXkgPT09IHVlID8gcmUuc3BsaWNlKGxlLCAxKSA6IGxlKys7XG4gICAgICAgIGNlLnVwZGF0ZVVSTCgpO1xuICAgICAgfSwgZ2V0OiBmdW5jdGlvbih0ZSkge1xuICAgICAgICBnKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgICAgICBmb3IgKHZhciBjZSA9IFUodGhpcykuZW50cmllcywgcmUgPSB0ZSArIFwiXCIsIHVlID0gMDsgdWUgPCBjZS5sZW5ndGg7IHVlKyspXG4gICAgICAgICAgaWYgKGNlW3VlXS5rZXkgPT09IHJlKVxuICAgICAgICAgICAgcmV0dXJuIGNlW3VlXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBnZXRBbGw6IGZ1bmN0aW9uKHRlKSB7XG4gICAgICAgIGcoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIGZvciAodmFyIGNlID0gVSh0aGlzKS5lbnRyaWVzLCByZSA9IHRlICsgXCJcIiwgdWUgPSBbXSwgbGUgPSAwOyBsZSA8IGNlLmxlbmd0aDsgbGUrKylcbiAgICAgICAgICBjZVtsZV0ua2V5ID09PSByZSAmJiB1ZS5wdXNoKGNlW2xlXS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB1ZTtcbiAgICAgIH0sIGhhczogZnVuY3Rpb24odGUpIHtcbiAgICAgICAgZyhhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgZm9yICh2YXIgY2UgPSBVKHRoaXMpLmVudHJpZXMsIHJlID0gdGUgKyBcIlwiLCB1ZSA9IDA7IHVlIDwgY2UubGVuZ3RoOyApXG4gICAgICAgICAgaWYgKGNlW3VlKytdLmtleSA9PT0gcmUpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIHNldDogZnVuY3Rpb24odGUsIGNlKSB7XG4gICAgICAgIGcoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIGZvciAodmFyIHJlLCB1ZSA9IFUodGhpcyksIGxlID0gdWUuZW50cmllcywgSyA9ICExLCBhZSA9IHRlICsgXCJcIiwgaGUgPSBjZSArIFwiXCIsIF9lID0gMDsgX2UgPCBsZS5sZW5ndGg7IF9lKyspXG4gICAgICAgICAgKHJlID0gbGVbX2VdKS5rZXkgPT09IGFlICYmIChLID8gbGUuc3BsaWNlKF9lLS0sIDEpIDogKEsgPSAhMCwgcmUudmFsdWUgPSBoZSkpO1xuICAgICAgICBLIHx8IGxlLnB1c2goeyBrZXk6IGFlLCB2YWx1ZTogaGUgfSksIHVlLnVwZGF0ZVVSTCgpO1xuICAgICAgfSwgc29ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHRlLCBjZSwgcmUgPSBVKHRoaXMpLCB1ZSA9IHJlLmVudHJpZXMsIGxlID0gdWUuc2xpY2UoKSwgSyA9IHVlLmxlbmd0aCA9IDA7IEsgPCBsZS5sZW5ndGg7IEsrKykge1xuICAgICAgICAgIGZvciAodGUgPSBsZVtLXSwgY2UgPSAwOyBjZSA8IEs7IGNlKyspXG4gICAgICAgICAgICBpZiAodWVbY2VdLmtleSA+IHRlLmtleSkge1xuICAgICAgICAgICAgICB1ZS5zcGxpY2UoY2UsIDAsIHRlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2UgPT09IEsgJiYgdWUucHVzaCh0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmUudXBkYXRlVVJMKCk7XG4gICAgICB9LCBmb3JFYWNoOiBmdW5jdGlvbih0ZSkge1xuICAgICAgICBmb3IgKHZhciBjZSwgcmUgPSBVKHRoaXMpLmVudHJpZXMsIHVlID0gaih0ZSwgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsIDMpLCBsZSA9IDA7IGxlIDwgcmUubGVuZ3RoOyApXG4gICAgICAgICAgdWUoKGNlID0gcmVbbGUrK10pLnZhbHVlLCBjZS5rZXksIHRoaXMpO1xuICAgICAgfSwga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWSh0aGlzLCBcImtleXNcIik7XG4gICAgICB9LCB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFkodGhpcywgXCJ2YWx1ZXNcIik7XG4gICAgICB9LCBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBZKHRoaXMsIFwiZW50cmllc1wiKTtcbiAgICAgIH0gfSwgeyBlbnVtZXJhYmxlOiAhMCB9KSwgbyhKLCBMLCBKLmVudHJpZXMpLCBvKEosIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHRlLCBjZSA9IFUodGhpcykuZW50cmllcywgcmUgPSBbXSwgdWUgPSAwOyB1ZSA8IGNlLmxlbmd0aDsgKVxuICAgICAgICAgIHRlID0gY2VbdWUrK10sIHJlLnB1c2godSh0ZS5rZXkpICsgXCI9XCIgKyB1KHRlLnZhbHVlKSk7XG4gICAgICAgIHJldHVybiByZS5qb2luKFwiJlwiKTtcbiAgICAgIH0sIHsgZW51bWVyYWJsZTogITAgfSksIGwoZiwgRiksIHIoeyBnbG9iYWw6ICEwLCBmb3JjZWQ6ICFzIH0sIHsgVVJMU2VhcmNoUGFyYW1zOiBmIH0pLCBzIHx8IHR5cGVvZiBNICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgUiAhPSBcImZ1bmN0aW9uXCIgfHwgcih7IGdsb2JhbDogITAsIGVudW1lcmFibGU6ICEwLCBmb3JjZWQ6ICEwIH0sIHsgZmV0Y2g6IGZ1bmN0aW9uKGxlKSB7XG4gICAgICAgIHZhciBjZSwgcmUsIHVlLCBsZSA9IFtsZV07XG4gICAgICAgIHJldHVybiAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiAoUyhjZSA9IGFyZ3VtZW50c1sxXSkgJiYgKHJlID0gY2UuYm9keSwgVChyZSkgPT09IEYgJiYgKCh1ZSA9IGNlLmhlYWRlcnMgPyBuZXcgUihjZS5oZWFkZXJzKSA6IG5ldyBSKCkpLmhhcyhcImNvbnRlbnQtdHlwZVwiKSB8fCB1ZS5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOFwiKSwgY2UgPSBFKGNlLCB7IGJvZHk6IEEoMCwgU3RyaW5nKHJlKSksIGhlYWRlcnM6IEEoMCwgdWUpIH0pKSksIGxlLnB1c2goY2UpKSwgTS5hcHBseSh0aGlzLCBsZSk7XG4gICAgICB9IH0pLCBILmV4cG9ydHMgPSB7IFVSTFNlYXJjaFBhcmFtczogZiwgZ2V0U3RhdGU6IFUgfTtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCI6IDksIFwiLi4vaW50ZXJuYWxzL2FuLW9iamVjdFwiOiAxMCwgXCIuLi9pbnRlcm5hbHMvY2xhc3NvZlwiOiAyOSwgXCIuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yXCI6IDM3LCBcIi4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvclwiOiAzOSwgXCIuLi9pbnRlcm5hbHMvZXhwb3J0XCI6IDUwLCBcIi4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHRcIjogNTUsIFwiLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pblwiOiA1NywgXCIuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yXCI6IDU5LCBcIi4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kXCI6IDU4LCBcIi4uL2ludGVybmFscy9oYXNcIjogNjEsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9pcy1vYmplY3RcIjogNzUsIFwiLi4vaW50ZXJuYWxzL25hdGl2ZS11cmxcIjogODUsIFwiLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGVcIjogOTEsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsXCI6IDEwOCwgXCIuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWdcIjogMTE4LCBcIi4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbFwiOiAxNDksIFwiLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQgfV0sIDI0NTogW2Z1bmN0aW9uKHgsIEgsIEMpIHtcbiAgICAgIHgoXCIuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKTtcbiAgICAgIGZ1bmN0aW9uIG0oaWUpIHtcbiAgICAgICAgdmFyIE9lLCBHZSwgTGUsIHJ0O1xuICAgICAgICBpZiAodHlwZW9mIGllID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb3IgKE9lID0gW10sIEdlID0gMDsgR2UgPCA0OyBHZSsrKVxuICAgICAgICAgICAgT2UudW5zaGlmdChpZSAlIDI1NiksIGllID0gVihpZSAvIDI1Nik7XG4gICAgICAgICAgcmV0dXJuIE9lLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaWUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gaWU7XG4gICAgICAgIGZvciAoT2UgPSBcIlwiLCBMZSA9IGFlKGllKSwgR2UgPSAwOyBHZSA8IDg7IEdlKyspXG4gICAgICAgICAgcnQgJiYgaWVbR2VdID09PSAwIHx8IChydCA9IHJ0ICYmICExLCBMZSA9PT0gR2UgPyAoT2UgKz0gR2UgPyBcIjpcIiA6IFwiOjpcIiwgcnQgPSAhMCkgOiAoT2UgKz0gaWVbR2VdLnRvU3RyaW5nKDE2KSwgR2UgPCA3ICYmIChPZSArPSBcIjpcIikpKTtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT2UgKyBcIl1cIjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoaWUpIHtcbiAgICAgICAgcmV0dXJuICFpZS5ob3N0IHx8IGllLmNhbm5vdEJlQUJhc2VVUkwgfHwgaWUuc2NoZW1lID09IFwiZmlsZVwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdShpZSwgT2UsIEdlLCBMZSkge1xuICAgICAgICB2YXIgcnQsIFBlLCBjdCwgcWUgPSBHZSB8fCBSZSwgdXQgPSAwLCBaZSA9IFwiXCIsIEF0ID0gITEsIFV0ID0gITEsIEN0ID0gITE7XG4gICAgICAgIGZvciAoR2UgfHwgKGllLnNjaGVtZSA9IFwiXCIsIGllLnVzZXJuYW1lID0gXCJcIiwgaWUucGFzc3dvcmQgPSBcIlwiLCBpZS5ob3N0ID0gbnVsbCwgaWUucG9ydCA9IG51bGwsIGllLnBhdGggPSBbXSwgaWUucXVlcnkgPSBudWxsLCBpZS5mcmFnbWVudCA9IG51bGwsIGllLmNhbm5vdEJlQUJhc2VVUkwgPSAhMSwgT2UgPSBPZS5yZXBsYWNlKHVlLCBcIlwiKSksIE9lID0gT2UucmVwbGFjZShsZSwgXCJcIiksIHJ0ID0gVChPZSk7IHV0IDw9IHJ0Lmxlbmd0aDsgKSB7XG4gICAgICAgICAgc3dpdGNoIChQZSA9IHJ0W3V0XSwgcWUpIHtcbiAgICAgICAgICAgIGNhc2UgUmU6XG4gICAgICAgICAgICAgIGlmICghUGUgfHwgIWIudGVzdChQZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoR2UpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gVztcbiAgICAgICAgICAgICAgICBxZSA9IFo7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgWmUgKz0gUGUudG9Mb3dlckNhc2UoKSwgcWUgPSB3ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHdlOlxuICAgICAgICAgICAgICBpZiAoUGUgJiYgKE8udGVzdChQZSkgfHwgUGUgPT0gXCIrXCIgfHwgUGUgPT0gXCItXCIgfHwgUGUgPT0gXCIuXCIpKVxuICAgICAgICAgICAgICAgIFplICs9IFBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChQZSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKEdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVztcbiAgICAgICAgICAgICAgICAgIFplID0gXCJcIiwgcWUgPSBaLCB1dCA9IDA7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEdlICYmIChNZShpZSkgIT0gcChEZSwgWmUpIHx8IFplID09IFwiZmlsZVwiICYmIChRZShpZSkgfHwgaWUucG9ydCAhPT0gbnVsbCkgfHwgaWUuc2NoZW1lID09IFwiZmlsZVwiICYmICFpZS5ob3N0KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoaWUuc2NoZW1lID0gWmUsIEdlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKE1lKGllKSAmJiBEZVtpZS5zY2hlbWVdID09IGllLnBvcnQgJiYgKGllLnBvcnQgPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgWmUgPSBcIlwiLCBpZS5zY2hlbWUgPT0gXCJmaWxlXCIgPyBxZSA9IHN0IDogTWUoaWUpICYmIExlICYmIExlLnNjaGVtZSA9PSBpZS5zY2hlbWUgPyBxZSA9ICQgOiBNZShpZSkgPyBxZSA9IGplIDogcnRbdXQgKyAxXSA9PSBcIi9cIiA/IChxZSA9IHEsIHV0KyspIDogKGllLmNhbm5vdEJlQUJhc2VVUkwgPSAhMCwgaWUucGF0aC5wdXNoKFwiXCIpLCBxZSA9IGJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWjpcbiAgICAgICAgICAgICAgaWYgKCFMZSB8fCBMZS5jYW5ub3RCZUFCYXNlVVJMICYmIFBlICE9IFwiI1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiBXO1xuICAgICAgICAgICAgICBpZiAoTGUuY2Fubm90QmVBQmFzZVVSTCAmJiBQZSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGllLnNjaGVtZSA9IExlLnNjaGVtZSwgaWUucGF0aCA9IExlLnBhdGguc2xpY2UoKSwgaWUucXVlcnkgPSBMZS5xdWVyeSwgaWUuZnJhZ21lbnQgPSBcIlwiLCBpZS5jYW5ub3RCZUFCYXNlVVJMID0gITAsIHFlID0gTXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcWUgPSBMZS5zY2hlbWUgPT0gXCJmaWxlXCIgPyBzdCA6IGVlO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJDpcbiAgICAgICAgICAgICAgaWYgKFBlICE9IFwiL1wiIHx8IHJ0W3V0ICsgMV0gIT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBxZSA9IGVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHFlID0gQ2UsIHV0Kys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBxOlxuICAgICAgICAgICAgICBpZiAoUGUgPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBxZSA9IEZlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHFlID0gb3Q7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBlZTpcbiAgICAgICAgICAgICAgaWYgKGllLnNjaGVtZSA9IExlLnNjaGVtZSwgUGUgPT0gZilcbiAgICAgICAgICAgICAgICBpZS51c2VybmFtZSA9IExlLnVzZXJuYW1lLCBpZS5wYXNzd29yZCA9IExlLnBhc3N3b3JkLCBpZS5ob3N0ID0gTGUuaG9zdCwgaWUucG9ydCA9IExlLnBvcnQsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIGllLnF1ZXJ5ID0gTGUucXVlcnk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKFBlID09IFwiL1wiIHx8IFBlID09IFwiXFxcXFwiICYmIE1lKGllKSlcbiAgICAgICAgICAgICAgICBxZSA9IHBlO1xuICAgICAgICAgICAgICBlbHNlIGlmIChQZSA9PSBcIj9cIilcbiAgICAgICAgICAgICAgICBpZS51c2VybmFtZSA9IExlLnVzZXJuYW1lLCBpZS5wYXNzd29yZCA9IExlLnBhc3N3b3JkLCBpZS5ob3N0ID0gTGUuaG9zdCwgaWUucG9ydCA9IExlLnBvcnQsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIGllLnF1ZXJ5ID0gXCJcIiwgcWUgPSBJdDtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFBlICE9IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICBpZS51c2VybmFtZSA9IExlLnVzZXJuYW1lLCBpZS5wYXNzd29yZCA9IExlLnBhc3N3b3JkLCBpZS5ob3N0ID0gTGUuaG9zdCwgaWUucG9ydCA9IExlLnBvcnQsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIGllLnBhdGgucG9wKCksIHFlID0gb3Q7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWUudXNlcm5hbWUgPSBMZS51c2VybmFtZSwgaWUucGFzc3dvcmQgPSBMZS5wYXNzd29yZCwgaWUuaG9zdCA9IExlLmhvc3QsIGllLnBvcnQgPSBMZS5wb3J0LCBpZS5wYXRoID0gTGUucGF0aC5zbGljZSgpLCBpZS5xdWVyeSA9IExlLnF1ZXJ5LCBpZS5mcmFnbWVudCA9IFwiXCIsIHFlID0gTXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBlOlxuICAgICAgICAgICAgICBpZiAoIU1lKGllKSB8fCBQZSAhPSBcIi9cIiAmJiBQZSAhPSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGlmIChQZSAhPSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgaWUudXNlcm5hbWUgPSBMZS51c2VybmFtZSwgaWUucGFzc3dvcmQgPSBMZS5wYXNzd29yZCwgaWUuaG9zdCA9IExlLmhvc3QsIGllLnBvcnQgPSBMZS5wb3J0LCBxZSA9IG90O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFlID0gRmU7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHFlID0gQ2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqZTpcbiAgICAgICAgICAgICAgaWYgKHFlID0gQ2UsIFBlICE9IFwiL1wiIHx8IFplLmNoYXJBdCh1dCArIDEpICE9IFwiL1wiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB1dCsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2U6XG4gICAgICAgICAgICAgIGlmIChQZSA9PSBcIi9cIiB8fCBQZSA9PSBcIlxcXFxcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgcWUgPSBGZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIEZlOlxuICAgICAgICAgICAgICBpZiAoUGUgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgICBBdCAmJiAoWmUgPSBcIiU0MFwiICsgWmUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEF0ID0gITAsIE50ID0gVChaZSksIEt0ID0gMDsgS3QgPCBOdC5sZW5ndGg7IEt0KyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBYdCA9IE50W0t0XTtcbiAgICAgICAgICAgICAgICAgIFh0ICE9IFwiOlwiIHx8IEN0ID8gKFh0ID0geGUoWHQsIGdlKSwgQ3QgPyBpZS5wYXNzd29yZCArPSBYdCA6IGllLnVzZXJuYW1lICs9IFh0KSA6IEN0ID0gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFplID0gXCJcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChQZSA9PSBmIHx8IFBlID09IFwiL1wiIHx8IFBlID09IFwiP1wiIHx8IFBlID09IFwiI1wiIHx8IFBlID09IFwiXFxcXFwiICYmIE1lKGllKSkge1xuICAgICAgICAgICAgICAgIGlmIChBdCAmJiBaZSA9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFU7XG4gICAgICAgICAgICAgICAgdXQgLT0gVChaZSkubGVuZ3RoICsgMSwgWmUgPSBcIlwiLCBxZSA9IE5lO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBaZSArPSBQZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5lOlxuICAgICAgICAgICAgY2FzZSBCZTpcbiAgICAgICAgICAgICAgaWYgKEdlICYmIGllLnNjaGVtZSA9PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgIHFlID0gS2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFBlICE9IFwiOlwiIHx8IFV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFBlID09IGYgfHwgUGUgPT0gXCIvXCIgfHwgUGUgPT0gXCI/XCIgfHwgUGUgPT0gXCIjXCIgfHwgUGUgPT0gXCJcXFxcXCIgJiYgTWUoaWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoTWUoaWUpICYmIFplID09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICAgICAgICAgICAgaWYgKEdlICYmIFplID09IFwiXCIgJiYgKFFlKGllKSB8fCBpZS5wb3J0ICE9PSBudWxsKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgaWYgKGN0ID0gSyhpZSwgWmUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Q7XG4gICAgICAgICAgICAgICAgICBpZiAoWmUgPSBcIlwiLCBxZSA9IGF0LCBHZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFBlID09IFwiW1wiID8gVXQgPSAhMCA6IFBlID09IFwiXVwiICYmIChVdCA9ICExKSwgWmUgKz0gUGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFplID09IFwiXCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgICAgICAgICBpZiAoY3QgPSBLKGllLCBaZSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Q7XG4gICAgICAgICAgICAgICAgaWYgKFplID0gXCJcIiwgcWUgPSBXZSwgR2UgPT0gQmUpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlOlxuICAgICAgICAgICAgICBpZiAoIUQudGVzdChQZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoUGUgPT0gZiB8fCBQZSA9PSBcIi9cIiB8fCBQZSA9PSBcIj9cIiB8fCBQZSA9PSBcIiNcIiB8fCBQZSA9PSBcIlxcXFxcIiAmJiBNZShpZSkgfHwgR2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChaZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBKdCA9IHBhcnNlSW50KFplLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICg2NTUzNSA8IEp0KVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgICAgICAgICAgICAgaWUucG9ydCA9IE1lKGllKSAmJiBKdCA9PT0gRGVbaWUuc2NoZW1lXSA/IG51bGwgOiBKdCwgWmUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKEdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICBxZSA9IGF0O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBaZSArPSBQZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0OlxuICAgICAgICAgICAgICBpZiAoaWUuc2NoZW1lID0gXCJmaWxlXCIsIFBlID09IFwiL1wiIHx8IFBlID09IFwiXFxcXFwiKVxuICAgICAgICAgICAgICAgIHFlID0gbnQ7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghTGUgfHwgTGUuc2NoZW1lICE9IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgICAgICBxZSA9IG90O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChQZSA9PSBmKVxuICAgICAgICAgICAgICAgICAgaWUuaG9zdCA9IExlLmhvc3QsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIGllLnF1ZXJ5ID0gTGUucXVlcnk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUGUgPT0gXCI/XCIpXG4gICAgICAgICAgICAgICAgICBpZS5ob3N0ID0gTGUuaG9zdCwgaWUucGF0aCA9IExlLnBhdGguc2xpY2UoKSwgaWUucXVlcnkgPSBcIlwiLCBxZSA9IEl0O1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKFBlICE9IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIFZlKHJ0LnNsaWNlKHV0KS5qb2luKFwiXCIpKSB8fCAoaWUuaG9zdCA9IExlLmhvc3QsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIFhlKGllKSksIHFlID0gb3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWUuaG9zdCA9IExlLmhvc3QsIGllLnBhdGggPSBMZS5wYXRoLnNsaWNlKCksIGllLnF1ZXJ5ID0gTGUucXVlcnksIGllLmZyYWdtZW50ID0gXCJcIiwgcWUgPSBNdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG50OlxuICAgICAgICAgICAgICBpZiAoUGUgPT0gXCIvXCIgfHwgUGUgPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBxZSA9IEtlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIExlICYmIExlLnNjaGVtZSA9PSBcImZpbGVcIiAmJiAhVmUocnQuc2xpY2UodXQpLmpvaW4oXCJcIikpICYmICh6ZShMZS5wYXRoWzBdLCAhMCkgPyBpZS5wYXRoLnB1c2goTGUucGF0aFswXSkgOiBpZS5ob3N0ID0gTGUuaG9zdCksIHFlID0gb3Q7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBLZTpcbiAgICAgICAgICAgICAgaWYgKFBlID09IGYgfHwgUGUgPT0gXCIvXCIgfHwgUGUgPT0gXCJcXFxcXCIgfHwgUGUgPT0gXCI/XCIgfHwgUGUgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUdlICYmIHplKFplKSlcbiAgICAgICAgICAgICAgICAgIHFlID0gb3Q7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoWmUgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWUuaG9zdCA9IFwiXCIsIEdlKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdCA9IEsoaWUsIFplKSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZS5ob3N0ID09IFwibG9jYWxob3N0XCIgJiYgKGllLmhvc3QgPSBcIlwiKSwgR2UpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBaZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBxZSA9IGF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBaZSArPSBQZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGF0OlxuICAgICAgICAgICAgICBpZiAoTWUoaWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFlID0gb3QsIFBlICE9IFwiL1wiICYmIFBlICE9IFwiXFxcXFwiKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoR2UgfHwgUGUgIT0gXCI/XCIpXG4gICAgICAgICAgICAgICAgaWYgKEdlIHx8IFBlICE9IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGUgIT0gZiAmJiAocWUgPSBvdCwgUGUgIT0gXCIvXCIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIGllLmZyYWdtZW50ID0gXCJcIiwgcWUgPSBNdDtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGllLnF1ZXJ5ID0gXCJcIiwgcWUgPSBJdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG90OlxuICAgICAgICAgICAgICBpZiAoUGUgPT0gZiB8fCBQZSA9PSBcIi9cIiB8fCBQZSA9PSBcIlxcXFxcIiAmJiBNZShpZSkgfHwgIUdlICYmIChQZSA9PSBcIj9cIiB8fCBQZSA9PSBcIiNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmUoWmUpID8gKFhlKGllKSwgUGUgPT0gXCIvXCIgfHwgUGUgPT0gXCJcXFxcXCIgJiYgTWUoaWUpIHx8IGllLnBhdGgucHVzaChcIlwiKSkgOiBIZShaZSkgPyBQZSA9PSBcIi9cIiB8fCBQZSA9PSBcIlxcXFxcIiAmJiBNZShpZSkgfHwgaWUucGF0aC5wdXNoKFwiXCIpIDogKGllLnNjaGVtZSA9PSBcImZpbGVcIiAmJiAhaWUucGF0aC5sZW5ndGggJiYgemUoWmUpICYmIChpZS5ob3N0ICYmIChpZS5ob3N0ID0gXCJcIiksIFplID0gWmUuY2hhckF0KDApICsgXCI6XCIpLCBpZS5wYXRoLnB1c2goWmUpKSwgWmUgPSBcIlwiLCBpZS5zY2hlbWUgPT0gXCJmaWxlXCIgJiYgKFBlID09IGYgfHwgUGUgPT0gXCI/XCIgfHwgUGUgPT0gXCIjXCIpKVxuICAgICAgICAgICAgICAgICAgZm9yICg7IDEgPCBpZS5wYXRoLmxlbmd0aCAmJiBpZS5wYXRoWzBdID09PSBcIlwiOyApXG4gICAgICAgICAgICAgICAgICAgIGllLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBQZSA9PSBcIj9cIiA/IChpZS5xdWVyeSA9IFwiXCIsIHFlID0gSXQpIDogUGUgPT0gXCIjXCIgJiYgKGllLmZyYWdtZW50ID0gXCJcIiwgcWUgPSBNdCk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIFplICs9IHhlKFBlLCBmZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBidDpcbiAgICAgICAgICAgICAgUGUgPT0gXCI/XCIgPyAoaWUucXVlcnkgPSBcIlwiLCBxZSA9IEl0KSA6IFBlID09IFwiI1wiID8gKGllLmZyYWdtZW50ID0gXCJcIiwgcWUgPSBNdCkgOiBQZSAhPSBmICYmIChpZS5wYXRoWzBdICs9IHhlKFBlLCBoZSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSXQ6XG4gICAgICAgICAgICAgIEdlIHx8IFBlICE9IFwiI1wiID8gUGUgIT0gZiAmJiAoUGUgPT0gXCInXCIgJiYgTWUoaWUpID8gaWUucXVlcnkgKz0gXCIlMjdcIiA6IGllLnF1ZXJ5ICs9IFBlID09IFwiI1wiID8gXCIlMjNcIiA6IHhlKFBlLCBoZSkpIDogKGllLmZyYWdtZW50ID0gXCJcIiwgcWUgPSBNdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNdDpcbiAgICAgICAgICAgICAgUGUgIT0gZiAmJiAoaWUuZnJhZ21lbnQgKz0geGUoUGUsIF9lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHV0Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgoUGUpIHtcbiAgICAgICAgdmFyIE9lLCBHZSwgTGUgPSBjKHRoaXMsIGgsIFwiVVJMXCIpLCBydCA9IDEgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzFdIDogdm9pZCAwLCBQZSA9IFN0cmluZyhQZSksIGN0ID0gTChMZSwgeyB0eXBlOiBcIlVSTFwiIH0pO1xuICAgICAgICBpZiAocnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChydCBpbnN0YW5jZW9mIGgpXG4gICAgICAgICAgICBPZSA9IEYocnQpO1xuICAgICAgICAgIGVsc2UgaWYgKEdlID0gdShPZSA9IHt9LCBTdHJpbmcocnQpKSlcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihHZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdlID0gdShjdCwgUGUsIG51bGwsIE9lKSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoR2UpO1xuICAgICAgICB2YXIgcWUgPSBjdC5zZWFyY2hQYXJhbXMgPSBuZXcgTSgpO1xuICAgICAgICAocnQgPSBSKHFlKSkudXBkYXRlU2VhcmNoUGFyYW1zKGN0LnF1ZXJ5KSwgcnQudXBkYXRlVVJMID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY3QucXVlcnkgPSBTdHJpbmcocWUpIHx8IG51bGw7XG4gICAgICAgIH0sIGkgfHwgKExlLmhyZWYgPSBqdC5jYWxsKExlKSwgTGUub3JpZ2luID0gaHQuY2FsbChMZSksIExlLnByb3RvY29sID0gRHQuY2FsbChMZSksIExlLnVzZXJuYW1lID0gUHQuY2FsbChMZSksIExlLnBhc3N3b3JkID0gZ3QuY2FsbChMZSksIExlLmhvc3QgPSBGdC5jYWxsKExlKSwgTGUuaG9zdG5hbWUgPSBtZS5jYWxsKExlKSwgTGUucG9ydCA9IFVlLmNhbGwoTGUpLCBMZS5wYXRobmFtZSA9IFllLmNhbGwoTGUpLCBMZS5zZWFyY2ggPSBpdC5jYWxsKExlKSwgTGUuc2VhcmNoUGFyYW1zID0gZnQuY2FsbChMZSksIExlLmhhc2ggPSBwdC5jYWxsKExlKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKGllLCBPZSkge1xuICAgICAgICByZXR1cm4geyBnZXQ6IGllLCBzZXQ6IE9lLCBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCB9O1xuICAgICAgfVxuICAgICAgdmFyIGYsIHIsIHMsIG8gPSB4KFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiKSwgaSA9IHgoXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIiksIGwgPSB4KFwiLi4vaW50ZXJuYWxzL25hdGl2ZS11cmxcIiksIG10ID0geChcIi4uL2ludGVybmFscy9nbG9iYWxcIiksIG4gPSB4KFwiLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllc1wiKSwgYSA9IHgoXCIuLi9pbnRlcm5hbHMvcmVkZWZpbmVcIiksIGMgPSB4KFwiLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlXCIpLCBwID0geChcIi4uL2ludGVybmFscy9oYXNcIiksIGogPSB4KFwiLi4vaW50ZXJuYWxzL29iamVjdC1hc3NpZ25cIiksIFQgPSB4KFwiLi4vaW50ZXJuYWxzL2FycmF5LWZyb21cIiksIF8gPSB4KFwiLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGVcIikuY29kZUF0LCBTID0geChcIi4uL2ludGVybmFscy9zdHJpbmctcHVueWNvZGUtdG8tYXNjaWlcIiksIEUgPSB4KFwiLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnXCIpLCBBID0geChcIi4uL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zXCIpLCB4ID0geChcIi4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZVwiKSwgUCA9IG10LlVSTCwgTSA9IEEuVVJMU2VhcmNoUGFyYW1zLCBSID0gQS5nZXRTdGF0ZSwgTCA9IHguc2V0LCBGID0geC5nZXR0ZXJGb3IoXCJVUkxcIiksIFYgPSBNYXRoLmZsb29yLCBHID0gTWF0aC5wb3csIFUgPSBcIkludmFsaWQgYXV0aG9yaXR5XCIsIFcgPSBcIkludmFsaWQgc2NoZW1lXCIsIFggPSBcIkludmFsaWQgaG9zdFwiLCBuZSA9IFwiSW52YWxpZCBwb3J0XCIsIGIgPSAvW0EtWmEtel0vLCBPID0gL1tcXGQrLS5BLVphLXpdLywgRCA9IC9cXGQvLCBCID0gL14oMHh8MFgpLywgWSA9IC9eWzAtN10rJC8sIEogPSAvXlxcZCskLywgdGUgPSAvXltcXGRBLUZhLWZdKyQvLCBjZSA9IC9bXFx1MDAwMFxcdTAwMDlcXHUwMDBBXFx1MDAwRCAjJS86P0BbXFxcXF1dLywgcmUgPSAvW1xcdTAwMDBcXHUwMDA5XFx1MDAwQVxcdTAwMEQgIy86P0BbXFxcXF1dLywgdWUgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSt8W1xcdTAwMDAtXFx1MDAxRiBdKyQvZywgbGUgPSAvW1xcdTAwMDlcXHUwMDBBXFx1MDAwRF0vZywgSyA9IGZ1bmN0aW9uKGllLCBPZSkge1xuICAgICAgICB2YXIgR2UsIExlLCBydDtcbiAgICAgICAgaWYgKE9lLmNoYXJBdCgwKSA9PSBcIltcIilcbiAgICAgICAgICByZXR1cm4gT2UuY2hhckF0KE9lLmxlbmd0aCAtIDEpID09IFwiXVwiICYmIChHZSA9IGZ1bmN0aW9uKFBlKSB7XG4gICAgICAgICAgICB2YXIgY3QgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sIHFlID0gMCwgdXQgPSBudWxsLCBaZSA9IDAsIEF0LCBVdCwgQ3QsIE50LCBLdCwgWHQsIEp0LCBCdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gUGUuY2hhckF0KFplKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQnQoKSA9PSBcIjpcIikge1xuICAgICAgICAgICAgICBpZiAoUGUuY2hhckF0KDEpICE9IFwiOlwiKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgWmUgKz0gMiwgcWUrKywgdXQgPSBxZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBCdCgpOyApIHtcbiAgICAgICAgICAgICAgaWYgKHFlID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoQnQoKSA9PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGlmICh1dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBaZSsrLCBxZSsrLCB1dCA9IHFlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoQXQgPSBVdCA9IDA7IFV0IDwgNCAmJiB0ZS50ZXN0KEJ0KCkpOyApXG4gICAgICAgICAgICAgICAgQXQgPSBBdCAqIDE2ICsgcGFyc2VJbnQoQnQoKSwgMTYpLCBaZSsrLCBVdCsrO1xuICAgICAgICAgICAgICBpZiAoQnQoKSA9PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGlmIChVdCA9PSAwIHx8IChaZSAtPSBVdCwgcWUgPiA2KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKEN0ID0gMDsgQnQoKTsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoTnQgPSBudWxsLCBDdCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGlmIChCdCgpID09IFwiLlwiICYmIEN0IDwgNClcbiAgICAgICAgICAgICAgICAgICAgICBaZSsrO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgaWYgKCFELnRlc3QoQnQoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBELnRlc3QoQnQoKSk7ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoS3QgPSBwYXJzZUludChCdCgpLCAxMCksIE50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgIE50ID0gS3Q7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChOdCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIE50ID0gTnQgKiAxMCArIEt0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChOdCA+IDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIFplKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdFtxZV0gPSBjdFtxZV0gKiAyNTYgKyBOdCwgQ3QrKywgKEN0ID09IDIgfHwgQ3QgPT0gNCkgJiYgcWUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEN0ICE9IDQpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnQoKSA9PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGlmIChaZSsrLCAhQnQoKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY3RbcWUrK10gPSBBdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgZm9yIChYdCA9IHFlIC0gdXQsIHFlID0gNzsgcWUgIT0gMCAmJiBYdCA+IDA7IClcbiAgICAgICAgICAgICAgICBKdCA9IGN0W3FlXSwgY3RbcWUtLV0gPSBjdFt1dCArIFh0IC0gMV0sIGN0W3V0ICsgLS1YdF0gPSBKdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHFlICE9IDgpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJldHVybiBjdDtcbiAgICAgICAgICB9KE9lLnNsaWNlKDEsIC0xKSkpID8gdm9pZCAoaWUuaG9zdCA9IEdlKSA6IFg7XG4gICAgICAgIGlmIChNZShpZSkpXG4gICAgICAgICAgcmV0dXJuIE9lID0gUyhPZSksIGNlLnRlc3QoT2UpIHx8IChHZSA9IGZ1bmN0aW9uKFBlKSB7XG4gICAgICAgICAgICB2YXIgY3QgPSBQZS5zcGxpdChcIi5cIiksIHFlLCB1dCwgWmUsIEF0LCBVdCwgQ3QsIE50O1xuICAgICAgICAgICAgaWYgKGN0Lmxlbmd0aCAmJiBjdFtjdC5sZW5ndGggLSAxXSA9PSBcIlwiICYmIGN0LnBvcCgpLCAocWUgPSBjdC5sZW5ndGgpID4gNClcbiAgICAgICAgICAgICAgcmV0dXJuIFBlO1xuICAgICAgICAgICAgZm9yICh1dCA9IFtdLCBaZSA9IDA7IFplIDwgcWU7IFplKyspIHtcbiAgICAgICAgICAgICAgaWYgKEF0ID0gY3RbWmVdLCBBdCA9PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBQZTtcbiAgICAgICAgICAgICAgaWYgKFV0ID0gMTAsIEF0Lmxlbmd0aCA+IDEgJiYgQXQuY2hhckF0KDApID09IFwiMFwiICYmIChVdCA9IEIudGVzdChBdCkgPyAxNiA6IDgsIEF0ID0gQXQuc2xpY2UoVXQgPT0gOCA/IDEgOiAyKSksIEF0ID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIEN0ID0gMDtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoVXQgPT0gMTAgPyBKIDogVXQgPT0gOCA/IFkgOiB0ZSkudGVzdChBdCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gUGU7XG4gICAgICAgICAgICAgICAgQ3QgPSBwYXJzZUludChBdCwgVXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0LnB1c2goQ3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChaZSA9IDA7IFplIDwgcWU7IFplKyspXG4gICAgICAgICAgICAgIGlmIChDdCA9IHV0W1plXSwgWmUgPT0gcWUgLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKEN0ID49IEcoMjU2LCA1IC0gcWUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoQ3QgPiAyNTUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBmb3IgKE50ID0gdXQucG9wKCksIFplID0gMDsgWmUgPCB1dC5sZW5ndGg7IFplKyspXG4gICAgICAgICAgICAgIE50ICs9IHV0W1plXSAqIEcoMjU2LCAzIC0gWmUpO1xuICAgICAgICAgICAgcmV0dXJuIE50O1xuICAgICAgICAgIH0oT2UpKSA9PT0gbnVsbCA/IFggOiB2b2lkIChpZS5ob3N0ID0gR2UpO1xuICAgICAgICBpZiAocmUudGVzdChPZSkpXG4gICAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIGZvciAoR2UgPSBcIlwiLCBMZSA9IFQoT2UpLCBydCA9IDA7IHJ0IDwgTGUubGVuZ3RoOyBydCsrKVxuICAgICAgICAgIEdlICs9IHhlKExlW3J0XSwgaGUpO1xuICAgICAgICBpZS5ob3N0ID0gR2U7XG4gICAgICB9LCBhZSA9IGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIGZvciAodmFyIE9lID0gbnVsbCwgR2UgPSAxLCBMZSA9IG51bGwsIHJ0ID0gMCwgUGUgPSAwOyBQZSA8IDg7IFBlKyspXG4gICAgICAgICAgaWVbUGVdICE9PSAwID8gKEdlIDwgcnQgJiYgKE9lID0gTGUsIEdlID0gcnQpLCBMZSA9IG51bGwsIHJ0ID0gMCkgOiAoTGUgPT09IG51bGwgJiYgKExlID0gUGUpLCArK3J0KTtcbiAgICAgICAgcmV0dXJuIEdlIDwgcnQgJiYgKE9lID0gTGUsIEdlID0gcnQpLCBPZTtcbiAgICAgIH0sIGhlID0ge30sIF9lID0gaih7fSwgaGUsIHsgXCIgXCI6IDEsICdcIic6IDEsIFwiPFwiOiAxLCBcIj5cIjogMSwgXCJgXCI6IDEgfSksIGZlID0gaih7fSwgX2UsIHsgXCIjXCI6IDEsIFwiP1wiOiAxLCBcIntcIjogMSwgXCJ9XCI6IDEgfSksIGdlID0gaih7fSwgZmUsIHsgXCIvXCI6IDEsIFwiOlwiOiAxLCBcIjtcIjogMSwgXCI9XCI6IDEsIFwiQFwiOiAxLCBcIltcIjogMSwgXCJcXFxcXCI6IDEsIFwiXVwiOiAxLCBcIl5cIjogMSwgXCJ8XCI6IDEgfSksIHhlID0gZnVuY3Rpb24oaWUsIE9lKSB7XG4gICAgICAgIHZhciBHZSA9IF8oaWUsIDApO1xuICAgICAgICByZXR1cm4gMzIgPCBHZSAmJiBHZSA8IDEyNyAmJiAhcChPZSwgaWUpID8gaWUgOiBlbmNvZGVVUklDb21wb25lbnQoaWUpO1xuICAgICAgfSwgRGUgPSB7IGZ0cDogMjEsIGZpbGU6IG51bGwsIGh0dHA6IDgwLCBodHRwczogNDQzLCB3czogODAsIHdzczogNDQzIH0sIE1lID0gZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgcmV0dXJuIHAoRGUsIGllLnNjaGVtZSk7XG4gICAgICB9LCBRZSA9IGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIHJldHVybiBpZS51c2VybmFtZSAhPSBcIlwiIHx8IGllLnBhc3N3b3JkICE9IFwiXCI7XG4gICAgICB9LCB6ZSA9IGZ1bmN0aW9uKGllLCBPZSkge1xuICAgICAgICByZXR1cm4gaWUubGVuZ3RoID09IDIgJiYgYi50ZXN0KGllLmNoYXJBdCgwKSkgJiYgKChpZSA9IGllLmNoYXJBdCgxKSkgPT0gXCI6XCIgfHwgIU9lICYmIGllID09IFwifFwiKTtcbiAgICAgIH0sIFZlID0gZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgcmV0dXJuIDEgPCBpZS5sZW5ndGggJiYgemUoaWUuc2xpY2UoMCwgMikpICYmIChpZS5sZW5ndGggPT0gMiB8fCAoaWUgPSBpZS5jaGFyQXQoMikpID09PSBcIi9cIiB8fCBpZSA9PT0gXCJcXFxcXCIgfHwgaWUgPT09IFwiP1wiIHx8IGllID09PSBcIiNcIik7XG4gICAgICB9LCBYZSA9IGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIHZhciBPZSA9IGllLnBhdGgsIEdlID0gT2UubGVuZ3RoO1xuICAgICAgICAhR2UgfHwgaWUuc2NoZW1lID09IFwiZmlsZVwiICYmIEdlID09IDEgJiYgemUoT2VbMF0sICEwKSB8fCBPZS5wb3AoKTtcbiAgICAgIH0sIEhlID0gZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgcmV0dXJuIGllID09PSBcIi5cIiB8fCBpZS50b0xvd2VyQ2FzZSgpID09PSBcIiUyZVwiO1xuICAgICAgfSwgdmUgPSBmdW5jdGlvbihpZSkge1xuICAgICAgICByZXR1cm4gKGllID0gaWUudG9Mb3dlckNhc2UoKSkgPT09IFwiLi5cIiB8fCBpZSA9PT0gXCIlMmUuXCIgfHwgaWUgPT09IFwiLiUyZVwiIHx8IGllID09PSBcIiUyZSUyZVwiO1xuICAgICAgfSwgUmUgPSB7fSwgd2UgPSB7fSwgWiA9IHt9LCAkID0ge30sIHEgPSB7fSwgZWUgPSB7fSwgcGUgPSB7fSwgamUgPSB7fSwgQ2UgPSB7fSwgRmUgPSB7fSwgTmUgPSB7fSwgQmUgPSB7fSwgV2UgPSB7fSwgc3QgPSB7fSwgbnQgPSB7fSwgS2UgPSB7fSwgYXQgPSB7fSwgb3QgPSB7fSwgYnQgPSB7fSwgSXQgPSB7fSwgTXQgPSB7fSwgbXQgPSBoLnByb3RvdHlwZSwganQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGllID0gRih0aGlzKSwgT2UgPSBpZS5zY2hlbWUsIEdlID0gaWUudXNlcm5hbWUsIExlID0gaWUucGFzc3dvcmQsIHJ0ID0gaWUuaG9zdCwgUGUgPSBpZS5wb3J0LCBjdCA9IGllLnBhdGgsIHFlID0gaWUucXVlcnksIHV0ID0gaWUuZnJhZ21lbnQsIFplID0gT2UgKyBcIjpcIjtcbiAgICAgICAgcmV0dXJuIHJ0ICE9PSBudWxsID8gKFplICs9IFwiLy9cIiwgUWUoaWUpICYmIChaZSArPSBHZSArIChMZSA/IFwiOlwiICsgTGUgOiBcIlwiKSArIFwiQFwiKSwgWmUgKz0gbShydCksIFBlICE9PSBudWxsICYmIChaZSArPSBcIjpcIiArIFBlKSkgOiBPZSA9PSBcImZpbGVcIiAmJiAoWmUgKz0gXCIvL1wiKSwgWmUgKz0gaWUuY2Fubm90QmVBQmFzZVVSTCA/IGN0WzBdIDogY3QubGVuZ3RoID8gXCIvXCIgKyBjdC5qb2luKFwiL1wiKSA6IFwiXCIsIHFlICE9PSBudWxsICYmIChaZSArPSBcIj9cIiArIHFlKSwgdXQgIT09IG51bGwgJiYgKFplICs9IFwiI1wiICsgdXQpLCBaZTtcbiAgICAgIH0sIGh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZSA9IEYodGhpcyksIE9lID0gaWUuc2NoZW1lLCBHZSA9IGllLnBvcnQ7XG4gICAgICAgIGlmIChPZSA9PSBcImJsb2JcIilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoT2UucGF0aFswXSkub3JpZ2luO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9lICE9IFwiZmlsZVwiICYmIE1lKGllKSA/IE9lICsgXCI6Ly9cIiArIG0oaWUuaG9zdCkgKyAoR2UgIT09IG51bGwgPyBcIjpcIiArIEdlIDogXCJcIikgOiBcIm51bGxcIjtcbiAgICAgIH0sIER0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGKHRoaXMpLnNjaGVtZSArIFwiOlwiO1xuICAgICAgfSwgUHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEYodGhpcykudXNlcm5hbWU7XG4gICAgICB9LCBndCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRih0aGlzKS5wYXNzd29yZDtcbiAgICAgIH0sIEZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBPZSA9IEYodGhpcyksIGllID0gT2UuaG9zdCwgT2UgPSBPZS5wb3J0O1xuICAgICAgICByZXR1cm4gaWUgPT09IG51bGwgPyBcIlwiIDogT2UgPT09IG51bGwgPyBtKGllKSA6IG0oaWUpICsgXCI6XCIgKyBPZTtcbiAgICAgIH0sIG1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZSA9IEYodGhpcykuaG9zdDtcbiAgICAgICAgcmV0dXJuIGllID09PSBudWxsID8gXCJcIiA6IG0oaWUpO1xuICAgICAgfSwgVWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGllID0gRih0aGlzKS5wb3J0O1xuICAgICAgICByZXR1cm4gaWUgPT09IG51bGwgPyBcIlwiIDogU3RyaW5nKGllKTtcbiAgICAgIH0sIFllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZSA9IEYodGhpcyksIE9lID0gaWUucGF0aDtcbiAgICAgICAgcmV0dXJuIGllLmNhbm5vdEJlQUJhc2VVUkwgPyBPZVswXSA6IE9lLmxlbmd0aCA/IFwiL1wiICsgT2Uuam9pbihcIi9cIikgOiBcIlwiO1xuICAgICAgfSwgaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGllID0gRih0aGlzKS5xdWVyeTtcbiAgICAgICAgcmV0dXJuIGllID8gXCI/XCIgKyBpZSA6IFwiXCI7XG4gICAgICB9LCBmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRih0aGlzKS5zZWFyY2hQYXJhbXM7XG4gICAgICB9LCBwdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWUgPSBGKHRoaXMpLmZyYWdtZW50O1xuICAgICAgICByZXR1cm4gaWUgPyBcIiNcIiArIGllIDogXCJcIjtcbiAgICAgIH07XG4gICAgICBpICYmIG4obXQsIHsgaHJlZjogZyhqdCwgZnVuY3Rpb24oR2UpIHtcbiAgICAgICAgdmFyIE9lID0gRih0aGlzKSwgR2UgPSBTdHJpbmcoR2UpLCBHZSA9IHUoT2UsIEdlKTtcbiAgICAgICAgaWYgKEdlKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihHZSk7XG4gICAgICAgIFIoT2Uuc2VhcmNoUGFyYW1zKS51cGRhdGVTZWFyY2hQYXJhbXMoT2UucXVlcnkpO1xuICAgICAgfSksIG9yaWdpbjogZyhodCksIHByb3RvY29sOiBnKER0LCBmdW5jdGlvbihpZSkge1xuICAgICAgICB2YXIgT2UgPSBGKHRoaXMpO1xuICAgICAgICB1KE9lLCBTdHJpbmcoaWUpICsgXCI6XCIsIFJlKTtcbiAgICAgIH0pLCB1c2VybmFtZTogZyhQdCwgZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgdmFyIE9lID0gRih0aGlzKSwgR2UgPSBUKFN0cmluZyhpZSkpO1xuICAgICAgICBpZiAoIXkoT2UpKSB7XG4gICAgICAgICAgT2UudXNlcm5hbWUgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIExlID0gMDsgTGUgPCBHZS5sZW5ndGg7IExlKyspXG4gICAgICAgICAgICBPZS51c2VybmFtZSArPSB4ZShHZVtMZV0sIGdlKTtcbiAgICAgICAgfVxuICAgICAgfSksIHBhc3N3b3JkOiBnKGd0LCBmdW5jdGlvbihpZSkge1xuICAgICAgICB2YXIgT2UgPSBGKHRoaXMpLCBHZSA9IFQoU3RyaW5nKGllKSk7XG4gICAgICAgIGlmICgheShPZSkpIHtcbiAgICAgICAgICBPZS5wYXNzd29yZCA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgTGUgPSAwOyBMZSA8IEdlLmxlbmd0aDsgTGUrKylcbiAgICAgICAgICAgIE9lLnBhc3N3b3JkICs9IHhlKEdlW0xlXSwgZ2UpO1xuICAgICAgICB9XG4gICAgICB9KSwgaG9zdDogZyhGdCwgZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgdmFyIE9lID0gRih0aGlzKTtcbiAgICAgICAgT2UuY2Fubm90QmVBQmFzZVVSTCB8fCB1KE9lLCBTdHJpbmcoaWUpLCBOZSk7XG4gICAgICB9KSwgaG9zdG5hbWU6IGcobWUsIGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIHZhciBPZSA9IEYodGhpcyk7XG4gICAgICAgIE9lLmNhbm5vdEJlQUJhc2VVUkwgfHwgdShPZSwgU3RyaW5nKGllKSwgQmUpO1xuICAgICAgfSksIHBvcnQ6IGcoVWUsIGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIHZhciBPZSA9IEYodGhpcyk7XG4gICAgICAgIHkoT2UpIHx8ICgoaWUgPSBTdHJpbmcoaWUpKSA9PSBcIlwiID8gT2UucG9ydCA9IG51bGwgOiB1KE9lLCBpZSwgV2UpKTtcbiAgICAgIH0pLCBwYXRobmFtZTogZyhZZSwgZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgdmFyIE9lID0gRih0aGlzKTtcbiAgICAgICAgT2UuY2Fubm90QmVBQmFzZVVSTCB8fCAoT2UucGF0aCA9IFtdLCB1KE9lLCBpZSArIFwiXCIsIGF0KSk7XG4gICAgICB9KSwgc2VhcmNoOiBnKGl0LCBmdW5jdGlvbihpZSkge1xuICAgICAgICB2YXIgT2UgPSBGKHRoaXMpO1xuICAgICAgICAoaWUgPSBTdHJpbmcoaWUpKSA9PSBcIlwiID8gT2UucXVlcnkgPSBudWxsIDogKGllLmNoYXJBdCgwKSA9PSBcIj9cIiAmJiAoaWUgPSBpZS5zbGljZSgxKSksIE9lLnF1ZXJ5ID0gXCJcIiwgdShPZSwgaWUsIEl0KSksIFIoT2Uuc2VhcmNoUGFyYW1zKS51cGRhdGVTZWFyY2hQYXJhbXMoT2UucXVlcnkpO1xuICAgICAgfSksIHNlYXJjaFBhcmFtczogZyhmdCksIGhhc2g6IGcocHQsIGZ1bmN0aW9uKGllKSB7XG4gICAgICAgIHZhciBPZSA9IEYodGhpcyk7XG4gICAgICAgIChpZSA9IFN0cmluZyhpZSkpID09IFwiXCIgPyBPZS5mcmFnbWVudCA9IG51bGwgOiAoaWUuY2hhckF0KDApID09IFwiI1wiICYmIChpZSA9IGllLnNsaWNlKDEpKSwgT2UuZnJhZ21lbnQgPSBcIlwiLCB1KE9lLCBpZSwgTXQpKTtcbiAgICAgIH0pIH0pLCBhKG10LCBcInRvSlNPTlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGp0LmNhbGwodGhpcyk7XG4gICAgICB9LCB7IGVudW1lcmFibGU6ICEwIH0pLCBhKG10LCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ganQuY2FsbCh0aGlzKTtcbiAgICAgIH0sIHsgZW51bWVyYWJsZTogITAgfSksIFAgJiYgKHIgPSBQLmNyZWF0ZU9iamVjdFVSTCwgcyA9IFAucmV2b2tlT2JqZWN0VVJMLCByICYmIGEoaCwgXCJjcmVhdGVPYmplY3RVUkxcIiwgZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgcmV0dXJuIHIuYXBwbHkoUCwgYXJndW1lbnRzKTtcbiAgICAgIH0pLCBzICYmIGEoaCwgXCJyZXZva2VPYmplY3RVUkxcIiwgZnVuY3Rpb24oaWUpIHtcbiAgICAgICAgcmV0dXJuIHMuYXBwbHkoUCwgYXJndW1lbnRzKTtcbiAgICAgIH0pKSwgRShoLCBcIlVSTFwiKSwgbyh7IGdsb2JhbDogITAsIGZvcmNlZDogIWwsIHNoYW06ICFpIH0sIHsgVVJMOiBoIH0pO1xuICAgIH0sIHsgXCIuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2VcIjogOSwgXCIuLi9pbnRlcm5hbHMvYXJyYXktZnJvbVwiOiAxNywgXCIuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnNcIjogNDMsIFwiLi4vaW50ZXJuYWxzL2V4cG9ydFwiOiA1MCwgXCIuLi9pbnRlcm5hbHMvZ2xvYmFsXCI6IDYwLCBcIi4uL2ludGVybmFscy9oYXNcIjogNjEsIFwiLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlXCI6IDcxLCBcIi4uL2ludGVybmFscy9uYXRpdmUtdXJsXCI6IDg1LCBcIi4uL2ludGVybmFscy9vYmplY3QtYXNzaWduXCI6IDkwLCBcIi4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXNcIjogOTIsIFwiLi4vaW50ZXJuYWxzL3JlZGVmaW5lXCI6IDEwOSwgXCIuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWdcIjogMTE4LCBcIi4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlXCI6IDEyNCwgXCIuLi9pbnRlcm5hbHMvc3RyaW5nLXB1bnljb2RlLXRvLWFzY2lpXCI6IDEyNywgXCIuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXNcIjogMjQ0IH1dLCAyNDY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBILmV4cG9ydHMgPSB0KFwiLi9cIikucG9seWZpbGwoKTtcbiAgICB9LCB7IFwiLi9cIjogMjQ3IH1dLCAyNDc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICAoZnVuY3Rpb24obSwgeSkge1xuICAgICAgICB2YXIgdSwgaDtcbiAgICAgICAgdSA9IHRoaXMsIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiBnKEspIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgSyA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihLKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEspID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgICAgfSwgciA9IDAsIHMgPSB2b2lkIDAsIG8gPSB2b2lkIDAsIGkgPSBmdW5jdGlvbihLLCBhZSkge1xuICAgICAgICAgICAgaltyXSA9IEssIGpbciArIDFdID0gYWUsIChyICs9IDIpID09PSAyICYmIChvID8gbyhUKSA6IE0oKSk7XG4gICAgICAgICAgfSwgbCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHZvaWQgMCwgbiA9IGwgfHwge30sIG4gPSBuLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLCBhID0gdHlwZW9mIHNlbGYgPiBcInVcIiAmJiBtICE9PSB2b2lkIDAgJiYge30udG9TdHJpbmcuY2FsbChtKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIsIGMgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPCBcInVcIiAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyA8IFwidVwiICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA8IFwidVwiO1xuICAgICAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgICAgICB2YXIgSyA9IHNldFRpbWVvdXQ7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBLKFQsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGogPSBuZXcgQXJyYXkoMWUzKTtcbiAgICAgICAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgSyA9IDA7IEsgPCByOyBLICs9IDIpXG4gICAgICAgICAgICAgICgwLCBqW0tdKShqW0sgKyAxXSksIGpbS10gPSB2b2lkIDAsIGpbSyArIDFdID0gdm9pZCAwO1xuICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgSyA9IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKS5yZXF1aXJlKFwidmVydHhcIik7XG4gICAgICAgICAgICAgIHJldHVybiAocyA9IEsucnVuT25Mb29wIHx8IEsucnVuT25Db250ZXh0KSAhPT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcyhUKTtcbiAgICAgICAgICAgICAgfSA6IHAoKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgUywgRSwgQSwgTSA9IHZvaWQgMDtcbiAgICAgICAgICBmdW5jdGlvbiB4KEssIGFlKSB7XG4gICAgICAgICAgICB2YXIgaGUsIF9lID0gdGhpcywgZmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihMKSwgZ2UgPSAoZmVbUl0gPT09IHZvaWQgMCAmJiB0ZShmZSksIF9lLl9zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2UgPyAoaGUgPSBhcmd1bWVudHNbZ2UgLSAxXSwgaShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFkoZ2UsIGZlLCBoZSwgX2UuX3Jlc3VsdCk7XG4gICAgICAgICAgICB9KSkgOiBEKF9lLCBmZSwgSywgYWUpLCBmZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUChLKSB7XG4gICAgICAgICAgICB2YXIgYWU7XG4gICAgICAgICAgICByZXR1cm4gSyAmJiB0eXBlb2YgSyA9PSBcIm9iamVjdFwiICYmIEsuY29uc3RydWN0b3IgPT09IHRoaXMgPyBLIDogKFgoYWUgPSBuZXcgdGhpcyhMKSwgSyksIGFlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIE0gPSBhID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5uZXh0VGljayhUKTtcbiAgICAgICAgICB9IDogbiA/IChFID0gMCwgYSA9IG5ldyBuKFQpLCBBID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksIGEub2JzZXJ2ZShBLCB7IGNoYXJhY3RlckRhdGE6ICEwIH0pLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEEuZGF0YSA9IEUgPSArK0UgJSAyO1xuICAgICAgICAgIH0pIDogYyA/ICgoUyA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpKS5wb3J0MS5vbm1lc3NhZ2UgPSBULCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBTLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICAgIH0pIDogKGwgPT09IHZvaWQgMCAmJiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBfIDogcCkoKSwgUiA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbiAgICAgICAgICBmdW5jdGlvbiBMKCkge1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgRiA9IHZvaWQgMCwgViA9IDEsIEcgPSAyO1xuICAgICAgICAgIGZ1bmN0aW9uIFUoSywgYWUsIGhlKSB7XG4gICAgICAgICAgICBpKGZ1bmN0aW9uKF9lKSB7XG4gICAgICAgICAgICAgIHZhciBmZSA9ICExLCBnZSA9IGZ1bmN0aW9uKHhlLCBEZSwgTWUsIFFlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHhlLmNhbGwoRGUsIE1lLCBRZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoemUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0oaGUsIGFlLCBmdW5jdGlvbih4ZSkge1xuICAgICAgICAgICAgICAgIGZlIHx8IChmZSA9ICEwLCAoYWUgIT09IHhlID8gWCA6IGIpKF9lLCB4ZSkpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbih4ZSkge1xuICAgICAgICAgICAgICAgIGZlIHx8IChmZSA9ICEwLCBPKF9lLCB4ZSkpO1xuICAgICAgICAgICAgICB9LCBfZS5fbGFiZWwpO1xuICAgICAgICAgICAgICAhZmUgJiYgZ2UgJiYgKGZlID0gITAsIE8oX2UsIGdlKSk7XG4gICAgICAgICAgICB9LCBLKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVyhLLCBhZSwgaGUpIHtcbiAgICAgICAgICAgIHZhciBfZSwgZmU7XG4gICAgICAgICAgICBhZS5jb25zdHJ1Y3RvciA9PT0gSy5jb25zdHJ1Y3RvciAmJiBoZSA9PT0geCAmJiBhZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSBQID8gKF9lID0gSywgKGZlID0gYWUpLl9zdGF0ZSA9PT0gViA/IGIoX2UsIGZlLl9yZXN1bHQpIDogZmUuX3N0YXRlID09PSBHID8gTyhfZSwgZmUuX3Jlc3VsdCkgOiBEKGZlLCB2b2lkIDAsIGZ1bmN0aW9uKGdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBYKF9lLCBnZSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gTyhfZSwgZ2UpO1xuICAgICAgICAgICAgfSkpIDogaGUgIT09IHZvaWQgMCAmJiBnKGhlKSA/IFUoSywgYWUsIGhlKSA6IGIoSywgYWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBYKEssIGFlKSB7XG4gICAgICAgICAgICBpZiAoSyA9PT0gYWUpXG4gICAgICAgICAgICAgIE8oSywgbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIikpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaGUgPSB0eXBlb2YgYWUsIGFlID09PSBudWxsIHx8IGhlICE9IFwib2JqZWN0XCIgJiYgaGUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICBiKEssIGFlKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoZSA9IGFlLnRoZW47XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgTyhLLCBfZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVyhLLCBhZSwgaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBuZShLKSB7XG4gICAgICAgICAgICBLLl9vbmVycm9yICYmIEsuX29uZXJyb3IoSy5fcmVzdWx0KSwgQihLKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYihLLCBhZSkge1xuICAgICAgICAgICAgSy5fc3RhdGUgPT09IEYgJiYgKEsuX3Jlc3VsdCA9IGFlLCBLLl9zdGF0ZSA9IFYsIEsuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCAmJiBpKEIsIEspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTyhLLCBhZSkge1xuICAgICAgICAgICAgSy5fc3RhdGUgPT09IEYgJiYgKEsuX3N0YXRlID0gRywgSy5fcmVzdWx0ID0gYWUsIGkobmUsIEspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRChLLCBhZSwgaGUsIF9lKSB7XG4gICAgICAgICAgICB2YXIgZmUgPSBLLl9zdWJzY3JpYmVycywgZ2UgPSBmZS5sZW5ndGg7XG4gICAgICAgICAgICBLLl9vbmVycm9yID0gbnVsbCwgZmVbZ2VdID0gYWUsIGZlW2dlICsgVl0gPSBoZSwgZmVbZ2UgKyBHXSA9IF9lLCBnZSA9PT0gMCAmJiBLLl9zdGF0ZSAmJiBpKEIsIEspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBCKEspIHtcbiAgICAgICAgICAgIHZhciBhZSA9IEsuX3N1YnNjcmliZXJzLCBoZSA9IEsuX3N0YXRlO1xuICAgICAgICAgICAgaWYgKGFlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfZSwgZmUgPSB2b2lkIDAsIGdlID0gSy5fcmVzdWx0LCB4ZSA9IDA7IHhlIDwgYWUubGVuZ3RoOyB4ZSArPSAzKVxuICAgICAgICAgICAgICAgIF9lID0gYWVbeGVdLCBmZSA9IGFlW3hlICsgaGVdLCBfZSA/IFkoaGUsIF9lLCBmZSwgZ2UpIDogZmUoZ2UpO1xuICAgICAgICAgICAgICBLLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBZKEssIGFlLCBoZSwgX2UpIHtcbiAgICAgICAgICAgIHZhciBmZSA9IGcoaGUpLCBnZSA9IHZvaWQgMCwgeGUgPSB2b2lkIDAsIERlID0gITA7XG4gICAgICAgICAgICBpZiAoZmUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnZSA9IGhlKF9lKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoTWUpIHtcbiAgICAgICAgICAgICAgICBEZSA9ICExLCB4ZSA9IE1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhZSA9PT0gZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgTyhhZSwgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS5cIikpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGdlID0gX2U7XG4gICAgICAgICAgICBhZS5fc3RhdGUgPT09IEYgJiYgKGZlICYmIERlID8gWChhZSwgZ2UpIDogRGUgPT09ICExID8gTyhhZSwgeGUpIDogSyA9PT0gViA/IGIoYWUsIGdlKSA6IEsgPT09IEcgJiYgTyhhZSwgZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEogPSAwO1xuICAgICAgICAgIGZ1bmN0aW9uIHRlKEspIHtcbiAgICAgICAgICAgIEtbUl0gPSBKKyssIEsuX3N0YXRlID0gdm9pZCAwLCBLLl9yZXN1bHQgPSB2b2lkIDAsIEsuX3N1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oSykge1xuICAgICAgICAgICAgZm9yICh2YXIgYWUgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gRiAmJiBhZSA8IEsubGVuZ3RoOyBhZSsrKVxuICAgICAgICAgICAgICB0aGlzLl9lYWNoRW50cnkoS1thZV0sIGFlKTtcbiAgICAgICAgICB9LCByZS5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKEssIGFlKSB7XG4gICAgICAgICAgICB2YXIgaGUgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yLCBfZSA9IGhlLnJlc29sdmU7XG4gICAgICAgICAgICBpZiAoX2UgPT09IFApIHtcbiAgICAgICAgICAgICAgdmFyIGZlLCBnZSA9IHZvaWQgMCwgeGUgPSB2b2lkIDAsIERlID0gITE7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2UgPSBLLnRoZW47XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKE1lKSB7XG4gICAgICAgICAgICAgICAgRGUgPSAhMCwgeGUgPSBNZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnZSA9PT0geCAmJiBLLl9zdGF0ZSAhPT0gRiA/IHRoaXMuX3NldHRsZWRBdChLLl9zdGF0ZSwgYWUsIEsuX3Jlc3VsdCkgOiB0eXBlb2YgZ2UgIT0gXCJmdW5jdGlvblwiID8gKHRoaXMuX3JlbWFpbmluZy0tLCB0aGlzLl9yZXN1bHRbYWVdID0gSykgOiBoZSA9PT0gdWUgPyAoZmUgPSBuZXcgaGUoTCksIERlID8gTyhmZSwgeGUpIDogVyhmZSwgSywgZ2UpLCB0aGlzLl93aWxsU2V0dGxlQXQoZmUsIGFlKSkgOiB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGhlKGZ1bmN0aW9uKE1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lKEspO1xuICAgICAgICAgICAgICB9KSwgYWUpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChfZShLKSwgYWUpO1xuICAgICAgICAgIH0sIHJlLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oSywgYWUsIGhlKSB7XG4gICAgICAgICAgICB2YXIgX2UgPSB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICBfZS5fc3RhdGUgPT09IEYgJiYgKHRoaXMuX3JlbWFpbmluZy0tLCBLID09PSBHID8gTyhfZSwgaGUpIDogdGhpcy5fcmVzdWx0W2FlXSA9IGhlKSwgdGhpcy5fcmVtYWluaW5nID09PSAwICYmIGIoX2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgfSwgcmUucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihLLCBhZSkge1xuICAgICAgICAgICAgdmFyIGhlID0gdGhpcztcbiAgICAgICAgICAgIEQoSywgdm9pZCAwLCBmdW5jdGlvbihfZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaGUuX3NldHRsZWRBdChWLCBhZSwgX2UpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oX2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlLl9zZXR0bGVkQXQoRywgYWUsIF9lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNlID0gcmU7XG4gICAgICAgICAgZnVuY3Rpb24gcmUoSywgYWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBLLCB0aGlzLnByb21pc2UgPSBuZXcgSyhMKSwgdGhpcy5wcm9taXNlW1JdIHx8IHRlKHRoaXMucHJvbWlzZSksIGYoYWUpID8gKHRoaXMubGVuZ3RoID0gYWUubGVuZ3RoLCB0aGlzLl9yZW1haW5pbmcgPSBhZS5sZW5ndGgsIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCksIHRoaXMubGVuZ3RoICE9PSAwICYmICh0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDAsIHRoaXMuX2VudW1lcmF0ZShhZSksIHRoaXMuX3JlbWFpbmluZyAhPT0gMCkgfHwgYih0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCkpIDogTyh0aGlzLnByb21pc2UsIG5ldyBFcnJvcihcIkFycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgSyk7XG4gICAgICAgICAgfSwgbGUucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihLKSB7XG4gICAgICAgICAgICB2YXIgYWUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIGcoSykgPyB0aGlzLnRoZW4oZnVuY3Rpb24oaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFlLnJlc29sdmUoSygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWUucmVzb2x2ZShLKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgaGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkgOiB0aGlzLnRoZW4oSywgSyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdWUgPSBsZTtcbiAgICAgICAgICBmdW5jdGlvbiBsZShLKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tSXSA9IEorKywgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB2b2lkIDAsIHRoaXMuX3N1YnNjcmliZXJzID0gW10sIEwgIT09IEspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBLICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGxlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICAgICAgICB2YXIgYWUgPSB0aGlzO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEsoZnVuY3Rpb24oaGUpIHtcbiAgICAgICAgICAgICAgICAgIFgoYWUsIGhlKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihoZSkge1xuICAgICAgICAgICAgICAgICAgTyhhZSwgaGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChoZSkge1xuICAgICAgICAgICAgICAgIE8oYWUsIGhlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdWUucHJvdG90eXBlLnRoZW4gPSB4LCB1ZS5hbGwgPSBmdW5jdGlvbihLKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNlKHRoaXMsIEspLnByb21pc2U7XG4gICAgICAgICAgfSwgdWUucmFjZSA9IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICAgIHZhciBhZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZihLKSA/IG5ldyBhZShmdW5jdGlvbihoZSwgX2UpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZmUgPSBLLmxlbmd0aCwgZ2UgPSAwOyBnZSA8IGZlOyBnZSsrKVxuICAgICAgICAgICAgICAgIGFlLnJlc29sdmUoS1tnZV0pLnRoZW4oaGUsIF9lKTtcbiAgICAgICAgICAgIH0pIDogbmV3IGFlKGZ1bmN0aW9uKGhlLCBfZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2UobmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS5cIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgdWUucmVzb2x2ZSA9IFAsIHVlLnJlamVjdCA9IGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICAgIHZhciBhZSA9IG5ldyB0aGlzKEwpO1xuICAgICAgICAgICAgcmV0dXJuIE8oYWUsIEspLCBhZTtcbiAgICAgICAgICB9LCB1ZS5fc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oSykge1xuICAgICAgICAgICAgbyA9IEs7XG4gICAgICAgICAgfSwgdWUuX3NldEFzYXAgPSBmdW5jdGlvbihLKSB7XG4gICAgICAgICAgICBpID0gSztcbiAgICAgICAgICB9LCB1ZS5fYXNhcCA9IGksIHVlLnBvbHlmaWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgSyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgIEsgPSB5O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgPCBcInVcIilcbiAgICAgICAgICAgICAgSyA9IHNlbGY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgSyA9IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWUgPSBLLlByb21pc2U7XG4gICAgICAgICAgICBpZiAoYWUpIHtcbiAgICAgICAgICAgICAgdmFyIGhlID0gbnVsbDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhZS5yZXNvbHZlKCkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGUgPT09IFwiW29iamVjdCBQcm9taXNlXVwiICYmICFhZS5jYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEsuUHJvbWlzZSA9IHVlO1xuICAgICAgICAgIH0sIHVlLlByb21pc2UgPSB1ZTtcbiAgICAgICAgfSwgdHlwZW9mIEMgPT0gXCJvYmplY3RcIiAmJiBIICE9PSB2b2lkIDAgPyBILmV4cG9ydHMgPSBoKCkgOiB1LkVTNlByb21pc2UgPSBoKCk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHQoXCJfcHJvY2Vzc1wiKSwgdHlwZW9mIF9yIDwgXCJ1XCIgPyBfciA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHsgX3Byb2Nlc3M6IDI1NiB9XSwgMjQ4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0sIHk7XG4gICAgICBtID0gdGhpcywgeSA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgICAgdmFyIGcgPSA1ZTMsIGYgPSBcImNhbGxiYWNrXCI7XG4gICAgICAgIGZ1bmN0aW9uIHIobykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93W29dO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgd2luZG93W29dID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzKG8pIHtcbiAgICAgICAgICBvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobyksIG8gJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLnJlbW92ZUNoaWxkKG8pO1xuICAgICAgICB9XG4gICAgICAgIGguZXhwb3J0cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHZvaWQgMCA/IHt9IDogYXJndW1lbnRzWzFdLCBsID0gbywgbiA9IGkudGltZW91dCB8fCBnLCBhID0gaS5qc29ucENhbGxiYWNrIHx8IGYsIGMgPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHAsIGopIHtcbiAgICAgICAgICAgIHZhciBUID0gaS5qc29ucENhbGxiYWNrRnVuY3Rpb24gfHwgXCJqc29ucF9cIiArIERhdGUubm93KCkgKyBcIl9cIiArIE1hdGguY2VpbCgxZTUgKiBNYXRoLnJhbmRvbSgpKSwgXyA9IGEgKyBcIl9cIiArIFQsIFMgPSAod2luZG93W1RdID0gZnVuY3Rpb24oRSkge1xuICAgICAgICAgICAgICBwKHsgb2s6ICEwLCBqc29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEUpO1xuICAgICAgICAgICAgICB9IH0pLCBjICYmIGNsZWFyVGltZW91dChjKSwgcyhfKSwgcihUKTtcbiAgICAgICAgICAgIH0sIGwgKz0gbC5pbmRleE9mKFwiP1wiKSA9PT0gLTEgPyBcIj9cIiA6IFwiJlwiLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKTtcbiAgICAgICAgICAgIFMuc2V0QXR0cmlidXRlKFwic3JjXCIsIFwiXCIgKyBsICsgYSArIFwiPVwiICsgVCksIGkuY2hhcnNldCAmJiBTLnNldEF0dHJpYnV0ZShcImNoYXJzZXRcIiwgaS5jaGFyc2V0KSwgUy5pZCA9IF8sIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChTKSwgYyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGoobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCB0byBcIiArIG8gKyBcIiB0aW1lZCBvdXRcIikpLCByKFQpLCBzKF8pLCB3aW5kb3dbVF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByKFQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgbiksIFMub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBqKG5ldyBFcnJvcihcIkpTT05QIHJlcXVlc3QgdG8gXCIgKyBvICsgXCIgZmFpbGVkXCIpKSwgcihUKSwgcyhfKSwgYyAmJiBjbGVhclRpbWVvdXQoYyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSwgQyAhPT0gdm9pZCAwICYmIEggIT09IHZvaWQgMCA/IHkoMCwgSCkgOiAoeSh5ID0geyBleHBvcnRzOiB7fSB9LCB5KSwgbS5mZXRjaEpzb25wID0geS5leHBvcnRzKTtcbiAgICB9LCB7fV0sIDI0OTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgdSwgaCwgZywgZiwgciwgcywgbywgaSwgbCwgbiwgYTtcbiAgICAgICAgaWYgKCEoeSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkpXG4gICAgICAgICAgcmV0dXJuIGEgPSB5LmRvY3VtZW50LCB1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geS5VUkwgfHwgeS53ZWJraXRVUkwgfHwgeTtcbiAgICAgICAgICB9LCBoID0gYS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIFwiYVwiKSwgZyA9IFwiZG93bmxvYWRcIiBpbiBoLCBmID0gL2NvbnN0cnVjdG9yL2kudGVzdCh5LkhUTUxFbGVtZW50KSB8fCB5LnNhZmFyaSwgciA9IC9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSwgcyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICh5LnNldEltbWVkaWF0ZSB8fCB5LnNldFRpbWVvdXQpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBjO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfSwgbyA9IDRlNCwgaSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHR5cGVvZiBjID09IFwic3RyaW5nXCIgPyB1KCkucmV2b2tlT2JqZWN0VVJMKGMpIDogYy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0sIG8pO1xuICAgICAgICAgIH0sIGwgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYy50eXBlKSA/IG5ldyBCbG9iKFtcIlxcdUZFRkZcIiwgY10sIHsgdHlwZTogYy50eXBlIH0pIDogYztcbiAgICAgICAgICB9LCBhID0gKG4gPSBmdW5jdGlvbihjLCBwLCBFKSB7XG4gICAgICAgICAgICBFIHx8IChjID0gbChjKSk7XG4gICAgICAgICAgICB2YXIgVCwgXywgUyA9IHRoaXMsIEUgPSBjLnR5cGUgPT09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsIEEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IFMsIFAgPSBcIndyaXRlc3RhcnQgcHJvZ3Jlc3Mgd3JpdGUgd3JpdGVlbmRcIi5zcGxpdChcIiBcIiksIE0gPSB2b2lkIDAsIFIgPSAoUCA9IFtdLmNvbmNhdChQKSkubGVuZ3RoOyBSLS07ICkge1xuICAgICAgICAgICAgICAgIHZhciBMID0geFtcIm9uXCIgKyBQW1JdXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEwgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgTC5jYWxsKHgsIE0gfHwgeCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgICAgICAgICAgIHMoRik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTLnJlYWR5U3RhdGUgPSBTLklOSVQsIGcgPyAoVCA9IHUoKS5jcmVhdGVPYmplY3RVUkwoYyksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciB4LCBQO1xuICAgICAgICAgICAgICBoLmhyZWYgPSBULCBoLmRvd25sb2FkID0gcCwgeCA9IGgsIFAgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpLCB4LmRpc3BhdGNoRXZlbnQoUCksIEEoKSwgaShUKSwgUy5yZWFkeVN0YXRlID0gUy5ET05FO1xuICAgICAgICAgICAgfSkpIDogKHIgfHwgRSAmJiBmKSAmJiB5LkZpbGVSZWFkZXIgPyAoKF8gPSBuZXcgRmlsZVJlYWRlcigpKS5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHggPSByID8gXy5yZXN1bHQgOiBfLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCBcImRhdGE6YXR0YWNobWVudC9maWxlO1wiKTtcbiAgICAgICAgICAgICAgeS5vcGVuKHgsIFwiX2JsYW5rXCIpIHx8ICh5LmxvY2F0aW9uLmhyZWYgPSB4KSwgeCA9IHZvaWQgMCwgUy5yZWFkeVN0YXRlID0gUy5ET05FLCBBKCk7XG4gICAgICAgICAgICB9LCBfLnJlYWRBc0RhdGFVUkwoYyksIFMucmVhZHlTdGF0ZSA9IFMuSU5JVCkgOiAoVCA9IFQgfHwgdSgpLmNyZWF0ZU9iamVjdFVSTChjKSwgIUUgJiYgeS5vcGVuKFQsIFwiX2JsYW5rXCIpIHx8ICh5LmxvY2F0aW9uLmhyZWYgPSBUKSwgUy5yZWFkeVN0YXRlID0gUy5ET05FLCBBKCksIGkoVCkpO1xuICAgICAgICAgIH0pLnByb3RvdHlwZSwgdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iID8gZnVuY3Rpb24oYywgcCwgaikge1xuICAgICAgICAgICAgcmV0dXJuIHAgPSBwIHx8IGMubmFtZSB8fCBcImRvd25sb2FkXCIsIGogfHwgKGMgPSBsKGMpKSwgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYywgcCk7XG4gICAgICAgICAgfSA6IChhLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfSwgYS5yZWFkeVN0YXRlID0gYS5JTklUID0gMCwgYS5XUklUSU5HID0gMSwgYS5ET05FID0gMiwgYS5lcnJvciA9IGEub253cml0ZXN0YXJ0ID0gYS5vbnByb2dyZXNzID0gYS5vbndyaXRlID0gYS5vbmFib3J0ID0gYS5vbmVycm9yID0gYS5vbndyaXRlZW5kID0gbnVsbCwgZnVuY3Rpb24oYywgcCwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBuKGMsIHAgfHwgYy5uYW1lIHx8IFwiZG93bmxvYWRcIiwgaik7XG4gICAgICAgICAgfSk7XG4gICAgICB9KHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93IHx8IHRoaXMuY29udGVudCk7XG4gICAgICBIICE9PSB2b2lkIDAgJiYgSC5leHBvcnRzID8gSC5leHBvcnRzLnNhdmVBcyA9IG0gOiBWdCAhPSBudWxsO1xuICAgIH0sIHt9XSwgMjUwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdmFyIG0sIHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHUgPSAoeShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMpLCBoID0geyBHSUZFbmNvZGVyOiAoKSA9PiBBLCBhcHBseVBhbGV0dGU6ICgpID0+IGZ1bmN0aW9uKEYsIFYsIEcgPSBcInJnYjU2NVwiKSB7XG4gICAgICAgIGlmICghRiB8fCAhRi5idWZmZXIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpemUoKSBleHBlY3RlZCBSR0JBIFVpbnQ4QXJyYXkgZGF0YVwiKTtcbiAgICAgICAgaWYgKCEoRiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgRiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJxdWFudGl6ZSgpIGV4cGVjdGVkIFJHQkEgVWludDhBcnJheSBkYXRhXCIpO1xuICAgICAgICBpZiAoMjU2IDwgVi5sZW5ndGgpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHlQYWxldHRlKCkgb25seSB3b3JrcyB3aXRoIDI1NiBjb2xvcnMgb3IgbGVzc1wiKTtcbiAgICAgICAgY29uc3QgVSA9IG5ldyBVaW50MzJBcnJheShGLmJ1ZmZlciksIFcgPSBVLmxlbmd0aCwgWCA9IEcgPT09IFwicmdiNDQ0XCIgPyA0MDk2IDogNjU1MzYsIG5lID0gbmV3IFVpbnQ4QXJyYXkoVyksIGIgPSBuZXcgQXJyYXkoWCk7XG4gICAgICAgIGlmIChHID09PSBcInJnYmE0NDQ0XCIpXG4gICAgICAgICAgZm9yIChsZXQgbGUgPSAwOyBsZSA8IFc7IGxlKyspIHtcbiAgICAgICAgICAgIHZhciBZID0gVVtsZV0sIE8gPSBZID4+IDI0ICYgMjU1LCBEID0gWSA+PiAxNiAmIDI1NSwgQiA9IFkgPj4gOCAmIDI1NSwgWSA9IDI1NSAmIFksIEogPSBpKFksIEIsIEQsIE8pLCBKID0gSiBpbiBiID8gYltKXSA6IGJbSl0gPSBmdW5jdGlvbihLLCBhZSwgaGUsIF9lLCBmZSkge1xuICAgICAgICAgICAgICBsZXQgZ2UgPSAwLCB4ZSA9IDFlMTAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCB6ZSA9IDA7IHplIDwgZmUubGVuZ3RoOyB6ZSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIERlLCBNZSA9IGZlW3plXSwgUWUgPSBfKE1lWzNdIC0gX2UpO1xuICAgICAgICAgICAgICAgIFFlID4geGUgfHwgKERlID0gTWVbMF0sIChRZSArPSBfKERlIC0gSykpID4geGUgfHwgKERlID0gTWVbMV0sIChRZSArPSBfKERlIC0gYWUpKSA+IHhlIHx8IChEZSA9IE1lWzJdLCAoUWUgKz0gXyhEZSAtIGhlKSkgPiB4ZSB8fCAoeGUgPSBRZSwgZ2UgPSB6ZSkpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdlO1xuICAgICAgICAgICAgfShZLCBCLCBELCBPLCBWKTtcbiAgICAgICAgICAgIG5lW2xlXSA9IEo7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsZSA9IEcgPT09IFwicmdiNDQ0XCIgPyBsIDogbztcbiAgICAgICAgICBmb3IgKGxldCBLID0gMDsgSyA8IFc7IEsrKykge1xuICAgICAgICAgICAgdmFyIHJlID0gVVtLXSwgdGUgPSByZSA+PiAxNiAmIDI1NSwgY2UgPSByZSA+PiA4ICYgMjU1LCByZSA9IDI1NSAmIHJlLCB1ZSA9IGxlKHJlLCBjZSwgdGUpLCB1ZSA9IHVlIGluIGIgPyBiW3VlXSA6IGJbdWVdID0gZnVuY3Rpb24oYWUsIGhlLCBfZSwgZmUpIHtcbiAgICAgICAgICAgICAgbGV0IGdlID0gMCwgeGUgPSAxZTEwMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgemUgPSAwOyB6ZSA8IGZlLmxlbmd0aDsgemUrKykge1xuICAgICAgICAgICAgICAgIHZhciBEZSwgTWUgPSBmZVt6ZV0sIFFlID0gXyhNZVswXSAtIGFlKTtcbiAgICAgICAgICAgICAgICBRZSA+IHhlIHx8IChEZSA9IE1lWzFdLCAoUWUgKz0gXyhEZSAtIGhlKSkgPiB4ZSB8fCAoRGUgPSBNZVsyXSwgKFFlICs9IF8oRGUgLSBfZSkpID4geGUgfHwgKHhlID0gUWUsIGdlID0gemUpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdlO1xuICAgICAgICAgICAgfShyZSwgY2UsIHRlLCBWKTtcbiAgICAgICAgICAgIG5lW0tdID0gdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZTtcbiAgICAgIH0sIGRlZmF1bHQ6ICgpID0+IEwsIG5lYXJlc3RDb2xvcjogKCkgPT4gZnVuY3Rpb24oRiwgViwgRyA9IGopIHtcbiAgICAgICAgcmV0dXJuIEZbUyhGLCBWLCBHKV07XG4gICAgICB9LCBuZWFyZXN0Q29sb3JJbmRleDogKCkgPT4gUywgbmVhcmVzdENvbG9ySW5kZXhXaXRoRGlzdGFuY2U6ICgpID0+IEUsIHByZXF1YW50aXplOiAoKSA9PiBmdW5jdGlvbihGLCB7IHJvdW5kUkdCOiBWID0gNSwgcm91bmRBbHBoYTogRyA9IDEwLCBvbmVCaXRBbHBoYTogVSA9IG51bGwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFcgPSBuZXcgVWludDMyQXJyYXkoRi5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBEID0gMDsgRCA8IFcubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgICB2YXIgTyA9IFdbRF07XG4gICAgICAgICAgbGV0IEIgPSBPID4+IDI0ICYgMjU1O1xuICAgICAgICAgIHZhciBYLCBuZSA9IE8gPj4gMTYgJiAyNTUsIGIgPSBPID4+IDggJiAyNTUsIE8gPSAyNTUgJiBPO1xuICAgICAgICAgIEIgPSBUKEIsIEcpLCBVICYmIChYID0gdHlwZW9mIFUgPT0gXCJudW1iZXJcIiA/IFUgOiAxMjcsIEIgPSBCIDw9IFggPyAwIDogMjU1KSwgTyA9IFQoTywgViksIGIgPSBUKGIsIFYpLCBuZSA9IFQobmUsIFYpLCBXW0RdID0gQiA8PCAyNCB8IG5lIDw8IDE2IHwgYiA8PCA4IHwgTyA8PCAwO1xuICAgICAgICB9XG4gICAgICB9LCBxdWFudGl6ZTogKCkgPT4gZnVuY3Rpb24oRiwgViwgRyA9IHt9KSB7XG4gICAgICAgIHZhciB7IGZvcm1hdDogVSA9IFwicmdiNTY1XCIsIGNsZWFyQWxwaGE6IFcgPSAhMCwgY2xlYXJBbHBoYUNvbG9yOiBYID0gMCwgY2xlYXJBbHBoYVRocmVzaG9sZDogbmUgPSAwLCBvbmVCaXRBbHBoYTogYiA9ICExIH0gPSBHO1xuICAgICAgICBpZiAoIUYgfHwgIUYuYnVmZmVyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInF1YW50aXplKCkgZXhwZWN0ZWQgUkdCQSBVaW50OEFycmF5IGRhdGFcIik7XG4gICAgICAgIGlmICghKEYgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEYgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpemUoKSBleHBlY3RlZCBSR0JBIFVpbnQ4QXJyYXkgZGF0YVwiKTtcbiAgICAgICAgRiA9IG5ldyBVaW50MzJBcnJheShGLmJ1ZmZlcik7XG4gICAgICAgIGxldCBPID0gRy51c2VTcXJ0ICE9PSAhMTtcbiAgICAgICAgY29uc3QgRCA9IFUgPT09IFwicmdiYTQ0NDRcIiwgQiA9IGZ1bmN0aW9uKFZlLCBYZSkge1xuICAgICAgICAgIGNvbnN0IEhlID0gWGUgPT09IFwicmdiNDQ0XCIgPyA0MDk2IDogNjU1MzYsIHZlID0gbmV3IEFycmF5KEhlKSwgUmUgPSBWZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKFhlID09PSBcInJnYmE0NDQ0XCIpXG4gICAgICAgICAgICBmb3IgKGxldCBudCA9IDA7IG50IDwgUmU7ICsrbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHEgPSBWZVtudF0sIHdlID0gcSA+PiAyNCAmIDI1NSwgWiA9IHEgPj4gMTYgJiAyNTUsICQgPSBxID4+IDggJiAyNTUsIHEgPSAyNTUgJiBxLCBlZSA9IGkocSwgJCwgWiwgd2UpO1xuICAgICAgICAgICAgICBsZXQgS2UgPSBlZSBpbiB2ZSA/IHZlW2VlXSA6IHZlW2VlXSA9IHAoKTtcbiAgICAgICAgICAgICAgS2UucmMgKz0gcSwgS2UuZ2MgKz0gJCwgS2UuYmMgKz0gWiwgS2UuYWMgKz0gd2UsIEtlLmNudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFhlID09PSBcInJnYjQ0NFwiKVxuICAgICAgICAgICAgZm9yIChsZXQgbnQgPSAwOyBudCA8IFJlOyArK250KSB7XG4gICAgICAgICAgICAgIHZhciBDZSA9IFZlW250XSwgcGUgPSBDZSA+PiAxNiAmIDI1NSwgamUgPSBDZSA+PiA4ICYgMjU1LCBDZSA9IDI1NSAmIENlLCBGZSA9IGwoQ2UsIGplLCBwZSk7XG4gICAgICAgICAgICAgIGxldCBLZSA9IEZlIGluIHZlID8gdmVbRmVdIDogdmVbRmVdID0gcCgpO1xuICAgICAgICAgICAgICBLZS5yYyArPSBDZSwgS2UuZ2MgKz0gamUsIEtlLmJjICs9IHBlLCBLZS5jbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBudCA9IDA7IG50IDwgUmU7ICsrbnQpIHtcbiAgICAgICAgICAgICAgdmFyIFdlID0gVmVbbnRdLCBOZSA9IFdlID4+IDE2ICYgMjU1LCBCZSA9IFdlID4+IDggJiAyNTUsIFdlID0gMjU1ICYgV2UsIHN0ID0gbyhXZSwgQmUsIE5lKTtcbiAgICAgICAgICAgICAgbGV0IEtlID0gc3QgaW4gdmUgPyB2ZVtzdF0gOiB2ZVtzdF0gPSBwKCk7XG4gICAgICAgICAgICAgIEtlLnJjICs9IFdlLCBLZS5nYyArPSBCZSwgS2UuYmMgKz0gTmUsIEtlLmNudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2ZTtcbiAgICAgICAgfShGLCBVKSwgWSA9IEIubGVuZ3RoLCBKID0gWSAtIDEsIHRlID0gbmV3IFVpbnQzMkFycmF5KFkgKyAxKTtcbiAgICAgICAgZm9yICh2YXIgY2UgPSAwLCByZSA9IDA7IHJlIDwgWTsgKytyZSkge1xuICAgICAgICAgIGNvbnN0IFZlID0gQltyZV07XG4gICAgICAgICAgVmUgIT0gbnVsbCAmJiAoTWUgPSAxIC8gVmUuY250LCBEICYmIChWZS5hYyAqPSBNZSksIFZlLnJjICo9IE1lLCBWZS5nYyAqPSBNZSwgVmUuYmMgKj0gTWUsIEJbY2UrK10gPSBWZSk7XG4gICAgICAgIH1cbiAgICAgICAgYShWKSAvIGNlIDwgMC4wMjIgJiYgKE8gPSAhMSk7XG4gICAgICAgIGZvciAodmFyIHVlLCBsZSwgSywgcmUgPSAwOyByZSA8IGNlIC0gMTsgKytyZSlcbiAgICAgICAgICBCW3JlXS5mdyA9IHJlICsgMSwgQltyZSArIDFdLmJrID0gcmUsIE8gJiYgKEJbcmVdLmNudCA9IE1hdGguc3FydChCW3JlXS5jbnQpKTtcbiAgICAgICAgZm9yIChPICYmIChCW3JlXS5jbnQgPSBNYXRoLnNxcnQoQltyZV0uY250KSksIHJlID0gMDsgcmUgPCBjZTsgKytyZSkge1xuICAgICAgICAgIGMoQiwgcmUpO1xuICAgICAgICAgIHZhciBhZSA9IEJbcmVdLmVycjtcbiAgICAgICAgICBmb3IgKGxlID0gKyt0ZVswXTsgMSA8IGxlICYmIChLID0gbGUgPj4gMSwgIShCW3VlID0gdGVbS11dLmVyciA8PSBhZSkpOyBsZSA9IEspXG4gICAgICAgICAgICB0ZVtsZV0gPSB1ZTtcbiAgICAgICAgICB0ZVtsZV0gPSByZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGUsIF9lID0gY2UgLSBWO1xuICAgICAgICBmb3IgKHJlID0gMDsgcmUgPCBfZTsgKSB7XG4gICAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgICB2YXIgZmUgPSB0ZVsxXTtcbiAgICAgICAgICAgIGlmICgoaGUgPSBCW2ZlXSkudG0gPj0gaGUubXRtICYmIEJbaGUubm5dLm10bSA8PSBoZS50bSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBmb3IgKGhlLm10bSA9PSBKID8gZmUgPSB0ZVsxXSA9IHRlW3RlWzBdLS1dIDogKGMoQiwgZmUpLCBoZS50bSA9IHJlKSwgYWUgPSBCW2ZlXS5lcnIsIGxlID0gMTsgKEsgPSBsZSArIGxlKSA8PSB0ZVswXSAmJiAoSyA8IHRlWzBdICYmIEJbdGVbS11dLmVyciA+IEJbdGVbSyArIDFdXS5lcnIgJiYgSysrLCAhKGFlIDw9IEJbdWUgPSB0ZVtLXV0uZXJyKSk7IGxlID0gSylcbiAgICAgICAgICAgICAgdGVbbGVdID0gdWU7XG4gICAgICAgICAgICB0ZVtsZV0gPSBmZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdlID0gQltoZS5ubl0sIHhlID0gaGUuY250LCBEZSA9IGdlLmNudCwgTWUgPSAxIC8gKHhlICsgRGUpO1xuICAgICAgICAgIEQgJiYgKGhlLmFjID0gTWUgKiAoeGUgKiBoZS5hYyArIERlICogZ2UuYWMpKSwgaGUucmMgPSBNZSAqICh4ZSAqIGhlLnJjICsgRGUgKiBnZS5yYyksIGhlLmdjID0gTWUgKiAoeGUgKiBoZS5nYyArIERlICogZ2UuZ2MpLCBoZS5iYyA9IE1lICogKHhlICogaGUuYmMgKyBEZSAqIGdlLmJjKSwgaGUuY250ICs9IGdlLmNudCwgaGUubXRtID0gKytyZSwgQltnZS5ia10uZncgPSBnZS5mdywgQltnZS5md10uYmsgPSBnZS5iaywgZ2UubXRtID0gSjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUWUgPSBbXTtcbiAgICAgICAgZm9yIChyZSA9IDA7IDsgMCkge1xuICAgICAgICAgIGxldCBWZSA9IG4oTWF0aC5yb3VuZChCW3JlXS5yYyksIDAsIDI1NSksIFhlID0gbihNYXRoLnJvdW5kKEJbcmVdLmdjKSwgMCwgMjU1KSwgSGUgPSBuKE1hdGgucm91bmQoQltyZV0uYmMpLCAwLCAyNTUpLCB2ZSA9IDI1NTtcbiAgICAgICAgICBEICYmICh2ZSA9IG4oTWF0aC5yb3VuZChCW3JlXS5hYyksIDAsIDI1NSksIGIgJiYgKHplID0gdHlwZW9mIGIgPT0gXCJudW1iZXJcIiA/IGIgOiAxMjcsIHZlID0gdmUgPD0gemUgPyAwIDogMjU1KSwgVyAmJiB2ZSA8PSBuZSAmJiAoVmUgPSBYZSA9IEhlID0gWCwgdmUgPSAwKSk7XG4gICAgICAgICAgdmFyIHplID0gRCA/IFtWZSwgWGUsIEhlLCB2ZV0gOiBbVmUsIFhlLCBIZV07XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uKFJlLCB3ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcSA9IDA7IHEgPCBSZS5sZW5ndGg7IHErKykge1xuICAgICAgICAgICAgICB2YXIgJCA9IFJlW3FdLCBaID0gJFswXSA9PT0gd2VbMF0gJiYgJFsxXSA9PT0gd2VbMV0gJiYgJFsyXSA9PT0gd2VbMl0sICQgPSAhKDQgPD0gJC5sZW5ndGggJiYgNCA8PSB3ZS5sZW5ndGgpIHx8ICRbM10gPT09IHdlWzNdO1xuICAgICAgICAgICAgICBpZiAoWiAmJiAkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9KFFlLCB6ZSkgfHwgUWUucHVzaCh6ZSksIChyZSA9IEJbcmVdLmZ3KSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFlO1xuICAgICAgfSwgc25hcENvbG9yc1RvUGFsZXR0ZTogKCkgPT4gZnVuY3Rpb24oRiwgViwgRyA9IDUpIHtcbiAgICAgICAgaWYgKEYubGVuZ3RoICYmIFYubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIFUgPSBGLm1hcCgoTykgPT4gTy5zbGljZSgwLCAzKSksIFcgPSBHICogRywgWCA9IEZbMF0ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgVi5sZW5ndGg7IE8rKykge1xuICAgICAgICAgICAgbGV0IEQgPSBWW09dO1xuICAgICAgICAgICAgRCA9IEQubGVuZ3RoIDwgWCA/IFtEWzBdLCBEWzFdLCBEWzJdLCAyNTVdIDogRC5sZW5ndGggPiBYID8gRC5zbGljZSgwLCAzKSA6IEQuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBiID0gRShVLCBELnNsaWNlKDAsIDMpLCBqKSwgbmUgPSBiWzBdLCBiID0gYlsxXTtcbiAgICAgICAgICAgIDAgPCBiICYmIGIgPD0gVyAmJiAoRltuZV0gPSBEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gfTtcbiAgICAgIGZvciAobSBpbiBoKVxuICAgICAgICB5KHUsIG0sIHsgZ2V0OiBoW21dLCBlbnVtZXJhYmxlOiAhMCB9KTtcbiAgICAgIHZhciBnID0geyBzaWduYXR1cmU6IFwiR0lGXCIsIHZlcnNpb246IFwiODlhXCIsIHRyYWlsZXI6IDU5LCBleHRlbnNpb25JbnRyb2R1Y2VyOiAzMywgYXBwbGljYXRpb25FeHRlbnNpb25MYWJlbDogMjU1LCBncmFwaGljQ29udHJvbEV4dGVuc2lvbkxhYmVsOiAyNDksIGltYWdlU2VwYXJhdG9yOiA0NCwgc2lnbmF0dXJlU2l6ZTogMywgdmVyc2lvblNpemU6IDMsIGdsb2JhbENvbG9yVGFibGVGbGFnTWFzazogMTI4LCBjb2xvclJlc29sdXRpb25NYXNrOiAxMTIsIHNvcnRGbGFnTWFzazogOCwgZ2xvYmFsQ29sb3JUYWJsZVNpemVNYXNrOiA3LCBhcHBsaWNhdGlvbklkZW50aWZpZXJTaXplOiA4LCBhcHBsaWNhdGlvbkF1dGhDb2RlU2l6ZTogMywgZGlzcG9zYWxNZXRob2RNYXNrOiAyOCwgdXNlcklucHV0RmxhZ01hc2s6IDIsIHRyYW5zcGFyZW50Q29sb3JGbGFnTWFzazogMSwgbG9jYWxDb2xvclRhYmxlRmxhZ01hc2s6IDEyOCwgaW50ZXJsYWNlRmxhZ01hc2s6IDY0LCBpZFNvcnRGbGFnTWFzazogMzIsIGxvY2FsQ29sb3JUYWJsZVNpemVNYXNrOiA3IH07XG4gICAgICBmdW5jdGlvbiBmKEYgPSAyNTYpIHtcbiAgICAgICAgbGV0IFYgPSAwLCBHID0gbmV3IFVpbnQ4QXJyYXkoRik7XG4gICAgICAgIHJldHVybiB7IGdldCBidWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIEcuYnVmZmVyO1xuICAgICAgICB9LCByZXNldCgpIHtcbiAgICAgICAgICBWID0gMDtcbiAgICAgICAgfSwgYnl0ZXNWaWV3KCkge1xuICAgICAgICAgIHJldHVybiBHLnN1YmFycmF5KDAsIFYpO1xuICAgICAgICB9LCBieXRlcygpIHtcbiAgICAgICAgICByZXR1cm4gRy5zbGljZSgwLCBWKTtcbiAgICAgICAgfSwgd3JpdGVCeXRlKFcpIHtcbiAgICAgICAgICBVKFYgKyAxKSwgR1tWXSA9IFcsIFYrKztcbiAgICAgICAgfSwgd3JpdGVCeXRlcyhXLCBYID0gMCwgbmUgPSBXLmxlbmd0aCkge1xuICAgICAgICAgIFUoViArIG5lKTtcbiAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IG5lOyBiKyspXG4gICAgICAgICAgICBHW1YrK10gPSBXW2IgKyBYXTtcbiAgICAgICAgfSwgd3JpdGVCeXRlc1ZpZXcoVywgWCA9IDAsIG5lID0gVy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgVShWICsgbmUpLCBHLnNldChXLnN1YmFycmF5KFgsIFggKyBuZSksIFYpLCBWICs9IG5lO1xuICAgICAgICB9IH07XG4gICAgICAgIGZ1bmN0aW9uIFUoVykge1xuICAgICAgICAgIHZhciBYID0gRy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCEoVyA8PSBYKSkge1xuICAgICAgICAgICAgVyA9IE1hdGgubWF4KFcsIFggKiAoWCA8IDEwNDg1NzYgPyAyIDogMS4xMjUpID4+PiAwKSwgWCAhPSAwICYmIChXID0gTWF0aC5tYXgoVywgMjU2KSk7XG4gICAgICAgICAgICBjb25zdCBuZSA9IEc7XG4gICAgICAgICAgICBHID0gbmV3IFVpbnQ4QXJyYXkoVyksIDAgPCBWICYmIEcuc2V0KG5lLnN1YmFycmF5KDAsIFYpLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByID0gWzAsIDEsIDMsIDcsIDE1LCAzMSwgNjMsIDEyNywgMjU1LCA1MTEsIDEwMjMsIDIwNDcsIDQwOTUsIDgxOTEsIDE2MzgzLCAzMjc2NywgNjU1MzVdLCBzID0gZnVuY3Rpb24oRiwgViwgRywgRCwgVyA9IGYoNTEyKSwgWCA9IG5ldyBVaW50OEFycmF5KDI1NiksIG5lID0gbmV3IEludDMyQXJyYXkoNTAwMyksIGIgPSBuZXcgSW50MzJBcnJheSg1MDAzKSkge1xuICAgICAgICB2YXIgTyA9IG5lLmxlbmd0aCwgRCA9IE1hdGgubWF4KDIsIEQpO1xuICAgICAgICBYLmZpbGwoMCksIGIuZmlsbCgwKSwgbmUuZmlsbCgtMSk7XG4gICAgICAgIGxldCBCID0gMCwgWSA9IDA7XG4gICAgICAgIHZhciBKID0gRCArIDE7XG4gICAgICAgIGNvbnN0IHRlID0gSjtcbiAgICAgICAgbGV0IGNlID0gITEsIHJlID0gdGUsIHVlID0gKDEgPDwgcmUpIC0gMTtcbiAgICAgICAgdmFyIGxlID0gMSA8PCBKIC0gMTtcbiAgICAgICAgY29uc3QgSyA9IDEgKyBsZTtcbiAgICAgICAgbGV0IGFlID0gMiArIGxlLCBoZSA9IDAsIF9lID0gR1swXSwgZmUgPSAwO1xuICAgICAgICBmb3IgKGxldCB6ZSA9IE87IHplIDwgNjU1MzY7IHplICo9IDIpXG4gICAgICAgICAgKytmZTtcbiAgICAgICAgZmUgPSA4IC0gZmUsIFcud3JpdGVCeXRlKEQpLCBRZShsZSk7XG4gICAgICAgIHZhciBnZSA9IEcubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCB6ZSA9IDE7IHplIDwgZ2U7IHplKyspXG4gICAgICAgICAgZToge1xuICAgICAgICAgICAgdmFyIHhlID0gR1t6ZV0sIERlID0gKHhlIDw8IDEyKSArIF9lO1xuICAgICAgICAgICAgbGV0IFZlID0geGUgPDwgZmUgXiBfZTtcbiAgICAgICAgICAgIGlmIChuZVtWZV0gPT09IERlKVxuICAgICAgICAgICAgICBfZSA9IGJbVmVdO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIE1lID0gVmUgPT09IDAgPyAxIDogTyAtIFZlOyAwIDw9IG5lW1ZlXTsgKVxuICAgICAgICAgICAgICAgIGlmICgoVmUgLT0gTWUpIDwgMCAmJiAoVmUgKz0gTyksIG5lW1ZlXSA9PT0gRGUpIHtcbiAgICAgICAgICAgICAgICAgIF9lID0gYltWZV07XG4gICAgICAgICAgICAgICAgICBicmVhayBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUWUoX2UpLCBfZSA9IHhlLCBhZSA8IDQwOTYgPyAoYltWZV0gPSBhZSsrLCBuZVtWZV0gPSBEZSkgOiAobmUuZmlsbCgtMSksIGFlID0gMiArIGxlLCBjZSA9ICEwLCBRZShsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFlKF9lKSwgUWUoSyksIFcud3JpdGVCeXRlKDApLCBXLmJ5dGVzVmlldygpO1xuICAgICAgICBmdW5jdGlvbiBRZSh6ZSkge1xuICAgICAgICAgIGZvciAoQiAmPSByW1ldLCAwIDwgWSA/IEIgfD0gemUgPDwgWSA6IEIgPSB6ZSwgWSArPSByZTsgOCA8PSBZOyApXG4gICAgICAgICAgICBYW2hlKytdID0gMjU1ICYgQiwgMjU0IDw9IGhlICYmIChXLndyaXRlQnl0ZShoZSksIFcud3JpdGVCeXRlc1ZpZXcoWCwgMCwgaGUpLCBoZSA9IDApLCBCID4+PSA4LCBZIC09IDg7XG4gICAgICAgICAgaWYgKChhZSA+IHVlIHx8IGNlKSAmJiAoY2UgPyAocmUgPSB0ZSwgdWUgPSAoMSA8PCByZSkgLSAxLCBjZSA9ICExKSA6ICgrK3JlLCB1ZSA9IHJlID09PSAxMiA/IDEgPDwgcmUgOiAoMSA8PCByZSkgLSAxKSksIHplID09IEspIHtcbiAgICAgICAgICAgIGZvciAoOyAwIDwgWTsgKVxuICAgICAgICAgICAgICBYW2hlKytdID0gMjU1ICYgQiwgMjU0IDw9IGhlICYmIChXLndyaXRlQnl0ZShoZSksIFcud3JpdGVCeXRlc1ZpZXcoWCwgMCwgaGUpLCBoZSA9IDApLCBCID4+PSA4LCBZIC09IDg7XG4gICAgICAgICAgICAwIDwgaGUgJiYgKFcud3JpdGVCeXRlKGhlKSwgVy53cml0ZUJ5dGVzVmlldyhYLCAwLCBoZSksIGhlID0gMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gbyhGLCBWLCBHKSB7XG4gICAgICAgIHJldHVybiBGIDw8IDggJiA2MzQ4OCB8IFYgPDwgMiAmIDk5MiB8IEcgPj4gMztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoRiwgViwgRywgVSkge1xuICAgICAgICByZXR1cm4gRiA+PiA0IHwgMjQwICYgViB8ICgyNDAgJiBHKSA8PCA0IHwgKDI0MCAmIFUpIDw8IDg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKEYsIFYsIEcpIHtcbiAgICAgICAgcmV0dXJuIEYgPj4gNCA8PCA4IHwgMjQwICYgViB8IEcgPj4gNDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG4oRiwgViwgRykge1xuICAgICAgICByZXR1cm4gRiA8IFYgPyBWIDogRyA8IEYgPyBHIDogRjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGEoRikge1xuICAgICAgICByZXR1cm4gRiAqIEY7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKEYsIFYsIEcpIHtcbiAgICAgICAgdmFyIFUgPSAwLCBXID0gMWUxMDA7XG4gICAgICAgIGNvbnN0IFggPSBGW1ZdO1xuICAgICAgICBmb3IgKHZhciBuZSA9IFguY250LCBiID0gWC5hYywgTyA9IFgucmMsIEQgPSBYLmdjLCBCID0gWC5iYywgWSA9IFguZnc7IFkgIT0gMDsgWSA9IEZbWV0uZncpIHtcbiAgICAgICAgICB2YXIgSiwgdGUgPSBGW1ldLCBjZSA9IHRlLmNudCwgY2UgPSBuZSAqIGNlIC8gKG5lICsgY2UpO1xuICAgICAgICAgIFcgPD0gY2UgfHwgKEogPSAwLCBXIDw9IChKICs9IGNlICogYSh0ZS5yYyAtIE8pKSB8fCBXIDw9IChKICs9IGNlICogYSh0ZS5nYyAtIEQpKSB8fCBXIDw9IChKICs9IGNlICogYSh0ZS5iYyAtIEIpKSB8fCAoVyA9IEosIFUgPSBZKSk7XG4gICAgICAgIH1cbiAgICAgICAgWC5lcnIgPSBXLCBYLm5uID0gVTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgIHJldHVybiB7IGFjOiAwLCByYzogMCwgZ2M6IDAsIGJjOiAwLCBjbnQ6IDAsIG5uOiAwLCBmdzogMCwgYms6IDAsIHRtOiAwLCBtdG06IDAsIGVycjogMCB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaihGLCBWKSB7XG4gICAgICAgIGZvciAodmFyIEcgPSAwLCBVID0gMDsgVSA8IEYubGVuZ3RoOyBVKyspIHtcbiAgICAgICAgICB2YXIgVyA9IEZbVV0gLSBWW1VdO1xuICAgICAgICAgIEcgKz0gVyAqIFc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUKEYsIFYpIHtcbiAgICAgICAgcmV0dXJuIDEgPCBWID8gTWF0aC5yb3VuZChGIC8gVikgKiBWIDogRjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF8oRikge1xuICAgICAgICByZXR1cm4gRiAqIEY7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBTKEYsIFYsIEcgPSBqKSB7XG4gICAgICAgIGxldCBVID0gMSAvIDAsIFcgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbmUgPSAwOyBuZSA8IEYubGVuZ3RoOyBuZSsrKSB7XG4gICAgICAgICAgdmFyIFggPSBHKFYsIEZbbmVdKTtcbiAgICAgICAgICBYIDwgVSAmJiAoVSA9IFgsIFcgPSBuZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBFKEYsIFYsIEcgPSBqKSB7XG4gICAgICAgIGxldCBVID0gMSAvIDAsIFcgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbmUgPSAwOyBuZSA8IEYubGVuZ3RoOyBuZSsrKSB7XG4gICAgICAgICAgdmFyIFggPSBHKFYsIEZbbmVdKTtcbiAgICAgICAgICBYIDwgVSAmJiAoVSA9IFgsIFcgPSBuZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtXLCBVXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEEoRiA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbENhcGFjaXR5OiBWID0gNDA5NiwgYXV0bzogRyA9ICEwIH0gPSBGLCBVID0gZihWKSwgVyA9IG5ldyBVaW50OEFycmF5KDI1NiksIFggPSBuZXcgSW50MzJBcnJheSg1MDAzKSwgbmUgPSBuZXcgSW50MzJBcnJheSg1MDAzKTtcbiAgICAgICAgbGV0IGIgPSAhMTtcbiAgICAgICAgcmV0dXJuIHsgcmVzZXQoKSB7XG4gICAgICAgICAgVS5yZXNldCgpLCBiID0gITE7XG4gICAgICAgIH0sIGZpbmlzaCgpIHtcbiAgICAgICAgICBVLndyaXRlQnl0ZShnLnRyYWlsZXIpO1xuICAgICAgICB9LCBieXRlcygpIHtcbiAgICAgICAgICByZXR1cm4gVS5ieXRlcygpO1xuICAgICAgICB9LCBieXRlc1ZpZXcoKSB7XG4gICAgICAgICAgcmV0dXJuIFUuYnl0ZXNWaWV3KCk7XG4gICAgICAgIH0sIGdldCBidWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIFUuYnVmZmVyO1xuICAgICAgICB9LCBnZXQgc3RyZWFtKCkge1xuICAgICAgICAgIHJldHVybiBVO1xuICAgICAgICB9LCB3cml0ZUhlYWRlcjogTywgd3JpdGVGcmFtZShELCBCLCBZLCBfZSA9IHt9KSB7XG4gICAgICAgICAgdmFyIHsgdHJhbnNwYXJlbnQ6IHRlID0gITEsIHRyYW5zcGFyZW50SW5kZXg6IGNlID0gMCwgZGVsYXk6IE1lID0gMCwgcGFsZXR0ZTogcmUgPSBudWxsLCByZXBlYXQ6IGdlID0gMCwgY29sb3JEZXB0aDogdWUgPSA4LCBkaXNwb3NlOiBsZSA9IC0xIH0gPSBfZTtcbiAgICAgICAgICBsZXQgSyA9ICExO1xuICAgICAgICAgIGlmIChHID8gYiB8fCAoSyA9ICEwLCBPKCksIGIgPSAhMCkgOiBLID0gISFfZS5maXJzdCwgQiA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoQikpLCBZID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihZKSksIEspIHtcbiAgICAgICAgICAgIGlmICghcmUpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGZyYW1lIG11c3QgaW5jbHVkZSBhIHsgcGFsZXR0ZSB9IG9wdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBbX2UsIHhlLCBoZSwgRGUsIGZlID0gOF0gPSBbVSwgQiwgWSwgcmUsIHVlXTtcbiAgICAgICAgICAgIERlID0gUihEZS5sZW5ndGgpIC0gMSwgZmUgPSAxMjggfCBmZSAtIDEgPDwgNCB8IERlLCBQKF9lLCB4ZSksIFAoX2UsIGhlKSwgX2Uud3JpdGVCeXRlcyhbZmUsIDAsIDBdKSwgeChVLCByZSksIDAgPD0gZ2UgJiYgKERlID0gVSwgeGUgPSBnZSwgRGUud3JpdGVCeXRlKDMzKSwgRGUud3JpdGVCeXRlKDI1NSksIERlLndyaXRlQnl0ZSgxMSksIE0oRGUsIFwiTkVUU0NBUEUyLjBcIiksIERlLndyaXRlQnl0ZSgzKSwgRGUud3JpdGVCeXRlKDEpLCBQKERlLCB4ZSksIERlLndyaXRlQnl0ZSgwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZSwgaGUgPSBNYXRoLnJvdW5kKE1lIC8gMTApLCBfZSA9IFUsIGZlID0gbGUsIGdlID0gaGUsIHhlID0gdGUsIERlID0gY2UsIE1lID0gKF9lLndyaXRlQnl0ZSgzMyksIF9lLndyaXRlQnl0ZSgyNDkpLCBfZS53cml0ZUJ5dGUoNCksIERlIDwgMCAmJiAoRGUgPSAwLCB4ZSA9ICExKSwgeGUgPSB4ZSA/IChhZSA9IDEsIDIpIDogYWUgPSAwLCAwIDw9IGZlICYmICh4ZSA9IDcgJiBmZSksIHhlIDw8PSAyLCBfZS53cml0ZUJ5dGUoMCB8IHhlIHwgYWUpLCBQKF9lLCBnZSksIF9lLndyaXRlQnl0ZShEZSB8fCAwKSwgX2Uud3JpdGVCeXRlKDApLCAhIXJlICYmICFLKTtcbiAgICAgICAgICBsZSA9IFUsIHRlID0gQiwgY2UgPSBZLCBhZSA9IE1lID8gcmUgOiBudWxsLCBsZS53cml0ZUJ5dGUoNDQpLCBQKGxlLCAwKSwgUChsZSwgMCksIFAobGUsIHRlKSwgUChsZSwgY2UpLCBhZSA/ICh0ZSA9IFIoYWUubGVuZ3RoKSAtIDEsIGxlLndyaXRlQnl0ZSgxMjggfCB0ZSkpIDogbGUud3JpdGVCeXRlKDApLCBNZSAmJiB4KFUsIHJlKSwgW2dlLCBfZSwgY2UsIHRlLCBsZSA9IDgsIE1lLCByZSwgRF0gPSBbVSwgRCwgQiwgWSwgdWUsIFcsIFgsIG5lXSwgcyhjZSwgdGUsIF9lLCBsZSwgZ2UsIE1lLCByZSwgRCk7XG4gICAgICAgIH0gfTtcbiAgICAgICAgZnVuY3Rpb24gTygpIHtcbiAgICAgICAgICBNKFUsIFwiR0lGODlhXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB4KEYsIFYpIHtcbiAgICAgICAgdmFyIEcgPSAxIDw8IFIoVi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBVID0gMDsgVSA8IEc7IFUrKykge1xuICAgICAgICAgIGxldCBXID0gWzAsIDAsIDBdO1xuICAgICAgICAgIFUgPCBWLmxlbmd0aCAmJiAoVyA9IFZbVV0pLCBGLndyaXRlQnl0ZShXWzBdKSwgRi53cml0ZUJ5dGUoV1sxXSksIEYud3JpdGVCeXRlKFdbMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBQKEYsIFYpIHtcbiAgICAgICAgRi53cml0ZUJ5dGUoMjU1ICYgViksIEYud3JpdGVCeXRlKFYgPj4gOCAmIDI1NSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBNKEYsIFYpIHtcbiAgICAgICAgZm9yICh2YXIgRyA9IDA7IEcgPCBWLmxlbmd0aDsgRysrKVxuICAgICAgICAgIEYud3JpdGVCeXRlKFYuY2hhckNvZGVBdChHKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBSKEYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguY2VpbChNYXRoLmxvZzIoRikpLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBMID0gQTtcbiAgICB9LCB7fV0sIDI1MTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIEMucmVhZCA9IGZ1bmN0aW9uKG0sIHksIHUsIGgsIGMpIHtcbiAgICAgICAgdmFyIGYsIHIsIHMgPSA4ICogYyAtIGggLSAxLCBvID0gKDEgPDwgcykgLSAxLCBpID0gbyA+PiAxLCBsID0gLTcsIG4gPSB1ID8gYyAtIDEgOiAwLCBhID0gdSA/IC0xIDogMSwgYyA9IG1beSArIG5dO1xuICAgICAgICBmb3IgKG4gKz0gYSwgZiA9IGMgJiAoMSA8PCAtbCkgLSAxLCBjID4+PSAtbCwgbCArPSBzOyAwIDwgbDsgZiA9IDI1NiAqIGYgKyBtW3kgKyBuXSwgbiArPSBhLCBsIC09IDgpXG4gICAgICAgICAgO1xuICAgICAgICBmb3IgKHIgPSBmICYgKDEgPDwgLWwpIC0gMSwgZiA+Pj0gLWwsIGwgKz0gaDsgMCA8IGw7IHIgPSAyNTYgKiByICsgbVt5ICsgbl0sIG4gKz0gYSwgbCAtPSA4KVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKGYgPT09IDApXG4gICAgICAgICAgZiA9IDEgLSBpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoZiA9PT0gbylcbiAgICAgICAgICAgIHJldHVybiByID8gTmFOIDogMSAvIDAgKiAoYyA/IC0xIDogMSk7XG4gICAgICAgICAgciArPSBNYXRoLnBvdygyLCBoKSwgZiAtPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYyA/IC0xIDogMSkgKiByICogTWF0aC5wb3coMiwgZiAtIGgpO1xuICAgICAgfSwgQy53cml0ZSA9IGZ1bmN0aW9uKG0sIHksIHUsIGgsIGcsIHApIHtcbiAgICAgICAgdmFyIHIsIHMsIG8gPSA4ICogcCAtIGcgLSAxLCBpID0gKDEgPDwgbykgLSAxLCBsID0gaSA+PiAxLCBuID0gZyA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDAsIGEgPSBoID8gMCA6IHAgLSAxLCBjID0gaCA/IDEgOiAtMSwgcCA9IHkgPCAwIHx8IHkgPT09IDAgJiYgMSAvIHkgPCAwID8gMSA6IDA7XG4gICAgICAgIGZvciAoeSA9IE1hdGguYWJzKHkpLCBpc05hTih5KSB8fCB5ID09PSAxIC8gMCA/IChzID0gaXNOYU4oeSkgPyAxIDogMCwgciA9IGkpIDogKHIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHkpIC8gTWF0aC5MTjIpLCB5ICogKGggPSBNYXRoLnBvdygyLCAtcikpIDwgMSAmJiAoci0tLCBoICo9IDIpLCAyIDw9ICh5ICs9IDEgPD0gciArIGwgPyBuIC8gaCA6IG4gKiBNYXRoLnBvdygyLCAxIC0gbCkpICogaCAmJiAocisrLCBoIC89IDIpLCBpIDw9IHIgKyBsID8gKHMgPSAwLCByID0gaSkgOiAxIDw9IHIgKyBsID8gKHMgPSAoeSAqIGggLSAxKSAqIE1hdGgucG93KDIsIGcpLCByICs9IGwpIDogKHMgPSB5ICogTWF0aC5wb3coMiwgbCAtIDEpICogTWF0aC5wb3coMiwgZyksIHIgPSAwKSk7IDggPD0gZzsgbVt1ICsgYV0gPSAyNTUgJiBzLCBhICs9IGMsIHMgLz0gMjU2LCBnIC09IDgpXG4gICAgICAgICAgO1xuICAgICAgICBmb3IgKHIgPSByIDw8IGcgfCBzLCBvICs9IGc7IDAgPCBvOyBtW3UgKyBhXSA9IDI1NSAmIHIsIGEgKz0gYywgciAvPSAyNTYsIG8gLT0gOClcbiAgICAgICAgICA7XG4gICAgICAgIG1bdSArIGEgLSBjXSB8PSAxMjggKiBwO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDI1MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHZhciBtO1xuICAgICAgZnVuY3Rpb24geShaLCAkKSB7XG4gICAgICAgIHJldHVybiBaLmIgPT09ICQuYiAmJiBaLmEgPT09ICQuYTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHUoWiwgJCkge1xuICAgICAgICByZXR1cm4gWi5iIDwgJC5iIHx8IFouYiA9PT0gJC5iICYmIFouYSA8PSAkLmE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoKFosICQsIHEpIHtcbiAgICAgICAgdmFyIGVlID0gJC5iIC0gWi5iLCBwZSA9IHEuYiAtICQuYjtcbiAgICAgICAgcmV0dXJuIDAgPCBlZSArIHBlID8gZWUgPCBwZSA/ICQuYSAtIFouYSArIGVlIC8gKGVlICsgcGUpICogKFouYSAtIHEuYSkgOiAkLmEgLSBxLmEgKyBwZSAvIChlZSArIHBlKSAqIChxLmEgLSBaLmEpIDogMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGcoWiwgJCwgcSkge1xuICAgICAgICB2YXIgZWUgPSAkLmIgLSBaLmIsIHBlID0gcS5iIC0gJC5iO1xuICAgICAgICByZXR1cm4gMCA8IGVlICsgcGUgPyAoJC5hIC0gcS5hKSAqIGVlICsgKCQuYSAtIFouYSkgKiBwZSA6IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKFosICQpIHtcbiAgICAgICAgcmV0dXJuIFouYSA8ICQuYSB8fCBaLmEgPT09ICQuYSAmJiBaLmIgPD0gJC5iO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihaLCAkLCBxKSB7XG4gICAgICAgIHZhciBlZSA9ICQuYSAtIFouYSwgcGUgPSBxLmEgLSAkLmE7XG4gICAgICAgIHJldHVybiAwIDwgZWUgKyBwZSA/IGVlIDwgcGUgPyAkLmIgLSBaLmIgKyBlZSAvIChlZSArIHBlKSAqIChaLmIgLSBxLmIpIDogJC5iIC0gcS5iICsgcGUgLyAoZWUgKyBwZSkgKiAocS5iIC0gWi5iKSA6IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKFosICQsIHEpIHtcbiAgICAgICAgdmFyIGVlID0gJC5hIC0gWi5hLCBwZSA9IHEuYSAtICQuYTtcbiAgICAgICAgcmV0dXJuIDAgPCBlZSArIHBlID8gKCQuYiAtIHEuYikgKiBlZSArICgkLmIgLSBaLmIpICogcGUgOiAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbyhaLCAkLCBxLCBlZSkge1xuICAgICAgICByZXR1cm4gKFogPSBaIDwgMCA/IDAgOiBaKSA8PSAocSA9IHEgPCAwID8gMCA6IHEpID8gcSA9PT0gMCA/ICgkICsgZWUpIC8gMiA6ICQgKyBaIC8gKFogKyBxKSAqIChlZSAtICQpIDogZWUgKyBxIC8gKFogKyBxKSAqICgkIC0gZWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShaKSB7XG4gICAgICAgIHZhciAkID0gcChaLmIpO1xuICAgICAgICByZXR1cm4gVCgkLCBaLmMpLCBUKCQuYiwgWi5jKSwgXygkLCBaLmEpLCAkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbChaLCAkKSB7XG4gICAgICAgIHZhciBxID0gITEsIGVlID0gITE7XG4gICAgICAgIFogIT09ICQgJiYgKCQuYSAhPT0gWi5hICYmIChlZSA9ICEwLCBFKCQuYSwgWi5hKSksICQuZCAhPT0gWi5kICYmIChxID0gITAsIEEoJC5kLCBaLmQpKSwgaigkLCBaKSwgZWUgfHwgKFQoJCwgWi5hKSwgWi5hLmMgPSBaKSwgcSB8fCAoXygkLCBaLmQpLCBaLmQuYSA9IFopKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG4oWikge1xuICAgICAgICB2YXIgJCA9IFouYiwgcSA9ICExO1xuICAgICAgICBaLmQgIT09IFouYi5kICYmIChxID0gITAsIEEoWi5kLCBaLmIuZCkpLCBaLmMgPT09IFogPyBFKFouYSwgbnVsbCkgOiAoWi5iLmQuYSA9IFouYi5lLCBaLmEuYyA9IFouYywgaihaLCBaLmIuZSksIHEgfHwgXyhaLCBaLmQpKSwgJC5jID09PSAkID8gKEUoJC5hLCBudWxsKSwgQSgkLmQsIG51bGwpKSA6IChaLmQuYSA9ICQuYi5lLCAkLmEuYyA9ICQuYywgaigkLCAkLmIuZSkpLCBTKFopO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYShaKSB7XG4gICAgICAgIHZhciAkID0gcChaKSwgcSA9ICQuYjtcbiAgICAgICAgcmV0dXJuIGooJCwgWi5lKSwgJC5hID0gWi5iLmEsIFQocSwgJC5hKSwgJC5kID0gcS5kID0gWi5kLCAkID0gJC5iLCBqKFouYiwgWi5iLmIuZSksIGooWi5iLCAkKSwgWi5iLmEgPSAkLmEsICQuYi5hLmMgPSAkLmIsICQuYi5kID0gWi5iLmQsICQuZiA9IFouZiwgJC5iLmYgPSBaLmIuZiwgJDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGMoWiwgJCkge1xuICAgICAgICB2YXIgcSA9ICExLCBlZSA9IHAoWiksIHBlID0gZWUuYjtcbiAgICAgICAgcmV0dXJuICQuZCAhPT0gWi5kICYmIChxID0gITAsIEEoJC5kLCBaLmQpKSwgaihlZSwgWi5lKSwgaihwZSwgJCksIGVlLmEgPSBaLmIuYSwgcGUuYSA9ICQuYSwgZWUuZCA9IHBlLmQgPSBaLmQsIFouZC5hID0gcGUsIHEgfHwgXyhlZSwgWi5kKSwgZWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwKFopIHtcbiAgICAgICAgdmFyICQgPSBuZXcgaGUoKSwgcSA9IG5ldyBoZSgpLCBlZSA9IFouYi5oO1xuICAgICAgICByZXR1cm4gKCgocS5oID0gZWUpLmIuaCA9ICQpLmggPSBaKS5iLmggPSBxLCAkLmIgPSBxLCAoKCQuYyA9ICQpLmUgPSBxKS5iID0gJCwgKHEuYyA9IHEpLmUgPSAkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaihaLCAkKSB7XG4gICAgICAgIHZhciBxID0gWi5jLCBlZSA9ICQuYztcbiAgICAgICAgcS5iLmUgPSAkLCAoZWUuYi5lID0gWikuYyA9IGVlLCAkLmMgPSBxO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVChaLCAkKSB7XG4gICAgICAgIHZhciBxID0gJC5mLCBlZSA9IG5ldyBmZSgkLCBxKTtcbiAgICAgICAgZm9yIChxLmUgPSBlZSwgcSA9ICgkLmYgPSBlZSkuYyA9IFo7IHEuYSA9IGVlLCAocSA9IHEuYykgIT09IFo7IClcbiAgICAgICAgICA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfKFosICQpIHtcbiAgICAgICAgdmFyIHEgPSAkLmQsIGVlID0gbmV3IGFlKCQsIHEpO1xuICAgICAgICBmb3IgKHEuYiA9IGVlLCAoJC5kID0gZWUpLmEgPSBaLCBlZS5jID0gJC5jLCBxID0gWjsgcS5kID0gZWUsIChxID0gcS5lKSAhPT0gWjsgKVxuICAgICAgICAgIDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFMoWikge1xuICAgICAgICB2YXIgJCA9IFouaDtcbiAgICAgICAgWiA9IFouYi5oLCAoJC5iLmggPSBaKS5iLmggPSAkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRShaLCAkKSB7XG4gICAgICAgIGZvciAodmFyIHEgPSBaLmMsIGVlID0gcTsgZWUuYSA9ICQsIChlZSA9IGVlLmMpICE9PSBxOyApXG4gICAgICAgICAgO1xuICAgICAgICBxID0gWi5mLCAoKGVlID0gWi5lKS5mID0gcSkuZSA9IGVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gQShaLCAkKSB7XG4gICAgICAgIGZvciAodmFyIHEgPSBaLmEsIGVlID0gcTsgZWUuZCA9ICQsIChlZSA9IGVlLmUpICE9PSBxOyApXG4gICAgICAgICAgO1xuICAgICAgICBxID0gWi5kLCAoKGVlID0gWi5iKS5kID0gcSkuYiA9IGVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geChaKSB7XG4gICAgICAgIHZhciAkID0gMDtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKFpbMV0pID4gTWF0aC5hYnMoWlswXSkgJiYgKCQgPSAxKSwgJCA9IE1hdGguYWJzKFpbMl0pID4gTWF0aC5hYnMoWlskXSkgPyAyIDogJDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFAoWiwgJCkge1xuICAgICAgICBaLmYgKz0gJC5mLCBaLmIuZiArPSAkLmIuZjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE0oWiwgJCwgcSkge1xuICAgICAgICByZXR1cm4gWiA9IFouYSwgJCA9ICQuYSwgcSA9IHEuYSwgJC5iLmEgPT09IFogPyBxLmIuYSA9PT0gWiA/IHUoJC5hLCBxLmEpID8gZyhxLmIuYSwgJC5hLCBxLmEpIDw9IDAgOiAwIDw9IGcoJC5iLmEsIHEuYSwgJC5hKSA6IGcocS5iLmEsIFosIHEuYSkgPD0gMCA6IHEuYi5hID09PSBaID8gMCA8PSBnKCQuYi5hLCBaLCAkLmEpIDogKCQgPSBoKCQuYi5hLCBaLCAkLmEpLCAoWiA9IGgocS5iLmEsIFosIHEuYSkpIDw9ICQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUihaKSB7XG4gICAgICAgIFouYS5pID0gbnVsbDtcbiAgICAgICAgdmFyICQgPSBaLmU7XG4gICAgICAgICQuYS5jID0gJC5jLCAkLmMuYSA9ICQuYSwgWi5lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEwoWiwgJCkge1xuICAgICAgICBuKFouYSksIFouYyA9ICExLCAoWi5hID0gJCkuaSA9IFo7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBGKFopIHtcbiAgICAgICAgZm9yICh2YXIgJCA9IFouYS5hOyAoWiA9IHdlKFopKS5hLmEgPT09ICQ7IClcbiAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBaLmMgJiYgKEwoWiwgJCA9IGMoUmUoWikuYS5iLCBaLmEuZSkpLCBaID0gd2UoWikpLCBaO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVihaLCAkLCBxKSB7XG4gICAgICAgIHZhciBlZSA9IG5ldyB2ZSgpO1xuICAgICAgICByZXR1cm4gZWUuYSA9IHEsIGVlLmUgPSBjZShaLmYsICQuZSwgZWUpLCBxLmkgPSBlZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEcoWiwgJCkge1xuICAgICAgICBzd2l0Y2ggKFoucykge1xuICAgICAgICAgIGNhc2UgMTAwMTMwOlxuICAgICAgICAgICAgcmV0dXJuICgxICYgJCkgIT0gMDtcbiAgICAgICAgICBjYXNlIDEwMDEzMTpcbiAgICAgICAgICAgIHJldHVybiAkICE9PSAwO1xuICAgICAgICAgIGNhc2UgMTAwMTMyOlxuICAgICAgICAgICAgcmV0dXJuIDAgPCAkO1xuICAgICAgICAgIGNhc2UgMTAwMTMzOlxuICAgICAgICAgICAgcmV0dXJuICQgPCAwO1xuICAgICAgICAgIGNhc2UgMTAwMTM0OlxuICAgICAgICAgICAgcmV0dXJuIDIgPD0gJCB8fCAkIDw9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFUoWikge1xuICAgICAgICB2YXIgJCA9IFouYSwgcSA9ICQuZDtcbiAgICAgICAgcS5jID0gWi5kLCBxLmEgPSAkLCBSKFopO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVyhaLCAkLCBxKSB7XG4gICAgICAgIGZvciAoJCA9IChaID0gJCkuYTsgWiAhPT0gcTsgKSB7XG4gICAgICAgICAgWi5jID0gITE7XG4gICAgICAgICAgdmFyIGVlID0gUmUoWiksIHBlID0gZWUuYTtcbiAgICAgICAgICBpZiAocGUuYSAhPT0gJC5hKSB7XG4gICAgICAgICAgICBpZiAoIWVlLmMpIHtcbiAgICAgICAgICAgICAgVShaKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMKGVlLCBwZSA9IGMoJC5jLmIsIHBlLmIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJC5jICE9PSBwZSAmJiAobChwZS5iLmUsIHBlKSwgbCgkLCBwZSkpLCBVKFopLCAkID0gZWUuYSwgWiA9IGVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gWChaLCAkLCBxLCBlZSwgcGUsIGplKSB7XG4gICAgICAgIGZvciAodmFyIENlID0gITA7IFYoWiwgJCwgcS5iKSwgKHEgPSBxLmMpICE9PSBlZTsgKVxuICAgICAgICAgIDtcbiAgICAgICAgZm9yIChwZSA9PT0gbnVsbCAmJiAocGUgPSBSZSgkKS5hLmIuYyk7IChxID0gKGVlID0gUmUoJCkpLmEuYikuYSA9PT0gcGUuYTsgKVxuICAgICAgICAgIHEuYyAhPT0gcGUgJiYgKGwocS5iLmUsIHEpLCBsKHBlLmIuZSwgcSkpLCBlZS5mID0gJC5mIC0gcS5mLCBlZS5kID0gRyhaLCBlZS5mKSwgJC5iID0gITAsICFDZSAmJiBEKFosICQpICYmIChQKHEsIHBlKSwgUigkKSwgbihwZSkpLCBDZSA9ICExLCAkID0gZWUsIHBlID0gcTtcbiAgICAgICAgJC5iID0gITAsIGplICYmIFkoWiwgJCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuZShaLCAkLCBxLCBlZSwgcGUpIHtcbiAgICAgICAgdmFyIGplID0gWyQuZ1swXSwgJC5nWzFdLCAkLmdbMl1dO1xuICAgICAgICAkLmQgPSBudWxsLCAkLmQgPSBaLm8gJiYgWi5vKGplLCBxLCBlZSwgWi5jKSB8fCBudWxsLCAkLmQgPT09IG51bGwgJiYgKHBlID8gWi5uIHx8IChLKFosIDEwMDE1NiksIFoubiA9ICEwKSA6ICQuZCA9IHFbMF0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYihaLCAkLCBxKSB7XG4gICAgICAgIHZhciBlZSA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgZWVbMF0gPSAkLmEuZCwgZWVbMV0gPSBxLmEuZCwgbmUoWiwgJC5hLCBlZSwgWzAuNSwgMC41LCAwLCAwXSwgITEpLCBsKCQsIHEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTyhaLCAkLCBxLCBlZSwgcGUpIHtcbiAgICAgICAgdmFyIGplID0gTWF0aC5hYnMoJC5iIC0gWi5iKSArIE1hdGguYWJzKCQuYSAtIFouYSksIENlID0gTWF0aC5hYnMocS5iIC0gWi5iKSArIE1hdGguYWJzKHEuYSAtIFouYSksIEZlID0gcGUgKyAxO1xuICAgICAgICBlZVtwZV0gPSAwLjUgKiBDZSAvIChqZSArIENlKSwgZWVbRmVdID0gMC41ICogamUgLyAoamUgKyBDZSksIFouZ1swXSArPSBlZVtwZV0gKiAkLmdbMF0gKyBlZVtGZV0gKiBxLmdbMF0sIFouZ1sxXSArPSBlZVtwZV0gKiAkLmdbMV0gKyBlZVtGZV0gKiBxLmdbMV0sIFouZ1syXSArPSBlZVtwZV0gKiAkLmdbMl0gKyBlZVtGZV0gKiBxLmdbMl07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBEKFosICQpIHtcbiAgICAgICAgdmFyIHEgPSBSZSgkKSwgZWUgPSAkLmEsIHBlID0gcS5hO1xuICAgICAgICBpZiAodShlZS5hLCBwZS5hKSkge1xuICAgICAgICAgIGlmICgwIDwgZyhwZS5iLmEsIGVlLmEsIHBlLmEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmICh5KGVlLmEsIHBlLmEpKSB7XG4gICAgICAgICAgICBpZiAoZWUuYSAhPT0gcGUuYSkge1xuICAgICAgICAgICAgICB2YXIgcSA9IFouZSwgamUgPSBlZS5hLmg7XG4gICAgICAgICAgICAgIGlmICgwIDw9IGplKSB7XG4gICAgICAgICAgICAgICAgdmFyIENlID0gKHEgPSBxLmIpLmQsIEZlID0gcS5lLCBOZSA9IHEuYywgQmUgPSBOZVtqZV07XG4gICAgICAgICAgICAgICAgQ2VbQmVdID0gQ2VbcS5hXSwgKE5lW0NlW0JlXV0gPSBCZSkgPD0gLS1xLmEgJiYgKEJlIDw9IDEgfHwgdShGZVtDZVtCZSA+PiAxXV0sIEZlW0NlW0JlXV0pID8gWGUgOiBIZSkocSwgQmUpLCBGZVtqZV0gPSBudWxsLCBOZVtqZV0gPSBxLmIsIHEuYiA9IGplO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKHEuY1stKGplICsgMSldID0gbnVsbDsgMCA8IHEuYSAmJiBxLmNbcS5kW3EuYSAtIDFdXSA9PT0gbnVsbDsgKVxuICAgICAgICAgICAgICAgICAgLS1xLmE7XG4gICAgICAgICAgICAgIGIoWiwgcGUuYi5lLCBlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBhKHBlLmIpLCBsKGVlLCBwZS5iLmUpLCAkLmIgPSBxLmIgPSAhMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZyhlZS5iLmEsIHBlLmEsIGVlLmEpIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB3ZSgkKS5iID0gJC5iID0gITAsIGEoZWUuYiksIGwocGUuYi5lLCBlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBCKFosICQpIHtcbiAgICAgICAgdmFyIHEgPSBSZSgkKSwgZWUgPSAkLmEsIHBlID0gcS5hLCBqZSA9IGVlLmEsIENlID0gcGUuYSwgRmUgPSBlZS5iLmEsIE5lID0gcGUuYi5hLCBCZSA9IG5ldyBmZSgpO1xuICAgICAgICBpZiAoZyhGZSwgWi5hLCBqZSksIGcoTmUsIFouYSwgQ2UpLCAhKGplID09PSBDZSB8fCBNYXRoLm1pbihqZS5hLCBGZS5hKSA+IE1hdGgubWF4KENlLmEsIE5lLmEpKSkge1xuICAgICAgICAgIGlmICh1KGplLCBDZSkpIHtcbiAgICAgICAgICAgIGlmICgwIDwgZyhOZSwgamUsIENlKSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZyhGZSwgQ2UsIGplKSA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdmFyIFdlLCBzdCwgbnQgPSBGZSwgS2UgPSBqZSwgYXQgPSBOZSwgb3QgPSBDZTtcbiAgICAgICAgICBpZiAodShudCwgS2UpIHx8IChXZSA9IG50LCBudCA9IEtlLCBLZSA9IFdlKSwgdShhdCwgb3QpIHx8IChXZSA9IGF0LCBhdCA9IG90LCBvdCA9IFdlKSwgdShudCwgYXQpIHx8IChXZSA9IG50LCBudCA9IGF0LCBhdCA9IFdlLCBXZSA9IEtlLCBLZSA9IG90LCBvdCA9IFdlKSwgdShhdCwgS2UpID8gdShLZSwgb3QpID8gKChXZSA9IGgobnQsIGF0LCBLZSkpICsgKHN0ID0gaChhdCwgS2UsIG90KSkgPCAwICYmIChXZSA9IC1XZSwgc3QgPSAtc3QpLCBCZS5iID0gbyhXZSwgYXQuYiwgc3QsIEtlLmIpKSA6ICgoV2UgPSBnKG50LCBhdCwgS2UpKSArIChzdCA9IC1nKG50LCBvdCwgS2UpKSA8IDAgJiYgKFdlID0gLVdlLCBzdCA9IC1zdCksIEJlLmIgPSBvKFdlLCBhdC5iLCBzdCwgb3QuYikpIDogQmUuYiA9IChhdC5iICsgS2UuYikgLyAyLCBmKG50LCBLZSkgfHwgKFdlID0gbnQsIG50ID0gS2UsIEtlID0gV2UpLCBmKGF0LCBvdCkgfHwgKFdlID0gYXQsIGF0ID0gb3QsIG90ID0gV2UpLCBmKG50LCBhdCkgfHwgKFdlID0gbnQsIG50ID0gYXQsIGF0ID0gV2UsIFdlID0gS2UsIEtlID0gb3QsIG90ID0gV2UpLCBmKGF0LCBLZSkgPyBmKEtlLCBvdCkgPyAoKFdlID0gcihudCwgYXQsIEtlKSkgKyAoc3QgPSByKGF0LCBLZSwgb3QpKSA8IDAgJiYgKFdlID0gLVdlLCBzdCA9IC1zdCksIEJlLmEgPSBvKFdlLCBhdC5hLCBzdCwgS2UuYSkpIDogKChXZSA9IHMobnQsIGF0LCBLZSkpICsgKHN0ID0gLXMobnQsIG90LCBLZSkpIDwgMCAmJiAoV2UgPSAtV2UsIHN0ID0gLXN0KSwgQmUuYSA9IG8oV2UsIGF0LmEsIHN0LCBvdC5hKSkgOiBCZS5hID0gKGF0LmEgKyBLZS5hKSAvIDIsIHUoQmUsIFouYSkgJiYgKEJlLmIgPSBaLmEuYiwgQmUuYSA9IFouYS5hKSwgbnQgPSB1KGplLCBDZSkgPyBqZSA6IENlLCB1KG50LCBCZSkgJiYgKEJlLmIgPSBudC5iLCBCZS5hID0gbnQuYSksIHkoQmUsIGplKSB8fCB5KEJlLCBDZSkpXG4gICAgICAgICAgICByZXR1cm4gRChaLCAkKSwgMDtcbiAgICAgICAgICBpZiAoIXkoRmUsIFouYSkgJiYgMCA8PSBnKEZlLCBaLmEsIEJlKSB8fCAheShOZSwgWi5hKSAmJiBnKE5lLCBaLmEsIEJlKSA8PSAwKSB7XG4gICAgICAgICAgICBpZiAoTmUgPT09IFouYSlcbiAgICAgICAgICAgICAgYShlZS5iKSwgbChwZS5iLCBlZSksIGVlID0gUmUoJCA9IEYoJCkpLmEsIFcoWiwgUmUoJCksIHEpLCBYKFosICQsIGVlLmIuZSwgZWUsIGVlLCAhMCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKEZlICE9PSBaLmEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgPD0gZyhGZSwgWi5hLCBCZSkgJiYgKHdlKCQpLmIgPSAkLmIgPSAhMCwgYShlZS5iKSwgZWUuYS5iID0gWi5hLmIsIGVlLmEuYSA9IFouYS5hKSwgdm9pZCAoZyhOZSwgWi5hLCBCZSkgPD0gMCAmJiAoJC5iID0gcS5iID0gITAsIGEocGUuYiksIHBlLmEuYiA9IFouYS5iLCBwZS5hLmEgPSBaLmEuYSkpO1xuICAgICAgICAgICAgICBmb3IgKGEocGUuYiksIGwoZWUuZSwgcGUuYi5lKSwgQ2UgPSAoamUgPSBxID0gJCkuYS5iLmE7IChqZSA9IHdlKGplKSkuYS5iLmEgPT09IENlOyApXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBqZSA9IFJlKCQgPSBqZSkuYS5iLmMsIHEuYSA9IHBlLmIuZSwgWChaLCAkLCAocGUgPSBXKFosIHEsIG51bGwpKS5jLCBlZS5iLmMsIGplLCAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYShlZS5iKSwgYShwZS5iKSwgbChwZS5iLmUsIGVlKSwgZWUuYS5iID0gQmUuYiwgZWUuYS5hID0gQmUuYSwgZWUuYS5oID0geGUoWi5lLCBlZS5hKSwgZWUgPSBlZS5hLCBwZSA9IFswLCAwLCAwLCAwXSwgQmUgPSBbamUuZCwgRmUuZCwgQ2UuZCwgTmUuZF0sIGVlLmdbMF0gPSBlZS5nWzFdID0gZWUuZ1syXSA9IDAsIE8oZWUsIGplLCBGZSwgcGUsIDApLCBPKGVlLCBDZSwgTmUsIHBlLCAyKSwgbmUoWiwgZWUsIEJlLCBwZSwgITApLCB3ZSgkKS5iID0gJC5iID0gcS5iID0gITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFkoWiwgJCkge1xuICAgICAgICBmb3IgKHZhciBxID0gUmUoJCk7IDsgKSB7XG4gICAgICAgICAgZm9yICg7IHEuYjsgKVxuICAgICAgICAgICAgcSA9IFJlKCQgPSBxKTtcbiAgICAgICAgICBpZiAoISQuYiAmJiAoKCQgPSB3ZShxID0gJCkpID09PSBudWxsIHx8ICEkLmIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgJC5iID0gITE7XG4gICAgICAgICAgdmFyIGVlID0gJC5hLCBwZSA9IHEuYTtcbiAgICAgICAgICBpZiAoamUgPSBlZS5iLmEgIT09IHBlLmIuYSlcbiAgICAgICAgICAgIGU6IHtcbiAgICAgICAgICAgICAgdmFyIGplLCBDZSA9IFJlKGplID0gJCksIEZlID0gamUuYSwgTmUgPSBDZS5hLCBCZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHUoRmUuYi5hLCBOZS5iLmEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcoRmUuYi5hLCBOZS5iLmEsIEZlLmEpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgamUgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdlKGplKS5iID0gamUuYiA9ICEwLCBCZSA9IGEoRmUpLCBsKE5lLmIsIEJlKSwgQmUuZC5jID0gamUuZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGcoTmUuYi5hLCBGZS5iLmEsIE5lLmEpKSB7XG4gICAgICAgICAgICAgICAgICBqZSA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgamUuYiA9IENlLmIgPSAhMCwgQmUgPSBhKE5lKSwgbChGZS5lLCBOZS5iKSwgQmUuYi5kLmMgPSBqZS5kO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGplID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGplICYmIChxLmMgPyAoUihxKSwgbihwZSksIHBlID0gKHEgPSBSZSgkKSkuYSkgOiAkLmMgJiYgKFIoJCksIG4oZWUpLCBlZSA9ICgkID0gd2UocSkpLmEpKSwgZWUuYSAhPT0gcGUuYSkge1xuICAgICAgICAgICAgaWYgKGVlLmIuYSA9PT0gcGUuYi5hIHx8ICQuYyB8fCBxLmMgfHwgZWUuYi5hICE9PSBaLmEgJiYgcGUuYi5hICE9PSBaLmEpXG4gICAgICAgICAgICAgIEQoWiwgJCk7XG4gICAgICAgICAgICBlbHNlIGlmIChCKFosICQpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWUuYSA9PT0gcGUuYSAmJiBlZS5iLmEgPT09IHBlLmIuYSAmJiAoUChwZSwgZWUpLCBSKCQpLCBuKGVlKSwgJCA9IHdlKHEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gSihaLCAkKSB7XG4gICAgICAgIHZhciBxID0gbmV3IHZlKCksIGVlID0gaShaLmIpO1xuICAgICAgICBlZS5hLmIgPSA0ZTE1MCwgZWUuYS5hID0gJCwgZWUuYi5hLmIgPSAtNGUxNTAsIGVlLmIuYS5hID0gJCwgWi5hID0gZWUuYi5hLCBxLmEgPSBlZSwgcS5mID0gMCwgcS5kID0gITEsIHEuYyA9ICExLCBxLmggPSAhMCwgcS5iID0gITEsIGVlID0gY2UoZWUgPSBaLmYsIGVlLmEsIHEpLCBxLmUgPSBlZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRlKFopIHtcbiAgICAgICAgdGhpcy5hID0gbmV3IHJlKCksIHRoaXMuYiA9IFosIHRoaXMuYyA9IE07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjZShaLCAkLCBxKSB7XG4gICAgICAgIGZvciAoOyAoJCA9ICQuYykuYiAhPT0gbnVsbCAmJiAhWi5jKFouYiwgJC5iLCBxKTsgKVxuICAgICAgICAgIDtcbiAgICAgICAgcmV0dXJuIFogPSBuZXcgcmUocSwgJC5hLCAkKSwgJC5hLmMgPSBaLCAkLmEgPSBaO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmUoWiwgJCwgcSkge1xuICAgICAgICB0aGlzLmIgPSBaIHx8IG51bGwsIHRoaXMuYSA9ICQgfHwgdGhpcywgdGhpcy5jID0gcSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdWUoKSB7XG4gICAgICAgIHRoaXMuZCA9IDAsIHRoaXMucCA9IHRoaXMuYiA9IHRoaXMucSA9IG51bGwsIHRoaXMuaiA9IFswLCAwLCAwXSwgdGhpcy5zID0gMTAwMTMwLCB0aGlzLm4gPSAhMSwgdGhpcy5vID0gdGhpcy5hID0gdGhpcy5lID0gdGhpcy5mID0gbnVsbCwgdGhpcy5tID0gITEsIHRoaXMuYyA9IHRoaXMuciA9IHRoaXMuaSA9IHRoaXMuayA9IHRoaXMubCA9IHRoaXMuaCA9IG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsZShaLCAkKSB7XG4gICAgICAgIGlmIChaLmQgIT09ICQpXG4gICAgICAgICAgZm9yICg7IFouZCAhPT0gJDsgKVxuICAgICAgICAgICAgaWYgKFouZCA8ICQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoWi5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgSyhaLCAxMDAxNTEpLCBaLnUobnVsbCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBLKFosIDEwMDE1MiksIFoudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHN3aXRjaCAoWi5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgSyhaLCAxMDAxNTQpLCBaLnYoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIEsoWiwgMTAwMTUzKSwgWi53KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEsoWiwgJCkge1xuICAgICAgICBaLnAgJiYgWi5wKCQsIFouYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhZShaLCAkKSB7XG4gICAgICAgIHRoaXMuYiA9IFogfHwgdGhpcywgdGhpcy5kID0gJCB8fCB0aGlzLCB0aGlzLmEgPSBudWxsLCB0aGlzLmMgPSAhMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhlKCkge1xuICAgICAgICAodGhpcy5oID0gdGhpcykuaSA9IHRoaXMuZCA9IHRoaXMuYSA9IHRoaXMuZSA9IHRoaXMuYyA9IHRoaXMuYiA9IG51bGwsIHRoaXMuZiA9IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfZSgpIHtcbiAgICAgICAgdGhpcy5jID0gbmV3IGZlKCksIHRoaXMuYSA9IG5ldyBhZSgpLCB0aGlzLmIgPSBuZXcgaGUoKSwgdGhpcy5kID0gbmV3IGhlKCksIHRoaXMuYi5iID0gdGhpcy5kLCB0aGlzLmQuYiA9IHRoaXMuYjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGZlKFosICQpIHtcbiAgICAgICAgdGhpcy5lID0gWiB8fCB0aGlzLCB0aGlzLmYgPSAkIHx8IHRoaXMsIHRoaXMuZCA9IHRoaXMuYyA9IG51bGwsIHRoaXMuZyA9IFswLCAwLCAwXSwgdGhpcy5oID0gdGhpcy5hID0gdGhpcy5iID0gMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdlKCkge1xuICAgICAgICB0aGlzLmMgPSBbXSwgdGhpcy5kID0gbnVsbCwgdGhpcy5hID0gMCwgdGhpcy5lID0gITEsIHRoaXMuYiA9IG5ldyBNZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geGUoWiwgJCkge1xuICAgICAgICB2YXIgcSwgZWUsIHBlO1xuICAgICAgICByZXR1cm4gWi5lID8gKDIgKiAoZWUgPSArKyhxID0gWi5iKS5hKSA+IHEuZiAmJiAocS5mICo9IDIsIHEuYyA9IFFlKHEuYywgcS5mICsgMSkpLCBxLmIgPT09IDAgPyBwZSA9IGVlIDogKHBlID0gcS5iLCBxLmIgPSBxLmNbcS5iXSksIHEuZVtwZV0gPSAkLCBxLmNbcGVdID0gZWUsIHEuZFtlZV0gPSBwZSwgcS5oICYmIEhlKHEsIGVlKSwgcGUpIDogKHEgPSBaLmErKywgWi5jW3FdID0gJCwgLShxICsgMSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRGUoWikge1xuICAgICAgICBpZiAoWi5hID09PSAwKVxuICAgICAgICAgIHJldHVybiBWZShaLmIpO1xuICAgICAgICB2YXIgJCA9IFouY1taLmRbWi5hIC0gMV1dO1xuICAgICAgICBpZiAoWi5iLmEgIT09IDAgJiYgdSh6ZShaLmIpLCAkKSlcbiAgICAgICAgICByZXR1cm4gVmUoWi5iKTtcbiAgICAgICAgZm9yICg7IC0tWi5hLCAwIDwgWi5hICYmIFouY1taLmRbWi5hIC0gMV1dID09PSBudWxsOyApXG4gICAgICAgICAgO1xuICAgICAgICByZXR1cm4gJDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE1lKCkge1xuICAgICAgICB0aGlzLmQgPSBRZShbMF0sIDMzKSwgdGhpcy5lID0gW251bGwsIG51bGxdLCB0aGlzLmMgPSBbMCwgMF0sIHRoaXMuYSA9IDAsIHRoaXMuZiA9IDMyLCB0aGlzLmIgPSAwLCB0aGlzLmggPSAhMSwgdGhpcy5kWzFdID0gMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFFlKFosICQpIHtcbiAgICAgICAgZm9yICh2YXIgcSA9IEFycmF5KCQpLCBlZSA9IDA7IGVlIDwgWi5sZW5ndGg7IGVlKyspXG4gICAgICAgICAgcVtlZV0gPSBaW2VlXTtcbiAgICAgICAgZm9yICg7IGVlIDwgJDsgZWUrKylcbiAgICAgICAgICBxW2VlXSA9IDA7XG4gICAgICAgIHJldHVybiBxO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gemUoWikge1xuICAgICAgICByZXR1cm4gWi5lW1ouZFsxXV07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBWZShaKSB7XG4gICAgICAgIHZhciAkID0gWi5kLCBxID0gWi5lLCBlZSA9IFouYywgcGUgPSAkWzFdLCBqZSA9IHFbcGVdO1xuICAgICAgICByZXR1cm4gMCA8IFouYSAmJiAoJFsxXSA9ICRbWi5hXSwgZWVbJFsxXV0gPSAxLCBxW3BlXSA9IG51bGwsIGVlW3BlXSA9IFouYiwgWi5iID0gcGUsIDAgPCAtLVouYSAmJiBYZShaLCAxKSksIGplO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gWGUoWiwgJCkge1xuICAgICAgICBmb3IgKHZhciBxID0gWi5kLCBlZSA9IFouZSwgcGUgPSBaLmMsIGplID0gJCwgQ2UgPSBxW2plXTsgOyApIHtcbiAgICAgICAgICB2YXIgRmUgPSBqZSA8PCAxLCBOZSA9IChGZSA8IFouYSAmJiB1KGVlW3FbRmUgKyAxXV0sIGVlW3FbRmVdXSkgJiYgKEZlICs9IDEpLCBxW0ZlXSk7XG4gICAgICAgICAgaWYgKEZlID4gWi5hIHx8IHUoZWVbQ2VdLCBlZVtOZV0pKSB7XG4gICAgICAgICAgICBwZVtxW2plXSA9IENlXSA9IGplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlW3FbamVdID0gTmVdID0gamUsIGplID0gRmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEhlKFosICQpIHtcbiAgICAgICAgZm9yICh2YXIgcSA9IFouZCwgZWUgPSBaLmUsIHBlID0gWi5jLCBqZSA9ICQsIENlID0gcVtqZV07IDsgKSB7XG4gICAgICAgICAgdmFyIEZlID0gamUgPj4gMSwgTmUgPSBxW0ZlXTtcbiAgICAgICAgICBpZiAoRmUgPT0gMCB8fCB1KGVlW05lXSwgZWVbQ2VdKSkge1xuICAgICAgICAgICAgcGVbcVtqZV0gPSBDZV0gPSBqZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZVtxW2plXSA9IE5lXSA9IGplLCBqZSA9IEZlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2ZSgpIHtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5hID0gbnVsbCwgdGhpcy5mID0gMCwgdGhpcy5jID0gdGhpcy5iID0gdGhpcy5oID0gdGhpcy5kID0gITE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBSZShaKSB7XG4gICAgICAgIHJldHVybiBaLmUuYy5iO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd2UoWikge1xuICAgICAgICByZXR1cm4gWi5lLmEuYjtcbiAgICAgIH1cbiAgICAgIChtID0gdWUucHJvdG90eXBlKS54ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxlKHRoaXMsIDApO1xuICAgICAgfSwgbS5CID0gZnVuY3Rpb24oWiwgJCkge1xuICAgICAgICBzd2l0Y2ggKFopIHtcbiAgICAgICAgICBjYXNlIDEwMDE0MjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIDEwMDE0MDpcbiAgICAgICAgICAgIHN3aXRjaCAoJCkge1xuICAgICAgICAgICAgICBjYXNlIDEwMDEzMDpcbiAgICAgICAgICAgICAgY2FzZSAxMDAxMzE6XG4gICAgICAgICAgICAgIGNhc2UgMTAwMTMyOlxuICAgICAgICAgICAgICBjYXNlIDEwMDEzMzpcbiAgICAgICAgICAgICAgY2FzZSAxMDAxMzQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKHRoaXMucyA9ICQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxNDE6XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAodGhpcy5tID0gISEkKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgSyh0aGlzLCAxMDA5MDApO1xuICAgICAgICB9XG4gICAgICAgIEsodGhpcywgMTAwOTAxKTtcbiAgICAgIH0sIG0ueSA9IGZ1bmN0aW9uKFopIHtcbiAgICAgICAgc3dpdGNoIChaKSB7XG4gICAgICAgICAgY2FzZSAxMDAxNDI6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjYXNlIDEwMDE0MDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgICAgICAgY2FzZSAxMDAxNDE6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBLKHRoaXMsIDEwMDkwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgbS5BID0gZnVuY3Rpb24oWiwgJCwgcSkge1xuICAgICAgICB0aGlzLmpbMF0gPSBaLCB0aGlzLmpbMV0gPSAkLCB0aGlzLmpbMl0gPSBxO1xuICAgICAgfSwgbS56ID0gZnVuY3Rpb24oWiwgJCkge1xuICAgICAgICB2YXIgcSA9ICQgfHwgbnVsbDtcbiAgICAgICAgc3dpdGNoIChaKSB7XG4gICAgICAgICAgY2FzZSAxMDAxMDA6XG4gICAgICAgICAgY2FzZSAxMDAxMDY6XG4gICAgICAgICAgICB0aGlzLmggPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMDQ6XG4gICAgICAgICAgY2FzZSAxMDAxMTA6XG4gICAgICAgICAgICB0aGlzLmwgPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMDE6XG4gICAgICAgICAgY2FzZSAxMDAxMDc6XG4gICAgICAgICAgICB0aGlzLmsgPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMDI6XG4gICAgICAgICAgY2FzZSAxMDAxMDg6XG4gICAgICAgICAgICB0aGlzLmkgPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMDM6XG4gICAgICAgICAgY2FzZSAxMDAxMDk6XG4gICAgICAgICAgICB0aGlzLnAgPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMDU6XG4gICAgICAgICAgY2FzZSAxMDAxMTE6XG4gICAgICAgICAgICB0aGlzLm8gPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDAxMTI6XG4gICAgICAgICAgICB0aGlzLnIgPSBxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIEsodGhpcywgMTAwOTAwKTtcbiAgICAgICAgfVxuICAgICAgfSwgbS5DID0gZnVuY3Rpb24oWiwgJCkge1xuICAgICAgICB2YXIgcSA9ICExLCBlZSA9IFswLCAwLCAwXTtcbiAgICAgICAgbGUodGhpcywgMik7XG4gICAgICAgIGZvciAodmFyIHBlID0gMDsgcGUgPCAzOyArK3BlKSB7XG4gICAgICAgICAgdmFyIGplID0gWltwZV07XG4gICAgICAgICAgamUgPCAtMWUxNTAgJiYgKGplID0gLTFlMTUwLCBxID0gITApLCAxZTE1MCA8IGplICYmIChqZSA9IDFlMTUwLCBxID0gITApLCBlZVtwZV0gPSBqZTtcbiAgICAgICAgfVxuICAgICAgICBxICYmIEsodGhpcywgMTAwMTU1KSwgKHEgPSB0aGlzLnEpID09PSBudWxsID8gbChxID0gaSh0aGlzLmIpLCBxLmIpIDogKGEocSksIHEgPSBxLmUpLCBxLmEuZCA9ICQsIHEuYS5nWzBdID0gZWVbMF0sIHEuYS5nWzFdID0gZWVbMV0sIHEuYS5nWzJdID0gZWVbMl0sIHEuZiA9IDEsIHEuYi5mID0gLTEsIHRoaXMucSA9IHE7XG4gICAgICB9LCBtLnUgPSBmdW5jdGlvbihaKSB7XG4gICAgICAgIGxlKHRoaXMsIDApLCB0aGlzLmQgPSAxLCB0aGlzLmIgPSBuZXcgX2UoKSwgdGhpcy5jID0gWjtcbiAgICAgIH0sIG0udCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZSh0aGlzLCAxKSwgdGhpcy5kID0gMiwgdGhpcy5xID0gbnVsbDtcbiAgICAgIH0sIG0udiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZSh0aGlzLCAyKSwgdGhpcy5kID0gMTtcbiAgICAgIH0sIG0udyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZSh0aGlzLCAxKSwgdGhpcy5kID0gMDtcbiAgICAgICAgdmFyIFosICQsIHEgPSB0aGlzLmpbMF0sIGVlID0gdGhpcy5qWzFdLCBwZSA9IHRoaXMualsyXSwgamUgPSAhMSwgQ2UgPSBbcSwgZWUsIHBlXTtcbiAgICAgICAgaWYgKHEgPT09IDAgJiYgZWUgPT09IDAgJiYgcGUgPT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBlZSA9IFstMmUxNTAsIC0yZTE1MCwgLTJlMTUwXSwgRmUgPSBbMmUxNTAsIDJlMTUwLCAyZTE1MF0sIHBlID0gW10sIE5lID0gW10sIHEgPSAoamUgPSB0aGlzLmIuYykuZTsgcSAhPT0gamU7IHEgPSBxLmUpXG4gICAgICAgICAgICBmb3IgKHZhciBCZSA9IDA7IEJlIDwgMzsgKytCZSkge1xuICAgICAgICAgICAgICB2YXIgV2UgPSBxLmdbQmVdO1xuICAgICAgICAgICAgICBXZSA8IEZlW0JlXSAmJiAoRmVbQmVdID0gV2UsIE5lW0JlXSA9IHEpLCBXZSA+IGVlW0JlXSAmJiAoZWVbQmVdID0gV2UsIHBlW0JlXSA9IHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZVsxXSAtIEZlWzFdID4gZWVbcSA9IDBdIC0gRmVbMF0gJiYgKHEgPSAxKSwgRmVbcSA9IGVlWzJdIC0gRmVbMl0gPiBlZVtxXSAtIEZlW3FdID8gMiA6IHFdID49IGVlW3FdKVxuICAgICAgICAgICAgQ2VbMF0gPSAwLCBDZVsxXSA9IDAsIENlWzJdID0gMTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoRmUgPSBOZVtxXSwgcGUgPSBwZVtxXSwgTmUgPSBbZWUgPSAwLCAwLCAwXSwgRmUgPSBbRmUuZ1swXSAtIHBlLmdbMF0sIEZlLmdbMV0gLSBwZS5nWzFdLCBGZS5nWzJdIC0gcGUuZ1syXV0sIEJlID0gWzAsIDAsIDBdLCBxID0gamUuZTsgcSAhPT0gamU7IHEgPSBxLmUpXG4gICAgICAgICAgICAgIEJlWzBdID0gcS5nWzBdIC0gcGUuZ1swXSwgQmVbMV0gPSBxLmdbMV0gLSBwZS5nWzFdLCBCZVsyXSA9IHEuZ1syXSAtIHBlLmdbMl0sIE5lWzBdID0gRmVbMV0gKiBCZVsyXSAtIEZlWzJdICogQmVbMV0sIE5lWzFdID0gRmVbMl0gKiBCZVswXSAtIEZlWzBdICogQmVbMl0sIE5lWzJdID0gRmVbMF0gKiBCZVsxXSAtIEZlWzFdICogQmVbMF0sIGVlIDwgKFdlID0gTmVbMF0gKiBOZVswXSArIE5lWzFdICogTmVbMV0gKyBOZVsyXSAqIE5lWzJdKSAmJiAoZWUgPSBXZSwgQ2VbMF0gPSBOZVswXSwgQ2VbMV0gPSBOZVsxXSwgQ2VbMl0gPSBOZVsyXSk7XG4gICAgICAgICAgICBlZSA8PSAwICYmIChDZVswXSA9IENlWzFdID0gQ2VbMl0gPSAwLCBDZVt4KEZlKV0gPSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgamUgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKE5lID0geChDZSksIHEgPSB0aGlzLmIuYywgZWUgPSAoTmUgKyAxKSAlIDMsIHBlID0gKE5lICsgMikgJSAzLCBOZSA9IDAgPCBDZVtOZV0gPyAxIDogLTEsIENlID0gcS5lOyBDZSAhPT0gcTsgQ2UgPSBDZS5lKVxuICAgICAgICAgIENlLmIgPSBDZS5nW2VlXSwgQ2UuYSA9IE5lICogQ2UuZ1twZV07XG4gICAgICAgIGlmIChqZSkge1xuICAgICAgICAgIGZvciAoQ2UgPSAwLCBxID0gKGplID0gdGhpcy5iLmEpLmI7IHEgIT09IGplOyBxID0gcS5iKVxuICAgICAgICAgICAgaWYgKCEoKGVlID0gcS5hKS5mIDw9IDApKVxuICAgICAgICAgICAgICBmb3IgKDsgQ2UgKz0gKGVlLmEuYiAtIGVlLmIuYS5iKSAqIChlZS5hLmEgKyBlZS5iLmEuYSksIChlZSA9IGVlLmUpICE9PSBxLmE7IClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgaWYgKENlIDwgMClcbiAgICAgICAgICAgIGZvciAoamUgPSAoQ2UgPSB0aGlzLmIuYykuZTsgamUgIT09IENlOyBqZSA9IGplLmUpXG4gICAgICAgICAgICAgIGplLmEgPSAtamUuYTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHRoaXMubiA9ICExLCBDZSA9IHRoaXMuYi5iLCBxID0gQ2UuaDsgcSAhPT0gQ2U7IHEgPSBqZSlcbiAgICAgICAgICBqZSA9IHEuaCwgZWUgPSBxLmUsIHkocS5hLCBxLmIuYSkgJiYgcS5lLmUgIT09IHEgJiYgKGIodGhpcywgZWUsIHEpLCBuKHEpLCBlZSA9IChxID0gZWUpLmUpLCBlZS5lID09PSBxICYmIChlZSAhPT0gcSAmJiAoZWUgIT09IGplICYmIGVlICE9PSBqZS5iIHx8IChqZSA9IGplLmgpLCBuKGVlKSksIHEgIT09IGplICYmIHEgIT09IGplLmIgfHwgKGplID0gamUuaCksIG4ocSkpO1xuICAgICAgICBmb3IgKHRoaXMuZSA9IENlID0gbmV3IGdlKCksIGplID0gdGhpcy5iLmMsIHEgPSBqZS5lOyBxICE9PSBqZTsgcSA9IHEuZSlcbiAgICAgICAgICBxLmggPSB4ZShDZSwgcSk7XG4gICAgICAgIHZhciBzdCA9IENlO1xuICAgICAgICBzdC5kID0gW107XG4gICAgICAgIGZvciAodmFyIG50ID0gMDsgbnQgPCBzdC5hOyBudCsrKVxuICAgICAgICAgIHN0LmRbbnRdID0gbnQ7XG4gICAgICAgIHN0LmQuc29ydCgvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24ob3QpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYnQsIEl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdShvdFtidF0sIG90W0l0XSkgPyAxIDogLTE7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShzdC5jKSksIHN0LmUgPSAhMDtcbiAgICAgICAgZm9yICh2YXIgS2UgPSBzdC5iLCBhdCA9IEtlLmE7IDEgPD0gYXQ7IC0tYXQpXG4gICAgICAgICAgWGUoS2UsIGF0KTtcbiAgICAgICAgZm9yIChLZS5oID0gITAsIHRoaXMuZiA9IG5ldyB0ZSh0aGlzKSwgSih0aGlzLCAtNGUxNTApLCBKKHRoaXMsIDRlMTUwKTsgKENlID0gRGUodGhpcy5lKSkgIT09IG51bGw7ICkge1xuICAgICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgICAgZTpcbiAgICAgICAgICAgICAgaWYgKChxID0gdGhpcy5lKS5hID09PSAwKVxuICAgICAgICAgICAgICAgIGplID0gemUocS5iKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoamUgPSBxLmNbcS5kW3EuYSAtIDFdXSwgcS5iLmEgIT09IDAgJiYgdShxID0gemUocS5iKSwgamUpKSB7XG4gICAgICAgICAgICAgICAgamUgPSBxO1xuICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqZSA9PT0gbnVsbCB8fCAheShqZSwgQ2UpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGplID0gRGUodGhpcy5lKSwgYih0aGlzLCBDZS5jLCBqZS5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKGZ1bmN0aW9uIG90KGJ0LCBJdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgTXQsIG10ID0gKGJ0LmEgPSBJdCkuYzsgbXQuaSA9PT0gbnVsbDsgKVxuICAgICAgICAgICAgICBpZiAoKG10ID0gbXQuYykgPT09IEl0LmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXQgPSBidCwganQgPSBJdDtcbiAgICAgICAgICAgICAgICAoZ3QgPSBuZXcgdmUoKSkuYSA9IGp0LmMuYjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBGdCA9IChodCA9IG10LmYpLmE7IChGdCA9IEZ0LmEpLmIgIT09IG51bGwgJiYgIWh0LmMoaHQuYiwgZ3QsIEZ0LmIpOyApXG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgdmFyIGh0LCBEdCwgUHQgPSBSZShodCA9IEZ0LmIpLCBndCA9IGh0LmEsIEZ0ID0gUHQuYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoZyhndC5iLmEsIGp0LCBndC5hKSA9PT0gMCA/IHkoKGd0ID0gaHQuYSkuYSwganQpIHx8IHkoZ3QuYi5hLCBqdCkgfHwgKGEoZ3QuYiksIGh0LmMgJiYgKG4oZ3QuYyksIGh0LmMgPSAhMSksIGwoanQuYywgZ3QpLCBvdChtdCwganQpKSA6IChEdCA9IHUoRnQuYi5hLCBndC5iLmEpID8gaHQgOiBQdCwgUHQgPSB2b2lkIDAsIGh0LmQgfHwgRHQuYyA/IChQdCA9IER0ID09PSBodCA/IGMoanQuYy5iLCBndC5lKSA6IGMoRnQuYi5jLmIsIGp0LmMpLmIsIER0LmMgPyBMKER0LCBQdCkgOiAoKGh0ID0gVihndCA9IG10LCBodCwgUHQpKS5mID0gd2UoaHQpLmYgKyBodC5hLmYsIGh0LmQgPSBHKGd0LCBodC5mKSksIG90KG10LCBqdCkpIDogWChtdCwgaHQsIGp0LmMsIGp0LmMsIG51bGwsICEwKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBodCA9IChndCA9IFJlKG10ID0gRihtdC5pKSkpLmEsIChndCA9IFcoYnQsIGd0LCBudWxsKSkuYyA9PT0gaHQgPyAoZ3QgPSAoaHQgPSBndCkuYywgRnQgPSBSZShtdCksIFB0ID0gbXQuYSwgRHQgPSBGdC5hLCBNdCA9ICExLCBQdC5iLmEgIT09IER0LmIuYSAmJiBCKGJ0LCBtdCksIHkoUHQuYSwgYnQuYSkgJiYgKGwoZ3QuYi5lLCBQdCksIGd0ID0gUmUobXQgPSBGKG10KSkuYSwgVyhidCwgUmUobXQpLCBGdCksIE10ID0gITApLCB5KER0LmEsIGJ0LmEpICYmIChsKGh0LCBEdC5iLmUpLCBodCA9IFcoYnQsIEZ0LCBudWxsKSwgTXQgPSAhMCksIE10ID8gWChidCwgbXQsIGh0LmMsIGd0LCBndCwgITApIDogKGp0ID0gdShEdC5hLCBQdC5hKSA/IER0LmIuZSA6IFB0LCBYKGJ0LCBtdCwganQgPSBjKGh0LmMuYiwganQpLCBqdC5jLCBqdC5jLCAhMSksIGp0LmIuaS5jID0gITAsIFkoYnQsIG10KSkpIDogWChidCwgbXQsIGd0LmMsIGh0LCBodCwgITApO1xuICAgICAgICAgIH0pKHRoaXMsIENlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHRoaXMuYSA9IHRoaXMuZi5hLmEuYi5hLmEsIENlID0gMDsgKGplID0gdGhpcy5mLmEuYS5iKSAhPT0gbnVsbDsgKVxuICAgICAgICAgIGplLmggfHwgKytDZSwgUihqZSk7XG4gICAgICAgIGZvciAodGhpcy5mID0gbnVsbCwgKENlID0gdGhpcy5lKS5iID0gbnVsbCwgQ2UuZCA9IG51bGwsIHRoaXMuZSA9IENlLmMgPSBudWxsLCBDZSA9IHRoaXMuYiwgcSA9IENlLmEuYjsgcSAhPT0gQ2UuYTsgcSA9IGplKVxuICAgICAgICAgIGplID0gcS5iLCAocSA9IHEuYSkuZS5lID09PSBxICYmIChQKHEuYywgcSksIG4ocSkpO1xuICAgICAgICBpZiAoIXRoaXMubikge1xuICAgICAgICAgIGlmIChDZSA9IHRoaXMuYiwgdGhpcy5tKVxuICAgICAgICAgICAgZm9yIChxID0gQ2UuYi5oOyBxICE9PSBDZS5iOyBxID0gamUpXG4gICAgICAgICAgICAgIGplID0gcS5oLCBxLmIuZC5jICE9PSBxLmQuYyA/IHEuZiA9IHEuZC5jID8gMSA6IC0xIDogbihxKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKHEgPSBDZS5hLmI7IHEgIT09IENlLmE7IHEgPSBqZSlcbiAgICAgICAgICAgICAgaWYgKGplID0gcS5iLCBxLmMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHEgPSBxLmE7IHUocS5iLmEsIHEuYSk7IHEgPSBxLmMuYilcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgdShxLmEsIHEuYi5hKTsgcSA9IHEuZSlcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmb3IgKGVlID0gcS5jLmIsIHBlID0gdm9pZCAwOyBxLmUgIT09IGVlOyApXG4gICAgICAgICAgICAgICAgICBpZiAodShxLmIuYSwgZWUuYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGVlLmUgIT09IHEgJiYgKHUoKCQgPSBlZS5lKS5iLmEsICQuYSkgfHwgZyhlZS5hLCBlZS5iLmEsIGVlLmUuYi5hKSA8PSAwKTsgKVxuICAgICAgICAgICAgICAgICAgICAgIGVlID0gKHBlID0gYyhlZS5lLCBlZSkpLmI7XG4gICAgICAgICAgICAgICAgICAgIGVlID0gZWUuYy5iO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGVlLmUgIT09IHEgJiYgKHUoKFogPSBxLmMuYikuYSwgWi5iLmEpIHx8IDAgPD0gZyhxLmIuYSwgcS5hLCBxLmMuYi5hKSk7IClcbiAgICAgICAgICAgICAgICAgICAgICBxID0gKHBlID0gYyhxLCBxLmMuYikpLmI7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLmU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICg7IGVlLmUuZSAhPT0gcTsgKVxuICAgICAgICAgICAgICAgICAgcGUgPSBjKGVlLmUsIGVlKSwgZWUgPSBwZS5iO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaCB8fCB0aGlzLmkgfHwgdGhpcy5rIHx8IHRoaXMubClcbiAgICAgICAgICAgIGlmICh0aGlzLm0pIHtcbiAgICAgICAgICAgICAgZm9yIChqZSA9IChDZSA9IHRoaXMuYikuYS5iOyBqZSAhPT0gQ2UuYTsgamUgPSBqZS5iKVxuICAgICAgICAgICAgICAgIGlmIChqZS5jKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHRoaXMuaCAmJiB0aGlzLmgoMiwgdGhpcy5jKSwgcSA9IGplLmE7IHRoaXMuayAmJiB0aGlzLmsocS5hLmQsIHRoaXMuYyksIChxID0gcS5lKSAhPT0gamUuYTsgKVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICB0aGlzLmkgJiYgdGhpcy5pKHRoaXMuYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChDZSA9IHRoaXMuYiwgamUgPSAhIXRoaXMubCwgcSA9ICExLCBlZSA9IC0xLCBwZSA9IENlLmEuZDsgcGUgIT09IENlLmE7IHBlID0gcGUuZClcbiAgICAgICAgICAgICAgICBpZiAocGUuYylcbiAgICAgICAgICAgICAgICAgIGZvciAocSB8fCAodGhpcy5oICYmIHRoaXMuaCg0LCB0aGlzLmMpLCBxID0gITApLCBOZSA9IHBlLmE7IGplICYmIChGZSA9IE5lLmIuZC5jID8gMCA6IDEsIGVlICE9PSBGZSAmJiAoZWUgPSBGZSwgdGhpcy5sICYmIHRoaXMubCghIWVlLCB0aGlzLmMpKSksIHRoaXMuayAmJiB0aGlzLmsoTmUuYS5kLCB0aGlzLmMpLCAoTmUgPSBOZS5lKSAhPT0gcGUuYTsgKVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIHEgJiYgdGhpcy5pICYmIHRoaXMuaSh0aGlzLmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgICAgIGZvciAoQ2UgPSB0aGlzLmIsIHEgPSBDZS5hLmI7IHEgIT09IENlLmE7IHEgPSBqZSlcbiAgICAgICAgICAgICAgaWYgKGplID0gcS5iLCAhcS5jKSB7XG4gICAgICAgICAgICAgICAgZm9yIChwZSA9IChlZSA9IHEuYSkuZSwgTmUgPSB2b2lkIDA7IHBlID0gKE5lID0gcGUpLmUsIChOZS5kID0gbnVsbCkgPT09IE5lLmIuZCAmJiAoTmUuYyA9PT0gTmUgPyBFKE5lLmEsIG51bGwpIDogKE5lLmEuYyA9IE5lLmMsIGooTmUsIE5lLmIuZSkpLCAoRmUgPSBOZS5iKS5jID09PSBGZSA/IEUoRmUuYSwgbnVsbCkgOiAoRmUuYS5jID0gRmUuYywgaihGZSwgRmUuYi5lKSksIFMoTmUpKSwgTmUgIT09IGVlOyApXG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZWUgPSBxLmQsICgocSA9IHEuYikuZCA9IGVlKS5iID0gcTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucih0aGlzLmIpLCB2b2lkICh0aGlzLmMgPSB0aGlzLmIgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iID0gdGhpcy5jID0gbnVsbDtcbiAgICAgIH0sIHRoaXMubGlidGVzcyA9IHsgR2x1VGVzc2VsYXRvcjogdWUsIHdpbmRpbmdSdWxlOiB7IEdMVV9URVNTX1dJTkRJTkdfT0REOiAxMDAxMzAsIEdMVV9URVNTX1dJTkRJTkdfTk9OWkVSTzogMTAwMTMxLCBHTFVfVEVTU19XSU5ESU5HX1BPU0lUSVZFOiAxMDAxMzIsIEdMVV9URVNTX1dJTkRJTkdfTkVHQVRJVkU6IDEwMDEzMywgR0xVX1RFU1NfV0lORElOR19BQlNfR0VRX1RXTzogMTAwMTM0IH0sIHByaW1pdGl2ZVR5cGU6IHsgR0xfTElORV9MT09QOiAyLCBHTF9UUklBTkdMRVM6IDQsIEdMX1RSSUFOR0xFX1NUUklQOiA1LCBHTF9UUklBTkdMRV9GQU46IDYgfSwgZXJyb3JUeXBlOiB7IEdMVV9URVNTX01JU1NJTkdfQkVHSU5fUE9MWUdPTjogMTAwMTUxLCBHTFVfVEVTU19NSVNTSU5HX0VORF9QT0xZR09OOiAxMDAxNTMsIEdMVV9URVNTX01JU1NJTkdfQkVHSU5fQ09OVE9VUjogMTAwMTUyLCBHTFVfVEVTU19NSVNTSU5HX0VORF9DT05UT1VSOiAxMDAxNTQsIEdMVV9URVNTX0NPT1JEX1RPT19MQVJHRTogMTAwMTU1LCBHTFVfVEVTU19ORUVEX0NPTUJJTkVfQ0FMTEJBQ0s6IDEwMDE1NiB9LCBnbHVFbnVtOiB7IEdMVV9URVNTX01FU0g6IDEwMDExMiwgR0xVX1RFU1NfVE9MRVJBTkNFOiAxMDAxNDIsIEdMVV9URVNTX1dJTkRJTkdfUlVMRTogMTAwMTQwLCBHTFVfVEVTU19CT1VOREFSWV9PTkxZOiAxMDAxNDEsIEdMVV9JTlZBTElEX0VOVU06IDEwMDkwMCwgR0xVX0lOVkFMSURfVkFMVUU6IDEwMDkwMSwgR0xVX1RFU1NfQkVHSU46IDEwMDEwMCwgR0xVX1RFU1NfVkVSVEVYOiAxMDAxMDEsIEdMVV9URVNTX0VORDogMTAwMTAyLCBHTFVfVEVTU19FUlJPUjogMTAwMTAzLCBHTFVfVEVTU19FREdFX0ZMQUc6IDEwMDEwNCwgR0xVX1RFU1NfQ09NQklORTogMTAwMTA1LCBHTFVfVEVTU19CRUdJTl9EQVRBOiAxMDAxMDYsIEdMVV9URVNTX1ZFUlRFWF9EQVRBOiAxMDAxMDcsIEdMVV9URVNTX0VORF9EQVRBOiAxMDAxMDgsIEdMVV9URVNTX0VSUk9SX0RBVEE6IDEwMDEwOSwgR0xVX1RFU1NfRURHRV9GTEFHX0RBVEE6IDEwMDExMCwgR0xVX1RFU1NfQ09NQklORV9EQVRBOiAxMDAxMTEgfSB9LCB1ZS5wcm90b3R5cGUuZ2x1RGVsZXRlVGVzcyA9IHVlLnByb3RvdHlwZS54LCB1ZS5wcm90b3R5cGUuZ2x1VGVzc1Byb3BlcnR5ID0gdWUucHJvdG90eXBlLkIsIHVlLnByb3RvdHlwZS5nbHVHZXRUZXNzUHJvcGVydHkgPSB1ZS5wcm90b3R5cGUueSwgdWUucHJvdG90eXBlLmdsdVRlc3NOb3JtYWwgPSB1ZS5wcm90b3R5cGUuQSwgdWUucHJvdG90eXBlLmdsdVRlc3NDYWxsYmFjayA9IHVlLnByb3RvdHlwZS56LCB1ZS5wcm90b3R5cGUuZ2x1VGVzc1ZlcnRleCA9IHVlLnByb3RvdHlwZS5DLCB1ZS5wcm90b3R5cGUuZ2x1VGVzc0JlZ2luUG9seWdvbiA9IHVlLnByb3RvdHlwZS51LCB1ZS5wcm90b3R5cGUuZ2x1VGVzc0JlZ2luQ29udG91ciA9IHVlLnByb3RvdHlwZS50LCB1ZS5wcm90b3R5cGUuZ2x1VGVzc0VuZENvbnRvdXIgPSB1ZS5wcm90b3R5cGUudiwgdWUucHJvdG90eXBlLmdsdVRlc3NFbmRQb2x5Z29uID0gdWUucHJvdG90eXBlLncsIEggIT09IHZvaWQgMCAmJiAoSC5leHBvcnRzID0gdGhpcy5saWJ0ZXNzKTtcbiAgICB9LCB7fV0sIDI1MzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0odSwgaCwgZywgZikge1xuICAgICAgICB2YXIgciA9IDAsIHMgPSAoZiA9IGYgPT09IHZvaWQgMCA/IHt9IDogZikubG9vcCA9PT0gdm9pZCAwID8gbnVsbCA6IGYubG9vcCwgbyA9IGYucGFsZXR0ZSA9PT0gdm9pZCAwID8gbnVsbCA6IGYucGFsZXR0ZTtcbiAgICAgICAgaWYgKGggPD0gMCB8fCBnIDw9IDAgfHwgNjU1MzUgPCBoIHx8IDY1NTM1IDwgZylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIik7XG4gICAgICAgIGZ1bmN0aW9uIGkoXykge1xuICAgICAgICAgIGlmIChfID0gXy5sZW5ndGgsIF8gPCAyIHx8IDI1NiA8IF8gfHwgXyAmIF8gLSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgIH1cbiAgICAgICAgdVtyKytdID0gNzEsIHVbcisrXSA9IDczLCB1W3IrK10gPSA3MCwgdVtyKytdID0gNTYsIHVbcisrXSA9IDU3LCB1W3IrK10gPSA5NztcbiAgICAgICAgdmFyIGwgPSAwLCBuID0gMDtcbiAgICAgICAgaWYgKG8gIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gaShvKTsgYSA+Pj0gMTsgKVxuICAgICAgICAgICAgKytsO1xuICAgICAgICAgIGlmIChhID0gMSA8PCBsLCAtLWwsIGYuYmFja2dyb3VuZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoYSA8PSAobiA9IGYuYmFja2dyb3VuZCkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IGV4cGxpY2l0bHkgcGFzc2VkIGFzIDAuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodVtyKytdID0gMjU1ICYgaCwgdVtyKytdID0gaCA+PiA4ICYgMjU1LCB1W3IrK10gPSAyNTUgJiBnLCB1W3IrK10gPSBnID4+IDggJiAyNTUsIHVbcisrXSA9IChvICE9PSBudWxsID8gMTI4IDogMCkgfCBsLCB1W3IrK10gPSBuLCB1W3IrK10gPSAwLCBvICE9PSBudWxsKVxuICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBwID0gby5sZW5ndGg7IGMgPCBwOyArK2MpIHtcbiAgICAgICAgICAgIHZhciBqID0gb1tjXTtcbiAgICAgICAgICAgIHVbcisrXSA9IGogPj4gMTYgJiAyNTUsIHVbcisrXSA9IGogPj4gOCAmIDI1NSwgdVtyKytdID0gMjU1ICYgajtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHMgPCAwIHx8IDY1NTM1IDwgcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3AgY291bnQgaW52YWxpZC5cIik7XG4gICAgICAgICAgdVtyKytdID0gMzMsIHVbcisrXSA9IDI1NSwgdVtyKytdID0gMTEsIHVbcisrXSA9IDc4LCB1W3IrK10gPSA2OSwgdVtyKytdID0gODQsIHVbcisrXSA9IDgzLCB1W3IrK10gPSA2NywgdVtyKytdID0gNjUsIHVbcisrXSA9IDgwLCB1W3IrK10gPSA2OSwgdVtyKytdID0gNTAsIHVbcisrXSA9IDQ2LCB1W3IrK10gPSA0OCwgdVtyKytdID0gMywgdVtyKytdID0gMSwgdVtyKytdID0gMjU1ICYgcywgdVtyKytdID0gcyA+PiA4ICYgMjU1LCB1W3IrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBUID0gITE7XG4gICAgICAgIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbihfLCBTLCBFLCBBLCB4LCBQKSB7XG4gICAgICAgICAgaWYgKFQgPT09ICEwICYmICgtLXIsIFQgPSAhMSksIFAgPSBQID09PSB2b2lkIDAgPyB7fSA6IFAsIF8gPCAwIHx8IFMgPCAwIHx8IDY1NTM1IDwgXyB8fCA2NTUzNSA8IFMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4L3kgaW52YWxpZC5cIik7XG4gICAgICAgICAgaWYgKEUgPD0gMCB8fCBBIDw9IDAgfHwgNjU1MzUgPCBFIHx8IDY1NTM1IDwgQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKTtcbiAgICAgICAgICBpZiAoeC5sZW5ndGggPCBFICogQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggcGl4ZWxzIGZvciB0aGUgZnJhbWUgc2l6ZS5cIik7XG4gICAgICAgICAgdmFyIE0gPSAhMCwgUiA9IFAucGFsZXR0ZTtcbiAgICAgICAgICBpZiAoUiA9PSBudWxsICYmIChNID0gITEsIFIgPSBvKSwgUiA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgZWl0aGVyIGEgbG9jYWwgb3IgZ2xvYmFsIHBhbGV0dGUuXCIpO1xuICAgICAgICAgIGZvciAodmFyIEYgPSBpKFIpLCBMID0gMDsgRiA+Pj0gMTsgKVxuICAgICAgICAgICAgKytMO1xuICAgICAgICAgIHZhciBGID0gMSA8PCBMLCBWID0gUC5kZWxheSA9PT0gdm9pZCAwID8gMCA6IFAuZGVsYXksIEcgPSBQLmRpc3Bvc2FsID09PSB2b2lkIDAgPyAwIDogUC5kaXNwb3NhbDtcbiAgICAgICAgICBpZiAoRyA8IDAgfHwgMyA8IEcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNwb3NhbCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgICAgICAgIHZhciBVID0gITEsIFcgPSAwO1xuICAgICAgICAgIGlmIChQLnRyYW5zcGFyZW50ICE9PSB2b2lkIDAgJiYgUC50cmFuc3BhcmVudCAhPT0gbnVsbCAmJiAoVSA9ICEwLCAoVyA9IFAudHJhbnNwYXJlbnQpIDwgMCB8fCBGIDw9IFcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXCIpO1xuICAgICAgICAgIGlmIChHID09PSAwICYmICFVICYmIFYgPT09IDAgfHwgKHVbcisrXSA9IDMzLCB1W3IrK10gPSAyNDksIHVbcisrXSA9IDQsIHVbcisrXSA9IEcgPDwgMiB8IChVID09PSAhMCA/IDEgOiAwKSwgdVtyKytdID0gMjU1ICYgViwgdVtyKytdID0gViA+PiA4ICYgMjU1LCB1W3IrK10gPSBXLCB1W3IrK10gPSAwKSwgdVtyKytdID0gNDQsIHVbcisrXSA9IDI1NSAmIF8sIHVbcisrXSA9IF8gPj4gOCAmIDI1NSwgdVtyKytdID0gMjU1ICYgUywgdVtyKytdID0gUyA+PiA4ICYgMjU1LCB1W3IrK10gPSAyNTUgJiBFLCB1W3IrK10gPSBFID4+IDggJiAyNTUsIHVbcisrXSA9IDI1NSAmIEEsIHVbcisrXSA9IEEgPj4gOCAmIDI1NSwgdVtyKytdID0gTSA9PT0gITAgPyAxMjggfCBMIC0gMSA6IDAsIE0gPT09ICEwKVxuICAgICAgICAgICAgZm9yICh2YXIgWCA9IDAsIG5lID0gUi5sZW5ndGg7IFggPCBuZTsgKytYKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gUltYXTtcbiAgICAgICAgICAgICAgdVtyKytdID0gYiA+PiAxNiAmIDI1NSwgdVtyKytdID0gYiA+PiA4ICYgMjU1LCB1W3IrK10gPSAyNTUgJiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByID0gZnVuY3Rpb24oTywgRCwgQiwgWSkge1xuICAgICAgICAgICAgT1tEKytdID0gQjtcbiAgICAgICAgICAgIHZhciBKID0gRCsrLCB0ZSA9IDEgPDwgQiwgY2UgPSB0ZSAtIDEsIHJlID0gMSArIHRlLCB1ZSA9IDEgKyByZSwgbGUgPSBCICsgMSwgSyA9IDAsIGFlID0gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhlKFZlKSB7XG4gICAgICAgICAgICAgIGZvciAoOyBWZSA8PSBLOyApXG4gICAgICAgICAgICAgICAgT1tEKytdID0gMjU1ICYgYWUsIGFlID4+PSA4LCBLIC09IDgsIEQgPT09IEogKyAyNTYgJiYgKE9bSl0gPSAyNTUsIEogPSBEKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX2UoVmUpIHtcbiAgICAgICAgICAgICAgYWUgfD0gVmUgPDwgSywgSyArPSBsZSwgaGUoOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmUgPSBZWzBdICYgY2UsIGdlID0ge307XG4gICAgICAgICAgICBfZSh0ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciB4ZSA9IDEsIERlID0gWS5sZW5ndGg7IHhlIDwgRGU7ICsreGUpIHtcbiAgICAgICAgICAgICAgdmFyIE1lID0gWVt4ZV0gJiBjZSwgUWUgPSBmZSA8PCA4IHwgTWUsIHplID0gZ2VbUWVdO1xuICAgICAgICAgICAgICBpZiAoemUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGZvciAoYWUgfD0gZmUgPDwgSywgSyArPSBsZTsgOCA8PSBLOyApXG4gICAgICAgICAgICAgICAgICBPW0QrK10gPSAyNTUgJiBhZSwgYWUgPj49IDgsIEsgLT0gOCwgRCA9PT0gSiArIDI1NiAmJiAoT1tKXSA9IDI1NSwgSiA9IEQrKyk7XG4gICAgICAgICAgICAgICAgdWUgPT09IDQwOTYgPyAoX2UodGUpLCB1ZSA9IDEgKyByZSwgbGUgPSBCICsgMSwgZ2UgPSB7fSkgOiAoMSA8PCBsZSA8PSB1ZSAmJiArK2xlLCBnZVtRZV0gPSB1ZSsrKSwgZmUgPSBNZTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZmUgPSB6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfZShmZSksIF9lKHJlKSwgaGUoMSksIEogKyAxID09PSBEID8gT1tKXSA9IDAgOiAoT1tKXSA9IEQgLSBKIC0gMSwgT1tEKytdID0gMCksIEQ7XG4gICAgICAgICAgfSh1LCByLCBMIDwgMiA/IDIgOiBMLCB4KTtcbiAgICAgICAgfSwgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gVCA9PT0gITEgJiYgKHVbcisrXSA9IDU5LCBUID0gITApLCByO1xuICAgICAgICB9LCB0aGlzLmdldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICB9LCB0aGlzLnNldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICB1ID0gXztcbiAgICAgICAgfSwgdGhpcy5nZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCB0aGlzLnNldE91dHB1dEJ1ZmZlclBvc2l0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgIHIgPSBfO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geSh1LCBoLCBnLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSB1W2grK10sIHMgPSAxIDw8IHIsIG8gPSAxICsgcywgaSA9IDEgKyBvLCBsID0gciArIDEsIG4gPSAoMSA8PCBsKSAtIDEsIGEgPSAwLCBjID0gMCwgcCA9IDAsIGogPSB1W2grK10sIFQgPSBuZXcgSW50MzJBcnJheSg0MDk2KSwgXyA9IG51bGw7IDsgKSB7XG4gICAgICAgICAgZm9yICg7IGEgPCAxNiAmJiBqICE9PSAwOyApXG4gICAgICAgICAgICBjIHw9IHVbaCsrXSA8PCBhLCBhICs9IDgsIGogPT09IDEgPyBqID0gdVtoKytdIDogLS1qO1xuICAgICAgICAgIGlmIChhIDwgbClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHZhciBTID0gYyAmIG47XG4gICAgICAgICAgaWYgKGMgPj49IGwsIGEgLT0gbCwgUyA9PSBzKVxuICAgICAgICAgICAgaSA9IDEgKyBvLCBuID0gKDEgPDwgKGwgPSByICsgMSkpIC0gMSwgXyA9IG51bGw7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoUyA9PSBvKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGZvciAodmFyIEUgPSBTIDwgaSA/IFMgOiBfLCBBID0gMCwgeCA9IEU7IHMgPCB4OyApXG4gICAgICAgICAgICAgIHggPSBUW3hdID4+IDgsICsrQTtcbiAgICAgICAgICAgIHZhciBQID0geDtcbiAgICAgICAgICAgIGlmIChmIDwgcCArIEEgKyAoRSAhPT0gUyA/IDEgOiAwKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgIGdbcCsrXSA9IFA7XG4gICAgICAgICAgICB2YXIgTSA9IHAgKz0gQTtcbiAgICAgICAgICAgIGZvciAoRSAhPT0gUyAmJiAoZ1twKytdID0gUCksIHggPSBFOyBBLS07IClcbiAgICAgICAgICAgICAgeCA9IFRbeF0sIGdbLS1NXSA9IDI1NSAmIHgsIHggPj49IDg7XG4gICAgICAgICAgICBfICE9PSBudWxsICYmIGkgPCA0MDk2ICYmIChUW2krK10gPSBfIDw8IDggfCBQLCBuICsgMSA8PSBpICYmIGwgPCAxMiAmJiAoKytsLCBuID0gbiA8PCAxIHwgMSkpLCBfID0gUztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCAhPT0gZiAmJiBjb25zb2xlLmxvZyhcIldhcm5pbmcsIGdpZiBzdHJlYW0gc2hvcnRlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIEMuR2lmV3JpdGVyID0gbSwgQy5HaWZSZWFkZXIgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdmFyIGggPSAwO1xuICAgICAgICAgIGlmICh1W2grK10gIT09IDcxIHx8IHVbaCsrXSAhPT0gNzMgfHwgdVtoKytdICE9PSA3MCB8fCB1W2grK10gIT09IDU2IHx8ICh1W2grK10gKyAxICYgMjUzKSAhPSA1NiB8fCB1W2grK10gIT09IDk3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHSUYgODdhLzg5YSBoZWFkZXIuXCIpO1xuICAgICAgICAgIHZhciBnID0gdVtoKytdIHwgdVtoKytdIDw8IDgsIGYgPSB1W2grK10gfCB1W2grK10gPDwgOCwgciA9IHVbaCsrXSwgcyA9IDEgPDwgMSArICg3ICYgciksIG8gPSAodVtoKytdLCB1W2grK10sIG51bGwpLCBpID0gbnVsbCwgbCA9IChyID4+IDcgJiYgKG8gPSBoLCBoICs9IDMgKiAoaSA9IHMpKSwgITApLCBuID0gW10sIGEgPSAwLCBjID0gbnVsbCwgcCA9IDAsIGogPSBudWxsO1xuICAgICAgICAgIGZvciAodGhpcy53aWR0aCA9IGcsIHRoaXMuaGVpZ2h0ID0gZjsgbCAmJiBoIDwgdS5sZW5ndGg7IClcbiAgICAgICAgICAgIHN3aXRjaCAodVtoKytdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgICAgc3dpdGNoICh1W2grK10pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodVtoXSAhPT0gMTEgfHwgdVtoICsgMV0gPT0gNzggJiYgdVtoICsgMl0gPT0gNjkgJiYgdVtoICsgM10gPT0gODQgJiYgdVtoICsgNF0gPT0gODMgJiYgdVtoICsgNV0gPT0gNjcgJiYgdVtoICsgNl0gPT0gNjUgJiYgdVtoICsgN10gPT0gODAgJiYgdVtoICsgOF0gPT0gNjkgJiYgdVtoICsgOV0gPT0gNTAgJiYgdVtoICsgMTBdID09IDQ2ICYmIHVbaCArIDExXSA9PSA0OCAmJiB1W2ggKyAxMl0gPT0gMyAmJiB1W2ggKyAxM10gPT0gMSAmJiB1W2ggKyAxNl0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICBoICs9IDE0LCBqID0gdVtoKytdIHwgdVtoKytdIDw8IDgsIGgrKztcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaCArPSAxMjsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAgPD0gKF8gPSB1W2grK10pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBoICs9IF87XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjQ5OlxuICAgICAgICAgICAgICAgICAgICBpZiAodVtoKytdICE9PSA0IHx8IHVbaCArIDRdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSB1W2grK10sIGEgPSB1W2grK10gfCB1W2grK10gPDwgOCwgYyA9IHVbaCsrXTtcbiAgICAgICAgICAgICAgICAgICAgISgxICYgVCkgJiYgKGMgPSBudWxsKSwgcCA9IFQgPj4gMiAmIDcsIGgrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI1NDpcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCA8PSAoXyA9IHVbaCsrXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF8gPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBoICs9IF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdyYXBoaWMgY29udHJvbCBsYWJlbDogMHhcIiArIHVbaCAtIDFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIHZhciBfLCBTID0gdVtoKytdIHwgdVtoKytdIDw8IDgsIEUgPSB1W2grK10gfCB1W2grK10gPDwgOCwgQSA9IHVbaCsrXSB8IHVbaCsrXSA8PCA4LCB4ID0gdVtoKytdIHwgdVtoKytdIDw8IDgsIFYgPSB1W2grK10sIFAgPSBWID4+IDYgJiAxLCBNID0gMSA8PCAxICsgKDcgJiBWKSwgUiA9IG8sIEwgPSBpLCBGID0gITEsIFYgPSAoViA+PiA3ICYmIChGID0gITAsIFIgPSBoLCBoICs9IDMgKiAoTCA9IE0pKSwgaCk7XG4gICAgICAgICAgICAgICAgZm9yIChoKys7IDsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISgwIDw9IChfID0gdVtoKytdKSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKF8gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgaCArPSBfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuLnB1c2goeyB4OiBTLCB5OiBFLCB3aWR0aDogQSwgaGVpZ2h0OiB4LCBoYXNfbG9jYWxfcGFsZXR0ZTogRiwgcGFsZXR0ZV9vZmZzZXQ6IFIsIHBhbGV0dGVfc2l6ZTogTCwgZGF0YV9vZmZzZXQ6IFYsIGRhdGFfbGVuZ3RoOiBoIC0gViwgdHJhbnNwYXJlbnRfaW5kZXg6IGMsIGludGVybGFjZWQ6ICEhUCwgZGVsYXk6IGEsIGRpc3Bvc2FsOiBwIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICAgIGwgPSAhMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIHVbaCAtIDFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5udW1GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuLmxlbmd0aDtcbiAgICAgICAgICB9LCB0aGlzLmxvb3BDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgICAgfSwgdGhpcy5mcmFtZUluZm8gPSBmdW5jdGlvbihHKSB7XG4gICAgICAgICAgICBpZiAoRyA8IDAgfHwgRyA+PSBuLmxlbmd0aClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBuW0ddO1xuICAgICAgICAgIH0sIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSA9IGZ1bmN0aW9uKEcsIFUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIEcgPSB0aGlzLmZyYW1lSW5mbyhHKSwgVyA9IEcud2lkdGggKiBHLmhlaWdodCwgWCA9IG5ldyBVaW50OEFycmF5KFcpLCBuZSA9ICh5KHUsIEcuZGF0YV9vZmZzZXQsIFgsIFcpLCBHLnBhbGV0dGVfb2Zmc2V0KSwgYiA9IEcudHJhbnNwYXJlbnRfaW5kZXgsIE8gPSAoYiA9PT0gbnVsbCAmJiAoYiA9IDI1NiksIEcud2lkdGgpLCBEID0gZyAtIE8sIEIgPSBPLCBZID0gNCAqIChHLnkgKiBnICsgRy54KSwgSiA9IDQgKiAoKEcueSArIEcuaGVpZ2h0KSAqIGcgKyBHLngpLCB0ZSA9IFksIGNlID0gNCAqIEQsIHJlID0gKEcuaW50ZXJsYWNlZCA9PT0gITAgJiYgKGNlICs9IDQgKiBnICogNyksIDgpLCB1ZSA9IDAsIGxlID0gWC5sZW5ndGg7IHVlIDwgbGU7ICsrdWUpIHtcbiAgICAgICAgICAgICAgdmFyIEssIGFlLCBoZSA9IFhbdWVdO1xuICAgICAgICAgICAgICBCID09PSAwICYmIChCID0gTywgSiA8PSAodGUgKz0gY2UpICYmIChjZSA9IDQgKiBEICsgNCAqIGcgKiAocmUgLSAxKSwgdGUgPSBZICsgKE8gKyBEKSAqIChyZSA8PCAxKSwgcmUgPj49IDEpKSwgaGUgPT09IGIgPyB0ZSArPSA0IDogKEsgPSB1W25lICsgMyAqIGhlXSwgYWUgPSB1W25lICsgMyAqIGhlICsgMV0sIGhlID0gdVtuZSArIDMgKiBoZSArIDJdLCBVW3RlKytdID0gaGUsIFVbdGUrK10gPSBhZSwgVVt0ZSsrXSA9IEssIFVbdGUrK10gPSAyNTUpLCAtLUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBID0gZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgZm9yICh2YXIgRyA9IHRoaXMuZnJhbWVJbmZvKEcpLCBXID0gRy53aWR0aCAqIEcuaGVpZ2h0LCBYID0gbmV3IFVpbnQ4QXJyYXkoVyksIG5lID0gKHkodSwgRy5kYXRhX29mZnNldCwgWCwgVyksIEcucGFsZXR0ZV9vZmZzZXQpLCBiID0gRy50cmFuc3BhcmVudF9pbmRleCwgTyA9IChiID09PSBudWxsICYmIChiID0gMjU2KSwgRy53aWR0aCksIEQgPSBnIC0gTywgQiA9IE8sIFkgPSA0ICogKEcueSAqIGcgKyBHLngpLCBKID0gNCAqICgoRy55ICsgRy5oZWlnaHQpICogZyArIEcueCksIHRlID0gWSwgY2UgPSA0ICogRCwgcmUgPSAoRy5pbnRlcmxhY2VkID09PSAhMCAmJiAoY2UgKz0gNCAqIGcgKiA3KSwgOCksIHVlID0gMCwgbGUgPSBYLmxlbmd0aDsgdWUgPCBsZTsgKyt1ZSkge1xuICAgICAgICAgICAgICB2YXIgSywgYWUsIGhlID0gWFt1ZV07XG4gICAgICAgICAgICAgIEIgPT09IDAgJiYgKEIgPSBPLCBKIDw9ICh0ZSArPSBjZSkgJiYgKGNlID0gNCAqIEQgKyA0ICogZyAqIChyZSAtIDEpLCB0ZSA9IFkgKyAoTyArIEQpICogKHJlIDw8IDEpLCByZSA+Pj0gMSkpLCBoZSA9PT0gYiA/IHRlICs9IDQgOiAoSyA9IHVbbmUgKyAzICogaGVdLCBhZSA9IHVbbmUgKyAzICogaGUgKyAxXSwgaGUgPSB1W25lICsgMyAqIGhlICsgMl0sIFVbdGUrK10gPSBLLCBVW3RlKytdID0gYWUsIFVbdGUrK10gPSBoZSwgVVt0ZSsrXSA9IDI1NSksIC0tQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfSwge31dLCAyNTQ6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICAoZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeSwgdTtcbiAgICAgICAgeSA9IHRoaXMsIHUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZyhJKSB7XG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIHZhciB2LCB3ID0gU3RyaW5nKHRoaXMpLCBrID0gdy5sZW5ndGgsIEkgPSBJID8gTnVtYmVyKEkpIDogMDtcbiAgICAgICAgICAgIGlmICghKChJID0gSSAhPSBJID8gMCA6IEkpIDwgMCB8fCBrIDw9IEkpKVxuICAgICAgICAgICAgICByZXR1cm4gNTUyOTYgPD0gKHYgPSB3LmNoYXJDb2RlQXQoSSkpICYmIHYgPD0gNTYzMTkgJiYgSSArIDEgPCBrICYmIDU2MzIwIDw9IChrID0gdy5jaGFyQ29kZUF0KEkgKyAxKSkgJiYgayA8PSA1NzM0MyA/IDEwMjQgKiAodiAtIDU1Mjk2KSArIGsgLSA1NjMyMCArIDY1NTM2IDogdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCB8fCAoKGYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBkID0ge30sIHYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHcgPSB2KGQsIGQsIGQpICYmIHY7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH0oKSkgPyBmKFN0cmluZy5wcm90b3R5cGUsIFwiY29kZVBvaW50QXRcIiwgeyB2YWx1ZTogZywgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGcpO1xuICAgICAgICAgIHZhciBmLCByID0gMCwgcyA9IC0zO1xuICAgICAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gbmV3IFVpbnQxNkFycmF5KDE2KSwgdGhpcy50cmFucyA9IG5ldyBVaW50MTZBcnJheSgyODgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBpKGQsIHYpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gZCwgdGhpcy5zb3VyY2VJbmRleCA9IDAsIHRoaXMudGFnID0gMCwgdGhpcy5iaXRjb3VudCA9IDAsIHRoaXMuZGVzdCA9IHYsIHRoaXMuZGVzdExlbiA9IDAsIHRoaXMubHRyZWUgPSBuZXcgbygpLCB0aGlzLmR0cmVlID0gbmV3IG8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGwgPSBuZXcgbygpLCBuID0gbmV3IG8oKSwgYSA9IG5ldyBVaW50OEFycmF5KDMwKSwgYyA9IG5ldyBVaW50MTZBcnJheSgzMCksIHAgPSBuZXcgVWludDhBcnJheSgzMCksIGogPSBuZXcgVWludDE2QXJyYXkoMzApLCBUID0gbmV3IFVpbnQ4QXJyYXkoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKSwgXyA9IG5ldyBvKCksIFMgPSBuZXcgVWludDhBcnJheSgzMjApO1xuICAgICAgICAgIGZ1bmN0aW9uIEUoZCwgdiwgdywgaykge1xuICAgICAgICAgICAgZm9yICh2YXIgSSwgTiA9IDA7IE4gPCB3OyArK04pXG4gICAgICAgICAgICAgIGRbTl0gPSAwO1xuICAgICAgICAgICAgZm9yIChOID0gMDsgTiA8IDMwIC0gdzsgKytOKVxuICAgICAgICAgICAgICBkW04gKyB3XSA9IE4gLyB3IHwgMDtcbiAgICAgICAgICAgIGZvciAoSSA9IGssIE4gPSAwOyBOIDwgMzA7ICsrTilcbiAgICAgICAgICAgICAgdltOXSA9IEksIEkgKz0gMSA8PCBkW05dO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgQSA9IG5ldyBVaW50MTZBcnJheSgxNik7XG4gICAgICAgICAgZnVuY3Rpb24geChkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBJLCBOID0gMDsgTiA8IDE2OyArK04pXG4gICAgICAgICAgICAgIGQudGFibGVbTl0gPSAwO1xuICAgICAgICAgICAgZm9yIChOID0gMDsgTiA8IGs7ICsrTilcbiAgICAgICAgICAgICAgZC50YWJsZVt2W3cgKyBOXV0rKztcbiAgICAgICAgICAgIGZvciAoTiA9IEkgPSBkLnRhYmxlWzBdID0gMDsgTiA8IDE2OyArK04pXG4gICAgICAgICAgICAgIEFbTl0gPSBJLCBJICs9IGQudGFibGVbTl07XG4gICAgICAgICAgICBmb3IgKE4gPSAwOyBOIDwgazsgKytOKVxuICAgICAgICAgICAgICB2W3cgKyBOXSAmJiAoZC50cmFuc1tBW3ZbdyArIE5dXSsrXSA9IE4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBQKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGlmICghdilcbiAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICBmb3IgKDsgZC5iaXRjb3VudCA8IDI0OyApXG4gICAgICAgICAgICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudCwgZC5iaXRjb3VudCArPSA4O1xuICAgICAgICAgICAgdmFyIGsgPSBkLnRhZyAmIDY1NTM1ID4+PiAxNiAtIHY7XG4gICAgICAgICAgICByZXR1cm4gZC50YWcgPj4+PSB2LCBkLmJpdGNvdW50IC09IHYsIGsgKyB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBNKGQsIHYpIHtcbiAgICAgICAgICAgIGZvciAoOyBkLmJpdGNvdW50IDwgMjQ7IClcbiAgICAgICAgICAgICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50LCBkLmJpdGNvdW50ICs9IDg7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMCwgayA9IDAsIEkgPSAwLCBOID0gZC50YWc7IGsgPSAyICogayArICgxICYgTiksIE4gPj4+PSAxLCB3ICs9IHYudGFibGVbKytJXSwgMCA8PSAoayAtPSB2LnRhYmxlW0ldKTsgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gZC50YWcgPSBOLCBkLmJpdGNvdW50IC09IEksIHYudHJhbnNbdyArIGtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgICAgICB2YXIgayA9IE0oZCwgdik7XG4gICAgICAgICAgICAgIGlmIChrID09PSAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgIGlmIChrIDwgMjU2KVxuICAgICAgICAgICAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBrO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgSSwgTiA9IFAoZCwgYVtrIC09IDI1N10sIGNba10pLCBrID0gTShkLCB3KSwgeiA9IEkgPSBkLmRlc3RMZW4gLSBQKGQsIHBba10sIGpba10pOyB6IDwgSSArIE47ICsreilcbiAgICAgICAgICAgICAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLmRlc3Rbel07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIEwgPSBsLCBGID0gbiwgViA9IDA7IFYgPCA3OyArK1YpXG4gICAgICAgICAgICBMLnRhYmxlW1ZdID0gMDtcbiAgICAgICAgICBmb3IgKEwudGFibGVbN10gPSAyNCwgTC50YWJsZVs4XSA9IDE1MiwgTC50YWJsZVs5XSA9IDExMiwgViA9IDA7IFYgPCAyNDsgKytWKVxuICAgICAgICAgICAgTC50cmFuc1tWXSA9IDI1NiArIFY7XG4gICAgICAgICAgZm9yIChWID0gMDsgViA8IDE0NDsgKytWKVxuICAgICAgICAgICAgTC50cmFuc1syNCArIFZdID0gVjtcbiAgICAgICAgICBmb3IgKFYgPSAwOyBWIDwgODsgKytWKVxuICAgICAgICAgICAgTC50cmFuc1sxNjggKyBWXSA9IDI4MCArIFY7XG4gICAgICAgICAgZm9yIChWID0gMDsgViA8IDExMjsgKytWKVxuICAgICAgICAgICAgTC50cmFuc1sxNzYgKyBWXSA9IDE0NCArIFY7XG4gICAgICAgICAgZm9yIChWID0gMDsgViA8IDU7ICsrVilcbiAgICAgICAgICAgIEYudGFibGVbVl0gPSAwO1xuICAgICAgICAgIGZvciAoRi50YWJsZVs1XSA9IDMyLCBWID0gMDsgViA8IDMyOyArK1YpXG4gICAgICAgICAgICBGLnRyYW5zW1ZdID0gVjtcbiAgICAgICAgICBFKGEsIGMsIDQsIDMpLCBFKHAsIGosIDIsIDEpLCBhWzI4XSA9IDAsIGNbMjhdID0gMjU4O1xuICAgICAgICAgIHZhciBHID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdmFyIHcsIGssIEksIE4gPSBuZXcgaShkLCB2KTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChJID0gdm9pZCAwLCAoayA9IE4pLmJpdGNvdW50LS0gfHwgKGsudGFnID0gay5zb3VyY2Vbay5zb3VyY2VJbmRleCsrXSwgay5iaXRjb3VudCA9IDcpLCBJID0gMSAmIGsudGFnLCBrLnRhZyA+Pj49IDEsIGsgPSBJLCBQKE4sIDIsIDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgdyA9IGZ1bmN0aW9uKEVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyICRlLCBsdDsgOCA8IEVlLmJpdGNvdW50OyApXG4gICAgICAgICAgICAgICAgICAgICAgRWUuc291cmNlSW5kZXgtLSwgRWUuYml0Y291bnQgLT0gODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgkZSA9IDI1NiAqIEVlLnNvdXJjZVtFZS5zb3VyY2VJbmRleCArIDFdICsgRWUuc291cmNlW0VlLnNvdXJjZUluZGV4XSkgIT09ICg2NTUzNSAmIH4oMjU2ICogRWUuc291cmNlW0VlLnNvdXJjZUluZGV4ICsgM10gKyBFZS5zb3VyY2VbRWUuc291cmNlSW5kZXggKyAyXSkpKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKEVlLnNvdXJjZUluZGV4ICs9IDQsIGx0ID0gJGU7IGx0OyAtLWx0KVxuICAgICAgICAgICAgICAgICAgICAgIEVlLmRlc3RbRWUuZGVzdExlbisrXSA9IEVlLnNvdXJjZVtFZS5zb3VyY2VJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVlLmJpdGNvdW50ID0gMCwgcjtcbiAgICAgICAgICAgICAgICAgIH0oTik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICB3ID0gUihOLCBsLCBuKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIEFlID0ga2UgPSBJZSA9IFRlID0geiA9IGRlID0gYmUgPSBTZSA9IHllID0gb2UgPSBzZSA9IFEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB6LCBRID0gTiwgc2UgPSBOLmx0cmVlLCBvZSA9IE4uZHRyZWUsIHllID0gUChRLCA1LCAyNTcpLCBTZSA9IFAoUSwgNSwgMSksIGJlID0gUChRLCA0LCA0KSwgZGUgPSAwOyBkZSA8IDE5OyArK2RlKVxuICAgICAgICAgICAgICAgICAgICBTW2RlXSA9IDA7XG4gICAgICAgICAgICAgICAgICBmb3IgKGRlID0gMDsgZGUgPCBiZTsgKytkZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgSWUgPSBQKFEsIDMsIDApO1xuICAgICAgICAgICAgICAgICAgICBTW1RbZGVdXSA9IEllO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yICh4KF8sIFMsIDAsIDE5KSwgeiA9IDA7IHogPCB5ZSArIFNlOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtlID0gTShRLCBfKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBBZSA9IFNbeiAtIDFdLCBUZSA9IFAoUSwgMiwgMyk7IFRlOyAtLVRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBTW3orK10gPSBBZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFRlID0gUChRLCAzLCAzKTsgVGU7IC0tVGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFNbeisrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChUZSA9IFAoUSwgNywgMTEpOyBUZTsgLS1UZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgU1t6KytdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBTW3orK10gPSBrZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgeChzZSwgUywgMCwgeWUpLCB4KG9lLCBTLCB5ZSwgU2UpLCB3ID0gUihOLCBOLmx0cmVlLCBOLmR0cmVlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB3ID0gcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodyAhPT0gcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGVycm9yXCIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoIWspO1xuICAgICAgICAgICAgcmV0dXJuIE4uZGVzdExlbiA8IE4uZGVzdC5sZW5ndGggPyB0eXBlb2YgTi5kZXN0LnNsaWNlID09IFwiZnVuY3Rpb25cIiA/IE4uZGVzdC5zbGljZSgwLCBOLmRlc3RMZW4pIDogTi5kZXN0LnN1YmFycmF5KDAsIE4uZGVzdExlbikgOiBOLmRlc3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmdW5jdGlvbiBVKGQsIHYsIHcsIGssIEkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygxIC0gSSwgMykgKiBkICsgMyAqIE1hdGgucG93KDEgLSBJLCAyKSAqIEkgKiB2ICsgMyAqICgxIC0gSSkgKiBNYXRoLnBvdyhJLCAyKSAqIHcgKyBNYXRoLnBvdyhJLCAzKSAqIGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICAgICAgICB0aGlzLngxID0gTnVtYmVyLk5hTiwgdGhpcy55MSA9IE51bWJlci5OYU4sIHRoaXMueDIgPSBOdW1iZXIuTmFOLCB0aGlzLnkyID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gWCgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXSwgdGhpcy5maWxsID0gXCJibGFja1wiLCB0aGlzLnN0cm9rZSA9IG51bGwsIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBuZShkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGIoZCwgdikge1xuICAgICAgICAgICAgZCB8fCBuZSh2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueDIpIHx8IGlzTmFOKHRoaXMueTIpO1xuICAgICAgICAgIH0sIFcucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdHlwZW9mIGQgPT0gXCJudW1iZXJcIiAmJiAoKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSAmJiAodGhpcy54MSA9IGQsIHRoaXMueDIgPSBkKSwgZCA8IHRoaXMueDEgJiYgKHRoaXMueDEgPSBkKSwgZCA+IHRoaXMueDIgJiYgKHRoaXMueDIgPSBkKSksIHR5cGVvZiB2ID09IFwibnVtYmVyXCIgJiYgKChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkgJiYgKHRoaXMueTEgPSB2LCB0aGlzLnkyID0gdiksIHYgPCB0aGlzLnkxICYmICh0aGlzLnkxID0gdiksIHYgPiB0aGlzLnkyICYmICh0aGlzLnkyID0gdikpO1xuICAgICAgICAgIH0sIFcucHJvdG90eXBlLmFkZFggPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50KGQsIG51bGwpO1xuICAgICAgICAgIH0sIFcucHJvdG90eXBlLmFkZFkgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50KG51bGwsIGQpO1xuICAgICAgICAgIH0sIFcucHJvdG90eXBlLmFkZEJlemllciA9IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEksIE4sIHosIFEpIHtcbiAgICAgICAgICAgIHZhciBzZSA9IFtkLCB2XSwgb2UgPSBbdywga10sIHllID0gW0ksIE5dLCBTZSA9IFt6LCBRXTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoZCwgdiksIHRoaXMuYWRkUG9pbnQoeiwgUSk7XG4gICAgICAgICAgICBmb3IgKHZhciBiZSA9IDA7IGJlIDw9IDE7IGJlKyspIHtcbiAgICAgICAgICAgICAgdmFyIGRlLCBJZSA9IDYgKiBzZVtiZV0gLSAxMiAqIG9lW2JlXSArIDYgKiB5ZVtiZV0sIGtlID0gLTMgKiBzZVtiZV0gKyA5ICogb2VbYmVdIC0gOSAqIHllW2JlXSArIDMgKiBTZVtiZV0sIEFlID0gMyAqIG9lW2JlXSAtIDMgKiBzZVtiZV07XG4gICAgICAgICAgICAgIGtlID09IDAgPyBJZSA9PSAwIHx8IDAgPCAoZGUgPSAtQWUgLyBJZSkgJiYgZGUgPCAxICYmIChiZSA9PT0gMCAmJiB0aGlzLmFkZFgoVShzZVtiZV0sIG9lW2JlXSwgeWVbYmVdLCBTZVtiZV0sIGRlKSksIGJlID09PSAxICYmIHRoaXMuYWRkWShVKHNlW2JlXSwgb2VbYmVdLCB5ZVtiZV0sIFNlW2JlXSwgZGUpKSkgOiAoZGUgPSBNYXRoLnBvdyhJZSwgMikgLSA0ICogQWUgKiBrZSkgPCAwIHx8ICgwIDwgKEFlID0gKC1JZSArIE1hdGguc3FydChkZSkpIC8gKDIgKiBrZSkpICYmIEFlIDwgMSAmJiAoYmUgPT09IDAgJiYgdGhpcy5hZGRYKFUoc2VbYmVdLCBvZVtiZV0sIHllW2JlXSwgU2VbYmVdLCBBZSkpLCBiZSA9PT0gMSAmJiB0aGlzLmFkZFkoVShzZVtiZV0sIG9lW2JlXSwgeWVbYmVdLCBTZVtiZV0sIEFlKSkpLCAwIDwgKEFlID0gKC1JZSAtIE1hdGguc3FydChkZSkpIC8gKDIgKiBrZSkpICYmIEFlIDwgMSAmJiAoYmUgPT09IDAgJiYgdGhpcy5hZGRYKFUoc2VbYmVdLCBvZVtiZV0sIHllW2JlXSwgU2VbYmVdLCBBZSkpLCBiZSA9PT0gMSAmJiB0aGlzLmFkZFkoVShzZVtiZV0sIG9lW2JlXSwgeWVbYmVdLCBTZVtiZV0sIEFlKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBXLnByb3RvdHlwZS5hZGRRdWFkID0gZnVuY3Rpb24oZCwgdiwgdywgaywgSSwgTikge1xuICAgICAgICAgICAgdyA9IGQgKyAyIC8gMyAqICh3IC0gZCksIGsgPSB2ICsgMiAvIDMgKiAoayAtIHYpLCB0aGlzLmFkZEJlemllcihkLCB2LCB3LCBrLCB3ICsgMSAvIDMgKiAoSSAtIGQpLCBrICsgMSAvIDMgKiAoTiAtIHYpLCBJLCBOKTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goeyB0eXBlOiBcIk1cIiwgeDogZCwgeTogdiB9KTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goeyB0eXBlOiBcIkxcIiwgeDogZCwgeTogdiB9KTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5jdXJ2ZVRvID0gWC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEksIE4pIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucHVzaCh7IHR5cGU6IFwiQ1wiLCB4MTogZCwgeTE6IHYsIHgyOiB3LCB5MjogaywgeDogSSwgeTogTiB9KTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5xdWFkVG8gPSBYLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKHsgdHlwZTogXCJRXCIsIHgxOiBkLCB5MTogdiwgeDogdywgeTogayB9KTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5jbG9zZSA9IFgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKHsgdHlwZTogXCJaXCIgfSk7XG4gICAgICAgICAgfSwgWC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICBpZiAoZC5jb21tYW5kcylcbiAgICAgICAgICAgICAgZCA9IGQuY29tbWFuZHM7XG4gICAgICAgICAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgVylcbiAgICAgICAgICAgICAgcmV0dXJuIHYgPSBkLCB0aGlzLm1vdmVUbyh2LngxLCB2LnkxKSwgdGhpcy5saW5lVG8odi54Miwgdi55MSksIHRoaXMubGluZVRvKHYueDIsIHYueTIpLCB0aGlzLmxpbmVUbyh2LngxLCB2LnkyKSwgdm9pZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBkKTtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IG5ldyBXKCksIHYgPSAwLCB3ID0gMCwgayA9IDAsIEkgPSAwLCBOID0gMDsgTiA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBOKyspIHtcbiAgICAgICAgICAgICAgdmFyIHogPSB0aGlzLmNvbW1hbmRzW05dO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICBkLmFkZFBvaW50KHoueCwgei55KSwgdiA9IGsgPSB6LngsIHcgPSBJID0gei55O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgICAgIGQuYWRkUG9pbnQoei54LCB6LnkpLCBrID0gei54LCBJID0gei55O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgICAgICAgIGQuYWRkUXVhZChrLCBJLCB6LngxLCB6LnkxLCB6LngsIHoueSksIGsgPSB6LngsIEkgPSB6Lnk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgICAgICAgICAgZC5hZGRCZXppZXIoaywgSSwgei54MSwgei55MSwgei54Miwgei55Miwgei54LCB6LnkpLCBrID0gei54LCBJID0gei55O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgIGsgPSB2LCBJID0gdztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBhdGggY29tbWFuZCBcIiArIHoudHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkLmlzRW1wdHkoKSAmJiBkLmFkZFBvaW50KDAsIDApLCBkO1xuICAgICAgICAgIH0sIFgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5jb21tYW5kc1t2XTtcbiAgICAgICAgICAgICAgdy50eXBlID09PSBcIk1cIiA/IGQubW92ZVRvKHcueCwgdy55KSA6IHcudHlwZSA9PT0gXCJMXCIgPyBkLmxpbmVUbyh3LngsIHcueSkgOiB3LnR5cGUgPT09IFwiQ1wiID8gZC5iZXppZXJDdXJ2ZVRvKHcueDEsIHcueTEsIHcueDIsIHcueTIsIHcueCwgdy55KSA6IHcudHlwZSA9PT0gXCJRXCIgPyBkLnF1YWRyYXRpY0N1cnZlVG8ody54MSwgdy55MSwgdy54LCB3LnkpIDogdy50eXBlID09PSBcIlpcIiAmJiBkLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxsICYmIChkLmZpbGxTdHlsZSA9IHRoaXMuZmlsbCwgZC5maWxsKCkpLCB0aGlzLnN0cm9rZSAmJiAoZC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlLCBkLmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsIGQuc3Ryb2tlKCkpO1xuICAgICAgICAgIH0sIFgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBOID0gYXJndW1lbnRzLCB6ID0gXCJcIiwgUSA9IDA7IFEgPCBhcmd1bWVudHMubGVuZ3RoOyBRICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBOW1FdO1xuICAgICAgICAgICAgICAgIDAgPD0gc2UgJiYgMCA8IFEgJiYgKHogKz0gXCIgXCIpLCB6ICs9IChzZSA9IHNlLCBNYXRoLnJvdW5kKHNlKSA9PT0gc2UgPyBcIlwiICsgTWF0aC5yb3VuZChzZSkgOiBzZS50b0ZpeGVkKGQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQgPSBkICE9PSB2b2lkIDAgPyBkIDogMjtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBcIlwiLCBrID0gMDsgayA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLmNvbW1hbmRzW2tdO1xuICAgICAgICAgICAgICBJLnR5cGUgPT09IFwiTVwiID8gdyArPSBcIk1cIiArIHYoSS54LCBJLnkpIDogSS50eXBlID09PSBcIkxcIiA/IHcgKz0gXCJMXCIgKyB2KEkueCwgSS55KSA6IEkudHlwZSA9PT0gXCJDXCIgPyB3ICs9IFwiQ1wiICsgdihJLngxLCBJLnkxLCBJLngyLCBJLnkyLCBJLngsIEkueSkgOiBJLnR5cGUgPT09IFwiUVwiID8gdyArPSBcIlFcIiArIHYoSS54MSwgSS55MSwgSS54LCBJLnkpIDogSS50eXBlID09PSBcIlpcIiAmJiAodyArPSBcIlpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gKHYgPSAnPHBhdGggZD1cIicpICsgdGhpcy50b1BhdGhEYXRhKGQpICsgJ1wiJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGwgJiYgdGhpcy5maWxsICE9PSBcImJsYWNrXCIgJiYgKHRoaXMuZmlsbCA9PT0gbnVsbCA/IHYgKz0gJyBmaWxsPVwibm9uZVwiJyA6IHYgKz0gJyBmaWxsPVwiJyArIHRoaXMuZmlsbCArICdcIicpLCB0aGlzLnN0cm9rZSAmJiAodiArPSAnIHN0cm9rZT1cIicgKyB0aGlzLnN0cm9rZSArICdcIiBzdHJva2Utd2lkdGg9XCInICsgdGhpcy5zdHJva2VXaWR0aCArICdcIicpLCB2ICs9IFwiLz5cIjtcbiAgICAgICAgICB9LCBYLnByb3RvdHlwZS50b0RPTUVsZW1lbnQgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudG9QYXRoRGF0YSh2KSwgdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgICAgIHJldHVybiB3LnNldEF0dHJpYnV0ZShcImRcIiwgdiksIHc7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgTyA9IHsgZmFpbDogbmUsIGFyZ3VtZW50OiBiLCBhc3NlcnQ6IGIgfSwgRCA9IHt9LCBCID0ge30sIFkgPSB7fTtcbiAgICAgICAgICBmdW5jdGlvbiBKKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBCLkJZVEUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5hcmd1bWVudCgwIDw9IGQgJiYgZCA8PSAyNTUsIFwiQnl0ZSB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAyNTUuXCIpLCBbZF07XG4gICAgICAgICAgfSwgWS5CWVRFID0gSigxKSwgQi5DSEFSID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtkLmNoYXJDb2RlQXQoMCldO1xuICAgICAgICAgIH0sIFkuQ0hBUiA9IEooMSksIEIuQ0hBUkFSUkFZID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IFtdLCB3ID0gMDsgdyA8IGQubGVuZ3RoOyB3ICs9IDEpXG4gICAgICAgICAgICAgIHZbd10gPSBkLmNoYXJDb2RlQXQodyk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9LCBZLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmxlbmd0aDtcbiAgICAgICAgICB9LCBCLlVTSE9SVCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZCA+PiA4ICYgMjU1LCAyNTUgJiBkXTtcbiAgICAgICAgICB9LCBZLlVTSE9SVCA9IEooMiksIEIuU0hPUlQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gWyhkID0gMzI3NjggPD0gZCA/IC0oNjU1MzYgLSBkKSA6IGQpID4+IDggJiAyNTUsIDI1NSAmIGRdO1xuICAgICAgICAgIH0sIFkuU0hPUlQgPSBKKDIpLCBCLlVJTlQyNCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZCA+PiAxNiAmIDI1NSwgZCA+PiA4ICYgMjU1LCAyNTUgJiBkXTtcbiAgICAgICAgICB9LCBZLlVJTlQyNCA9IEooMyksIEIuVUxPTkcgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2QgPj4gMjQgJiAyNTUsIGQgPj4gMTYgJiAyNTUsIGQgPj4gOCAmIDI1NSwgMjU1ICYgZF07XG4gICAgICAgICAgfSwgWS5VTE9ORyA9IEooNCksIEIuTE9ORyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbKGQgPSAyMTQ3NDgzNjQ4IDw9IGQgPyAtKDQyOTQ5NjcyOTYgLSBkKSA6IGQpID4+IDI0ICYgMjU1LCBkID4+IDE2ICYgMjU1LCBkID4+IDggJiAyNTUsIDI1NSAmIGRdO1xuICAgICAgICAgIH0sIFkuTE9ORyA9IEooNCksIEIuRklYRUQgPSBCLlVMT05HLCBZLkZJWEVEID0gWS5VTE9ORywgQi5GV09SRCA9IEIuU0hPUlQsIFkuRldPUkQgPSBZLlNIT1JULCBCLlVGV09SRCA9IEIuVVNIT1JULCBZLlVGV09SRCA9IFkuVVNIT1JULCBCLkxPTkdEQVRFVElNRSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMCwgZCA+PiAyNCAmIDI1NSwgZCA+PiAxNiAmIDI1NSwgZCA+PiA4ICYgMjU1LCAyNTUgJiBkXTtcbiAgICAgICAgICB9LCBZLkxPTkdEQVRFVElNRSA9IEooOCksIEIuVEFHID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIE8uYXJndW1lbnQoZC5sZW5ndGggPT09IDQsIFwiVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy5cIiksIFtkLmNoYXJDb2RlQXQoMCksIGQuY2hhckNvZGVBdCgxKSwgZC5jaGFyQ29kZUF0KDIpLCBkLmNoYXJDb2RlQXQoMyldO1xuICAgICAgICAgIH0sIFkuVEFHID0gSig0KSwgQi5DYXJkOCA9IEIuQllURSwgWS5DYXJkOCA9IFkuQllURSwgQi5DYXJkMTYgPSBCLlVTSE9SVCwgWS5DYXJkMTYgPSBZLlVTSE9SVCwgQi5PZmZTaXplID0gQi5CWVRFLCBZLk9mZlNpemUgPSBZLkJZVEUsIEIuU0lEID0gQi5VU0hPUlQsIFkuU0lEID0gWS5VU0hPUlQsIEIuTlVNQkVSID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xMDcgPD0gZCAmJiBkIDw9IDEwNyA/IFtkICsgMTM5XSA6IDEwOCA8PSBkICYmIGQgPD0gMTEzMSA/IFsyNDcgKyAoKGQgLT0gMTA4KSA+PiA4KSwgMjU1ICYgZF0gOiAtMTEzMSA8PSBkICYmIGQgPD0gLTEwOCA/IFsyNTEgKyAoKGQgPSAtZCAtIDEwOCkgPj4gOCksIDI1NSAmIGRdIDogLTMyNzY4IDw9IGQgJiYgZCA8PSAzMjc2NyA/IEIuTlVNQkVSMTYoZCkgOiBCLk5VTUJFUjMyKGQpO1xuICAgICAgICAgIH0sIFkuTlVNQkVSID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIEIuTlVNQkVSKGQpLmxlbmd0aDtcbiAgICAgICAgICB9LCBCLk5VTUJFUjE2ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIFsyOCwgZCA+PiA4ICYgMjU1LCAyNTUgJiBkXTtcbiAgICAgICAgICB9LCBZLk5VTUJFUjE2ID0gSigzKSwgQi5OVU1CRVIzMiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbMjksIGQgPj4gMjQgJiAyNTUsIGQgPj4gMTYgJiAyNTUsIGQgPj4gOCAmIDI1NSwgMjU1ICYgZF07XG4gICAgICAgICAgfSwgWS5OVU1CRVIzMiA9IEooNSksIEIuUkVBTCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBkLnRvU3RyaW5nKCksIHcgPSAvXFwuKFxcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcXGR7MCwyfSg/OmUoLispfCQpLy5leGVjKHYpLCBrID0gKHcgJiYgKHcgPSBwYXJzZUZsb2F0KFwiMWVcIiArICgod1syXSA/ICt3WzJdIDogMCkgKyB3WzFdLmxlbmd0aCkpLCB2ID0gKE1hdGgucm91bmQoZCAqIHcpIC8gdykudG9TdHJpbmcoKSksIFwiXCIpLCBJID0gMCwgTiA9IHYubGVuZ3RoOyBJIDwgTjsgSSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gdltJXTtcbiAgICAgICAgICAgICAgayArPSB6ID09PSBcImVcIiA/IHZbKytJXSA9PT0gXCItXCIgPyBcImNcIiA6IFwiYlwiIDogeiA9PT0gXCIuXCIgPyBcImFcIiA6IHogPT09IFwiLVwiID8gXCJlXCIgOiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgUSA9IFszMF0sIHNlID0gMCwgb2UgPSAoayArPSAxICYgay5sZW5ndGggPyBcImZcIiA6IFwiZmZcIikubGVuZ3RoOyBzZSA8IG9lOyBzZSArPSAyKVxuICAgICAgICAgICAgICBRLnB1c2gocGFyc2VJbnQoay5zdWJzdHIoc2UsIDIpLCAxNikpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgICAgfSwgWS5SRUFMID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIEIuUkVBTChkKS5sZW5ndGg7XG4gICAgICAgICAgfSwgQi5OQU1FID0gQi5DSEFSQVJSQVksIFkuTkFNRSA9IFkuQ0hBUkFSUkFZLCBCLlNUUklORyA9IEIuQ0hBUkFSUkFZLCBZLlNUUklORyA9IFkuQ0hBUkFSUkFZLCBELlVURjggPSBmdW5jdGlvbihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gW10sIEkgPSB3LCBOID0gMDsgTiA8IEk7IE4rKywgdiArPSAxKVxuICAgICAgICAgICAgICBrW05dID0gZC5nZXRVaW50OCh2KTtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGspO1xuICAgICAgICAgIH0sIEQuVVRGMTYgPSBmdW5jdGlvbihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gW10sIEkgPSB3IC8gMiwgTiA9IDA7IE4gPCBJOyBOKyssIHYgKz0gMilcbiAgICAgICAgICAgICAga1tOXSA9IGQuZ2V0VWludDE2KHYpO1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgayk7XG4gICAgICAgICAgfSwgQi5VVEYxNiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBbXSwgdyA9IDA7IHcgPCBkLmxlbmd0aDsgdyArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gZC5jaGFyQ29kZUF0KHcpO1xuICAgICAgICAgICAgICB2W3YubGVuZ3RoXSA9IGsgPj4gOCAmIDI1NSwgdlt2Lmxlbmd0aF0gPSAyNTUgJiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfSwgWS5VVEYxNiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogZC5sZW5ndGg7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdGUsIGNlID0geyBcIngtbWFjLWNyb2F0aWFuXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrOqcW+w7jCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvo7/CqeKBhOKCrOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLh1wiLCBcIngtbWFjLWN5cmlsbGljXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGa0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOXCIsIFwieC1tYWMtZ2FlbGljXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO44bmB4bmW4bmXybzGksW/4bmgwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmeG5oeG6m8O/xbjhuarigqzigLnigLrFtsW34bmrwrfhu7Lhu7PigYrDgsOKw4HDi8OIw43DjsOPw4zDk8OU4pmjw5LDmsObw5nEscOdw73FtMW14bqE4bqF4bqA4bqB4bqC4bqDXCIsIFwieC1tYWMtZ3JlZWtcIjogXCLDhMK5wrLDicKzw5bDnM6Fw6DDosOkzoTCqMOnw6nDqMOqw6vCo+KEosOuw6/igKLCveKAsMO0w7bCpuKCrMO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwwrfOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrDCrVwiLCBcIngtbWFjLWljZWxhbmRpY1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIiwgXCJ4LW1hYy1pbnVpdFwiOiBcIuGQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOX4ZOY4ZOa4ZOb4ZOq4ZSo4ZSp4ZSq4ZSr4ZSt4oCmwqDhlK7hlL7hlZXhlZbhlZfigJPigJTigJzigJ3igJjigJnhlZjhlZnhlZrhlZ3hlYbhlYfhlYjhlYnhlYvhlYzhlZDhlb/hloDhloHhloLhloPhloThloXhlo/hlpDhlpHhlpLhlpPhlpThlpXhmbHhmbLhmbPhmbThmbXhmbbhlpbhlqDhlqHhlqLhlqPhlqThlqXhlqbhlbzFgcWCXCIsIFwieC1tYWMtY2VcIjogXCLDhMSAxIHDicSEw5bDnMOhxIXEjMOkxI3EhsSHw6nFucW6xI7DrcSPxJLEk8SWw7PEl8O0w7bDtcO6xJrEm8O84oCgwrDEmMKjwqfigKLCtsOfwq7CqeKEosSZwqjiiaDEo8SuxK/EquKJpOKJpcSrxLbiiILiiJHFgsS7xLzEvcS+xLnEusWFxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLh1wiLCBtYWNpbnRvc2g6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLh1wiLCBcIngtbWFjLXJvbWFuaWFuXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImcK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAusiayJvigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIiwgXCJ4LW1hYy10dXJraXNoXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuMSexJ/EsMSxxZ7Fn+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZ76Kgy4bLnMKvy5jLmcuawrjLncuby4dcIiB9LCByZSA9IChELk1BQ1NUUklORyA9IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHZhciBJID0gY2Vba107XG4gICAgICAgICAgICBpZiAoSSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIE4gPSBcIlwiLCB6ID0gMDsgeiA8IHc7IHorKykge1xuICAgICAgICAgICAgICAgIHZhciBRID0gZC5nZXRVaW50OCh2ICsgeik7XG4gICAgICAgICAgICAgICAgTiArPSBRIDw9IDEyNyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoUSkgOiBJWzEyNyAmIFFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiAmJiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgICAgZnVuY3Rpb24gdWUoZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xMjggPD0gZCAmJiBkIDw9IDEyNztcbiAgICAgICAgICB9XG4gICAgICAgICAgQi5NQUNTVFJJTkcgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgICAgICAgaWYgKCF0ZSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBRIGluIHRlID0ge30sIGNlKVxuICAgICAgICAgICAgICAgICAgdGVbUV0gPSBuZXcgU3RyaW5nKFEpO1xuICAgICAgICAgICAgICB2YXIgc2UgPSB0ZVt6XTtcbiAgICAgICAgICAgICAgaWYgKHNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpZiAocmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvZSA9IHJlLmdldChzZSk7XG4gICAgICAgICAgICAgICAgICBpZiAob2UgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeWUgPSBjZVt6XTtcbiAgICAgICAgICAgICAgICBpZiAoeWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgU2UgPSB7fSwgYmUgPSAwOyBiZSA8IHllLmxlbmd0aDsgYmUrKylcbiAgICAgICAgICAgICAgICAgICAgU2VbeWUuY2hhckNvZGVBdChiZSldID0gYmUgKyAxMjg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmUgJiYgcmUuc2V0KHNlLCBTZSksIFNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSh2KTtcbiAgICAgICAgICAgIGlmICh3ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IFtdLCBJID0gMDsgSSA8IGQubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IGQuY2hhckNvZGVBdChJKTtcbiAgICAgICAgICAgICAgICBpZiAoMTI4IDw9IE4gJiYgKE4gPSB3W05dKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGtbSV0gPSBOO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFkuTUFDU1RSSU5HID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIGQgPSBCLk1BQ1NUUklORyhkLCB2KSwgZCAhPT0gdm9pZCAwID8gZC5sZW5ndGggOiAwO1xuICAgICAgICAgIH0sIEIuVkFSREVMVEFTID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIHYgPSBbXTsgayA8IGQubGVuZ3RoOyApXG4gICAgICAgICAgICAgIHZhciB3ID0gZFtrXSwgayA9ICh3ID09PSAwID8gZnVuY3Rpb24oSSwgTiwgeikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFEgPSAwLCBzZSA9IEkubGVuZ3RoOyBOIDwgc2UgJiYgUSA8IDY0ICYmIElbTl0gPT09IDA7IClcbiAgICAgICAgICAgICAgICAgICsrTiwgKytRO1xuICAgICAgICAgICAgICAgIHJldHVybiB6LnB1c2goMTI4IHwgUSAtIDEpLCBOO1xuICAgICAgICAgICAgICB9IDogLTEyOCA8PSB3ICYmIHcgPD0gMTI3ID8gZnVuY3Rpb24oSSwgTiwgeikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFEgPSAwLCBzZSA9IEkubGVuZ3RoLCBvZSA9IE47IG9lIDwgc2UgJiYgUSA8IDY0OyApIHtcbiAgICAgICAgICAgICAgICAgIHZhciB5ZSA9IElbb2VdO1xuICAgICAgICAgICAgICAgICAgaWYgKCF1ZSh5ZSkgfHwgeWUgPT09IDAgJiYgb2UgKyAxIDwgc2UgJiYgSVtvZSArIDFdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICsrb2UsICsrUTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgei5wdXNoKFEgLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBTZSA9IE47IFNlIDwgb2U7ICsrU2UpXG4gICAgICAgICAgICAgICAgICB6LnB1c2goSVtTZV0gKyAyNTYgJiAyNTUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZTtcbiAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKEksIE4sIHopIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBRID0gMCwgc2UgPSBJLmxlbmd0aCwgb2UgPSBOOyBvZSA8IHNlICYmIFEgPCA2NDsgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeWUgPSBJW29lXTtcbiAgICAgICAgICAgICAgICAgIGlmICh5ZSA9PT0gMCB8fCB1ZSh5ZSkgJiYgb2UgKyAxIDwgc2UgJiYgdWUoSVtvZSArIDFdKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICArK29lLCArK1E7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHoucHVzaCg2NCB8IFEgLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBTZSA9IE47IFNlIDwgb2U7ICsrU2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBiZSA9IElbU2VdO1xuICAgICAgICAgICAgICAgICAgei5wdXNoKGJlICsgNjU1MzYgPj4gOCAmIDI1NSwgYmUgKyAyNTYgJiAyNTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2U7XG4gICAgICAgICAgICAgIH0pKGQsIGssIHYpO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfSwgQi5JTkRFWCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSAxLCB3ID0gW3ZdLCBrID0gW10sIEkgPSAwOyBJIDwgZC5sZW5ndGg7IEkgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgTiA9IEIuT0JKRUNUKGRbSV0pO1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShrLCBOKSwgdiArPSBOLmxlbmd0aCwgdy5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICAgICAgZm9yICh2YXIgeiA9IFtdLCBRID0gMSArIE1hdGguZmxvb3IoTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSkgLyA4IHwgMCwgc2UgPSBbdm9pZCAwLCBCLkJZVEUsIEIuVVNIT1JULCBCLlVJTlQyNCwgQi5VTE9OR11bUV0sIG9lID0gMDsgb2UgPCB3Lmxlbmd0aDsgb2UgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeWUgPSBzZSh3W29lXSk7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHosIHllKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KEIuQ2FyZDE2KGQubGVuZ3RoKSwgQi5PZmZTaXplKFEpLCB6LCBrKTtcbiAgICAgICAgICB9LCBZLklOREVYID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIEIuSU5ERVgoZCkubGVuZ3RoO1xuICAgICAgICAgIH0sIEIuRElDVCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBbXSwgdyA9IE9iamVjdC5rZXlzKGQpLCBrID0gdy5sZW5ndGgsIEkgPSAwOyBJIDwgazsgSSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBOID0gcGFyc2VJbnQod1tJXSwgMCksIHogPSBkW05dO1xuICAgICAgICAgICAgICB2ID0gKHYgPSB2LmNvbmNhdChCLk9QRVJBTkQoei52YWx1ZSwgei50eXBlKSkpLmNvbmNhdChCLk9QRVJBVE9SKE4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIFkuRElDVCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBCLkRJQ1QoZCkubGVuZ3RoO1xuICAgICAgICAgIH0sIEIuT1BFUkFUT1IgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA8IDEyMDAgPyBbZF0gOiBbMTIsIGQgLSAxMjAwXTtcbiAgICAgICAgICB9LCBCLk9QRVJBTkQgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpXG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdi5sZW5ndGg7IGsgKz0gMSlcbiAgICAgICAgICAgICAgICBPLmFyZ3VtZW50KGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgXCJOb3QgZW5vdWdoIGFyZ3VtZW50cyBnaXZlbiBmb3IgdHlwZVwiICsgdiksIHcgPSB3LmNvbmNhdChCLk9QRVJBTkQoZFtrXSwgdltrXSkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodiA9PT0gXCJTSURcIilcbiAgICAgICAgICAgICAgdyA9IHcuY29uY2F0KEIuTlVNQkVSKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHYgPT09IFwib2Zmc2V0XCIpXG4gICAgICAgICAgICAgIHcgPSB3LmNvbmNhdChCLk5VTUJFUjMyKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHYgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHcgPSB3LmNvbmNhdChCLk5VTUJFUihkKSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHYgIT09IFwicmVhbFwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmFuZCB0eXBlIFwiICsgdik7XG4gICAgICAgICAgICAgIHcgPSB3LmNvbmNhdChCLlJFQUwoZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfSwgQi5PUCA9IEIuQllURSwgWS5PUCA9IFkuQllURTtcbiAgICAgICAgICB2YXIgbGUgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgJiYgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgZnVuY3Rpb24gSyhkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHYubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB2W2tdO1xuICAgICAgICAgICAgICB0aGlzW0kubmFtZV0gPSBJLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGFibGVOYW1lID0gZCwgdGhpcy5maWVsZHMgPSB2LCB3KVxuICAgICAgICAgICAgICBmb3IgKHZhciBOID0gT2JqZWN0LmtleXModyksIHogPSAwOyB6IDwgTi5sZW5ndGg7IHogKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBRID0gTlt6XSwgc2UgPSB3W1FdO1xuICAgICAgICAgICAgICAgIHRoaXNbUV0gIT09IHZvaWQgMCAmJiAodGhpc1tRXSA9IHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBhZShkLCB2LCB3KSB7XG4gICAgICAgICAgICB3ID09PSB2b2lkIDAgJiYgKHcgPSB2Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgayA9IG5ldyBBcnJheSh2Lmxlbmd0aCArIDEpO1xuICAgICAgICAgICAga1swXSA9IHsgbmFtZTogZCArIFwiQ291bnRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IHcgfTtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgdi5sZW5ndGg7IEkrKylcbiAgICAgICAgICAgICAga1tJICsgMV0gPSB7IG5hbWU6IGQgKyBJLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogdltJXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGhlKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBrID0gdi5sZW5ndGgsIEkgPSBuZXcgQXJyYXkoayArIDEpO1xuICAgICAgICAgICAgSVswXSA9IHsgbmFtZTogZCArIFwiQ291bnRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IGsgfTtcbiAgICAgICAgICAgIGZvciAodmFyIE4gPSAwOyBOIDwgazsgTisrKVxuICAgICAgICAgICAgICBJW04gKyAxXSA9IHsgbmFtZTogZCArIE4sIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IHcodltOXSwgTikgfTtcbiAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBfZShkLCB2LCB3KSB7XG4gICAgICAgICAgICB2YXIgayA9IHYubGVuZ3RoLCBJID0gW107XG4gICAgICAgICAgICBJWzBdID0geyBuYW1lOiBkICsgXCJDb3VudFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogayB9O1xuICAgICAgICAgICAgZm9yICh2YXIgTiA9IDA7IE4gPCBrOyBOKyspXG4gICAgICAgICAgICAgIEkgPSBJLmNvbmNhdCh3KHZbTl0sIE4pKTtcbiAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBmZShkKSB7XG4gICAgICAgICAgICBkLmZvcm1hdCA9PT0gMSA/IEsuY2FsbCh0aGlzLCBcImNvdmVyYWdlVGFibGVcIiwgW3sgbmFtZTogXCJjb3ZlcmFnZUZvcm1hdFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMSB9XS5jb25jYXQoYWUoXCJnbHlwaFwiLCBkLmdseXBocykpKSA6IE8uYXNzZXJ0KCExLCBcIkNhbid0IGNyZWF0ZSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgMiB5ZXQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBnZShkKSB7XG4gICAgICAgICAgICBLLmNhbGwodGhpcywgXCJzY3JpcHRMaXN0VGFibGVcIiwgX2UoXCJzY3JpcHRSZWNvcmRcIiwgZCwgZnVuY3Rpb24odiwgdykge1xuICAgICAgICAgICAgICB2YXIgayA9IHYuc2NyaXB0LCBJID0gay5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgICAgcmV0dXJuIE8uYXNzZXJ0KCEhSSwgXCJVbmFibGUgdG8gd3JpdGUgR1NVQjogc2NyaXB0IFwiICsgdi50YWcgKyBcIiBoYXMgbm8gZGVmYXVsdCBsYW5ndWFnZSBzeXN0ZW0uXCIpLCBbeyBuYW1lOiBcInNjcmlwdFRhZ1wiICsgdywgdHlwZTogXCJUQUdcIiwgdmFsdWU6IHYudGFnIH0sIHsgbmFtZTogXCJzY3JpcHRcIiArIHcsIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IG5ldyBLKFwic2NyaXB0VGFibGVcIiwgW3sgbmFtZTogXCJkZWZhdWx0TGFuZ1N5c1wiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgSyhcImRlZmF1bHRMYW5nU3lzXCIsIFt7IG5hbWU6IFwibG9va3VwT3JkZXJcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInJlcUZlYXR1cmVJbmRleFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogSS5yZXFGZWF0dXJlSW5kZXggfV0uY29uY2F0KGFlKFwiZmVhdHVyZUluZGV4XCIsIEkuZmVhdHVyZUluZGV4ZXMpKSkgfV0uY29uY2F0KF9lKFwibGFuZ1N5c1wiLCBrLmxhbmdTeXNSZWNvcmRzLCBmdW5jdGlvbihOLCB6KSB7XG4gICAgICAgICAgICAgICAgdmFyIFEgPSBOLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IG5hbWU6IFwibGFuZ1N5c1RhZ1wiICsgeiwgdHlwZTogXCJUQUdcIiwgdmFsdWU6IE4udGFnIH0sIHsgbmFtZTogXCJsYW5nU3lzXCIgKyB6LCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgSyhcImxhbmdTeXNcIiwgW3sgbmFtZTogXCJsb29rdXBPcmRlclwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwicmVxRmVhdHVyZUluZGV4XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiBRLnJlcUZlYXR1cmVJbmRleCB9XS5jb25jYXQoYWUoXCJmZWF0dXJlSW5kZXhcIiwgUS5mZWF0dXJlSW5kZXhlcykpKSB9XTtcbiAgICAgICAgICAgICAgfSkpKSB9XTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24geGUoZCkge1xuICAgICAgICAgICAgSy5jYWxsKHRoaXMsIFwiZmVhdHVyZUxpc3RUYWJsZVwiLCBfZShcImZlYXR1cmVSZWNvcmRcIiwgZCwgZnVuY3Rpb24odiwgdykge1xuICAgICAgICAgICAgICB2YXIgayA9IHYuZmVhdHVyZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFt7IG5hbWU6IFwiZmVhdHVyZVRhZ1wiICsgdywgdHlwZTogXCJUQUdcIiwgdmFsdWU6IHYudGFnIH0sIHsgbmFtZTogXCJmZWF0dXJlXCIgKyB3LCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgSyhcImZlYXR1cmVUYWJsZVwiLCBbeyBuYW1lOiBcImZlYXR1cmVQYXJhbXNcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IGsuZmVhdHVyZVBhcmFtcyB9XS5jb25jYXQoYWUoXCJsb29rdXBMaXN0SW5kZXhcIiwgay5sb29rdXBMaXN0SW5kZXhlcykpKSB9XTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRGUoZCwgdikge1xuICAgICAgICAgICAgSy5jYWxsKHRoaXMsIFwibG9va3VwTGlzdFRhYmxlXCIsIGhlKFwibG9va3VwXCIsIGQsIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSB2W3cubG9va3VwVHlwZV07XG4gICAgICAgICAgICAgIHJldHVybiBPLmFzc2VydCghIWssIFwiVW5hYmxlIHRvIHdyaXRlIEdTVUIgbG9va3VwIHR5cGUgXCIgKyB3Lmxvb2t1cFR5cGUgKyBcIiB0YWJsZXMuXCIpLCBuZXcgSyhcImxvb2t1cFRhYmxlXCIsIFt7IG5hbWU6IFwibG9va3VwVHlwZVwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogdy5sb29rdXBUeXBlIH0sIHsgbmFtZTogXCJsb29rdXBGbGFnXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiB3Lmxvb2t1cEZsYWcgfV0uY29uY2F0KGhlKFwic3VidGFibGVcIiwgdy5zdWJ0YWJsZXMsIGspKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEIuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChsZSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IGxlLmdldChkKTtcbiAgICAgICAgICAgICAgaWYgKHYgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIE4gPSBbXSwgdyA9IGQubGVuZ3RoLCBrID0gMDsgayA8IHc7IGsgKz0gMSlcbiAgICAgICAgICAgICAgdmFyIEkgPSBkW2tdLCBOID0gTi5jb25jYXQoQltJLnR5cGVdKEkudmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBsZSAmJiBsZS5zZXQoZCwgTiksIE47XG4gICAgICAgICAgfSwgWS5DSEFSU1RSSU5HID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIEIuQ0hBUlNUUklORyhkKS5sZW5ndGg7XG4gICAgICAgICAgfSwgQi5PQkpFQ1QgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IEJbZC50eXBlXTtcbiAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KHYgIT09IHZvaWQgMCwgXCJObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSBcIiArIGQudHlwZSksIHYoZC52YWx1ZSk7XG4gICAgICAgICAgfSwgWS5PQkpFQ1QgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IFlbZC50eXBlXTtcbiAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KHYgIT09IHZvaWQgMCwgXCJObyBzaXplT2YgZnVuY3Rpb24gZm9yIHR5cGUgXCIgKyBkLnR5cGUpLCB2KGQudmFsdWUpO1xuICAgICAgICAgIH0sIEIuVEFCTEUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gW10sIHcgPSBkLmZpZWxkcy5sZW5ndGgsIGsgPSBbXSwgSSA9IFtdLCBOID0gMDsgTiA8IHc7IE4gKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeiA9IGQuZmllbGRzW05dLCBzZSA9IEJbei50eXBlXSwgUSA9IChPLmFyZ3VtZW50KHNlICE9PSB2b2lkIDAsIFwiTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgXCIgKyB6LnR5cGUgKyBcIiAoXCIgKyB6Lm5hbWUgKyBcIilcIiksIGRbei5uYW1lXSksIHNlID0gc2UoUSA9IFEgPT09IHZvaWQgMCA/IHoudmFsdWUgOiBRKTtcbiAgICAgICAgICAgICAgei50eXBlID09PSBcIlRBQkxFXCIgPyAoSS5wdXNoKHYubGVuZ3RoKSwgdiA9IHYuY29uY2F0KFswLCAwXSksIGsucHVzaChzZSkpIDogdiA9IHYuY29uY2F0KHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG9lID0gMDsgb2UgPCBrLmxlbmd0aDsgb2UgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeWUgPSBJW29lXSwgU2UgPSB2Lmxlbmd0aDtcbiAgICAgICAgICAgICAgTy5hcmd1bWVudChTZSA8IDY1NTM2LCBcIlRhYmxlIFwiICsgZC50YWJsZU5hbWUgKyBcIiB0b28gYmlnLlwiKSwgdlt5ZV0gPSBTZSA+PiA4LCB2W3llICsgMV0gPSAyNTUgJiBTZSwgdiA9IHYuY29uY2F0KGtbb2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIFkuVEFCTEUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gMCwgdyA9IGQuZmllbGRzLmxlbmd0aCwgayA9IDA7IGsgPCB3OyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSBkLmZpZWxkc1trXSwgTiA9IFlbSS50eXBlXSwgeiA9IChPLmFyZ3VtZW50KE4gIT09IHZvaWQgMCwgXCJObyBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgXCIgKyBJLnR5cGUgKyBcIiAoXCIgKyBJLm5hbWUgKyBcIilcIiksIGRbSS5uYW1lXSk7XG4gICAgICAgICAgICAgIHYgKz0gTih6ID0geiA9PT0gdm9pZCAwID8gSS52YWx1ZSA6IHopLCBJLnR5cGUgPT09IFwiVEFCTEVcIiAmJiAodiArPSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIEIuUkVDT1JEID0gQi5UQUJMRSwgWS5SRUNPUkQgPSBZLlRBQkxFLCBCLkxJVEVSQUwgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9LCBZLkxJVEVSQUwgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5sZW5ndGg7XG4gICAgICAgICAgfSwgSy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQi5UQUJMRSh0aGlzKTtcbiAgICAgICAgICB9LCBLLnByb3RvdHlwZS5zaXplT2YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBZLlRBQkxFKHRoaXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIE1lID0geyBUYWJsZTogSywgUmVjb3JkOiBLLCBDb3ZlcmFnZTogKGZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSy5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGZlLCBTY3JpcHRMaXN0OiAoZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShLLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZ2UsIEZlYXR1cmVMaXN0OiAoeGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShLLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0geGUsIExvb2t1cExpc3Q6IChEZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEsucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBEZSwgdXNob3J0TGlzdDogYWUsIHRhYmxlTGlzdDogaGUsIHJlY29yZExpc3Q6IF9lIH07XG4gICAgICAgICAgZnVuY3Rpb24gUWUoZCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VWludDgodik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHplKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVpbnQxNih2LCAhMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFZlKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVpbnQzMih2LCAhMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFhlKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldEludDE2KHYsICExKSArIGQuZ2V0VWludDE2KHYgKyAyLCAhMSkgLyA2NTUzNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEhlID0geyBieXRlOiAxLCB1U2hvcnQ6IDIsIHNob3J0OiAyLCB1TG9uZzogNCwgZml4ZWQ6IDQsIGxvbmdEYXRlVGltZTogOCwgdGFnOiA0IH07XG4gICAgICAgICAgZnVuY3Rpb24gdmUoZCwgdikge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZCwgdGhpcy5vZmZzZXQgPSB2LCB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmUucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDEsIGQ7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMSwgZDtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VDYXJkOCA9IHZlLnByb3RvdHlwZS5wYXJzZUJ5dGUsIHZlLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IHZlLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyLCBkO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVNJRCA9IHZlLnByb3RvdHlwZS5wYXJzZVVTaG9ydCwgdmUucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSB2ZS5wcm90b3R5cGUucGFyc2VVU2hvcnQsIHZlLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMiwgZDtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyLCBkO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZU9mZnNldDMyID0gdmUucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gVmUodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNCwgZDtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSBYZSh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0LCBkO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5kYXRhLCB3ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LCBrID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gZDtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgZDsgSSsrKVxuICAgICAgICAgICAgICBrICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodi5nZXRVaW50OCh3ICsgSSkpO1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gVmUodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcbiAgICAgICAgICAgIHJldHVybiBkIC09IDIwODI4NDQ4MDAsIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gOCwgZDtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSB6ZSh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCksIHcgPSB6ZSh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNCwgdiArIHcgLyAoZCA9IGQgPT09IHZvaWQgMCA/IDQwOTYgOiBkKSAvIDEwO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBIZVtkXSAqICh2ID0gdiA9PT0gdm9pZCAwID8gMSA6IHYpO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQgPT09IHZvaWQgMCAmJiAoZCA9IHRoaXMucGFyc2VVTG9uZygpKTtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBuZXcgQXJyYXkoZCksIHcgPSB0aGlzLmRhdGEsIGsgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQsIEkgPSAwOyBJIDwgZDsgSSsrKVxuICAgICAgICAgICAgICB2W0ldID0gdy5nZXRVaW50MzIoayksIGsgKz0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQgKiBkLCB2O1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9IHZlLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3QgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkID09PSB2b2lkIDAgJiYgKGQgPSB0aGlzLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IG5ldyBBcnJheShkKSwgdyA9IHRoaXMuZGF0YSwgayA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCwgSSA9IDA7IEkgPCBkOyBJKyspXG4gICAgICAgICAgICAgIHZbSV0gPSB3LmdldFVpbnQxNihrKSwgayArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMiAqIGQsIHY7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlU2hvcnRMaXN0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IG5ldyBBcnJheShkKSwgdyA9IHRoaXMuZGF0YSwgayA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCwgSSA9IDA7IEkgPCBkOyBJKyspXG4gICAgICAgICAgICAgIHZbSV0gPSB3LmdldEludDE2KGspLCBrICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyICogZCwgdjtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VCeXRlTGlzdCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBuZXcgQXJyYXkoZCksIHcgPSB0aGlzLmRhdGEsIGsgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQsIEkgPSAwOyBJIDwgZDsgSSsrKVxuICAgICAgICAgICAgICB2W0ldID0gdy5nZXRVaW50OChrKyspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gZCwgdjtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VMaXN0ID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdiB8fCAodiA9IGQsIGQgPSB0aGlzLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IG5ldyBBcnJheShkKSwgayA9IDA7IGsgPCBkOyBrKyspXG4gICAgICAgICAgICAgIHdba10gPSB2LmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VMaXN0MzIgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB2IHx8ICh2ID0gZCwgZCA9IHRoaXMucGFyc2VVTG9uZygpKTtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBuZXcgQXJyYXkoZCksIGsgPSAwOyBrIDwgZDsgaysrKVxuICAgICAgICAgICAgICB3W2tdID0gdi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHYgfHwgKHYgPSBkLCBkID0gdGhpcy5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBuZXcgQXJyYXkoZCksIGsgPSBPYmplY3Qua2V5cyh2KSwgSSA9IDA7IEkgPCBkOyBJKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgTiA9IHt9LCB6ID0gMDsgeiA8IGsubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgUSA9IGtbel0sIHNlID0gdltRXTtcbiAgICAgICAgICAgICAgICBOW1FdID0gc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3W0ldID0gTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHYgfHwgKHYgPSBkLCBkID0gdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IG5ldyBBcnJheShkKSwgayA9IE9iamVjdC5rZXlzKHYpLCBJID0gMDsgSSA8IGQ7IEkrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBOID0ge30sIHogPSAwOyB6IDwgay5sZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgIHZhciBRID0ga1t6XSwgc2UgPSB2W1FdO1xuICAgICAgICAgICAgICAgIE5bUV0gPSBzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdbSV0gPSBOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlU3RydWN0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBPYmplY3Qua2V5cyhkKSwgdyA9IHt9LCBrID0gMDsgayA8IHYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB2W2tdLCBOID0gZFtJXTtcbiAgICAgICAgICAgICAgd1tJXSA9IE4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICBpZiAoKGQgPSBkID09PSB2b2lkIDAgPyB0aGlzLnBhcnNlVVNob3J0KCkgOiBkKSAhPT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIHYgPSB7fSwgMSAmIGQgJiYgKHYueFBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpKSwgMiAmIGQgJiYgKHYueVBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpKSwgNCAmIGQgJiYgKHYueEFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKSksIDggJiBkICYmICh2LnlBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCkpLCAxNiAmIGQgJiYgKHYueFBsYURldmljZSA9IHZvaWQgMCwgdGhpcy5wYXJzZVNob3J0KCkpLCAzMiAmIGQgJiYgKHYueVBsYURldmljZSA9IHZvaWQgMCwgdGhpcy5wYXJzZVNob3J0KCkpLCA2NCAmIGQgJiYgKHYueEFkdkRldmljZSA9IHZvaWQgMCwgdGhpcy5wYXJzZVNob3J0KCkpLCAxMjggJiBkICYmICh2LnlBZHZEZXZpY2UgPSB2b2lkIDAsIHRoaXMucGFyc2VTaG9ydCgpKSwgdjtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSB0aGlzLnBhcnNlVVNob3J0KCksIHYgPSB0aGlzLnBhcnNlVVNob3J0KCksIHcgPSBuZXcgQXJyYXkodiksIGsgPSAwOyBrIDwgdjsgaysrKVxuICAgICAgICAgICAgICB3W2tdID0gdGhpcy5wYXJzZVZhbHVlUmVjb3JkKGQpO1xuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlUG9pbnRlciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgICAgICAgICBpZiAoMCA8IHYpXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdmUodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHYpLnBhcnNlU3RydWN0KGQpO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIzMiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5wYXJzZU9mZnNldDMyKCk7XG4gICAgICAgICAgICBpZiAoMCA8IHYpXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdmUodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHYpLnBhcnNlU3RydWN0KGQpO1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZUxpc3RPZkxpc3RzID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKSwgdyA9IHYubGVuZ3RoLCBrID0gdGhpcy5yZWxhdGl2ZU9mZnNldCwgSSA9IG5ldyBBcnJheSh3KSwgTiA9IDA7IE4gPCB3OyBOKyspIHtcbiAgICAgICAgICAgICAgdmFyIHogPSB2W05dO1xuICAgICAgICAgICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgICAgICAgICBJW05dID0gdm9pZCAwO1xuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlbGF0aXZlT2Zmc2V0ID0geiwgZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFEgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCksIHNlID0gbmV3IEFycmF5KFEubGVuZ3RoKSwgb2UgPSAwOyBvZSA8IFEubGVuZ3RoOyBvZSsrKVxuICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHogKyBRW29lXSwgc2Vbb2VdID0gZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIElbTl0gPSBzZTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgSVtOXSA9IHRoaXMucGFyc2VVU2hvcnRMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU9mZnNldCA9IGssIEk7XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LCB2ID0gdGhpcy5wYXJzZVVTaG9ydCgpLCB3ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgaWYgKHYgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiB7IGZvcm1hdDogMSwgZ2x5cGhzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh3KSB9O1xuICAgICAgICAgICAgaWYgKHYgIT09IDIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIjB4XCIgKyBkLnRvU3RyaW5nKDE2KSArIFwiOiBDb3ZlcmFnZSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IG5ldyBBcnJheSh3KSwgSSA9IDA7IEkgPCB3OyBJKyspXG4gICAgICAgICAgICAgIGtbSV0gPSB7IHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksIGVuZDogdGhpcy5wYXJzZVVTaG9ydCgpLCBpbmRleDogdGhpcy5wYXJzZVVTaG9ydCgpIH07XG4gICAgICAgICAgICByZXR1cm4geyBmb3JtYXQ6IDIsIHJhbmdlczogayB9O1xuICAgICAgICAgIH0sIHZlLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCwgdiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGlmICh2ID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4geyBmb3JtYXQ6IDEsIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSwgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSB9O1xuICAgICAgICAgICAgaWYgKHYgPT09IDIpXG4gICAgICAgICAgICAgIHJldHVybiB7IGZvcm1hdDogMiwgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7IHN0YXJ0OiB2ZS51U2hvcnQsIGVuZDogdmUudVNob3J0LCBjbGFzc0lkOiB2ZS51U2hvcnQgfSkgfTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIjB4XCIgKyBkLnRvU3RyaW5nKDE2KSArIFwiOiBDbGFzc0RlZiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuXCIpO1xuICAgICAgICAgIH0sIHZlLmxpc3QgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChkLCB2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSwgdmUubGlzdDMyID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QzMihkLCB2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSwgdmUucmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGQsIHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCB2ZS5yZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKGQsIHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCB2ZS5wb2ludGVyID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sIHZlLnBvaW50ZXIzMiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sIHZlLnRhZyA9IHZlLnByb3RvdHlwZS5wYXJzZVRhZywgdmUuYnl0ZSA9IHZlLnByb3RvdHlwZS5wYXJzZUJ5dGUsIHZlLnVTaG9ydCA9IHZlLm9mZnNldDE2ID0gdmUucHJvdG90eXBlLnBhcnNlVVNob3J0LCB2ZS51U2hvcnRMaXN0ID0gdmUucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCwgdmUudUxvbmcgPSB2ZS5vZmZzZXQzMiA9IHZlLnByb3RvdHlwZS5wYXJzZVVMb25nLCB2ZS51TG9uZ0xpc3QgPSB2ZS5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3QsIHZlLnN0cnVjdCA9IHZlLnByb3RvdHlwZS5wYXJzZVN0cnVjdCwgdmUuY292ZXJhZ2UgPSB2ZS5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZSwgdmUuY2xhc3NEZWYgPSB2ZS5wcm90b3R5cGUucGFyc2VDbGFzc0RlZjtcbiAgICAgICAgICB2YXIgUmUgPSB7IHJlc2VydmVkOiB2ZS51U2hvcnQsIHJlcUZlYXR1cmVJbmRleDogdmUudVNob3J0LCBmZWF0dXJlSW5kZXhlczogdmUudVNob3J0TGlzdCB9LCB3ZSA9ICh2ZS5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIodmUucmVjb3JkTGlzdCh7IHRhZzogdmUudGFnLCBzY3JpcHQ6IHZlLnBvaW50ZXIoeyBkZWZhdWx0TGFuZ1N5czogdmUucG9pbnRlcihSZSksIGxhbmdTeXNSZWNvcmRzOiB2ZS5yZWNvcmRMaXN0KHsgdGFnOiB2ZS50YWcsIGxhbmdTeXM6IHZlLnBvaW50ZXIoUmUpIH0pIH0pIH0pKSB8fCBbXTtcbiAgICAgICAgICB9LCB2ZS5wcm90b3R5cGUucGFyc2VGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKHZlLnJlY29yZExpc3QoeyB0YWc6IHZlLnRhZywgZmVhdHVyZTogdmUucG9pbnRlcih7IGZlYXR1cmVQYXJhbXM6IHZlLm9mZnNldDE2LCBsb29rdXBMaXN0SW5kZXhlczogdmUudVNob3J0TGlzdCB9KSB9KSkgfHwgW107XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlTG9va3VwTGlzdCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5saXN0KHZlLnBvaW50ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5wYXJzZVVTaG9ydCgpLCB3ID0gKE8uYXJndW1lbnQoMSA8PSB2ICYmIHYgPD0gOSwgXCJHUE9TL0dTVUIgbG9va3VwIHR5cGUgXCIgKyB2ICsgXCIgdW5rbm93bi5cIiksIHRoaXMucGFyc2VVU2hvcnQoKSksIGsgPSAxNiAmIHc7XG4gICAgICAgICAgICAgIHJldHVybiB7IGxvb2t1cFR5cGU6IHYsIGxvb2t1cEZsYWc6IHcsIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QodmUucG9pbnRlcihkW3ZdKSksIG1hcmtGaWx0ZXJpbmdTZXQ6IGsgPyB0aGlzLnBhcnNlVVNob3J0KCkgOiB2b2lkIDAgfTtcbiAgICAgICAgICAgIH0pKSkgfHwgW107XG4gICAgICAgICAgfSwgdmUucHJvdG90eXBlLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnBhcnNlVVNob3J0KCksIHYgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KGQgPT09IDEgJiYgdiA8IDEsIFwiR1BPUy9HU1VCIGZlYXR1cmUgdmFyaWF0aW9ucyB0YWJsZSB1bmtub3duLlwiKSwgdGhpcy5wYXJzZVJlY29yZExpc3QzMih7IGNvbmRpdGlvblNldE9mZnNldDogdmUub2Zmc2V0MzIsIGZlYXR1cmVUYWJsZVN1YnN0aXR1dGlvbk9mZnNldDogdmUub2Zmc2V0MzIgfSk7XG4gICAgICAgICAgICB9KSB8fCBbXTtcbiAgICAgICAgICB9LCB7IGdldEJ5dGU6IFFlLCBnZXRDYXJkODogUWUsIGdldFVTaG9ydDogemUsIGdldENhcmQxNjogemUsIGdldFNob3J0OiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRJbnQxNih2LCAhMSk7XG4gICAgICAgICAgfSwgZ2V0VUxvbmc6IFZlLCBnZXRGaXhlZDogWGUsIGdldFRhZzogZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IFwiXCIsIGsgPSB2OyBrIDwgdiArIDQ7IGsgKz0gMSlcbiAgICAgICAgICAgICAgdyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGQuZ2V0SW50OChrKSk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICB9LCBnZXRPZmZzZXQ6IGZ1bmN0aW9uKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBJID0gMDsgSSA8IHc7IEkgKz0gMSlcbiAgICAgICAgICAgICAgayA9IChrIDw8PSA4KSArIGQuZ2V0VWludDgodiArIEkpO1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfSwgZ2V0Qnl0ZXM6IGZ1bmN0aW9uKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBbXSwgSSA9IHY7IEkgPCB3OyBJICs9IDEpXG4gICAgICAgICAgICAgIGsucHVzaChkLmdldFVpbnQ4KEkpKTtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgIH0sIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBcIlwiLCB3ID0gMDsgdyA8IGQubGVuZ3RoOyB3ICs9IDEpXG4gICAgICAgICAgICAgIHYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkW3ddKTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIFBhcnNlcjogdmUgfSksIFogPSB7IHBhcnNlOiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0ge30sIGsgPSAody52ZXJzaW9uID0gd2UuZ2V0VVNob3J0KGQsIHYpLCBPLmFyZ3VtZW50KHcudmVyc2lvbiA9PT0gMCwgXCJjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuXCIpLCB3Lm51bVRhYmxlcyA9IHdlLmdldFVTaG9ydChkLCB2ICsgMiksIC0xKSwgSSA9IHcubnVtVGFibGVzIC0gMTsgMCA8PSBJOyAtLUkpIHtcbiAgICAgICAgICAgICAgdmFyIE4gPSB3ZS5nZXRVU2hvcnQoZCwgdiArIDQgKyA4ICogSSksIHogPSB3ZS5nZXRVU2hvcnQoZCwgdiArIDQgKyA4ICogSSArIDIpO1xuICAgICAgICAgICAgICBpZiAoTiA9PT0gMyAmJiAoeiA9PT0gMCB8fCB6ID09PSAxIHx8IHogPT09IDEwKSB8fCBOID09PSAwICYmICh6ID09PSAwIHx8IHogPT09IDEgfHwgeiA9PT0gMiB8fCB6ID09PSAzIHx8IHogPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgayA9IHdlLmdldFVMb25nKGQsIHYgKyA0ICsgOCAqIEkgKyA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IC0xKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCBjbWFwIHN1Yi10YWJsZXMgZm91bmQuXCIpO1xuICAgICAgICAgICAgdmFyIFEgPSBuZXcgd2UuUGFyc2VyKGQsIHYgKyBrKTtcbiAgICAgICAgICAgIGlmICh3LmZvcm1hdCA9IFEucGFyc2VVU2hvcnQoKSwgdy5mb3JtYXQgPT09IDEyKSB7XG4gICAgICAgICAgICAgIHZhciBzZSwgb2UgPSB3LCB5ZSA9IFE7XG4gICAgICAgICAgICAgIHllLnBhcnNlVVNob3J0KCksIG9lLmxlbmd0aCA9IHllLnBhcnNlVUxvbmcoKSwgb2UubGFuZ3VhZ2UgPSB5ZS5wYXJzZVVMb25nKCksIG9lLmdyb3VwQ291bnQgPSBzZSA9IHllLnBhcnNlVUxvbmcoKSwgb2UuZ2x5cGhJbmRleE1hcCA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBTZSA9IDA7IFNlIDwgc2U7IFNlICs9IDEpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmUgPSB5ZS5wYXJzZVVMb25nKCksIGRlID0geWUucGFyc2VVTG9uZygpLCBJZSA9IHllLnBhcnNlVUxvbmcoKSwga2UgPSBiZTsga2UgPD0gZGU7IGtlICs9IDEpXG4gICAgICAgICAgICAgICAgICBvZS5nbHlwaEluZGV4TWFwW2tlXSA9IEllLCBJZSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHcuZm9ybWF0ICE9PSA0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgZm9ybWF0IDQgYW5kIDEyIGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQgKGZvdW5kIGZvcm1hdCBcIiArIHcuZm9ybWF0ICsgXCIpLlwiKTtcbiAgICAgICAgICAgICAgdmFyIEFlID0gdywgVGUgPSBkLCBFZSA9IHYsICRlID0gaztcbiAgICAgICAgICAgICAgQWUubGVuZ3RoID0gUS5wYXJzZVVTaG9ydCgpLCBBZS5sYW5ndWFnZSA9IFEucGFyc2VVU2hvcnQoKSwgQWUuc2VnQ291bnQgPSBsdCA9IFEucGFyc2VVU2hvcnQoKSA+PiAxLCBRLnNraXAoXCJ1U2hvcnRcIiwgMyksIEFlLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbHQsIGV0ID0gbmV3IHdlLlBhcnNlcihUZSwgRWUgKyAkZSArIDE0KSwgdHQgPSBuZXcgd2UuUGFyc2VyKFRlLCBFZSArICRlICsgMTYgKyAyICogbHQpLCBkdCA9IG5ldyB3ZS5QYXJzZXIoVGUsIEVlICsgJGUgKyAxNiArIDQgKiBsdCksIHd0ID0gbmV3IHdlLlBhcnNlcihUZSwgRWUgKyAkZSArIDE2ICsgNiAqIGx0KSwgT3QgPSBFZSArICRlICsgMTYgKyA4ICogbHQsIFJ0ID0gMDsgUnQgPCBsdCAtIDE7IFJ0ICs9IDEpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgSHQgPSB2b2lkIDAsIFd0ID0gZXQucGFyc2VVU2hvcnQoKSwgUXQgPSB0dC5wYXJzZVVTaG9ydCgpLCB4dCA9IGR0LnBhcnNlU2hvcnQoKSwgU3QgPSB3dC5wYXJzZVVTaG9ydCgpLCB2dCA9IFF0OyB2dCA8PSBXdDsgdnQgKz0gMSlcbiAgICAgICAgICAgICAgICAgIFN0ICE9PSAwID8gKE90ID0gKE90ID0gd3Qub2Zmc2V0ICsgd3QucmVsYXRpdmVPZmZzZXQgLSAyKSArIFN0ICsgMiAqICh2dCAtIFF0KSwgKEh0ID0gd2UuZ2V0VVNob3J0KFRlLCBPdCkpICE9PSAwICYmIChIdCA9IEh0ICsgeHQgJiA2NTUzNSkpIDogSHQgPSB2dCArIHh0ICYgNjU1MzUsIEFlLmdseXBoSW5kZXhNYXBbdnRdID0gSHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICB9LCBtYWtlOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gITAsIHcgPSBkLmxlbmd0aCAtIDE7IDAgPCB3OyAtLXcpXG4gICAgICAgICAgICAgIGlmICg2NTUzNSA8IGQuZ2V0KHcpLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGluZyBDTUFQIGZvcm1hdCAxMiAobmVlZGVkISlcIiksIHYgPSAhMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGssIEksIE4gPSBbeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcIm51bVRhYmxlc1wiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogdiA/IDEgOiAyIH0sIHsgbmFtZTogXCJwbGF0Zm9ybUlEXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAzIH0sIHsgbmFtZTogXCJlbmNvZGluZ0lEXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAxIH0sIHsgbmFtZTogXCJvZmZzZXRcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogdiA/IDEyIDogMjAgfV0sIHogPSAoTiA9IChOID0gdiA/IE4gOiBOLmNvbmNhdChbeyBuYW1lOiBcImNtYXAxMlBsYXRmb3JtSURcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDMgfSwgeyBuYW1lOiBcImNtYXAxMkVuY29kaW5nSURcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDEwIH0sIHsgbmFtZTogXCJjbWFwMTJPZmZzZXRcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9XSkpLmNvbmNhdChbeyBuYW1lOiBcImZvcm1hdFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogNCB9LCB7IG5hbWU6IFwiY21hcDRMZW5ndGhcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImxhbmd1YWdlXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJzZWdDb3VudFgyXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJzZWFyY2hSYW5nZVwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiZW50cnlTZWxlY3RvclwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwicmFuZ2VTaGlmdFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9XSksIG5ldyBNZS5UYWJsZShcImNtYXBcIiwgTikpO1xuICAgICAgICAgICAgZm9yICh6LnNlZ21lbnRzID0gW10sIHcgPSAwOyB3IDwgZC5sZW5ndGg7IHcgKz0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBRID0gZC5nZXQodyksIHNlID0gMDsgc2UgPCBRLnVuaWNvZGVzLmxlbmd0aDsgc2UgKz0gMSlcbiAgICAgICAgICAgICAgICBrID0gUS51bmljb2Rlc1tzZV0sIEkgPSB3LCB6LnNlZ21lbnRzLnB1c2goeyBlbmQ6IGssIHN0YXJ0OiBrLCBkZWx0YTogLShrIC0gSSksIG9mZnNldDogMCwgZ2x5cGhJbmRleDogSSB9KTtcbiAgICAgICAgICAgICAgei5zZWdtZW50cyA9IHouc2VnbWVudHMuc29ydChmdW5jdGlvbihFZSwgJGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWUuc3RhcnQgLSAkZS5zdGFydDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6LnNlZ21lbnRzLnB1c2goeyBlbmQ6IDY1NTM1LCBzdGFydDogNjU1MzUsIGRlbHRhOiAxLCBvZmZzZXQ6IDAgfSk7XG4gICAgICAgICAgICB2YXIgb2UgPSB6LnNlZ21lbnRzLmxlbmd0aCwgeWUgPSAwLCBTZSA9IFtdLCBiZSA9IFtdLCBkZSA9IFtdLCBJZSA9IFtdLCBrZSA9IFtdLCBBZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IG9lOyB3ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIFRlID0gei5zZWdtZW50c1t3XTtcbiAgICAgICAgICAgICAgVGUuZW5kIDw9IDY1NTM1ICYmIFRlLnN0YXJ0IDw9IDY1NTM1ID8gKFNlID0gU2UuY29uY2F0KHsgbmFtZTogXCJlbmRfXCIgKyB3LCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogVGUuZW5kIH0pLCBiZSA9IGJlLmNvbmNhdCh7IG5hbWU6IFwic3RhcnRfXCIgKyB3LCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogVGUuc3RhcnQgfSksIGRlID0gZGUuY29uY2F0KHsgbmFtZTogXCJpZERlbHRhX1wiICsgdywgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogVGUuZGVsdGEgfSksIEllID0gSWUuY29uY2F0KHsgbmFtZTogXCJpZFJhbmdlT2Zmc2V0X1wiICsgdywgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IFRlLm9mZnNldCB9KSwgVGUuZ2x5cGhJZCAhPT0gdm9pZCAwICYmIChrZSA9IGtlLmNvbmNhdCh7IG5hbWU6IFwiZ2x5cGhfXCIgKyB3LCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogVGUuZ2x5cGhJZCB9KSkpIDogeWUgKz0gMSwgdiB8fCBUZS5nbHlwaEluZGV4ID09PSB2b2lkIDAgfHwgKEFlID0gKEFlID0gKEFlID0gQWUuY29uY2F0KHsgbmFtZTogXCJjbWFwMTJTdGFydF9cIiArIHcsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IFRlLnN0YXJ0IH0pKS5jb25jYXQoeyBuYW1lOiBcImNtYXAxMkVuZF9cIiArIHcsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IFRlLmVuZCB9KSkuY29uY2F0KHsgbmFtZTogXCJjbWFwMTJHbHlwaF9cIiArIHcsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IFRlLmdseXBoSW5kZXggfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHouc2VnQ291bnRYMiA9IDIgKiAob2UgLSB5ZSksIHouc2VhcmNoUmFuZ2UgPSAyICogTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhvZSAtIHllKSAvIE1hdGgubG9nKDIpKSksIHouZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHouc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpLCB6LnJhbmdlU2hpZnQgPSB6LnNlZ0NvdW50WDIgLSB6LnNlYXJjaFJhbmdlLCB6LmZpZWxkcyA9IHouZmllbGRzLmNvbmNhdChTZSksIHouZmllbGRzLnB1c2goeyBuYW1lOiBcInJlc2VydmVkUGFkXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0pLCB6LmZpZWxkcyA9IHouZmllbGRzLmNvbmNhdChiZSksIHouZmllbGRzID0gei5maWVsZHMuY29uY2F0KGRlKSwgei5maWVsZHMgPSB6LmZpZWxkcy5jb25jYXQoSWUpLCB6LmZpZWxkcyA9IHouZmllbGRzLmNvbmNhdChrZSksIHouY21hcDRMZW5ndGggPSAxNCArIDIgKiBTZS5sZW5ndGggKyAyICsgMiAqIGJlLmxlbmd0aCArIDIgKiBkZS5sZW5ndGggKyAyICogSWUubGVuZ3RoICsgMiAqIGtlLmxlbmd0aCwgdiB8fCAoTiA9IDE2ICsgNCAqIEFlLmxlbmd0aCwgei5jbWFwMTJPZmZzZXQgPSAyMCArIHouY21hcDRMZW5ndGgsIHouZmllbGRzID0gei5maWVsZHMuY29uY2F0KFt7IG5hbWU6IFwiY21hcDEyRm9ybWF0XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAxMiB9LCB7IG5hbWU6IFwiY21hcDEyUmVzZXJ2ZWRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImNtYXAxMkxlbmd0aFwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiBOIH0sIHsgbmFtZTogXCJjbWFwMTJMYW5ndWFnZVwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjbWFwMTJuR3JvdXBzXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IEFlLmxlbmd0aCAvIDMgfV0pLCB6LmZpZWxkcyA9IHouZmllbGRzLmNvbmNhdChBZSkpLCB6O1xuICAgICAgICAgIH0gfSwgJCA9IFtcIi5ub3RkZWZcIiwgXCJzcGFjZVwiLCBcImV4Y2xhbVwiLCBcInF1b3RlZGJsXCIsIFwibnVtYmVyc2lnblwiLCBcImRvbGxhclwiLCBcInBlcmNlbnRcIiwgXCJhbXBlcnNhbmRcIiwgXCJxdW90ZXJpZ2h0XCIsIFwicGFyZW5sZWZ0XCIsIFwicGFyZW5yaWdodFwiLCBcImFzdGVyaXNrXCIsIFwicGx1c1wiLCBcImNvbW1hXCIsIFwiaHlwaGVuXCIsIFwicGVyaW9kXCIsIFwic2xhc2hcIiwgXCJ6ZXJvXCIsIFwib25lXCIsIFwidHdvXCIsIFwidGhyZWVcIiwgXCJmb3VyXCIsIFwiZml2ZVwiLCBcInNpeFwiLCBcInNldmVuXCIsIFwiZWlnaHRcIiwgXCJuaW5lXCIsIFwiY29sb25cIiwgXCJzZW1pY29sb25cIiwgXCJsZXNzXCIsIFwiZXF1YWxcIiwgXCJncmVhdGVyXCIsIFwicXVlc3Rpb25cIiwgXCJhdFwiLCBcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJIXCIsIFwiSVwiLCBcIkpcIiwgXCJLXCIsIFwiTFwiLCBcIk1cIiwgXCJOXCIsIFwiT1wiLCBcIlBcIiwgXCJRXCIsIFwiUlwiLCBcIlNcIiwgXCJUXCIsIFwiVVwiLCBcIlZcIiwgXCJXXCIsIFwiWFwiLCBcIllcIiwgXCJaXCIsIFwiYnJhY2tldGxlZnRcIiwgXCJiYWNrc2xhc2hcIiwgXCJicmFja2V0cmlnaHRcIiwgXCJhc2NpaWNpcmN1bVwiLCBcInVuZGVyc2NvcmVcIiwgXCJxdW90ZWxlZnRcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLCBcImJyYWNlbGVmdFwiLCBcImJhclwiLCBcImJyYWNlcmlnaHRcIiwgXCJhc2NpaXRpbGRlXCIsIFwiZXhjbGFtZG93blwiLCBcImNlbnRcIiwgXCJzdGVybGluZ1wiLCBcImZyYWN0aW9uXCIsIFwieWVuXCIsIFwiZmxvcmluXCIsIFwic2VjdGlvblwiLCBcImN1cnJlbmN5XCIsIFwicXVvdGVzaW5nbGVcIiwgXCJxdW90ZWRibGxlZnRcIiwgXCJndWlsbGVtb3RsZWZ0XCIsIFwiZ3VpbHNpbmdsbGVmdFwiLCBcImd1aWxzaW5nbHJpZ2h0XCIsIFwiZmlcIiwgXCJmbFwiLCBcImVuZGFzaFwiLCBcImRhZ2dlclwiLCBcImRhZ2dlcmRibFwiLCBcInBlcmlvZGNlbnRlcmVkXCIsIFwicGFyYWdyYXBoXCIsIFwiYnVsbGV0XCIsIFwicXVvdGVzaW5nbGJhc2VcIiwgXCJxdW90ZWRibGJhc2VcIiwgXCJxdW90ZWRibHJpZ2h0XCIsIFwiZ3VpbGxlbW90cmlnaHRcIiwgXCJlbGxpcHNpc1wiLCBcInBlcnRob3VzYW5kXCIsIFwicXVlc3Rpb25kb3duXCIsIFwiZ3JhdmVcIiwgXCJhY3V0ZVwiLCBcImNpcmN1bWZsZXhcIiwgXCJ0aWxkZVwiLCBcIm1hY3JvblwiLCBcImJyZXZlXCIsIFwiZG90YWNjZW50XCIsIFwiZGllcmVzaXNcIiwgXCJyaW5nXCIsIFwiY2VkaWxsYVwiLCBcImh1bmdhcnVtbGF1dFwiLCBcIm9nb25la1wiLCBcImNhcm9uXCIsIFwiZW1kYXNoXCIsIFwiQUVcIiwgXCJvcmRmZW1pbmluZVwiLCBcIkxzbGFzaFwiLCBcIk9zbGFzaFwiLCBcIk9FXCIsIFwib3JkbWFzY3VsaW5lXCIsIFwiYWVcIiwgXCJkb3RsZXNzaVwiLCBcImxzbGFzaFwiLCBcIm9zbGFzaFwiLCBcIm9lXCIsIFwiZ2VybWFuZGJsc1wiLCBcIm9uZXN1cGVyaW9yXCIsIFwibG9naWNhbG5vdFwiLCBcIm11XCIsIFwidHJhZGVtYXJrXCIsIFwiRXRoXCIsIFwib25laGFsZlwiLCBcInBsdXNtaW51c1wiLCBcIlRob3JuXCIsIFwib25lcXVhcnRlclwiLCBcImRpdmlkZVwiLCBcImJyb2tlbmJhclwiLCBcImRlZ3JlZVwiLCBcInRob3JuXCIsIFwidGhyZWVxdWFydGVyc1wiLCBcInR3b3N1cGVyaW9yXCIsIFwicmVnaXN0ZXJlZFwiLCBcIm1pbnVzXCIsIFwiZXRoXCIsIFwibXVsdGlwbHlcIiwgXCJ0aHJlZXN1cGVyaW9yXCIsIFwiY29weXJpZ2h0XCIsIFwiQWFjdXRlXCIsIFwiQWNpcmN1bWZsZXhcIiwgXCJBZGllcmVzaXNcIiwgXCJBZ3JhdmVcIiwgXCJBcmluZ1wiLCBcIkF0aWxkZVwiLCBcIkNjZWRpbGxhXCIsIFwiRWFjdXRlXCIsIFwiRWNpcmN1bWZsZXhcIiwgXCJFZGllcmVzaXNcIiwgXCJFZ3JhdmVcIiwgXCJJYWN1dGVcIiwgXCJJY2lyY3VtZmxleFwiLCBcIklkaWVyZXNpc1wiLCBcIklncmF2ZVwiLCBcIk50aWxkZVwiLCBcIk9hY3V0ZVwiLCBcIk9jaXJjdW1mbGV4XCIsIFwiT2RpZXJlc2lzXCIsIFwiT2dyYXZlXCIsIFwiT3RpbGRlXCIsIFwiU2Nhcm9uXCIsIFwiVWFjdXRlXCIsIFwiVWNpcmN1bWZsZXhcIiwgXCJVZGllcmVzaXNcIiwgXCJVZ3JhdmVcIiwgXCJZYWN1dGVcIiwgXCJZZGllcmVzaXNcIiwgXCJaY2Fyb25cIiwgXCJhYWN1dGVcIiwgXCJhY2lyY3VtZmxleFwiLCBcImFkaWVyZXNpc1wiLCBcImFncmF2ZVwiLCBcImFyaW5nXCIsIFwiYXRpbGRlXCIsIFwiY2NlZGlsbGFcIiwgXCJlYWN1dGVcIiwgXCJlY2lyY3VtZmxleFwiLCBcImVkaWVyZXNpc1wiLCBcImVncmF2ZVwiLCBcImlhY3V0ZVwiLCBcImljaXJjdW1mbGV4XCIsIFwiaWRpZXJlc2lzXCIsIFwiaWdyYXZlXCIsIFwibnRpbGRlXCIsIFwib2FjdXRlXCIsIFwib2NpcmN1bWZsZXhcIiwgXCJvZGllcmVzaXNcIiwgXCJvZ3JhdmVcIiwgXCJvdGlsZGVcIiwgXCJzY2Fyb25cIiwgXCJ1YWN1dGVcIiwgXCJ1Y2lyY3VtZmxleFwiLCBcInVkaWVyZXNpc1wiLCBcInVncmF2ZVwiLCBcInlhY3V0ZVwiLCBcInlkaWVyZXNpc1wiLCBcInpjYXJvblwiLCBcImV4Y2xhbXNtYWxsXCIsIFwiSHVuZ2FydW1sYXV0c21hbGxcIiwgXCJkb2xsYXJvbGRzdHlsZVwiLCBcImRvbGxhcnN1cGVyaW9yXCIsIFwiYW1wZXJzYW5kc21hbGxcIiwgXCJBY3V0ZXNtYWxsXCIsIFwicGFyZW5sZWZ0c3VwZXJpb3JcIiwgXCJwYXJlbnJpZ2h0c3VwZXJpb3JcIiwgXCIyNjYgZmZcIiwgXCJvbmVkb3RlbmxlYWRlclwiLCBcInplcm9vbGRzdHlsZVwiLCBcIm9uZW9sZHN0eWxlXCIsIFwidHdvb2xkc3R5bGVcIiwgXCJ0aHJlZW9sZHN0eWxlXCIsIFwiZm91cm9sZHN0eWxlXCIsIFwiZml2ZW9sZHN0eWxlXCIsIFwic2l4b2xkc3R5bGVcIiwgXCJzZXZlbm9sZHN0eWxlXCIsIFwiZWlnaHRvbGRzdHlsZVwiLCBcIm5pbmVvbGRzdHlsZVwiLCBcImNvbW1hc3VwZXJpb3JcIiwgXCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoXCIsIFwicGVyaW9kc3VwZXJpb3JcIiwgXCJxdWVzdGlvbnNtYWxsXCIsIFwiYXN1cGVyaW9yXCIsIFwiYnN1cGVyaW9yXCIsIFwiY2VudHN1cGVyaW9yXCIsIFwiZHN1cGVyaW9yXCIsIFwiZXN1cGVyaW9yXCIsIFwiaXN1cGVyaW9yXCIsIFwibHN1cGVyaW9yXCIsIFwibXN1cGVyaW9yXCIsIFwibnN1cGVyaW9yXCIsIFwib3N1cGVyaW9yXCIsIFwicnN1cGVyaW9yXCIsIFwic3N1cGVyaW9yXCIsIFwidHN1cGVyaW9yXCIsIFwiZmZcIiwgXCJmZmlcIiwgXCJmZmxcIiwgXCJwYXJlbmxlZnRpbmZlcmlvclwiLCBcInBhcmVucmlnaHRpbmZlcmlvclwiLCBcIkNpcmN1bWZsZXhzbWFsbFwiLCBcImh5cGhlbnN1cGVyaW9yXCIsIFwiR3JhdmVzbWFsbFwiLCBcIkFzbWFsbFwiLCBcIkJzbWFsbFwiLCBcIkNzbWFsbFwiLCBcIkRzbWFsbFwiLCBcIkVzbWFsbFwiLCBcIkZzbWFsbFwiLCBcIkdzbWFsbFwiLCBcIkhzbWFsbFwiLCBcIklzbWFsbFwiLCBcIkpzbWFsbFwiLCBcIktzbWFsbFwiLCBcIkxzbWFsbFwiLCBcIk1zbWFsbFwiLCBcIk5zbWFsbFwiLCBcIk9zbWFsbFwiLCBcIlBzbWFsbFwiLCBcIlFzbWFsbFwiLCBcIlJzbWFsbFwiLCBcIlNzbWFsbFwiLCBcIlRzbWFsbFwiLCBcIlVzbWFsbFwiLCBcIlZzbWFsbFwiLCBcIldzbWFsbFwiLCBcIlhzbWFsbFwiLCBcIllzbWFsbFwiLCBcIlpzbWFsbFwiLCBcImNvbG9ubW9uZXRhcnlcIiwgXCJvbmVmaXR0ZWRcIiwgXCJydXBpYWhcIiwgXCJUaWxkZXNtYWxsXCIsIFwiZXhjbGFtZG93bnNtYWxsXCIsIFwiY2VudG9sZHN0eWxlXCIsIFwiTHNsYXNoc21hbGxcIiwgXCJTY2Fyb25zbWFsbFwiLCBcIlpjYXJvbnNtYWxsXCIsIFwiRGllcmVzaXNzbWFsbFwiLCBcIkJyZXZlc21hbGxcIiwgXCJDYXJvbnNtYWxsXCIsIFwiRG90YWNjZW50c21hbGxcIiwgXCJNYWNyb25zbWFsbFwiLCBcImZpZ3VyZWRhc2hcIiwgXCJoeXBoZW5pbmZlcmlvclwiLCBcIk9nb25la3NtYWxsXCIsIFwiUmluZ3NtYWxsXCIsIFwiQ2VkaWxsYXNtYWxsXCIsIFwicXVlc3Rpb25kb3duc21hbGxcIiwgXCJvbmVlaWdodGhcIiwgXCJ0aHJlZWVpZ2h0aHNcIiwgXCJmaXZlZWlnaHRoc1wiLCBcInNldmVuZWlnaHRoc1wiLCBcIm9uZXRoaXJkXCIsIFwidHdvdGhpcmRzXCIsIFwiemVyb3N1cGVyaW9yXCIsIFwiZm91cnN1cGVyaW9yXCIsIFwiZml2ZXN1cGVyaW9yXCIsIFwic2l4c3VwZXJpb3JcIiwgXCJzZXZlbnN1cGVyaW9yXCIsIFwiZWlnaHRzdXBlcmlvclwiLCBcIm5pbmVzdXBlcmlvclwiLCBcInplcm9pbmZlcmlvclwiLCBcIm9uZWluZmVyaW9yXCIsIFwidHdvaW5mZXJpb3JcIiwgXCJ0aHJlZWluZmVyaW9yXCIsIFwiZm91cmluZmVyaW9yXCIsIFwiZml2ZWluZmVyaW9yXCIsIFwic2l4aW5mZXJpb3JcIiwgXCJzZXZlbmluZmVyaW9yXCIsIFwiZWlnaHRpbmZlcmlvclwiLCBcIm5pbmVpbmZlcmlvclwiLCBcImNlbnRpbmZlcmlvclwiLCBcImRvbGxhcmluZmVyaW9yXCIsIFwicGVyaW9kaW5mZXJpb3JcIiwgXCJjb21tYWluZmVyaW9yXCIsIFwiQWdyYXZlc21hbGxcIiwgXCJBYWN1dGVzbWFsbFwiLCBcIkFjaXJjdW1mbGV4c21hbGxcIiwgXCJBdGlsZGVzbWFsbFwiLCBcIkFkaWVyZXNpc3NtYWxsXCIsIFwiQXJpbmdzbWFsbFwiLCBcIkFFc21hbGxcIiwgXCJDY2VkaWxsYXNtYWxsXCIsIFwiRWdyYXZlc21hbGxcIiwgXCJFYWN1dGVzbWFsbFwiLCBcIkVjaXJjdW1mbGV4c21hbGxcIiwgXCJFZGllcmVzaXNzbWFsbFwiLCBcIklncmF2ZXNtYWxsXCIsIFwiSWFjdXRlc21hbGxcIiwgXCJJY2lyY3VtZmxleHNtYWxsXCIsIFwiSWRpZXJlc2lzc21hbGxcIiwgXCJFdGhzbWFsbFwiLCBcIk50aWxkZXNtYWxsXCIsIFwiT2dyYXZlc21hbGxcIiwgXCJPYWN1dGVzbWFsbFwiLCBcIk9jaXJjdW1mbGV4c21hbGxcIiwgXCJPdGlsZGVzbWFsbFwiLCBcIk9kaWVyZXNpc3NtYWxsXCIsIFwiT0VzbWFsbFwiLCBcIk9zbGFzaHNtYWxsXCIsIFwiVWdyYXZlc21hbGxcIiwgXCJVYWN1dGVzbWFsbFwiLCBcIlVjaXJjdW1mbGV4c21hbGxcIiwgXCJVZGllcmVzaXNzbWFsbFwiLCBcIllhY3V0ZXNtYWxsXCIsIFwiVGhvcm5zbWFsbFwiLCBcIllkaWVyZXNpc3NtYWxsXCIsIFwiMDAxLjAwMFwiLCBcIjAwMS4wMDFcIiwgXCIwMDEuMDAyXCIsIFwiMDAxLjAwM1wiLCBcIkJsYWNrXCIsIFwiQm9sZFwiLCBcIkJvb2tcIiwgXCJMaWdodFwiLCBcIk1lZGl1bVwiLCBcIlJlZ3VsYXJcIiwgXCJSb21hblwiLCBcIlNlbWlib2xkXCJdLCBxID0gW1wiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwic3BhY2VcIiwgXCJleGNsYW1cIiwgXCJxdW90ZWRibFwiLCBcIm51bWJlcnNpZ25cIiwgXCJkb2xsYXJcIiwgXCJwZXJjZW50XCIsIFwiYW1wZXJzYW5kXCIsIFwicXVvdGVyaWdodFwiLCBcInBhcmVubGVmdFwiLCBcInBhcmVucmlnaHRcIiwgXCJhc3Rlcmlza1wiLCBcInBsdXNcIiwgXCJjb21tYVwiLCBcImh5cGhlblwiLCBcInBlcmlvZFwiLCBcInNsYXNoXCIsIFwiemVyb1wiLCBcIm9uZVwiLCBcInR3b1wiLCBcInRocmVlXCIsIFwiZm91clwiLCBcImZpdmVcIiwgXCJzaXhcIiwgXCJzZXZlblwiLCBcImVpZ2h0XCIsIFwibmluZVwiLCBcImNvbG9uXCIsIFwic2VtaWNvbG9uXCIsIFwibGVzc1wiLCBcImVxdWFsXCIsIFwiZ3JlYXRlclwiLCBcInF1ZXN0aW9uXCIsIFwiYXRcIiwgXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIiwgXCJHXCIsIFwiSFwiLCBcIklcIiwgXCJKXCIsIFwiS1wiLCBcIkxcIiwgXCJNXCIsIFwiTlwiLCBcIk9cIiwgXCJQXCIsIFwiUVwiLCBcIlJcIiwgXCJTXCIsIFwiVFwiLCBcIlVcIiwgXCJWXCIsIFwiV1wiLCBcIlhcIiwgXCJZXCIsIFwiWlwiLCBcImJyYWNrZXRsZWZ0XCIsIFwiYmFja3NsYXNoXCIsIFwiYnJhY2tldHJpZ2h0XCIsIFwiYXNjaWljaXJjdW1cIiwgXCJ1bmRlcnNjb3JlXCIsIFwicXVvdGVsZWZ0XCIsIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiLCBcImhcIiwgXCJpXCIsIFwialwiLCBcImtcIiwgXCJsXCIsIFwibVwiLCBcIm5cIiwgXCJvXCIsIFwicFwiLCBcInFcIiwgXCJyXCIsIFwic1wiLCBcInRcIiwgXCJ1XCIsIFwidlwiLCBcIndcIiwgXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJicmFjZWxlZnRcIiwgXCJiYXJcIiwgXCJicmFjZXJpZ2h0XCIsIFwiYXNjaWl0aWxkZVwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImV4Y2xhbWRvd25cIiwgXCJjZW50XCIsIFwic3RlcmxpbmdcIiwgXCJmcmFjdGlvblwiLCBcInllblwiLCBcImZsb3JpblwiLCBcInNlY3Rpb25cIiwgXCJjdXJyZW5jeVwiLCBcInF1b3Rlc2luZ2xlXCIsIFwicXVvdGVkYmxsZWZ0XCIsIFwiZ3VpbGxlbW90bGVmdFwiLCBcImd1aWxzaW5nbGxlZnRcIiwgXCJndWlsc2luZ2xyaWdodFwiLCBcImZpXCIsIFwiZmxcIiwgXCJcIiwgXCJlbmRhc2hcIiwgXCJkYWdnZXJcIiwgXCJkYWdnZXJkYmxcIiwgXCJwZXJpb2RjZW50ZXJlZFwiLCBcIlwiLCBcInBhcmFncmFwaFwiLCBcImJ1bGxldFwiLCBcInF1b3Rlc2luZ2xiYXNlXCIsIFwicXVvdGVkYmxiYXNlXCIsIFwicXVvdGVkYmxyaWdodFwiLCBcImd1aWxsZW1vdHJpZ2h0XCIsIFwiZWxsaXBzaXNcIiwgXCJwZXJ0aG91c2FuZFwiLCBcIlwiLCBcInF1ZXN0aW9uZG93blwiLCBcIlwiLCBcImdyYXZlXCIsIFwiYWN1dGVcIiwgXCJjaXJjdW1mbGV4XCIsIFwidGlsZGVcIiwgXCJtYWNyb25cIiwgXCJicmV2ZVwiLCBcImRvdGFjY2VudFwiLCBcImRpZXJlc2lzXCIsIFwiXCIsIFwicmluZ1wiLCBcImNlZGlsbGFcIiwgXCJcIiwgXCJodW5nYXJ1bWxhdXRcIiwgXCJvZ29uZWtcIiwgXCJjYXJvblwiLCBcImVtZGFzaFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIkFFXCIsIFwiXCIsIFwib3JkZmVtaW5pbmVcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJMc2xhc2hcIiwgXCJPc2xhc2hcIiwgXCJPRVwiLCBcIm9yZG1hc2N1bGluZVwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImFlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZG90bGVzc2lcIiwgXCJcIiwgXCJcIiwgXCJsc2xhc2hcIiwgXCJvc2xhc2hcIiwgXCJvZVwiLCBcImdlcm1hbmRibHNcIl0sIGVlID0gW1wiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwic3BhY2VcIiwgXCJleGNsYW1zbWFsbFwiLCBcIkh1bmdhcnVtbGF1dHNtYWxsXCIsIFwiXCIsIFwiZG9sbGFyb2xkc3R5bGVcIiwgXCJkb2xsYXJzdXBlcmlvclwiLCBcImFtcGVyc2FuZHNtYWxsXCIsIFwiQWN1dGVzbWFsbFwiLCBcInBhcmVubGVmdHN1cGVyaW9yXCIsIFwicGFyZW5yaWdodHN1cGVyaW9yXCIsIFwidHdvZG90ZW5sZWFkZXJcIiwgXCJvbmVkb3RlbmxlYWRlclwiLCBcImNvbW1hXCIsIFwiaHlwaGVuXCIsIFwicGVyaW9kXCIsIFwiZnJhY3Rpb25cIiwgXCJ6ZXJvb2xkc3R5bGVcIiwgXCJvbmVvbGRzdHlsZVwiLCBcInR3b29sZHN0eWxlXCIsIFwidGhyZWVvbGRzdHlsZVwiLCBcImZvdXJvbGRzdHlsZVwiLCBcImZpdmVvbGRzdHlsZVwiLCBcInNpeG9sZHN0eWxlXCIsIFwic2V2ZW5vbGRzdHlsZVwiLCBcImVpZ2h0b2xkc3R5bGVcIiwgXCJuaW5lb2xkc3R5bGVcIiwgXCJjb2xvblwiLCBcInNlbWljb2xvblwiLCBcImNvbW1hc3VwZXJpb3JcIiwgXCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoXCIsIFwicGVyaW9kc3VwZXJpb3JcIiwgXCJxdWVzdGlvbnNtYWxsXCIsIFwiXCIsIFwiYXN1cGVyaW9yXCIsIFwiYnN1cGVyaW9yXCIsIFwiY2VudHN1cGVyaW9yXCIsIFwiZHN1cGVyaW9yXCIsIFwiZXN1cGVyaW9yXCIsIFwiXCIsIFwiXCIsIFwiaXN1cGVyaW9yXCIsIFwiXCIsIFwiXCIsIFwibHN1cGVyaW9yXCIsIFwibXN1cGVyaW9yXCIsIFwibnN1cGVyaW9yXCIsIFwib3N1cGVyaW9yXCIsIFwiXCIsIFwiXCIsIFwicnN1cGVyaW9yXCIsIFwic3N1cGVyaW9yXCIsIFwidHN1cGVyaW9yXCIsIFwiXCIsIFwiZmZcIiwgXCJmaVwiLCBcImZsXCIsIFwiZmZpXCIsIFwiZmZsXCIsIFwicGFyZW5sZWZ0aW5mZXJpb3JcIiwgXCJcIiwgXCJwYXJlbnJpZ2h0aW5mZXJpb3JcIiwgXCJDaXJjdW1mbGV4c21hbGxcIiwgXCJoeXBoZW5zdXBlcmlvclwiLCBcIkdyYXZlc21hbGxcIiwgXCJBc21hbGxcIiwgXCJCc21hbGxcIiwgXCJDc21hbGxcIiwgXCJEc21hbGxcIiwgXCJFc21hbGxcIiwgXCJGc21hbGxcIiwgXCJHc21hbGxcIiwgXCJIc21hbGxcIiwgXCJJc21hbGxcIiwgXCJKc21hbGxcIiwgXCJLc21hbGxcIiwgXCJMc21hbGxcIiwgXCJNc21hbGxcIiwgXCJOc21hbGxcIiwgXCJPc21hbGxcIiwgXCJQc21hbGxcIiwgXCJRc21hbGxcIiwgXCJSc21hbGxcIiwgXCJTc21hbGxcIiwgXCJUc21hbGxcIiwgXCJVc21hbGxcIiwgXCJWc21hbGxcIiwgXCJXc21hbGxcIiwgXCJYc21hbGxcIiwgXCJZc21hbGxcIiwgXCJac21hbGxcIiwgXCJjb2xvbm1vbmV0YXJ5XCIsIFwib25lZml0dGVkXCIsIFwicnVwaWFoXCIsIFwiVGlsZGVzbWFsbFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImV4Y2xhbWRvd25zbWFsbFwiLCBcImNlbnRvbGRzdHlsZVwiLCBcIkxzbGFzaHNtYWxsXCIsIFwiXCIsIFwiXCIsIFwiU2Nhcm9uc21hbGxcIiwgXCJaY2Fyb25zbWFsbFwiLCBcIkRpZXJlc2lzc21hbGxcIiwgXCJCcmV2ZXNtYWxsXCIsIFwiQ2Fyb25zbWFsbFwiLCBcIlwiLCBcIkRvdGFjY2VudHNtYWxsXCIsIFwiXCIsIFwiXCIsIFwiTWFjcm9uc21hbGxcIiwgXCJcIiwgXCJcIiwgXCJmaWd1cmVkYXNoXCIsIFwiaHlwaGVuaW5mZXJpb3JcIiwgXCJcIiwgXCJcIiwgXCJPZ29uZWtzbWFsbFwiLCBcIlJpbmdzbWFsbFwiLCBcIkNlZGlsbGFzbWFsbFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIm9uZXF1YXJ0ZXJcIiwgXCJvbmVoYWxmXCIsIFwidGhyZWVxdWFydGVyc1wiLCBcInF1ZXN0aW9uZG93bnNtYWxsXCIsIFwib25lZWlnaHRoXCIsIFwidGhyZWVlaWdodGhzXCIsIFwiZml2ZWVpZ2h0aHNcIiwgXCJzZXZlbmVpZ2h0aHNcIiwgXCJvbmV0aGlyZFwiLCBcInR3b3RoaXJkc1wiLCBcIlwiLCBcIlwiLCBcInplcm9zdXBlcmlvclwiLCBcIm9uZXN1cGVyaW9yXCIsIFwidHdvc3VwZXJpb3JcIiwgXCJ0aHJlZXN1cGVyaW9yXCIsIFwiZm91cnN1cGVyaW9yXCIsIFwiZml2ZXN1cGVyaW9yXCIsIFwic2l4c3VwZXJpb3JcIiwgXCJzZXZlbnN1cGVyaW9yXCIsIFwiZWlnaHRzdXBlcmlvclwiLCBcIm5pbmVzdXBlcmlvclwiLCBcInplcm9pbmZlcmlvclwiLCBcIm9uZWluZmVyaW9yXCIsIFwidHdvaW5mZXJpb3JcIiwgXCJ0aHJlZWluZmVyaW9yXCIsIFwiZm91cmluZmVyaW9yXCIsIFwiZml2ZWluZmVyaW9yXCIsIFwic2l4aW5mZXJpb3JcIiwgXCJzZXZlbmluZmVyaW9yXCIsIFwiZWlnaHRpbmZlcmlvclwiLCBcIm5pbmVpbmZlcmlvclwiLCBcImNlbnRpbmZlcmlvclwiLCBcImRvbGxhcmluZmVyaW9yXCIsIFwicGVyaW9kaW5mZXJpb3JcIiwgXCJjb21tYWluZmVyaW9yXCIsIFwiQWdyYXZlc21hbGxcIiwgXCJBYWN1dGVzbWFsbFwiLCBcIkFjaXJjdW1mbGV4c21hbGxcIiwgXCJBdGlsZGVzbWFsbFwiLCBcIkFkaWVyZXNpc3NtYWxsXCIsIFwiQXJpbmdzbWFsbFwiLCBcIkFFc21hbGxcIiwgXCJDY2VkaWxsYXNtYWxsXCIsIFwiRWdyYXZlc21hbGxcIiwgXCJFYWN1dGVzbWFsbFwiLCBcIkVjaXJjdW1mbGV4c21hbGxcIiwgXCJFZGllcmVzaXNzbWFsbFwiLCBcIklncmF2ZXNtYWxsXCIsIFwiSWFjdXRlc21hbGxcIiwgXCJJY2lyY3VtZmxleHNtYWxsXCIsIFwiSWRpZXJlc2lzc21hbGxcIiwgXCJFdGhzbWFsbFwiLCBcIk50aWxkZXNtYWxsXCIsIFwiT2dyYXZlc21hbGxcIiwgXCJPYWN1dGVzbWFsbFwiLCBcIk9jaXJjdW1mbGV4c21hbGxcIiwgXCJPdGlsZGVzbWFsbFwiLCBcIk9kaWVyZXNpc3NtYWxsXCIsIFwiT0VzbWFsbFwiLCBcIk9zbGFzaHNtYWxsXCIsIFwiVWdyYXZlc21hbGxcIiwgXCJVYWN1dGVzbWFsbFwiLCBcIlVjaXJjdW1mbGV4c21hbGxcIiwgXCJVZGllcmVzaXNzbWFsbFwiLCBcIllhY3V0ZXNtYWxsXCIsIFwiVGhvcm5zbWFsbFwiLCBcIllkaWVyZXNpc3NtYWxsXCJdLCBwZSA9IFtcIi5ub3RkZWZcIiwgXCIubnVsbFwiLCBcIm5vbm1hcmtpbmdyZXR1cm5cIiwgXCJzcGFjZVwiLCBcImV4Y2xhbVwiLCBcInF1b3RlZGJsXCIsIFwibnVtYmVyc2lnblwiLCBcImRvbGxhclwiLCBcInBlcmNlbnRcIiwgXCJhbXBlcnNhbmRcIiwgXCJxdW90ZXNpbmdsZVwiLCBcInBhcmVubGVmdFwiLCBcInBhcmVucmlnaHRcIiwgXCJhc3Rlcmlza1wiLCBcInBsdXNcIiwgXCJjb21tYVwiLCBcImh5cGhlblwiLCBcInBlcmlvZFwiLCBcInNsYXNoXCIsIFwiemVyb1wiLCBcIm9uZVwiLCBcInR3b1wiLCBcInRocmVlXCIsIFwiZm91clwiLCBcImZpdmVcIiwgXCJzaXhcIiwgXCJzZXZlblwiLCBcImVpZ2h0XCIsIFwibmluZVwiLCBcImNvbG9uXCIsIFwic2VtaWNvbG9uXCIsIFwibGVzc1wiLCBcImVxdWFsXCIsIFwiZ3JlYXRlclwiLCBcInF1ZXN0aW9uXCIsIFwiYXRcIiwgXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIiwgXCJHXCIsIFwiSFwiLCBcIklcIiwgXCJKXCIsIFwiS1wiLCBcIkxcIiwgXCJNXCIsIFwiTlwiLCBcIk9cIiwgXCJQXCIsIFwiUVwiLCBcIlJcIiwgXCJTXCIsIFwiVFwiLCBcIlVcIiwgXCJWXCIsIFwiV1wiLCBcIlhcIiwgXCJZXCIsIFwiWlwiLCBcImJyYWNrZXRsZWZ0XCIsIFwiYmFja3NsYXNoXCIsIFwiYnJhY2tldHJpZ2h0XCIsIFwiYXNjaWljaXJjdW1cIiwgXCJ1bmRlcnNjb3JlXCIsIFwiZ3JhdmVcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLCBcImJyYWNlbGVmdFwiLCBcImJhclwiLCBcImJyYWNlcmlnaHRcIiwgXCJhc2NpaXRpbGRlXCIsIFwiQWRpZXJlc2lzXCIsIFwiQXJpbmdcIiwgXCJDY2VkaWxsYVwiLCBcIkVhY3V0ZVwiLCBcIk50aWxkZVwiLCBcIk9kaWVyZXNpc1wiLCBcIlVkaWVyZXNpc1wiLCBcImFhY3V0ZVwiLCBcImFncmF2ZVwiLCBcImFjaXJjdW1mbGV4XCIsIFwiYWRpZXJlc2lzXCIsIFwiYXRpbGRlXCIsIFwiYXJpbmdcIiwgXCJjY2VkaWxsYVwiLCBcImVhY3V0ZVwiLCBcImVncmF2ZVwiLCBcImVjaXJjdW1mbGV4XCIsIFwiZWRpZXJlc2lzXCIsIFwiaWFjdXRlXCIsIFwiaWdyYXZlXCIsIFwiaWNpcmN1bWZsZXhcIiwgXCJpZGllcmVzaXNcIiwgXCJudGlsZGVcIiwgXCJvYWN1dGVcIiwgXCJvZ3JhdmVcIiwgXCJvY2lyY3VtZmxleFwiLCBcIm9kaWVyZXNpc1wiLCBcIm90aWxkZVwiLCBcInVhY3V0ZVwiLCBcInVncmF2ZVwiLCBcInVjaXJjdW1mbGV4XCIsIFwidWRpZXJlc2lzXCIsIFwiZGFnZ2VyXCIsIFwiZGVncmVlXCIsIFwiY2VudFwiLCBcInN0ZXJsaW5nXCIsIFwic2VjdGlvblwiLCBcImJ1bGxldFwiLCBcInBhcmFncmFwaFwiLCBcImdlcm1hbmRibHNcIiwgXCJyZWdpc3RlcmVkXCIsIFwiY29weXJpZ2h0XCIsIFwidHJhZGVtYXJrXCIsIFwiYWN1dGVcIiwgXCJkaWVyZXNpc1wiLCBcIm5vdGVxdWFsXCIsIFwiQUVcIiwgXCJPc2xhc2hcIiwgXCJpbmZpbml0eVwiLCBcInBsdXNtaW51c1wiLCBcImxlc3NlcXVhbFwiLCBcImdyZWF0ZXJlcXVhbFwiLCBcInllblwiLCBcIm11XCIsIFwicGFydGlhbGRpZmZcIiwgXCJzdW1tYXRpb25cIiwgXCJwcm9kdWN0XCIsIFwicGlcIiwgXCJpbnRlZ3JhbFwiLCBcIm9yZGZlbWluaW5lXCIsIFwib3JkbWFzY3VsaW5lXCIsIFwiT21lZ2FcIiwgXCJhZVwiLCBcIm9zbGFzaFwiLCBcInF1ZXN0aW9uZG93blwiLCBcImV4Y2xhbWRvd25cIiwgXCJsb2dpY2Fsbm90XCIsIFwicmFkaWNhbFwiLCBcImZsb3JpblwiLCBcImFwcHJveGVxdWFsXCIsIFwiRGVsdGFcIiwgXCJndWlsbGVtb3RsZWZ0XCIsIFwiZ3VpbGxlbW90cmlnaHRcIiwgXCJlbGxpcHNpc1wiLCBcIm5vbmJyZWFraW5nc3BhY2VcIiwgXCJBZ3JhdmVcIiwgXCJBdGlsZGVcIiwgXCJPdGlsZGVcIiwgXCJPRVwiLCBcIm9lXCIsIFwiZW5kYXNoXCIsIFwiZW1kYXNoXCIsIFwicXVvdGVkYmxsZWZ0XCIsIFwicXVvdGVkYmxyaWdodFwiLCBcInF1b3RlbGVmdFwiLCBcInF1b3RlcmlnaHRcIiwgXCJkaXZpZGVcIiwgXCJsb3plbmdlXCIsIFwieWRpZXJlc2lzXCIsIFwiWWRpZXJlc2lzXCIsIFwiZnJhY3Rpb25cIiwgXCJjdXJyZW5jeVwiLCBcImd1aWxzaW5nbGxlZnRcIiwgXCJndWlsc2luZ2xyaWdodFwiLCBcImZpXCIsIFwiZmxcIiwgXCJkYWdnZXJkYmxcIiwgXCJwZXJpb2RjZW50ZXJlZFwiLCBcInF1b3Rlc2luZ2xiYXNlXCIsIFwicXVvdGVkYmxiYXNlXCIsIFwicGVydGhvdXNhbmRcIiwgXCJBY2lyY3VtZmxleFwiLCBcIkVjaXJjdW1mbGV4XCIsIFwiQWFjdXRlXCIsIFwiRWRpZXJlc2lzXCIsIFwiRWdyYXZlXCIsIFwiSWFjdXRlXCIsIFwiSWNpcmN1bWZsZXhcIiwgXCJJZGllcmVzaXNcIiwgXCJJZ3JhdmVcIiwgXCJPYWN1dGVcIiwgXCJPY2lyY3VtZmxleFwiLCBcImFwcGxlXCIsIFwiT2dyYXZlXCIsIFwiVWFjdXRlXCIsIFwiVWNpcmN1bWZsZXhcIiwgXCJVZ3JhdmVcIiwgXCJkb3RsZXNzaVwiLCBcImNpcmN1bWZsZXhcIiwgXCJ0aWxkZVwiLCBcIm1hY3JvblwiLCBcImJyZXZlXCIsIFwiZG90YWNjZW50XCIsIFwicmluZ1wiLCBcImNlZGlsbGFcIiwgXCJodW5nYXJ1bWxhdXRcIiwgXCJvZ29uZWtcIiwgXCJjYXJvblwiLCBcIkxzbGFzaFwiLCBcImxzbGFzaFwiLCBcIlNjYXJvblwiLCBcInNjYXJvblwiLCBcIlpjYXJvblwiLCBcInpjYXJvblwiLCBcImJyb2tlbmJhclwiLCBcIkV0aFwiLCBcImV0aFwiLCBcIllhY3V0ZVwiLCBcInlhY3V0ZVwiLCBcIlRob3JuXCIsIFwidGhvcm5cIiwgXCJtaW51c1wiLCBcIm11bHRpcGx5XCIsIFwib25lc3VwZXJpb3JcIiwgXCJ0d29zdXBlcmlvclwiLCBcInRocmVlc3VwZXJpb3JcIiwgXCJvbmVoYWxmXCIsIFwib25lcXVhcnRlclwiLCBcInRocmVlcXVhcnRlcnNcIiwgXCJmcmFuY1wiLCBcIkdicmV2ZVwiLCBcImdicmV2ZVwiLCBcIklkb3RhY2NlbnRcIiwgXCJTY2VkaWxsYVwiLCBcInNjZWRpbGxhXCIsIFwiQ2FjdXRlXCIsIFwiY2FjdXRlXCIsIFwiQ2Nhcm9uXCIsIFwiY2Nhcm9uXCIsIFwiZGNyb2F0XCJdO1xuICAgICAgICAgIGZ1bmN0aW9uIGplKGQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udCA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIENlKGQpIHtcbiAgICAgICAgICAgIHRoaXMuY21hcCA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEZlKGQsIHYpIHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RpbmcgPSBkLCB0aGlzLmNoYXJzZXQgPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBOZShkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGQudmVyc2lvbikge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lcyA9IHBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KGQubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgZC5udW1iZXJPZkdseXBoczsgdisrKVxuICAgICAgICAgICAgICAgICAgZC5nbHlwaE5hbWVJbmRleFt2XSA8IHBlLmxlbmd0aCA/IHRoaXMubmFtZXNbdl0gPSBwZVtkLmdseXBoTmFtZUluZGV4W3ZdXSA6IHRoaXMubmFtZXNbdl0gPSBkLm5hbWVzW2QuZ2x5cGhOYW1lSW5kZXhbdl0gLSBwZS5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KGQubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgZC5udW1iZXJPZkdseXBoczsgdysrKVxuICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1t3XSA9IHBlW3cgKyBkLmdseXBoTmFtZUluZGV4W3ddXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGplLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLmNvZGVQb2ludEF0KDApLCB3ID0gdGhpcy5mb250LmdseXBocztcbiAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdy5sZW5ndGg7IGsgKz0gMSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBJID0gdy5nZXQoayksIE4gPSAwOyBOIDwgSS51bmljb2Rlcy5sZW5ndGg7IE4gKz0gMSlcbiAgICAgICAgICAgICAgICAgIGlmIChJLnVuaWNvZGVzW05dID09PSB2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0sIENlLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2QuY29kZVBvaW50QXQoMCldIHx8IDA7XG4gICAgICAgICAgfSwgRmUucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9IGQuY29kZVBvaW50QXQoMCksIGQgPSB0aGlzLmVuY29kaW5nW2RdLCB0aGlzLmNoYXJzZXQuaW5kZXhPZihkKTtcbiAgICAgICAgICB9LCBOZS5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVzLmluZGV4T2YoZCk7XG4gICAgICAgICAgfSwgTmUucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lc1tkXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBCZSA9IHsgbGluZTogZnVuY3Rpb24oZCwgdiwgdywgaywgSSkge1xuICAgICAgICAgICAgZC5iZWdpblBhdGgoKSwgZC5tb3ZlVG8odiwgdyksIGQubGluZVRvKGssIEkpLCBkLnN0cm9rZSgpO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgICBmdW5jdGlvbiBXZShkKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3QoZCwgdiwgdykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsIHYsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQucGF0aCwgZFt3XTtcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICBkW3ddID0gaztcbiAgICAgICAgICAgIH0sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBudChkLCB2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb250ID0gZCwgdGhpcy5nbHlwaHMgPSB7fSwgQXJyYXkuaXNBcnJheSh2KSlcbiAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB2Lmxlbmd0aDsgdysrKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW3ddID0gdlt3XTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdiAmJiB2Lmxlbmd0aCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBXZS5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gZC5pbmRleCB8fCAwLCB0aGlzLm5hbWUgPSBkLm5hbWUgfHwgbnVsbCwgdGhpcy51bmljb2RlID0gZC51bmljb2RlIHx8IHZvaWQgMCwgdGhpcy51bmljb2RlcyA9IGQudW5pY29kZXMgfHwgZC51bmljb2RlICE9PSB2b2lkIDAgPyBbZC51bmljb2RlXSA6IFtdLCBkLnhNaW4gJiYgKHRoaXMueE1pbiA9IGQueE1pbiksIGQueU1pbiAmJiAodGhpcy55TWluID0gZC55TWluKSwgZC54TWF4ICYmICh0aGlzLnhNYXggPSBkLnhNYXgpLCBkLnlNYXggJiYgKHRoaXMueU1heCA9IGQueU1heCksIGQuYWR2YW5jZVdpZHRoICYmICh0aGlzLmFkdmFuY2VXaWR0aCA9IGQuYWR2YW5jZVdpZHRoKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCAoZCA9IGQucGF0aCwgdiA9IGQgfHwgbmV3IFgoKSwgeyBjb25maWd1cmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdiA9IHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIiA/IHYoKSA6IHY7XG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICB9LCBXZS5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwICYmICh0aGlzLnVuaWNvZGUgPSBkKSwgdGhpcy51bmljb2Rlcy5wdXNoKGQpO1xuICAgICAgICAgIH0sIFdlLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgIH0sIFdlLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oZCwgdiwgdywgaywgSSkge1xuICAgICAgICAgICAgZCA9IGQgIT09IHZvaWQgMCA/IGQgOiAwLCB2ID0gdiAhPT0gdm9pZCAwID8gdiA6IDAsIHcgPSB3ICE9PSB2b2lkIDAgPyB3IDogNzI7XG4gICAgICAgICAgICBmb3IgKHZhciBOLCB6LCBRID0gKGsgPSBrIHx8IHt9KS54U2NhbGUsIHNlID0gay55U2NhbGUsIG9lID0gKChOID0gay5oaW50aW5nICYmIEkgJiYgSS5oaW50aW5nID8gdGhpcy5wYXRoICYmIEkuaGludGluZy5leGVjKHRoaXMsIHcpIDogTikgPyAoeiA9IEkuaGludGluZy5nZXRDb21tYW5kcyhOKSwgZCA9IE1hdGgucm91bmQoZCksIHYgPSBNYXRoLnJvdW5kKHYpLCBRID0gc2UgPSAxKSA6ICh6ID0gdGhpcy5wYXRoLmNvbW1hbmRzLCBrID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogdywgUSA9PT0gdm9pZCAwICYmIChRID0gayksIHNlID09PSB2b2lkIDAgJiYgKHNlID0gaykpLCBuZXcgWCgpKSwgeWUgPSAwOyB5ZSA8IHoubGVuZ3RoOyB5ZSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBTZSA9IHpbeWVdO1xuICAgICAgICAgICAgICBTZS50eXBlID09PSBcIk1cIiA/IG9lLm1vdmVUbyhkICsgU2UueCAqIFEsIHYgKyAtU2UueSAqIHNlKSA6IFNlLnR5cGUgPT09IFwiTFwiID8gb2UubGluZVRvKGQgKyBTZS54ICogUSwgdiArIC1TZS55ICogc2UpIDogU2UudHlwZSA9PT0gXCJRXCIgPyBvZS5xdWFkcmF0aWNDdXJ2ZVRvKGQgKyBTZS54MSAqIFEsIHYgKyAtU2UueTEgKiBzZSwgZCArIFNlLnggKiBRLCB2ICsgLVNlLnkgKiBzZSkgOiBTZS50eXBlID09PSBcIkNcIiA/IG9lLmN1cnZlVG8oZCArIFNlLngxICogUSwgdiArIC1TZS55MSAqIHNlLCBkICsgU2UueDIgKiBRLCB2ICsgLVNlLnkyICogc2UsIGQgKyBTZS54ICogUSwgdiArIC1TZS55ICogc2UpIDogU2UudHlwZSA9PT0gXCJaXCIgJiYgb2UuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2U7XG4gICAgICAgICAgfSwgV2UucHJvdG90eXBlLmdldENvbnRvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludHMgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IFtdLCB2ID0gW10sIHcgPSAwOyB3IDwgdGhpcy5wb2ludHMubGVuZ3RoOyB3ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSB0aGlzLnBvaW50c1t3XTtcbiAgICAgICAgICAgICAgdi5wdXNoKGspLCBrLmxhc3RQb2ludE9mQ29udG91ciAmJiAoZC5wdXNoKHYpLCB2ID0gW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE8uYXJndW1lbnQodi5sZW5ndGggPT09IDAsIFwiVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuXCIpLCBkO1xuICAgICAgICAgIH0sIFdlLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gdGhpcy5wYXRoLmNvbW1hbmRzLCB2ID0gW10sIHcgPSBbXSwgayA9IDA7IGsgPCBkLmxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBJID0gZFtrXTtcbiAgICAgICAgICAgICAgSS50eXBlICE9PSBcIlpcIiAmJiAodi5wdXNoKEkueCksIHcucHVzaChJLnkpKSwgSS50eXBlICE9PSBcIlFcIiAmJiBJLnR5cGUgIT09IFwiQ1wiIHx8ICh2LnB1c2goSS54MSksIHcucHVzaChJLnkxKSksIEkudHlwZSA9PT0gXCJDXCIgJiYgKHYucHVzaChJLngyKSwgdy5wdXNoKEkueTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBOID0geyB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB2KSwgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgdyksIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHYpLCB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB3KSwgbGVmdFNpZGVCZWFyaW5nOiB0aGlzLmxlZnRTaWRlQmVhcmluZyB9O1xuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKE4ueE1pbikgfHwgKE4ueE1pbiA9IDApLCBpc0Zpbml0ZShOLnhNYXgpIHx8IChOLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aCksIGlzRmluaXRlKE4ueU1pbikgfHwgKE4ueU1pbiA9IDApLCBpc0Zpbml0ZShOLnlNYXgpIHx8IChOLnlNYXggPSAwKSwgTi5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBOLmxlZnRTaWRlQmVhcmluZyAtIChOLnhNYXggLSBOLnhNaW4pLCBOO1xuICAgICAgICAgIH0sIFdlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZCwgdiwgdywgaywgSSkge1xuICAgICAgICAgICAgdGhpcy5nZXRQYXRoKHYsIHcsIGssIEkpLmRyYXcoZCk7XG4gICAgICAgICAgfSwgV2UucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJKHllLCBTZSwgYmUsIGRlKSB7XG4gICAgICAgICAgICAgIHZhciBJZSA9IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICBkLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZSA9IDA7IGtlIDwgeWUubGVuZ3RoOyBrZSArPSAxKVxuICAgICAgICAgICAgICAgIGQubW92ZVRvKFNlICsgeWVba2VdLnggKiBkZSwgYmUgKyB5ZVtrZV0ueSAqIGRlKSwgZC5hcmMoU2UgKyB5ZVtrZV0ueCAqIGRlLCBiZSArIHllW2tlXS55ICogZGUsIDIsIDAsIEllLCAhMSk7XG4gICAgICAgICAgICAgIGQuY2xvc2VQYXRoKCksIGQuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiA9IHYgIT09IHZvaWQgMCA/IHYgOiAwLCB3ID0gdyAhPT0gdm9pZCAwID8gdyA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogKGsgPSBrICE9PSB2b2lkIDAgPyBrIDogMjQpLCBOID0gW10sIHogPSBbXSwgUSA9IHRoaXMucGF0aCwgc2UgPSAwOyBzZSA8IFEuY29tbWFuZHMubGVuZ3RoOyBzZSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBvZSA9IFEuY29tbWFuZHNbc2VdO1xuICAgICAgICAgICAgICBvZS54ICE9PSB2b2lkIDAgJiYgTi5wdXNoKHsgeDogb2UueCwgeTogLW9lLnkgfSksIG9lLngxICE9PSB2b2lkIDAgJiYgei5wdXNoKHsgeDogb2UueDEsIHk6IC1vZS55MSB9KSwgb2UueDIgIT09IHZvaWQgMCAmJiB6LnB1c2goeyB4OiBvZS54MiwgeTogLW9lLnkyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5maWxsU3R5bGUgPSBcImJsdWVcIiwgSShOLCB2LCB3LCBrKSwgZC5maWxsU3R5bGUgPSBcInJlZFwiLCBJKHosIHYsIHcsIGspO1xuICAgICAgICAgIH0sIFdlLnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHYgPSB2ICE9PSB2b2lkIDAgPyB2IDogMCwgdyA9IHcgIT09IHZvaWQgMCA/IHcgOiAwLCBrID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogKGsgPSBrICE9PSB2b2lkIDAgPyBrIDogMjQpLCBkLmxpbmVXaWR0aCA9IDEsIGQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCIsIEJlLmxpbmUoZCwgdiwgLTFlNCwgdiwgMWU0KSwgQmUubGluZShkLCAtMWU0LCB3LCAxZTQsIHcpO1xuICAgICAgICAgICAgdmFyIEkgPSB0aGlzLnhNaW4gfHwgMCwgTiA9IHRoaXMueU1pbiB8fCAwLCB6ID0gdGhpcy54TWF4IHx8IDAsIFEgPSB0aGlzLnlNYXggfHwgMCwgc2UgPSB0aGlzLmFkdmFuY2VXaWR0aCB8fCAwO1xuICAgICAgICAgICAgZC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiLCBCZS5saW5lKGQsIHYgKyBJICogaywgLTFlNCwgdiArIEkgKiBrLCAxZTQpLCBCZS5saW5lKGQsIHYgKyB6ICogaywgLTFlNCwgdiArIHogKiBrLCAxZTQpLCBCZS5saW5lKGQsIC0xZTQsIHcgKyAtTiAqIGssIDFlNCwgdyArIC1OICogayksIEJlLmxpbmUoZCwgLTFlNCwgdyArIC1RICogaywgMWU0LCB3ICsgLVEgKiBrKSwgZC5zdHJva2VTdHlsZSA9IFwiZ3JlZW5cIiwgQmUubGluZShkLCB2ICsgc2UgKiBrLCAtMWU0LCB2ICsgc2UgKiBrLCAxZTQpO1xuICAgICAgICAgIH0sIG50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZ2x5cGhzW2RdID09IFwiZnVuY3Rpb25cIiAmJiAodGhpcy5nbHlwaHNbZF0gPSB0aGlzLmdseXBoc1tkXSgpKSwgdGhpcy5nbHlwaHNbZF07XG4gICAgICAgICAgfSwgbnQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tkXSA9IHYsIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgS2UgPSB7IEdseXBoU2V0OiBudCwgZ2x5cGhMb2FkZXI6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2UoeyBpbmRleDogdiwgZm9udDogZCB9KTtcbiAgICAgICAgICB9LCB0dGZHbHlwaExvYWRlcjogZnVuY3Rpb24oZCwgdiwgdywgaywgSSwgTikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgeiA9IG5ldyBXZSh7IGluZGV4OiB2LCBmb250OiBkIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gei5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdyh6LCBrLCBJKTtcbiAgICAgICAgICAgICAgICB2YXIgUSA9IE4oZC5nbHlwaHMsIHopO1xuICAgICAgICAgICAgICAgIHJldHVybiBRLnVuaXRzUGVyRW0gPSBkLnVuaXRzUGVyRW0sIFE7XG4gICAgICAgICAgICAgIH0sIHN0KHosIFwieE1pblwiLCBcIl94TWluXCIpLCBzdCh6LCBcInhNYXhcIiwgXCJfeE1heFwiKSwgc3QoeiwgXCJ5TWluXCIsIFwiX3lNaW5cIiksIHN0KHosIFwieU1heFwiLCBcIl95TWF4XCIpLCB6O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCBjZmZHbHlwaExvYWRlcjogZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgSSA9IG5ldyBXZSh7IGluZGV4OiB2LCBmb250OiBkIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gSS5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIE4gPSB3KGQsIEksIGspO1xuICAgICAgICAgICAgICAgIHJldHVybiBOLnVuaXRzUGVyRW0gPSBkLnVuaXRzUGVyRW0sIE47XG4gICAgICAgICAgICAgIH0sIEk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgICBmdW5jdGlvbiBhdChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9IGQubGVuZ3RoIDwgMTI0MCA/IDEwNyA6IGQubGVuZ3RoIDwgMzM5MDAgPyAxMTMxIDogMzI3NjgsIGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG90KGQsIHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBrLCBJID0gW10sIE4gPSBbXSwgeiA9IHdlLmdldENhcmQxNihkLCB2KTtcbiAgICAgICAgICAgIGlmICh6ICE9PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIFEgPSB3ZS5nZXRCeXRlKGQsIHYgKyAyKSwgc2UgPSB2ICsgKHogKyAxKSAqIFEgKyAyLCBvZSA9IHYgKyAzLCB5ZSA9IDA7IHllIDwgeiArIDE7IHllICs9IDEpXG4gICAgICAgICAgICAgICAgSS5wdXNoKHdlLmdldE9mZnNldChkLCBvZSwgUSkpLCBvZSArPSBRO1xuICAgICAgICAgICAgICBrID0gc2UgKyBJW3pdO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGsgPSB2ICsgMjtcbiAgICAgICAgICAgIGZvciAodmFyIFNlID0gMDsgU2UgPCBJLmxlbmd0aCAtIDE7IFNlICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGJlID0gd2UuZ2V0Qnl0ZXMoZCwgc2UgKyBJW1NlXSwgc2UgKyBJW1NlICsgMV0pO1xuICAgICAgICAgICAgICB3ICYmIChiZSA9IHcoYmUpKSwgTi5wdXNoKGJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG9iamVjdHM6IE4sIHN0YXJ0T2Zmc2V0OiB2LCBlbmRPZmZzZXQ6IGsgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYnQoZCwgdikge1xuICAgICAgICAgICAgaWYgKHYgPT09IDI4KVxuICAgICAgICAgICAgICByZXR1cm4gZC5wYXJzZUJ5dGUoKSA8PCA4IHwgZC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGlmICh2ID09PSAyOSlcbiAgICAgICAgICAgICAgcmV0dXJuIGQucGFyc2VCeXRlKCkgPDwgMjQgfCBkLnBhcnNlQnl0ZSgpIDw8IDE2IHwgZC5wYXJzZUJ5dGUoKSA8PCA4IHwgZC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGlmICh2ID09PSAzMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gZCwgayA9IFwiXCIsIEkgPSBbXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiLlwiLCBcIkVcIiwgXCJFLVwiLCBudWxsLCBcIi1cIl07IDsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB3LnBhcnNlQnl0ZSgpLCBOID0geiA+PiA0LCB6ID0gMTUgJiB6O1xuICAgICAgICAgICAgICAgIGlmIChOID09IDE1IHx8IChrICs9IElbTl0sIHogPT0gMTUpKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgayArPSBJW3pdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDMyIDw9IHYgJiYgdiA8PSAyNDYpXG4gICAgICAgICAgICAgIHJldHVybiB2IC0gMTM5O1xuICAgICAgICAgICAgaWYgKDI0NyA8PSB2ICYmIHYgPD0gMjUwKVxuICAgICAgICAgICAgICByZXR1cm4gMjU2ICogKHYgLSAyNDcpICsgZC5wYXJzZUJ5dGUoKSArIDEwODtcbiAgICAgICAgICAgIGlmICgyNTEgPD0gdiAmJiB2IDw9IDI1NClcbiAgICAgICAgICAgICAgcmV0dXJuIDI1NiAqIC0odiAtIDI1MSkgLSBkLnBhcnNlQnl0ZSgpIC0gMTA4O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiMCBcIiArIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJdChkLCB2LCB3KSB7XG4gICAgICAgICAgICB2YXIgayA9IG5ldyB3ZS5QYXJzZXIoZCwgdiA9IHYgIT09IHZvaWQgMCA/IHYgOiAwKSwgSSA9IFtdLCBOID0gW107XG4gICAgICAgICAgICBmb3IgKHcgPSB3ICE9PSB2b2lkIDAgPyB3IDogZC5sZW5ndGg7IGsucmVsYXRpdmVPZmZzZXQgPCB3OyApIHtcbiAgICAgICAgICAgICAgdmFyIHogPSBrLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICB6IDw9IDIxID8gKHogPT09IDEyICYmICh6ID0gMTIwMCArIGsucGFyc2VCeXRlKCkpLCBJLnB1c2goW3osIE5dKSwgTiA9IFtdKSA6IE4ucHVzaChidChrLCB6KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBRID0gSSwgc2UgPSB7fSwgb2UgPSAwOyBvZSA8IFEubGVuZ3RoOyBvZSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB5ZSA9IFFbb2VdWzBdLCBTZSA9IFFbb2VdWzFdLCBiZSA9IHZvaWQgMCwgYmUgPSBTZS5sZW5ndGggPT09IDEgPyBTZVswXSA6IFNlO1xuICAgICAgICAgICAgICBpZiAoc2UuaGFzT3duUHJvcGVydHkoeWUpICYmICFpc05hTihzZVt5ZV0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBcIiArIHNlICsgXCIgYWxyZWFkeSBoYXMga2V5IFwiICsgeWUpO1xuICAgICAgICAgICAgICBzZVt5ZV0gPSBiZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTXQoZCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPSB2IDw9IDM5MCA/ICRbdl0gOiBkW3YgLSAzOTFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBtdChkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrLCBJID0ge30sIE4gPSAwOyBOIDwgdi5sZW5ndGg7IE4gKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeiA9IHZbTl07XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHoudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgUSA9IFtdO1xuICAgICAgICAgICAgICAgIFEubGVuZ3RoID0gei50eXBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzZSA9IDA7IHNlIDwgei50eXBlLmxlbmd0aDsgc2UrKylcbiAgICAgICAgICAgICAgICAgIChrID0gZFt6Lm9wXSAhPT0gdm9pZCAwID8gZFt6Lm9wXVtzZV0gOiB2b2lkIDApID09PSB2b2lkIDAgJiYgKGsgPSB6LnZhbHVlICE9PSB2b2lkIDAgJiYgei52YWx1ZVtzZV0gIT09IHZvaWQgMCA/IHoudmFsdWVbc2VdIDogbnVsbCksIHoudHlwZVtzZV0gPT09IFwiU0lEXCIgJiYgKGsgPSBNdCh3LCBrKSksIFFbc2VdID0gaztcbiAgICAgICAgICAgICAgICBJW3oubmFtZV0gPSBRO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAoayA9IGRbei5vcF0pID09PSB2b2lkIDAgJiYgKGsgPSB6LnZhbHVlICE9PSB2b2lkIDAgPyB6LnZhbHVlIDogbnVsbCksIHoudHlwZSA9PT0gXCJTSURcIiAmJiAoayA9IE10KHcsIGspKSwgSVt6Lm5hbWVdID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIganQgPSBbeyBuYW1lOiBcInZlcnNpb25cIiwgb3A6IDAsIHR5cGU6IFwiU0lEXCIgfSwgeyBuYW1lOiBcIm5vdGljZVwiLCBvcDogMSwgdHlwZTogXCJTSURcIiB9LCB7IG5hbWU6IFwiY29weXJpZ2h0XCIsIG9wOiAxMjAwLCB0eXBlOiBcIlNJRFwiIH0sIHsgbmFtZTogXCJmdWxsTmFtZVwiLCBvcDogMiwgdHlwZTogXCJTSURcIiB9LCB7IG5hbWU6IFwiZmFtaWx5TmFtZVwiLCBvcDogMywgdHlwZTogXCJTSURcIiB9LCB7IG5hbWU6IFwid2VpZ2h0XCIsIG9wOiA0LCB0eXBlOiBcIlNJRFwiIH0sIHsgbmFtZTogXCJpc0ZpeGVkUGl0Y2hcIiwgb3A6IDEyMDEsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJpdGFsaWNBbmdsZVwiLCBvcDogMTIwMiwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVuZGVybGluZVBvc2l0aW9uXCIsIG9wOiAxMjAzLCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogLTEwMCB9LCB7IG5hbWU6IFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsIG9wOiAxMjA0LCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogNTAgfSwgeyBuYW1lOiBcInBhaW50VHlwZVwiLCBvcDogMTIwNSwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImNoYXJzdHJpbmdUeXBlXCIsIG9wOiAxMjA2LCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogMiB9LCB7IG5hbWU6IFwiZm9udE1hdHJpeFwiLCBvcDogMTIwNywgdHlwZTogW1wicmVhbFwiLCBcInJlYWxcIiwgXCJyZWFsXCIsIFwicmVhbFwiLCBcInJlYWxcIiwgXCJyZWFsXCJdLCB2YWx1ZTogWzFlLTMsIDAsIDAsIDFlLTMsIDAsIDBdIH0sIHsgbmFtZTogXCJ1bmlxdWVJZFwiLCBvcDogMTMsIHR5cGU6IFwibnVtYmVyXCIgfSwgeyBuYW1lOiBcImZvbnRCQm94XCIsIG9wOiA1LCB0eXBlOiBbXCJudW1iZXJcIiwgXCJudW1iZXJcIiwgXCJudW1iZXJcIiwgXCJudW1iZXJcIl0sIHZhbHVlOiBbMCwgMCwgMCwgMF0gfSwgeyBuYW1lOiBcInN0cm9rZVdpZHRoXCIsIG9wOiAxMjA4LCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwieHVpZFwiLCBvcDogMTQsIHR5cGU6IFtdLCB2YWx1ZTogbnVsbCB9LCB7IG5hbWU6IFwiY2hhcnNldFwiLCBvcDogMTUsIHR5cGU6IFwib2Zmc2V0XCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJlbmNvZGluZ1wiLCBvcDogMTYsIHR5cGU6IFwib2Zmc2V0XCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjaGFyU3RyaW5nc1wiLCBvcDogMTcsIHR5cGU6IFwib2Zmc2V0XCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJwcml2YXRlXCIsIG9wOiAxOCwgdHlwZTogW1wibnVtYmVyXCIsIFwib2Zmc2V0XCJdLCB2YWx1ZTogWzAsIDBdIH0sIHsgbmFtZTogXCJyb3NcIiwgb3A6IDEyMzAsIHR5cGU6IFtcIlNJRFwiLCBcIlNJRFwiLCBcIm51bWJlclwiXSB9LCB7IG5hbWU6IFwiY2lkRm9udFZlcnNpb25cIiwgb3A6IDEyMzEsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjaWRGb250UmV2aXNpb25cIiwgb3A6IDEyMzIsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjaWRGb250VHlwZVwiLCBvcDogMTIzMywgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImNpZENvdW50XCIsIG9wOiAxMjM0LCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogODcyMCB9LCB7IG5hbWU6IFwidWlkQmFzZVwiLCBvcDogMTIzNSwgdHlwZTogXCJudW1iZXJcIiB9LCB7IG5hbWU6IFwiZmRBcnJheVwiLCBvcDogMTIzNiwgdHlwZTogXCJvZmZzZXRcIiB9LCB7IG5hbWU6IFwiZmRTZWxlY3RcIiwgb3A6IDEyMzcsIHR5cGU6IFwib2Zmc2V0XCIgfSwgeyBuYW1lOiBcImZvbnROYW1lXCIsIG9wOiAxMjM4LCB0eXBlOiBcIlNJRFwiIH1dLCBodCA9IFt7IG5hbWU6IFwic3VicnNcIiwgb3A6IDE5LCB0eXBlOiBcIm9mZnNldFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiZGVmYXVsdFdpZHRoWFwiLCBvcDogMjAsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJub21pbmFsV2lkdGhYXCIsIG9wOiAyMSwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IDAgfV07XG4gICAgICAgICAgZnVuY3Rpb24gRHQoZCwgdiwgdywgaykge1xuICAgICAgICAgICAgcmV0dXJuIG10KEl0KGQsIHYsIHcpLCBodCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFB0KGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSBbXSwgTiA9IDA7IE4gPCB3Lmxlbmd0aDsgTiArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHdbTl0pLmJ1ZmZlciksIHogPSAoUSA9IGssIG10KEl0KHosIDAsIHouYnl0ZUxlbmd0aCksIGp0LCBRKSksIFEgPSAoei5fc3VicnMgPSBbXSwgei5fc3VicnNCaWFzID0gMCwgei5wcml2YXRlWzBdKSwgc2UgPSB6LnByaXZhdGVbMV07XG4gICAgICAgICAgICAgIFEgIT09IDAgJiYgc2UgIT09IDAgJiYgKFEgPSBEdChkLCBzZSArIHYsIFEsIGspLCB6Ll9kZWZhdWx0V2lkdGhYID0gUS5kZWZhdWx0V2lkdGhYLCB6Ll9ub21pbmFsV2lkdGhYID0gUS5ub21pbmFsV2lkdGhYLCBRLnN1YnJzICE9PSAwICYmIChzZSA9IG90KGQsIHNlICsgUS5zdWJycyArIHYpLCB6Ll9zdWJycyA9IHNlLm9iamVjdHMsIHouX3N1YnJzQmlhcyA9IGF0KHouX3N1YnJzKSksIHouX3ByaXZhdGVEaWN0ID0gUSksIEkucHVzaCh6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBndChkLCB2LCB3KSB7XG4gICAgICAgICAgICB2YXIgaywgSSwgTiwgeiwgUSwgc2UsIG9lLCB5ZSwgU2UsIGJlID0gbmV3IFgoKSwgZGUgPSBbXSwgSWUgPSAwLCBrZSA9ICExLCBBZSA9ICExLCBUZSA9IDAsIEVlID0gMCwgJGUgPSAoU2UgPSAoZC5pc0NJREZvbnQgPyAoUSA9IGQudGFibGVzLmNmZi50b3BEaWN0Ll9mZFNlbGVjdFt2LmluZGV4XSwgUSA9IGQudGFibGVzLmNmZi50b3BEaWN0Ll9mZEFycmF5W1FdLCBzZSA9IFEuX3N1YnJzLCBvZSA9IFEuX3N1YnJzQmlhcywgeWUgPSBRLl9kZWZhdWx0V2lkdGhYLCBRKSA6IChzZSA9IGQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJycywgb2UgPSBkLnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnNCaWFzLCB5ZSA9IGQudGFibGVzLmNmZi50b3BEaWN0Ll9kZWZhdWx0V2lkdGhYLCBkLnRhYmxlcy5jZmYudG9wRGljdCkpLl9ub21pbmFsV2lkdGhYLCB5ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBsdCh0dCwgZHQpIHtcbiAgICAgICAgICAgICAgQWUgJiYgYmUuY2xvc2VQYXRoKCksIGJlLm1vdmVUbyh0dCwgZHQpLCBBZSA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZXQoKSB7XG4gICAgICAgICAgICAgIGRlLmxlbmd0aCAlIDIgPT0gMCB8fCBrZSB8fCAoJGUgPSBkZS5zaGlmdCgpICsgU2UpLCBJZSArPSBkZS5sZW5ndGggPj4gMSwgZGUubGVuZ3RoID0gMCwga2UgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0dChkdCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciB3dCwgT3QsIFJ0LCBIdCwgV3QsIFF0LCB4dCwgU3QsIHZ0LCBxdCwga3QsIHp0LCBUdCA9IDA7IFR0IDwgZHQubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgR3QgPSBkdFtUdF07XG4gICAgICAgICAgICAgICAgc3dpdGNoIChUdCArPSAxLCBHdCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBldCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgMSA8IGRlLmxlbmd0aCAmJiAha2UgJiYgKCRlID0gZGUuc2hpZnQoKSArIFNlLCBrZSA9ICEwKSwgRWUgKz0gZGUucG9wKCksIGx0KFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgMCA8IGRlLmxlbmd0aDsgKVxuICAgICAgICAgICAgICAgICAgICAgIFRlICs9IGRlLnNoaWZ0KCksIEVlICs9IGRlLnNoaWZ0KCksIGJlLmxpbmVUbyhUZSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDAgPCBkZS5sZW5ndGggJiYgKFRlICs9IGRlLnNoaWZ0KCksIGJlLmxpbmVUbyhUZSwgRWUpLCBkZS5sZW5ndGggIT09IDApOyApXG4gICAgICAgICAgICAgICAgICAgICAgRWUgKz0gZGUuc2hpZnQoKSwgYmUubGluZVRvKFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgMCA8IGRlLmxlbmd0aCAmJiAoRWUgKz0gZGUuc2hpZnQoKSwgYmUubGluZVRvKFRlLCBFZSksIGRlLmxlbmd0aCAhPT0gMCk7IClcbiAgICAgICAgICAgICAgICAgICAgICBUZSArPSBkZS5zaGlmdCgpLCBiZS5saW5lVG8oVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAwIDwgZGUubGVuZ3RoOyApXG4gICAgICAgICAgICAgICAgICAgICAgayA9IFRlICsgZGUuc2hpZnQoKSwgSSA9IEVlICsgZGUuc2hpZnQoKSwgTiA9IGsgKyBkZS5zaGlmdCgpLCB6ID0gSSArIGRlLnNoaWZ0KCksIFRlID0gTiArIGRlLnNoaWZ0KCksIEVlID0geiArIGRlLnNoaWZ0KCksIGJlLmN1cnZlVG8oaywgSSwgTiwgeiwgVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBXdCA9IGRlLnBvcCgpICsgb2UsIChRdCA9IHNlW1d0XSkgJiYgdHQoUXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoR3QgPSBkdFtUdF0sIFR0ICs9IDEsIEd0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBUZSArIGRlLnNoaWZ0KCksIEkgPSBFZSArIGRlLnNoaWZ0KCksIE4gPSBrICsgZGUuc2hpZnQoKSwgeiA9IEkgKyBkZS5zaGlmdCgpLCB4dCA9IE4gKyBkZS5zaGlmdCgpLCBTdCA9IHogKyBkZS5zaGlmdCgpLCB2dCA9IHh0ICsgZGUuc2hpZnQoKSwgcXQgPSBTdCArIGRlLnNoaWZ0KCksIGt0ID0gdnQgKyBkZS5zaGlmdCgpLCB6dCA9IHF0ICsgZGUuc2hpZnQoKSwgVGUgPSBrdCArIGRlLnNoaWZ0KCksIEVlID0genQgKyBkZS5zaGlmdCgpLCBkZS5zaGlmdCgpLCBiZS5jdXJ2ZVRvKGssIEksIE4sIHosIHh0LCBTdCksIGJlLmN1cnZlVG8odnQsIHF0LCBrdCwgenQsIFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IFRlICsgZGUuc2hpZnQoKSwgSSA9IEVlLCBOID0gayArIGRlLnNoaWZ0KCksIHogPSBJICsgZGUuc2hpZnQoKSwgeHQgPSBOICsgZGUuc2hpZnQoKSwgU3QgPSB6LCB2dCA9IHh0ICsgZGUuc2hpZnQoKSwgcXQgPSB6LCBrdCA9IHZ0ICsgZGUuc2hpZnQoKSwgenQgPSBFZSwgVGUgPSBrdCArIGRlLnNoaWZ0KCksIGJlLmN1cnZlVG8oaywgSSwgTiwgeiwgeHQsIFN0KSwgYmUuY3VydmVUbyh2dCwgcXQsIGt0LCB6dCwgVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gVGUgKyBkZS5zaGlmdCgpLCBJID0gRWUgKyBkZS5zaGlmdCgpLCBOID0gayArIGRlLnNoaWZ0KCksIHogPSBJICsgZGUuc2hpZnQoKSwgeHQgPSBOICsgZGUuc2hpZnQoKSwgU3QgPSB6LCB2dCA9IHh0ICsgZGUuc2hpZnQoKSwgcXQgPSB6LCBrdCA9IHZ0ICsgZGUuc2hpZnQoKSwgenQgPSBxdCArIGRlLnNoaWZ0KCksIFRlID0ga3QgKyBkZS5zaGlmdCgpLCBiZS5jdXJ2ZVRvKGssIEksIE4sIHosIHh0LCBTdCksIGJlLmN1cnZlVG8odnQsIHF0LCBrdCwgenQsIFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IFRlICsgZGUuc2hpZnQoKSwgSSA9IEVlICsgZGUuc2hpZnQoKSwgTiA9IGsgKyBkZS5zaGlmdCgpLCB6ID0gSSArIGRlLnNoaWZ0KCksIHh0ID0gTiArIGRlLnNoaWZ0KCksIFN0ID0geiArIGRlLnNoaWZ0KCksIHZ0ID0geHQgKyBkZS5zaGlmdCgpLCBxdCA9IFN0ICsgZGUuc2hpZnQoKSwga3QgPSB2dCArIGRlLnNoaWZ0KCksIHp0ID0gcXQgKyBkZS5zaGlmdCgpLCBNYXRoLmFicyhrdCAtIFRlKSA+IE1hdGguYWJzKHp0IC0gRWUpID8gVGUgPSBrdCArIGRlLnNoaWZ0KCkgOiBFZSA9IHp0ICsgZGUuc2hpZnQoKSwgYmUuY3VydmVUbyhrLCBJLCBOLCB6LCB4dCwgU3QpLCBiZS5jdXJ2ZVRvKHZ0LCBxdCwga3QsIHp0LCBUZSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2x5cGggXCIgKyB2LmluZGV4ICsgXCI6IHVua25vd24gb3BlcmF0b3IgMTIwMFwiICsgR3QpLCBkZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgMCA8IGRlLmxlbmd0aCAmJiAha2UgJiYgKCRlID0gZGUuc2hpZnQoKSArIFNlLCBrZSA9ICEwKSwgQWUgJiYgKGJlLmNsb3NlUGF0aCgpLCBBZSA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBldCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICBldCgpLCBUdCArPSBJZSArIDcgPj4gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAyIDwgZGUubGVuZ3RoICYmICFrZSAmJiAoJGUgPSBkZS5zaGlmdCgpICsgU2UsIGtlID0gITApLCBFZSArPSBkZS5wb3AoKSwgbHQoVGUgKz0gZGUucG9wKCksIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAxIDwgZGUubGVuZ3RoICYmICFrZSAmJiAoJGUgPSBkZS5zaGlmdCgpICsgU2UsIGtlID0gITApLCBsdChUZSArPSBkZS5wb3AoKSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgIGV0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDIgPCBkZS5sZW5ndGg7IClcbiAgICAgICAgICAgICAgICAgICAgICBrID0gVGUgKyBkZS5zaGlmdCgpLCBJID0gRWUgKyBkZS5zaGlmdCgpLCBOID0gayArIGRlLnNoaWZ0KCksIHogPSBJICsgZGUuc2hpZnQoKSwgVGUgPSBOICsgZGUuc2hpZnQoKSwgRWUgPSB6ICsgZGUuc2hpZnQoKSwgYmUuY3VydmVUbyhrLCBJLCBOLCB6LCBUZSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICBUZSArPSBkZS5zaGlmdCgpLCBFZSArPSBkZS5zaGlmdCgpLCBiZS5saW5lVG8oVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgNiA8IGRlLmxlbmd0aDsgKVxuICAgICAgICAgICAgICAgICAgICAgIFRlICs9IGRlLnNoaWZ0KCksIEVlICs9IGRlLnNoaWZ0KCksIGJlLmxpbmVUbyhUZSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICBrID0gVGUgKyBkZS5zaGlmdCgpLCBJID0gRWUgKyBkZS5zaGlmdCgpLCBOID0gayArIGRlLnNoaWZ0KCksIHogPSBJICsgZGUuc2hpZnQoKSwgVGUgPSBOICsgZGUuc2hpZnQoKSwgRWUgPSB6ICsgZGUuc2hpZnQoKSwgYmUuY3VydmVUbyhrLCBJLCBOLCB6LCBUZSwgRWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZGUubGVuZ3RoICUgMiAmJiAoVGUgKz0gZGUuc2hpZnQoKSk7IDAgPCBkZS5sZW5ndGg7IClcbiAgICAgICAgICAgICAgICAgICAgICBrID0gVGUsIEkgPSBFZSArIGRlLnNoaWZ0KCksIE4gPSBrICsgZGUuc2hpZnQoKSwgeiA9IEkgKyBkZS5zaGlmdCgpLCBUZSA9IE4sIEVlID0geiArIGRlLnNoaWZ0KCksIGJlLmN1cnZlVG8oaywgSSwgTiwgeiwgVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGRlLmxlbmd0aCAlIDIgJiYgKEVlICs9IGRlLnNoaWZ0KCkpOyAwIDwgZGUubGVuZ3RoOyApXG4gICAgICAgICAgICAgICAgICAgICAgayA9IFRlICsgZGUuc2hpZnQoKSwgSSA9IEVlLCBOID0gayArIGRlLnNoaWZ0KCksIHogPSBJICsgZGUuc2hpZnQoKSwgVGUgPSBOICsgZGUuc2hpZnQoKSwgRWUgPSB6LCBiZS5jdXJ2ZVRvKGssIEksIE4sIHosIFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICAgICAgd3QgPSBkdFtUdF0sIE90ID0gZHRbVHQgKyAxXSwgZGUucHVzaCgod3QgPDwgMjQgfCBPdCA8PCAxNikgPj4gMTYpLCBUdCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgICAgIFd0ID0gZGUucG9wKCkgKyBkLmdzdWJyc0JpYXMsIChRdCA9IGQuZ3N1YnJzW1d0XSkgJiYgdHQoUXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAwIDwgZGUubGVuZ3RoICYmIChrID0gVGUsIEkgPSBFZSArIGRlLnNoaWZ0KCksIE4gPSBrICsgZGUuc2hpZnQoKSwgeiA9IEkgKyBkZS5zaGlmdCgpLCBUZSA9IE4gKyBkZS5zaGlmdCgpLCBFZSA9IHogKyAoZGUubGVuZ3RoID09PSAxID8gZGUuc2hpZnQoKSA6IDApLCBiZS5jdXJ2ZVRvKGssIEksIE4sIHosIFRlLCBFZSksIGRlLmxlbmd0aCAhPT0gMCk7IClcbiAgICAgICAgICAgICAgICAgICAgICBrID0gVGUgKyBkZS5zaGlmdCgpLCBJID0gRWUsIE4gPSBrICsgZGUuc2hpZnQoKSwgeiA9IEkgKyBkZS5zaGlmdCgpLCBFZSA9IHogKyBkZS5zaGlmdCgpLCBUZSA9IE4gKyAoZGUubGVuZ3RoID09PSAxID8gZGUuc2hpZnQoKSA6IDApLCBiZS5jdXJ2ZVRvKGssIEksIE4sIHosIFRlLCBFZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDAgPCBkZS5sZW5ndGggJiYgKGsgPSBUZSArIGRlLnNoaWZ0KCksIEkgPSBFZSwgTiA9IGsgKyBkZS5zaGlmdCgpLCB6ID0gSSArIGRlLnNoaWZ0KCksIEVlID0geiArIGRlLnNoaWZ0KCksIFRlID0gTiArIChkZS5sZW5ndGggPT09IDEgPyBkZS5zaGlmdCgpIDogMCksIGJlLmN1cnZlVG8oaywgSSwgTiwgeiwgVGUsIEVlKSwgZGUubGVuZ3RoICE9PSAwKTsgKVxuICAgICAgICAgICAgICAgICAgICAgIGsgPSBUZSwgSSA9IEVlICsgZGUuc2hpZnQoKSwgTiA9IGsgKyBkZS5zaGlmdCgpLCB6ID0gSSArIGRlLnNoaWZ0KCksIFRlID0gTiArIGRlLnNoaWZ0KCksIEVlID0geiArIChkZS5sZW5ndGggPT09IDEgPyBkZS5zaGlmdCgpIDogMCksIGJlLmN1cnZlVG8oaywgSSwgTiwgeiwgVGUsIEVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBHdCA8IDMyID8gY29uc29sZS5sb2coXCJHbHlwaCBcIiArIHYuaW5kZXggKyBcIjogdW5rbm93biBvcGVyYXRvciBcIiArIEd0KSA6IEd0IDwgMjQ3ID8gZGUucHVzaChHdCAtIDEzOSkgOiBHdCA8IDI1MSA/ICh3dCA9IGR0W1R0XSwgVHQgKz0gMSwgZGUucHVzaCgyNTYgKiAoR3QgLSAyNDcpICsgd3QgKyAxMDgpKSA6IEd0IDwgMjU1ID8gKHd0ID0gZHRbVHRdLCBUdCArPSAxLCBkZS5wdXNoKDI1NiAqIC0oR3QgLSAyNTEpIC0gd3QgLSAxMDgpKSA6ICh3dCA9IGR0W1R0XSwgT3QgPSBkdFtUdCArIDFdLCBSdCA9IGR0W1R0ICsgMl0sIEh0ID0gZHRbVHQgKyAzXSwgVHQgKz0gNCwgZGUucHVzaCgod3QgPDwgMjQgfCBPdCA8PCAxNiB8IFJ0IDw8IDggfCBIdCkgLyA2NTUzNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSh3KSwgdi5hZHZhbmNlV2lkdGggPSAkZSwgYmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEZ0KGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBrID0gJC5pbmRleE9mKGQpO1xuICAgICAgICAgICAgcmV0dXJuIDAgPD0gayAmJiAodyA9IGspLCAwIDw9IChrID0gdi5pbmRleE9mKGQpKSA/IHcgPSBrICsgJC5sZW5ndGggOiAodyA9ICQubGVuZ3RoICsgdi5sZW5ndGgsIHYucHVzaChkKSksIHc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG1lKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSB7fSwgSSA9IDA7IEkgPCBkLmxlbmd0aDsgSSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBOID0gZFtJXSwgeiA9IHZbTi5uYW1lXTtcbiAgICAgICAgICAgICAgeiA9PT0gdm9pZCAwIHx8IGZ1bmN0aW9uIFEoc2UsIG9lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlID09PSBvZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlKSAmJiBBcnJheS5pc0FycmF5KG9lKSAmJiBzZS5sZW5ndGggPT09IG9lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeWUgPSAwOyB5ZSA8IHNlLmxlbmd0aDsgeWUgKz0gMSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFRKHNlW3llXSwgb2VbeWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0oeiwgTi52YWx1ZSkgfHwgKE4udHlwZSA9PT0gXCJTSURcIiAmJiAoeiA9IEZ0KHosIHcpKSwga1tOLm9wXSA9IHsgbmFtZTogTi5uYW1lLCB0eXBlOiBOLnR5cGUsIHZhbHVlOiB6IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFVlKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gbmV3IE1lLlJlY29yZChcIlRvcCBESUNUXCIsIFt7IG5hbWU6IFwiZGljdFwiLCB0eXBlOiBcIkRJQ1RcIiwgdmFsdWU6IHt9IH1dKTtcbiAgICAgICAgICAgIHJldHVybiB3LmRpY3QgPSBtZShqdCwgZCwgdiksIHc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFllKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IE1lLlJlY29yZChcIlRvcCBESUNUIElOREVYXCIsIFt7IG5hbWU6IFwidG9wRGljdHNcIiwgdHlwZTogXCJJTkRFWFwiLCB2YWx1ZTogW10gfV0pO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9wRGljdHMgPSBbeyBuYW1lOiBcInRvcERpY3RfMFwiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBkIH1dLCB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBpdChkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gbmV3IE1lLlJlY29yZChcIkNoYXJTdHJpbmdzIElOREVYXCIsIFt7IG5hbWU6IFwiY2hhclN0cmluZ3NcIiwgdHlwZTogXCJJTkRFWFwiLCB2YWx1ZTogW10gfV0pLCB3ID0gMDsgdyA8IGQubGVuZ3RoOyB3ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBkLmdldCh3KSwgSSA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gW10sIFEgPSBOLnBhdGgsIHNlID0gKHoucHVzaCh7IG5hbWU6IFwid2lkdGhcIiwgdHlwZTogXCJOVU1CRVJcIiwgdmFsdWU6IE4uYWR2YW5jZVdpZHRoIH0pLCAwKSwgb2UgPSAwLCB5ZSA9IDA7IHllIDwgUS5jb21tYW5kcy5sZW5ndGg7IHllICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBTZSwgYmUsIGRlLCBJZSwga2UgPSB2b2lkIDAsIEFlID0gdm9pZCAwLCBUZSA9IFEuY29tbWFuZHNbeWVdO1xuICAgICAgICAgICAgICAgICAgKFRlID0gVGUudHlwZSA9PT0gXCJRXCIgPyB7IHR5cGU6IFwiQ1wiLCB4OiBUZS54LCB5OiBUZS55LCB4MTogMSAvIDMgKiBzZSArIDIgLyAzICogVGUueDEsIHkxOiAxIC8gMyAqIG9lICsgMiAvIDMgKiBUZS55MSwgeDI6IDEgLyAzICogVGUueCArIDIgLyAzICogVGUueDEsIHkyOiAxIC8gMyAqIFRlLnkgKyAyIC8gMyAqIFRlLnkxIH0gOiBUZSkudHlwZSA9PT0gXCJNXCIgPyAoa2UgPSBNYXRoLnJvdW5kKFRlLnggLSBzZSksIEFlID0gTWF0aC5yb3VuZChUZS55IC0gb2UpLCB6LnB1c2goeyBuYW1lOiBcImR4XCIsIHR5cGU6IFwiTlVNQkVSXCIsIHZhbHVlOiBrZSB9KSwgei5wdXNoKHsgbmFtZTogXCJkeVwiLCB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogQWUgfSksIHoucHVzaCh7IG5hbWU6IFwicm1vdmV0b1wiLCB0eXBlOiBcIk9QXCIsIHZhbHVlOiAyMSB9KSwgc2UgPSBNYXRoLnJvdW5kKFRlLngpLCBvZSA9IE1hdGgucm91bmQoVGUueSkpIDogVGUudHlwZSA9PT0gXCJMXCIgPyAoa2UgPSBNYXRoLnJvdW5kKFRlLnggLSBzZSksIEFlID0gTWF0aC5yb3VuZChUZS55IC0gb2UpLCB6LnB1c2goeyBuYW1lOiBcImR4XCIsIHR5cGU6IFwiTlVNQkVSXCIsIHZhbHVlOiBrZSB9KSwgei5wdXNoKHsgbmFtZTogXCJkeVwiLCB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogQWUgfSksIHoucHVzaCh7IG5hbWU6IFwicmxpbmV0b1wiLCB0eXBlOiBcIk9QXCIsIHZhbHVlOiA1IH0pLCBzZSA9IE1hdGgucm91bmQoVGUueCksIG9lID0gTWF0aC5yb3VuZChUZS55KSkgOiBUZS50eXBlID09PSBcIkNcIiAmJiAoU2UgPSBNYXRoLnJvdW5kKFRlLngxIC0gc2UpLCBiZSA9IE1hdGgucm91bmQoVGUueTEgLSBvZSksIGRlID0gTWF0aC5yb3VuZChUZS54MiAtIFRlLngxKSwgSWUgPSBNYXRoLnJvdW5kKFRlLnkyIC0gVGUueTEpLCBrZSA9IE1hdGgucm91bmQoVGUueCAtIFRlLngyKSwgQWUgPSBNYXRoLnJvdW5kKFRlLnkgLSBUZS55MiksIHoucHVzaCh7IG5hbWU6IFwiZHgxXCIsIHR5cGU6IFwiTlVNQkVSXCIsIHZhbHVlOiBTZSB9KSwgei5wdXNoKHsgbmFtZTogXCJkeTFcIiwgdHlwZTogXCJOVU1CRVJcIiwgdmFsdWU6IGJlIH0pLCB6LnB1c2goeyBuYW1lOiBcImR4MlwiLCB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogZGUgfSksIHoucHVzaCh7IG5hbWU6IFwiZHkyXCIsIHR5cGU6IFwiTlVNQkVSXCIsIHZhbHVlOiBJZSB9KSwgei5wdXNoKHsgbmFtZTogXCJkeFwiLCB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZToga2UgfSksIHoucHVzaCh7IG5hbWU6IFwiZHlcIiwgdHlwZTogXCJOVU1CRVJcIiwgdmFsdWU6IEFlIH0pLCB6LnB1c2goeyBuYW1lOiBcInJyY3VydmV0b1wiLCB0eXBlOiBcIk9QXCIsIHZhbHVlOiA4IH0pLCBzZSA9IE1hdGgucm91bmQoVGUueCksIG9lID0gTWF0aC5yb3VuZChUZS55KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB6LnB1c2goeyBuYW1lOiBcImVuZGNoYXJcIiwgdHlwZTogXCJPUFwiLCB2YWx1ZTogMTQgfSksIHo7XG4gICAgICAgICAgICAgIH0oayk7XG4gICAgICAgICAgICAgIHYuY2hhclN0cmluZ3MucHVzaCh7IG5hbWU6IGsubmFtZSwgdHlwZTogXCJDSEFSU1RSSU5HXCIsIHZhbHVlOiBJIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmdCA9IHsgcGFyc2U6IGZ1bmN0aW9uKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIHcudGFibGVzLmNmZiA9IHt9LCBRID0gZCwgayA9IHYsIChJID0ge30pLmZvcm1hdE1ham9yID0gd2UuZ2V0Q2FyZDgoUSwgayksIEkuZm9ybWF0TWlub3IgPSB3ZS5nZXRDYXJkOChRLCBrICsgMSksIEkuc2l6ZSA9IHdlLmdldENhcmQ4KFEsIGsgKyAyKSwgSS5vZmZzZXRTaXplID0gd2UuZ2V0Q2FyZDgoUSwgayArIDMpLCBJLnN0YXJ0T2Zmc2V0ID0gaywgSS5lbmRPZmZzZXQgPSBrICsgNDtcbiAgICAgICAgICAgIHZhciBRID0gb3QoZCwgSS5lbmRPZmZzZXQsIHdlLmJ5dGVzVG9TdHJpbmcpLCBrID0gb3QoZCwgUS5lbmRPZmZzZXQpLCBJID0gb3QoZCwgay5lbmRPZmZzZXQsIHdlLmJ5dGVzVG9TdHJpbmcpLCBRID0gb3QoZCwgSS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHcuZ3N1YnJzID0gUS5vYmplY3RzLCB3LmdzdWJyc0JpYXMgPSBhdCh3LmdzdWJycyksIChRID0gUHQoZCwgdiwgay5vYmplY3RzLCBJLm9iamVjdHMpKS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNGRiB0YWJsZSBoYXMgdG9vIG1hbnkgZm9udHMgaW4gJ0ZvbnRTZXQnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9IFwiICsgUS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGsgPSBRWzBdLCAody50YWJsZXMuY2ZmLnRvcERpY3QgPSBrKS5fcHJpdmF0ZURpY3QgJiYgKHcuZGVmYXVsdFdpZHRoWCA9IGsuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFgsIHcubm9taW5hbFdpZHRoWCA9IGsuX3ByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFgpLCBrLnJvc1swXSAhPT0gdm9pZCAwICYmIGsucm9zWzFdICE9PSB2b2lkIDAgJiYgKHcuaXNDSURGb250ID0gITApLCB3LmlzQ0lERm9udCkge1xuICAgICAgICAgICAgICB2YXIgUSA9IGsuZmRBcnJheSwgTiA9IGsuZmRTZWxlY3Q7XG4gICAgICAgICAgICAgIGlmIChRID09PSAwIHx8IE4gPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBpcyBtYXJrZWQgYXMgYSBDSUQgZm9udCwgYnV0IEZEQXJyYXkgYW5kL29yIEZEU2VsZWN0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgIFEgPSBQdChkLCB2LCBvdChkLCBRICs9IHYpLm9iamVjdHMsIEkub2JqZWN0cyksIGsuX2ZkQXJyYXkgPSBRLCBrLl9mZFNlbGVjdCA9IGZ1bmN0aW9uKGJlLCBkZSwgSWUsIGtlKSB7XG4gICAgICAgICAgICAgICAgdmFyIEFlLCBUZSA9IFtdLCBFZSA9IG5ldyB3ZS5QYXJzZXIoYmUsIGRlKTtcbiAgICAgICAgICAgICAgICBpZiAoKGJlID0gRWUucGFyc2VDYXJkOCgpKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyICRlID0gMDsgJGUgPCBJZTsgJGUrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2UgPD0gKEFlID0gRWUucGFyc2VDYXJkOCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSBcIiArIEFlICsgXCIgKEZEIGNvdW50IFwiICsga2UgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIFRlLnB1c2goQWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGJlICE9PSAzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdCBcIiArIGJlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBsdCwgZXQgPSBFZS5wYXJzZUNhcmQxNigpLCB0dCA9IEVlLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodHQgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGluaXRpYWwgR0lEIFwiICsgdHQpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHQgPSAwOyBkdCA8IGV0OyBkdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBZSA9IEVlLnBhcnNlQ2FyZDgoKSwgbHQgPSBFZS5wYXJzZUNhcmQxNigpLCBrZSA8PSBBZSlcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSBcIiArIEFlICsgXCIgKEZEIGNvdW50IFwiICsga2UgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChJZSA8IGx0KVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIEdJRCBcIiArIGx0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHR0IDwgbHQ7IHR0KyspXG4gICAgICAgICAgICAgICAgICAgICAgVGUucHVzaChBZSk7XG4gICAgICAgICAgICAgICAgICAgIHR0ID0gbHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobHQgIT09IEllKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBmaW5hbCBHSUQgXCIgKyBsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBUZTtcbiAgICAgICAgICAgICAgfShkLCBOICs9IHYsIHcubnVtR2x5cGhzLCBRLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgTiA9IHYgKyBrLnByaXZhdGVbMV0sIFEgPSBEdChkLCBOLCBrLnByaXZhdGVbMF0sIEkub2JqZWN0cyksIHogPSAody5kZWZhdWx0V2lkdGhYID0gUS5kZWZhdWx0V2lkdGhYLCB3Lm5vbWluYWxXaWR0aFggPSBRLm5vbWluYWxXaWR0aFgsIFEuc3VicnMgIT09IDAgPyAoTiA9IG90KGQsIE4gKyBRLnN1YnJzKSwgdy5zdWJycyA9IE4ub2JqZWN0cywgdy5zdWJyc0JpYXMgPSBhdCh3LnN1YnJzKSkgOiAody5zdWJycyA9IFtdLCB3LnN1YnJzQmlhcyA9IDApLCBvdChkLCB2ICsgay5jaGFyU3RyaW5ncykpLCBRID0gKHcubkdseXBocyA9IHoub2JqZWN0cy5sZW5ndGgsIGZ1bmN0aW9uKHllLCBTZSwgYmUsIGRlKSB7XG4gICAgICAgICAgICAgIHZhciBJZSA9IG5ldyB3ZS5QYXJzZXIoeWUsIFNlKSwga2UgPSAoLS1iZSwgW1wiLm5vdGRlZlwiXSk7XG4gICAgICAgICAgICAgIGlmICgoeWUgPSBJZS5wYXJzZUNhcmQ4KCkpID09PSAwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIEFlID0gMDsgQWUgPCBiZTsgQWUgKz0gMSlcbiAgICAgICAgICAgICAgICAgIFRlID0gSWUucGFyc2VTSUQoKSwga2UucHVzaChNdChkZSwgVGUpKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoeWUgPT09IDEpXG4gICAgICAgICAgICAgICAgZm9yICg7IGtlLmxlbmd0aCA8PSBiZTsgKVxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgVGUgPSBJZS5wYXJzZVNJRCgpLCBFZSA9IEllLnBhcnNlQ2FyZDgoKSwgJGUgPSAwOyAkZSA8PSBFZTsgJGUgKz0gMSlcbiAgICAgICAgICAgICAgICAgICAga2UucHVzaChNdChkZSwgVGUpKSwgVGUgKz0gMTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHllICE9PSAyKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjaGFyc2V0IGZvcm1hdCBcIiArIHllKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsga2UubGVuZ3RoIDw9IGJlOyApIHtcbiAgICAgICAgICAgICAgICAgIFRlID0gSWUucGFyc2VTSUQoKSwgRWUgPSBJZS5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbHQgPSAwOyBsdCA8PSBFZTsgbHQgKz0gMSlcbiAgICAgICAgICAgICAgICAgICAga2UucHVzaChNdChkZSwgVGUpKSwgVGUgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGtlO1xuICAgICAgICAgICAgfShkLCB2ICsgay5jaGFyc2V0LCB3Lm5HbHlwaHMsIEkub2JqZWN0cykpO1xuICAgICAgICAgICAgay5lbmNvZGluZyA9PT0gMCA/IHcuY2ZmRW5jb2RpbmcgPSBuZXcgRmUocSwgUSkgOiBrLmVuY29kaW5nID09PSAxID8gdy5jZmZFbmNvZGluZyA9IG5ldyBGZShlZSwgUSkgOiB3LmNmZkVuY29kaW5nID0gZnVuY3Rpb24oeWUsIFNlLCBiZSkge1xuICAgICAgICAgICAgICB2YXIgZGUgPSB7fSwgSWUgPSBuZXcgd2UuUGFyc2VyKHllLCBTZSk7XG4gICAgICAgICAgICAgIGlmICgoeWUgPSBJZS5wYXJzZUNhcmQ4KCkpID09PSAwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtlID0gSWUucGFyc2VDYXJkOCgpLCBBZSA9IDA7IEFlIDwga2U7IEFlICs9IDEpXG4gICAgICAgICAgICAgICAgICBkZVtFZSA9IEllLnBhcnNlQ2FyZDgoKV0gPSBBZTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHllICE9PSAxKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZyBmb3JtYXQgXCIgKyB5ZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgVGUgPSBJZS5wYXJzZUNhcmQ4KCksIEVlID0gMSwgJGUgPSAwOyAkZSA8IFRlOyAkZSArPSAxKVxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbHQgPSBJZS5wYXJzZUNhcmQ4KCksIGV0ID0gSWUucGFyc2VDYXJkOCgpLCB0dCA9IGx0OyB0dCA8PSBsdCArIGV0OyB0dCArPSAxKVxuICAgICAgICAgICAgICAgICAgICBkZVt0dF0gPSBFZSwgRWUgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEZlKGRlLCBiZSk7XG4gICAgICAgICAgICB9KGQsIHYgKyBrLmVuY29kaW5nLCBRKSwgdy5lbmNvZGluZyA9IHcuZW5jb2RpbmcgfHwgdy5jZmZFbmNvZGluZywgdy5nbHlwaHMgPSBuZXcgS2UuR2x5cGhTZXQodyk7XG4gICAgICAgICAgICBmb3IgKHZhciBzZSA9IDA7IHNlIDwgdy5uR2x5cGhzOyBzZSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBvZSA9IHoub2JqZWN0c1tzZV07XG4gICAgICAgICAgICAgIHcuZ2x5cGhzLnB1c2goc2UsIEtlLmNmZkdseXBoTG9hZGVyKHcsIHNlLCBndCwgb2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtYWtlOiBmdW5jdGlvbihkLCB5ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgdywgayA9IG5ldyBNZS5UYWJsZShcIkNGRiBcIiwgW3sgbmFtZTogXCJoZWFkZXJcIiwgdHlwZTogXCJSRUNPUkRcIiB9LCB7IG5hbWU6IFwibmFtZUluZGV4XCIsIHR5cGU6IFwiUkVDT1JEXCIgfSwgeyBuYW1lOiBcInRvcERpY3RJbmRleFwiLCB0eXBlOiBcIlJFQ09SRFwiIH0sIHsgbmFtZTogXCJzdHJpbmdJbmRleFwiLCB0eXBlOiBcIlJFQ09SRFwiIH0sIHsgbmFtZTogXCJnbG9iYWxTdWJySW5kZXhcIiwgdHlwZTogXCJSRUNPUkRcIiB9LCB7IG5hbWU6IFwiY2hhcnNldHNcIiwgdHlwZTogXCJSRUNPUkRcIiB9LCB7IG5hbWU6IFwiY2hhclN0cmluZ3NJbmRleFwiLCB0eXBlOiBcIlJFQ09SRFwiIH0sIHsgbmFtZTogXCJwcml2YXRlRGljdFwiLCB0eXBlOiBcIlJFQ09SRFwiIH1dKSwgSSA9IDEgLyB5ZS51bml0c1BlckVtLCBJID0geyB2ZXJzaW9uOiB5ZS52ZXJzaW9uLCBmdWxsTmFtZTogeWUuZnVsbE5hbWUsIGZhbWlseU5hbWU6IHllLmZhbWlseU5hbWUsIHdlaWdodDogeWUud2VpZ2h0TmFtZSwgZm9udEJCb3g6IHllLmZvbnRCQm94IHx8IFswLCAwLCAwLCAwXSwgZm9udE1hdHJpeDogW0ksIDAsIDAsIEksIDAsIDBdLCBjaGFyc2V0OiA5OTksIGVuY29kaW5nOiAwLCBjaGFyU3RyaW5nczogOTk5LCBwcml2YXRlOiBbMCwgOTk5XSB9LCBOID0gW10sIHogPSAxOyB6IDwgZC5sZW5ndGg7IHogKz0gMSlcbiAgICAgICAgICAgICAgdyA9IGQuZ2V0KHopLCBOLnB1c2gody5uYW1lKTtcbiAgICAgICAgICAgIHZhciBRLCBzZSwgb2UgPSBbXSwgeWUgPSAoay5oZWFkZXIgPSBuZXcgTWUuUmVjb3JkKFwiSGVhZGVyXCIsIFt7IG5hbWU6IFwibWFqb3JcIiwgdHlwZTogXCJDYXJkOFwiLCB2YWx1ZTogMSB9LCB7IG5hbWU6IFwibWlub3JcIiwgdHlwZTogXCJDYXJkOFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiaGRyU2l6ZVwiLCB0eXBlOiBcIkNhcmQ4XCIsIHZhbHVlOiA0IH0sIHsgbmFtZTogXCJtYWpvclwiLCB0eXBlOiBcIkNhcmQ4XCIsIHZhbHVlOiAxIH1dKSwgay5uYW1lSW5kZXggPSBmdW5jdGlvbihiZSkge1xuICAgICAgICAgICAgICB2YXIgZGUgPSBuZXcgTWUuUmVjb3JkKFwiTmFtZSBJTkRFWFwiLCBbeyBuYW1lOiBcIm5hbWVzXCIsIHR5cGU6IFwiSU5ERVhcIiwgdmFsdWU6IFtdIH1dKTtcbiAgICAgICAgICAgICAgZGUubmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgSWUgPSAwOyBJZSA8IGJlLmxlbmd0aDsgSWUgKz0gMSlcbiAgICAgICAgICAgICAgICBkZS5uYW1lcy5wdXNoKHsgbmFtZTogXCJuYW1lX1wiICsgSWUsIHR5cGU6IFwiTkFNRVwiLCB2YWx1ZTogYmVbSWVdIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gZGU7XG4gICAgICAgICAgICB9KFt5ZS5wb3N0U2NyaXB0TmFtZV0pLCBVZShJLCBvZSkpLCBTZSA9IChrLnRvcERpY3RJbmRleCA9IFllKHllKSwgay5nbG9iYWxTdWJySW5kZXggPSBuZXcgTWUuUmVjb3JkKFwiR2xvYmFsIFN1YnIgSU5ERVhcIiwgW3sgbmFtZTogXCJzdWJyc1wiLCB0eXBlOiBcIklOREVYXCIsIHZhbHVlOiBbXSB9XSksIGsuY2hhcnNldHMgPSBmdW5jdGlvbihiZSwgZGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgSWUgPSBuZXcgTWUuUmVjb3JkKFwiQ2hhcnNldHNcIiwgW3sgbmFtZTogXCJmb3JtYXRcIiwgdHlwZTogXCJDYXJkOFwiLCB2YWx1ZTogMCB9XSksIGtlID0gMDsga2UgPCBiZS5sZW5ndGg7IGtlICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgQWUgPSBGdChiZVtrZV0sIGRlKTtcbiAgICAgICAgICAgICAgICBJZS5maWVsZHMucHVzaCh7IG5hbWU6IFwiZ2x5cGhfXCIgKyBrZSwgdHlwZTogXCJTSURcIiwgdmFsdWU6IEFlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBJZTtcbiAgICAgICAgICAgIH0oTiwgb2UpLCBrLmNoYXJTdHJpbmdzSW5kZXggPSBpdChkKSwgay5wcml2YXRlRGljdCA9IChTZSA9IHt9LCBRID0gb2UsIChzZSA9IG5ldyBNZS5SZWNvcmQoXCJQcml2YXRlIERJQ1RcIiwgW3sgbmFtZTogXCJkaWN0XCIsIHR5cGU6IFwiRElDVFwiLCB2YWx1ZToge30gfV0pKS5kaWN0ID0gbWUoaHQsIFNlLCBRKSwgc2UpLCBrLnN0cmluZ0luZGV4ID0gZnVuY3Rpb24oYmUpIHtcbiAgICAgICAgICAgICAgdmFyIGRlID0gbmV3IE1lLlJlY29yZChcIlN0cmluZyBJTkRFWFwiLCBbeyBuYW1lOiBcInN0cmluZ3NcIiwgdHlwZTogXCJJTkRFWFwiLCB2YWx1ZTogW10gfV0pO1xuICAgICAgICAgICAgICBkZS5zdHJpbmdzID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIEllID0gMDsgSWUgPCBiZS5sZW5ndGg7IEllICs9IDEpXG4gICAgICAgICAgICAgICAgZGUuc3RyaW5ncy5wdXNoKHsgbmFtZTogXCJzdHJpbmdfXCIgKyBJZSwgdHlwZTogXCJTVFJJTkdcIiwgdmFsdWU6IGJlW0llXSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlO1xuICAgICAgICAgICAgfShvZSksIGsuaGVhZGVyLnNpemVPZigpICsgay5uYW1lSW5kZXguc2l6ZU9mKCkgKyBrLnRvcERpY3RJbmRleC5zaXplT2YoKSArIGsuc3RyaW5nSW5kZXguc2l6ZU9mKCkgKyBrLmdsb2JhbFN1YnJJbmRleC5zaXplT2YoKSk7XG4gICAgICAgICAgICByZXR1cm4gSS5jaGFyc2V0ID0gU2UsIEkuZW5jb2RpbmcgPSAwLCBJLmNoYXJTdHJpbmdzID0gSS5jaGFyc2V0ICsgay5jaGFyc2V0cy5zaXplT2YoKSwgSS5wcml2YXRlWzFdID0gSS5jaGFyU3RyaW5ncyArIGsuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKSwgeWUgPSBVZShJLCBvZSksIGsudG9wRGljdEluZGV4ID0gWWUoeWUpLCBrO1xuICAgICAgICAgIH0gfSwgcHQgPSB7IHBhcnNlOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IHt9LCBrID0gbmV3IHdlLlBhcnNlcihrLCB2KTtcbiAgICAgICAgICAgIHJldHVybiB3LnZlcnNpb24gPSBrLnBhcnNlVmVyc2lvbigpLCB3LmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQoMWUzICogay5wYXJzZUZpeGVkKCkpIC8gMWUzLCB3LmNoZWNrU3VtQWRqdXN0bWVudCA9IGsucGFyc2VVTG9uZygpLCB3Lm1hZ2ljTnVtYmVyID0gay5wYXJzZVVMb25nKCksIE8uYXJndW1lbnQody5tYWdpY051bWJlciA9PT0gMTU5NDgzNDE2NSwgXCJGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLlwiKSwgdy5mbGFncyA9IGsucGFyc2VVU2hvcnQoKSwgdy51bml0c1BlckVtID0gay5wYXJzZVVTaG9ydCgpLCB3LmNyZWF0ZWQgPSBrLnBhcnNlTG9uZ0RhdGVUaW1lKCksIHcubW9kaWZpZWQgPSBrLnBhcnNlTG9uZ0RhdGVUaW1lKCksIHcueE1pbiA9IGsucGFyc2VTaG9ydCgpLCB3LnlNaW4gPSBrLnBhcnNlU2hvcnQoKSwgdy54TWF4ID0gay5wYXJzZVNob3J0KCksIHcueU1heCA9IGsucGFyc2VTaG9ydCgpLCB3Lm1hY1N0eWxlID0gay5wYXJzZVVTaG9ydCgpLCB3Lmxvd2VzdFJlY1BQRU0gPSBrLnBhcnNlVVNob3J0KCksIHcuZm9udERpcmVjdGlvbkhpbnQgPSBrLnBhcnNlU2hvcnQoKSwgdy5pbmRleFRvTG9jRm9ybWF0ID0gay5wYXJzZVNob3J0KCksIHcuZ2x5cGhEYXRhRm9ybWF0ID0gay5wYXJzZVNob3J0KCksIHc7XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBNYXRoLnJvdW5kKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMWUzKSArIDIwODI4NDQ4MDAsIHcgPSB2O1xuICAgICAgICAgICAgcmV0dXJuIGQuY3JlYXRlZFRpbWVzdGFtcCAmJiAodyA9IGQuY3JlYXRlZFRpbWVzdGFtcCArIDIwODI4NDQ4MDApLCBuZXcgTWUuVGFibGUoXCJoZWFkXCIsIFt7IG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcIkZJWEVEXCIsIHZhbHVlOiA2NTUzNiB9LCB7IG5hbWU6IFwiZm9udFJldmlzaW9uXCIsIHR5cGU6IFwiRklYRURcIiwgdmFsdWU6IDY1NTM2IH0sIHsgbmFtZTogXCJjaGVja1N1bUFkanVzdG1lbnRcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibWFnaWNOdW1iZXJcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMTU5NDgzNDE2NSB9LCB7IG5hbWU6IFwiZmxhZ3NcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVuaXRzUGVyRW1cIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDFlMyB9LCB7IG5hbWU6IFwiY3JlYXRlZFwiLCB0eXBlOiBcIkxPTkdEQVRFVElNRVwiLCB2YWx1ZTogdyB9LCB7IG5hbWU6IFwibW9kaWZpZWRcIiwgdHlwZTogXCJMT05HREFURVRJTUVcIiwgdmFsdWU6IHYgfSwgeyBuYW1lOiBcInhNaW5cIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwieU1pblwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ4TWF4XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInlNYXhcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibWFjU3R5bGVcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImxvd2VzdFJlY1BQRU1cIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImZvbnREaXJlY3Rpb25IaW50XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDIgfSwgeyBuYW1lOiBcImluZGV4VG9Mb2NGb3JtYXRcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiZ2x5cGhEYXRhRm9ybWF0XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfV0sIGQpO1xuICAgICAgICAgIH0gfSwgaWUgPSB7IHBhcnNlOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IHt9LCBrID0gbmV3IHdlLlBhcnNlcihrLCB2KTtcbiAgICAgICAgICAgIHJldHVybiB3LnZlcnNpb24gPSBrLnBhcnNlVmVyc2lvbigpLCB3LmFzY2VuZGVyID0gay5wYXJzZVNob3J0KCksIHcuZGVzY2VuZGVyID0gay5wYXJzZVNob3J0KCksIHcubGluZUdhcCA9IGsucGFyc2VTaG9ydCgpLCB3LmFkdmFuY2VXaWR0aE1heCA9IGsucGFyc2VVU2hvcnQoKSwgdy5taW5MZWZ0U2lkZUJlYXJpbmcgPSBrLnBhcnNlU2hvcnQoKSwgdy5taW5SaWdodFNpZGVCZWFyaW5nID0gay5wYXJzZVNob3J0KCksIHcueE1heEV4dGVudCA9IGsucGFyc2VTaG9ydCgpLCB3LmNhcmV0U2xvcGVSaXNlID0gay5wYXJzZVNob3J0KCksIHcuY2FyZXRTbG9wZVJ1biA9IGsucGFyc2VTaG9ydCgpLCB3LmNhcmV0T2Zmc2V0ID0gay5wYXJzZVNob3J0KCksIGsucmVsYXRpdmVPZmZzZXQgKz0gOCwgdy5tZXRyaWNEYXRhRm9ybWF0ID0gay5wYXJzZVNob3J0KCksIHcubnVtYmVyT2ZITWV0cmljcyA9IGsucGFyc2VVU2hvcnQoKSwgdztcbiAgICAgICAgICB9LCBtYWtlOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lLlRhYmxlKFwiaGhlYVwiLCBbeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJGSVhFRFwiLCB2YWx1ZTogNjU1MzYgfSwgeyBuYW1lOiBcImFzY2VuZGVyXCIsIHR5cGU6IFwiRldPUkRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImRlc2NlbmRlclwiLCB0eXBlOiBcIkZXT1JEXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJsaW5lR2FwXCIsIHR5cGU6IFwiRldPUkRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImFkdmFuY2VXaWR0aE1heFwiLCB0eXBlOiBcIlVGV09SRFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibWluTGVmdFNpZGVCZWFyaW5nXCIsIHR5cGU6IFwiRldPUkRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcIm1pblJpZ2h0U2lkZUJlYXJpbmdcIiwgdHlwZTogXCJGV09SRFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwieE1heEV4dGVudFwiLCB0eXBlOiBcIkZXT1JEXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjYXJldFNsb3BlUmlzZVwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAxIH0sIHsgbmFtZTogXCJjYXJldFNsb3BlUnVuXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImNhcmV0T2Zmc2V0XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInJlc2VydmVkMVwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJyZXNlcnZlZDJcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwicmVzZXJ2ZWQzXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInJlc2VydmVkNFwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJtZXRyaWNEYXRhRm9ybWF0XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcIm51bWJlck9mSE1ldHJpY3NcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfV0sIGQpO1xuICAgICAgICAgIH0gfSwgT2UgPSB7IHBhcnNlOiBmdW5jdGlvbihkLCB2LCB3LCBrLCBJKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBOLCB6LCBRID0gbmV3IHdlLlBhcnNlcihkLCB2KSwgc2UgPSAwOyBzZSA8IGs7IHNlICs9IDEpIHtcbiAgICAgICAgICAgICAgc2UgPCB3ICYmIChOID0gUS5wYXJzZVVTaG9ydCgpLCB6ID0gUS5wYXJzZVNob3J0KCkpO1xuICAgICAgICAgICAgICB2YXIgb2UgPSBJLmdldChzZSk7XG4gICAgICAgICAgICAgIG9lLmFkdmFuY2VXaWR0aCA9IE4sIG9lLmxlZnRTaWRlQmVhcmluZyA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IG5ldyBNZS5UYWJsZShcImhtdHhcIiwgW10pLCB3ID0gMDsgdyA8IGQubGVuZ3RoOyB3ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSBkLmdldCh3KSwgayA9IEkuYWR2YW5jZVdpZHRoIHx8IDAsIEkgPSBJLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICAgICAgICB2LmZpZWxkcy5wdXNoKHsgbmFtZTogXCJhZHZhbmNlV2lkdGhfXCIgKyB3LCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogayB9KSwgdi5maWVsZHMucHVzaCh7IG5hbWU6IFwibGVmdFNpZGVCZWFyaW5nX1wiICsgdywgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogSSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0gfSwgR2UgPSB7IG1ha2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBuZXcgTWUuVGFibGUoXCJsdGFnXCIsIFt7IG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAxIH0sIHsgbmFtZTogXCJmbGFnc1wiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJudW1UYWdzXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IGQubGVuZ3RoIH1dKSwgdyA9IFwiXCIsIGsgPSAxMiArIDQgKiBkLmxlbmd0aCwgSSA9IDA7IEkgPCBkLmxlbmd0aDsgKytJKSB7XG4gICAgICAgICAgICAgIHZhciBOID0gdy5pbmRleE9mKGRbSV0pO1xuICAgICAgICAgICAgICBOIDwgMCAmJiAoTiA9IHcubGVuZ3RoLCB3ICs9IGRbSV0pLCB2LmZpZWxkcy5wdXNoKHsgbmFtZTogXCJvZmZzZXQgXCIgKyBJLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogayArIE4gfSksIHYuZmllbGRzLnB1c2goeyBuYW1lOiBcImxlbmd0aCBcIiArIEksIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiBkW0ldLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LmZpZWxkcy5wdXNoKHsgbmFtZTogXCJzdHJpbmdQb29sXCIsIHR5cGU6IFwiQ0hBUkFSUkFZXCIsIHZhbHVlOiB3IH0pLCB2O1xuICAgICAgICAgIH0sIHBhcnNlOiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gbmV3IHdlLlBhcnNlcihkLCB2KSwgayA9IHcucGFyc2VVTG9uZygpLCBJID0gKE8uYXJndW1lbnQoayA9PT0gMSwgXCJVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uXCIpLCB3LnNraXAoXCJ1TG9uZ1wiLCAxKSwgdy5wYXJzZVVMb25nKCkpLCBOID0gW10sIHogPSAwOyB6IDwgSTsgeisrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIFEgPSBcIlwiLCBzZSA9IHYgKyB3LnBhcnNlVVNob3J0KCksIG9lID0gdy5wYXJzZVVTaG9ydCgpLCB5ZSA9IHNlOyB5ZSA8IHNlICsgb2U7ICsreWUpXG4gICAgICAgICAgICAgICAgUSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGQuZ2V0SW50OCh5ZSkpO1xuICAgICAgICAgICAgICBOLnB1c2goUSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgICB9IH0sIExlID0geyBwYXJzZTogZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgdmFyIHcgPSB7fSwgayA9IG5ldyB3ZS5QYXJzZXIoaywgdik7XG4gICAgICAgICAgICByZXR1cm4gdy52ZXJzaW9uID0gay5wYXJzZVZlcnNpb24oKSwgdy5udW1HbHlwaHMgPSBrLnBhcnNlVVNob3J0KCksIHcudmVyc2lvbiA9PT0gMSAmJiAody5tYXhQb2ludHMgPSBrLnBhcnNlVVNob3J0KCksIHcubWF4Q29udG91cnMgPSBrLnBhcnNlVVNob3J0KCksIHcubWF4Q29tcG9zaXRlUG9pbnRzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heENvbXBvc2l0ZUNvbnRvdXJzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heFpvbmVzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heFR3aWxpZ2h0UG9pbnRzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heFN0b3JhZ2UgPSBrLnBhcnNlVVNob3J0KCksIHcubWF4RnVuY3Rpb25EZWZzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heEluc3RydWN0aW9uRGVmcyA9IGsucGFyc2VVU2hvcnQoKSwgdy5tYXhTdGFja0VsZW1lbnRzID0gay5wYXJzZVVTaG9ydCgpLCB3Lm1heFNpemVPZkluc3RydWN0aW9ucyA9IGsucGFyc2VVU2hvcnQoKSwgdy5tYXhDb21wb25lbnRFbGVtZW50cyA9IGsucGFyc2VVU2hvcnQoKSwgdy5tYXhDb21wb25lbnREZXB0aCA9IGsucGFyc2VVU2hvcnQoKSksIHc7XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZS5UYWJsZShcIm1heHBcIiwgW3sgbmFtZTogXCJ2ZXJzaW9uXCIsIHR5cGU6IFwiRklYRURcIiwgdmFsdWU6IDIwNDgwIH0sIHsgbmFtZTogXCJudW1HbHlwaHNcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IGQgfV0pO1xuICAgICAgICAgIH0gfSwgcnQgPSBbXCJjb3B5cmlnaHRcIiwgXCJmb250RmFtaWx5XCIsIFwiZm9udFN1YmZhbWlseVwiLCBcInVuaXF1ZUlEXCIsIFwiZnVsbE5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwicG9zdFNjcmlwdE5hbWVcIiwgXCJ0cmFkZW1hcmtcIiwgXCJtYW51ZmFjdHVyZXJcIiwgXCJkZXNpZ25lclwiLCBcImRlc2NyaXB0aW9uXCIsIFwibWFudWZhY3R1cmVyVVJMXCIsIFwiZGVzaWduZXJVUkxcIiwgXCJsaWNlbnNlXCIsIFwibGljZW5zZVVSTFwiLCBcInJlc2VydmVkXCIsIFwicHJlZmVycmVkRmFtaWx5XCIsIFwicHJlZmVycmVkU3ViZmFtaWx5XCIsIFwiY29tcGF0aWJsZUZ1bGxOYW1lXCIsIFwic2FtcGxlVGV4dFwiLCBcInBvc3RTY3JpcHRGaW5kRm9udE5hbWVcIiwgXCJ3d3NGYW1pbHlcIiwgXCJ3d3NTdWJmYW1pbHlcIl0sIFBlID0geyAwOiBcImVuXCIsIDE6IFwiZnJcIiwgMjogXCJkZVwiLCAzOiBcIml0XCIsIDQ6IFwibmxcIiwgNTogXCJzdlwiLCA2OiBcImVzXCIsIDc6IFwiZGFcIiwgODogXCJwdFwiLCA5OiBcIm5vXCIsIDEwOiBcImhlXCIsIDExOiBcImphXCIsIDEyOiBcImFyXCIsIDEzOiBcImZpXCIsIDE0OiBcImVsXCIsIDE1OiBcImlzXCIsIDE2OiBcIm10XCIsIDE3OiBcInRyXCIsIDE4OiBcImhyXCIsIDE5OiBcInpoLUhhbnRcIiwgMjA6IFwidXJcIiwgMjE6IFwiaGlcIiwgMjI6IFwidGhcIiwgMjM6IFwia29cIiwgMjQ6IFwibHRcIiwgMjU6IFwicGxcIiwgMjY6IFwiaHVcIiwgMjc6IFwiZXNcIiwgMjg6IFwibHZcIiwgMjk6IFwic2VcIiwgMzA6IFwiZm9cIiwgMzE6IFwiZmFcIiwgMzI6IFwicnVcIiwgMzM6IFwiemhcIiwgMzQ6IFwibmwtQkVcIiwgMzU6IFwiZ2FcIiwgMzY6IFwic3FcIiwgMzc6IFwicm9cIiwgMzg6IFwiY3pcIiwgMzk6IFwic2tcIiwgNDA6IFwic2lcIiwgNDE6IFwieWlcIiwgNDI6IFwic3JcIiwgNDM6IFwibWtcIiwgNDQ6IFwiYmdcIiwgNDU6IFwidWtcIiwgNDY6IFwiYmVcIiwgNDc6IFwidXpcIiwgNDg6IFwia2tcIiwgNDk6IFwiYXotQ3lybFwiLCA1MDogXCJhei1BcmFiXCIsIDUxOiBcImh5XCIsIDUyOiBcImthXCIsIDUzOiBcIm1vXCIsIDU0OiBcImt5XCIsIDU1OiBcInRnXCIsIDU2OiBcInRrXCIsIDU3OiBcIm1uLUNOXCIsIDU4OiBcIm1uXCIsIDU5OiBcInBzXCIsIDYwOiBcImtzXCIsIDYxOiBcImt1XCIsIDYyOiBcInNkXCIsIDYzOiBcImJvXCIsIDY0OiBcIm5lXCIsIDY1OiBcInNhXCIsIDY2OiBcIm1yXCIsIDY3OiBcImJuXCIsIDY4OiBcImFzXCIsIDY5OiBcImd1XCIsIDcwOiBcInBhXCIsIDcxOiBcIm9yXCIsIDcyOiBcIm1sXCIsIDczOiBcImtuXCIsIDc0OiBcInRhXCIsIDc1OiBcInRlXCIsIDc2OiBcInNpXCIsIDc3OiBcIm15XCIsIDc4OiBcImttXCIsIDc5OiBcImxvXCIsIDgwOiBcInZpXCIsIDgxOiBcImlkXCIsIDgyOiBcInRsXCIsIDgzOiBcIm1zXCIsIDg0OiBcIm1zLUFyYWJcIiwgODU6IFwiYW1cIiwgODY6IFwidGlcIiwgODc6IFwib21cIiwgODg6IFwic29cIiwgODk6IFwic3dcIiwgOTA6IFwicndcIiwgOTE6IFwicm5cIiwgOTI6IFwibnlcIiwgOTM6IFwibWdcIiwgOTQ6IFwiZW9cIiwgMTI4OiBcImN5XCIsIDEyOTogXCJldVwiLCAxMzA6IFwiY2FcIiwgMTMxOiBcImxhXCIsIDEzMjogXCJxdVwiLCAxMzM6IFwiZ25cIiwgMTM0OiBcImF5XCIsIDEzNTogXCJ0dFwiLCAxMzY6IFwidWdcIiwgMTM3OiBcImR6XCIsIDEzODogXCJqdlwiLCAxMzk6IFwic3VcIiwgMTQwOiBcImdsXCIsIDE0MTogXCJhZlwiLCAxNDI6IFwiYnJcIiwgMTQzOiBcIml1XCIsIDE0NDogXCJnZFwiLCAxNDU6IFwiZ3ZcIiwgMTQ2OiBcImdhXCIsIDE0NzogXCJ0b1wiLCAxNDg6IFwiZWwtcG9seXRvblwiLCAxNDk6IFwia2xcIiwgMTUwOiBcImF6XCIsIDE1MTogXCJublwiIH0sIGN0ID0geyAwOiAwLCAxOiAwLCAyOiAwLCAzOiAwLCA0OiAwLCA1OiAwLCA2OiAwLCA3OiAwLCA4OiAwLCA5OiAwLCAxMDogNSwgMTE6IDEsIDEyOiA0LCAxMzogMCwgMTQ6IDYsIDE1OiAwLCAxNjogMCwgMTc6IDAsIDE4OiAwLCAxOTogMiwgMjA6IDQsIDIxOiA5LCAyMjogMjEsIDIzOiAzLCAyNDogMjksIDI1OiAyOSwgMjY6IDI5LCAyNzogMjksIDI4OiAyOSwgMjk6IDAsIDMwOiAwLCAzMTogNCwgMzI6IDcsIDMzOiAyNSwgMzQ6IDAsIDM1OiAwLCAzNjogMCwgMzc6IDAsIDM4OiAyOSwgMzk6IDI5LCA0MDogMCwgNDE6IDUsIDQyOiA3LCA0MzogNywgNDQ6IDcsIDQ1OiA3LCA0NjogNywgNDc6IDcsIDQ4OiA3LCA0OTogNywgNTA6IDQsIDUxOiAyNCwgNTI6IDIzLCA1MzogNywgNTQ6IDcsIDU1OiA3LCA1NjogNywgNTc6IDI3LCA1ODogNywgNTk6IDQsIDYwOiA0LCA2MTogNCwgNjI6IDQsIDYzOiAyNiwgNjQ6IDksIDY1OiA5LCA2NjogOSwgNjc6IDEzLCA2ODogMTMsIDY5OiAxMSwgNzA6IDEwLCA3MTogMTIsIDcyOiAxNywgNzM6IDE2LCA3NDogMTQsIDc1OiAxNSwgNzY6IDE4LCA3NzogMTksIDc4OiAyMCwgNzk6IDIyLCA4MDogMzAsIDgxOiAwLCA4MjogMCwgODM6IDAsIDg0OiA0LCA4NTogMjgsIDg2OiAyOCwgODc6IDI4LCA4ODogMCwgODk6IDAsIDkwOiAwLCA5MTogMCwgOTI6IDAsIDkzOiAwLCA5NDogMCwgMTI4OiAwLCAxMjk6IDAsIDEzMDogMCwgMTMxOiAwLCAxMzI6IDAsIDEzMzogMCwgMTM0OiAwLCAxMzU6IDcsIDEzNjogNCwgMTM3OiAyNiwgMTM4OiAwLCAxMzk6IDAsIDE0MDogMCwgMTQxOiAwLCAxNDI6IDAsIDE0MzogMjgsIDE0NDogMCwgMTQ1OiAwLCAxNDY6IDAsIDE0NzogMCwgMTQ4OiA2LCAxNDk6IDAsIDE1MDogMCwgMTUxOiAwIH0sIHFlID0geyAxMDc4OiBcImFmXCIsIDEwNTI6IFwic3FcIiwgMTE1NjogXCJnc3dcIiwgMTExODogXCJhbVwiLCA1MTIxOiBcImFyLURaXCIsIDE1MzYxOiBcImFyLUJIXCIsIDMwNzM6IFwiYXJcIiwgMjA0OTogXCJhci1JUVwiLCAxMTI2NTogXCJhci1KT1wiLCAxMzMxMzogXCJhci1LV1wiLCAxMjI4OTogXCJhci1MQlwiLCA0MDk3OiBcImFyLUxZXCIsIDYxNDU6IFwiYXJ5XCIsIDgxOTM6IFwiYXItT01cIiwgMTYzODU6IFwiYXItUUFcIiwgMTAyNTogXCJhci1TQVwiLCAxMDI0MTogXCJhci1TWVwiLCA3MTY5OiBcImFlYlwiLCAxNDMzNzogXCJhci1BRVwiLCA5MjE3OiBcImFyLVlFXCIsIDEwNjc6IFwiaHlcIiwgMTEwMTogXCJhc1wiLCAyMDkyOiBcImF6LUN5cmxcIiwgMTA2ODogXCJhelwiLCAxMTMzOiBcImJhXCIsIDEwNjk6IFwiZXVcIiwgMTA1OTogXCJiZVwiLCAyMTE3OiBcImJuXCIsIDEwOTM6IFwiYm4tSU5cIiwgODIxODogXCJicy1DeXJsXCIsIDUxNDY6IFwiYnNcIiwgMTE1MDogXCJiclwiLCAxMDI2OiBcImJnXCIsIDEwMjc6IFwiY2FcIiwgMzA3NjogXCJ6aC1IS1wiLCA1MTI0OiBcInpoLU1PXCIsIDIwNTI6IFwiemhcIiwgNDEwMDogXCJ6aC1TR1wiLCAxMDI4OiBcInpoLVRXXCIsIDExNTU6IFwiY29cIiwgMTA1MDogXCJoclwiLCA0MTIyOiBcImhyLUJBXCIsIDEwMjk6IFwiY3NcIiwgMTAzMDogXCJkYVwiLCAxMTY0OiBcInByc1wiLCAxMTI1OiBcImR2XCIsIDIwNjc6IFwibmwtQkVcIiwgMTA0MzogXCJubFwiLCAzMDgxOiBcImVuLUFVXCIsIDEwMjQ5OiBcImVuLUJaXCIsIDQxMDU6IFwiZW4tQ0FcIiwgOTIyNTogXCJlbi0wMjlcIiwgMTYzOTM6IFwiZW4tSU5cIiwgNjE1MzogXCJlbi1JRVwiLCA4MjAxOiBcImVuLUpNXCIsIDE3NDE3OiBcImVuLU1ZXCIsIDUxMjk6IFwiZW4tTlpcIiwgMTMzMjE6IFwiZW4tUEhcIiwgMTg0NDE6IFwiZW4tU0dcIiwgNzE3NzogXCJlbi1aQVwiLCAxMTI3MzogXCJlbi1UVFwiLCAyMDU3OiBcImVuLUdCXCIsIDEwMzM6IFwiZW5cIiwgMTIyOTc6IFwiZW4tWldcIiwgMTA2MTogXCJldFwiLCAxMDgwOiBcImZvXCIsIDExMjQ6IFwiZmlsXCIsIDEwMzU6IFwiZmlcIiwgMjA2MDogXCJmci1CRVwiLCAzMDg0OiBcImZyLUNBXCIsIDEwMzY6IFwiZnJcIiwgNTEzMjogXCJmci1MVVwiLCA2MTU2OiBcImZyLU1DXCIsIDQxMDg6IFwiZnItQ0hcIiwgMTEyMjogXCJmeVwiLCAxMTEwOiBcImdsXCIsIDEwNzk6IFwia2FcIiwgMzA3OTogXCJkZS1BVFwiLCAxMDMxOiBcImRlXCIsIDUxMjc6IFwiZGUtTElcIiwgNDEwMzogXCJkZS1MVVwiLCAyMDU1OiBcImRlLUNIXCIsIDEwMzI6IFwiZWxcIiwgMTEzNTogXCJrbFwiLCAxMDk1OiBcImd1XCIsIDExMjg6IFwiaGFcIiwgMTAzNzogXCJoZVwiLCAxMDgxOiBcImhpXCIsIDEwMzg6IFwiaHVcIiwgMTAzOTogXCJpc1wiLCAxMTM2OiBcImlnXCIsIDEwNTc6IFwiaWRcIiwgMTExNzogXCJpdVwiLCAyMTQxOiBcIml1LUxhdG5cIiwgMjEwODogXCJnYVwiLCAxMDc2OiBcInhoXCIsIDEwNzc6IFwienVcIiwgMTA0MDogXCJpdFwiLCAyMDY0OiBcIml0LUNIXCIsIDEwNDE6IFwiamFcIiwgMTA5OTogXCJrblwiLCAxMDg3OiBcImtrXCIsIDExMDc6IFwia21cIiwgMTE1ODogXCJxdWNcIiwgMTE1OTogXCJyd1wiLCAxMDg5OiBcInN3XCIsIDExMTE6IFwia29rXCIsIDEwNDI6IFwia29cIiwgMTA4ODogXCJreVwiLCAxMTA4OiBcImxvXCIsIDEwNjI6IFwibHZcIiwgMTA2MzogXCJsdFwiLCAyMDk0OiBcImRzYlwiLCAxMTM0OiBcImxiXCIsIDEwNzE6IFwibWtcIiwgMjExMDogXCJtcy1CTlwiLCAxMDg2OiBcIm1zXCIsIDExMDA6IFwibWxcIiwgMTA4MjogXCJtdFwiLCAxMTUzOiBcIm1pXCIsIDExNDY6IFwiYXJuXCIsIDExMDI6IFwibXJcIiwgMTE0ODogXCJtb2hcIiwgMTEwNDogXCJtblwiLCAyMTI4OiBcIm1uLUNOXCIsIDExMjE6IFwibmVcIiwgMTA0NDogXCJuYlwiLCAyMDY4OiBcIm5uXCIsIDExNTQ6IFwib2NcIiwgMTA5NjogXCJvclwiLCAxMTIzOiBcInBzXCIsIDEwNDU6IFwicGxcIiwgMTA0NjogXCJwdFwiLCAyMDcwOiBcInB0LVBUXCIsIDEwOTQ6IFwicGFcIiwgMTEzMTogXCJxdS1CT1wiLCAyMTU1OiBcInF1LUVDXCIsIDMxNzk6IFwicXVcIiwgMTA0ODogXCJyb1wiLCAxMDQ3OiBcInJtXCIsIDEwNDk6IFwicnVcIiwgOTI3NTogXCJzbW5cIiwgNDE1NTogXCJzbWotTk9cIiwgNTE3OTogXCJzbWpcIiwgMzEzMTogXCJzZS1GSVwiLCAxMDgzOiBcInNlXCIsIDIxMDc6IFwic2UtU0VcIiwgODI1MTogXCJzbXNcIiwgNjIwMzogXCJzbWEtTk9cIiwgNzIyNzogXCJzbXNcIiwgMTEwMzogXCJzYVwiLCA3MTk0OiBcInNyLUN5cmwtQkFcIiwgMzA5ODogXCJzclwiLCA2MTcwOiBcInNyLUxhdG4tQkFcIiwgMjA3NDogXCJzci1MYXRuXCIsIDExMzI6IFwibnNvXCIsIDEwNzQ6IFwidG5cIiwgMTExNTogXCJzaVwiLCAxMDUxOiBcInNrXCIsIDEwNjA6IFwic2xcIiwgMTEyNzQ6IFwiZXMtQVJcIiwgMTYzOTQ6IFwiZXMtQk9cIiwgMTMzMjI6IFwiZXMtQ0xcIiwgOTIyNjogXCJlcy1DT1wiLCA1MTMwOiBcImVzLUNSXCIsIDcxNzg6IFwiZXMtRE9cIiwgMTIyOTg6IFwiZXMtRUNcIiwgMTc0MTg6IFwiZXMtU1ZcIiwgNDEwNjogXCJlcy1HVFwiLCAxODQ0MjogXCJlcy1ITlwiLCAyMDU4OiBcImVzLU1YXCIsIDE5NDY2OiBcImVzLU5JXCIsIDYxNTQ6IFwiZXMtUEFcIiwgMTUzNzA6IFwiZXMtUFlcIiwgMTAyNTA6IFwiZXMtUEVcIiwgMjA0OTA6IFwiZXMtUFJcIiwgMzA4MjogXCJlc1wiLCAxMDM0OiBcImVzXCIsIDIxNTE0OiBcImVzLVVTXCIsIDE0MzQ2OiBcImVzLVVZXCIsIDgyMDI6IFwiZXMtVkVcIiwgMjA3NzogXCJzdi1GSVwiLCAxMDUzOiBcInN2XCIsIDExMTQ6IFwic3lyXCIsIDEwNjQ6IFwidGdcIiwgMjE0MzogXCJ0em1cIiwgMTA5NzogXCJ0YVwiLCAxMDkyOiBcInR0XCIsIDEwOTg6IFwidGVcIiwgMTA1NDogXCJ0aFwiLCAxMTA1OiBcImJvXCIsIDEwNTU6IFwidHJcIiwgMTA5MDogXCJ0a1wiLCAxMTUyOiBcInVnXCIsIDEwNTg6IFwidWtcIiwgMTA3MDogXCJoc2JcIiwgMTA1NjogXCJ1clwiLCAyMTE1OiBcInV6LUN5cmxcIiwgMTA5MTogXCJ1elwiLCAxMDY2OiBcInZpXCIsIDExMDY6IFwiY3lcIiwgMTE2MDogXCJ3b1wiLCAxMTU3OiBcInNhaFwiLCAxMTQ0OiBcImlpXCIsIDExMzA6IFwieW9cIiB9LCB1dCA9IFwidXRmLTE2XCIsIFplID0geyAwOiBcIm1hY2ludG9zaFwiLCAxOiBcIngtbWFjLWphcGFuZXNlXCIsIDI6IFwieC1tYWMtY2hpbmVzZXRyYWRcIiwgMzogXCJ4LW1hYy1rb3JlYW5cIiwgNjogXCJ4LW1hYy1ncmVla1wiLCA3OiBcIngtbWFjLWN5cmlsbGljXCIsIDk6IFwieC1tYWMtZGV2YW5hZ2FpXCIsIDEwOiBcIngtbWFjLWd1cm11a2hpXCIsIDExOiBcIngtbWFjLWd1amFyYXRpXCIsIDEyOiBcIngtbWFjLW9yaXlhXCIsIDEzOiBcIngtbWFjLWJlbmdhbGlcIiwgMTQ6IFwieC1tYWMtdGFtaWxcIiwgMTU6IFwieC1tYWMtdGVsdWd1XCIsIDE2OiBcIngtbWFjLWthbm5hZGFcIiwgMTc6IFwieC1tYWMtbWFsYXlhbGFtXCIsIDE4OiBcIngtbWFjLXNpbmhhbGVzZVwiLCAxOTogXCJ4LW1hYy1idXJtZXNlXCIsIDIwOiBcIngtbWFjLWtobWVyXCIsIDIxOiBcIngtbWFjLXRoYWlcIiwgMjI6IFwieC1tYWMtbGFvXCIsIDIzOiBcIngtbWFjLWdlb3JnaWFuXCIsIDI0OiBcIngtbWFjLWFybWVuaWFuXCIsIDI1OiBcIngtbWFjLWNoaW5lc2VzaW1wXCIsIDI2OiBcIngtbWFjLXRpYmV0YW5cIiwgMjc6IFwieC1tYWMtbW9uZ29saWFuXCIsIDI4OiBcIngtbWFjLWV0aGlvcGljXCIsIDI5OiBcIngtbWFjLWNlXCIsIDMwOiBcIngtbWFjLXZpZXRuYW1lc2VcIiwgMzE6IFwieC1tYWMtZXh0YXJhYmljXCIgfSwgQXQgPSB7IDE1OiBcIngtbWFjLWljZWxhbmRpY1wiLCAxNzogXCJ4LW1hYy10dXJraXNoXCIsIDE4OiBcIngtbWFjLWNyb2F0aWFuXCIsIDI0OiBcIngtbWFjLWNlXCIsIDI1OiBcIngtbWFjLWNlXCIsIDI2OiBcIngtbWFjLWNlXCIsIDI3OiBcIngtbWFjLWNlXCIsIDI4OiBcIngtbWFjLWNlXCIsIDMwOiBcIngtbWFjLWljZWxhbmRpY1wiLCAzNzogXCJ4LW1hYy1yb21hbmlhblwiLCAzODogXCJ4LW1hYy1jZVwiLCAzOTogXCJ4LW1hYy1jZVwiLCA0MDogXCJ4LW1hYy1jZVwiLCAxNDM6IFwieC1tYWMtaW51aXRcIiwgMTQ2OiBcIngtbWFjLWdhZWxpY1wiIH07XG4gICAgICAgICAgZnVuY3Rpb24gVXQoZCwgdiwgdykge1xuICAgICAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXQ7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gQXRbd10gfHwgWmVbdl07XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMSB8fCB2ID09PSAxMClcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQ3QoZCkge1xuICAgICAgICAgICAgdmFyIHYsIHcgPSB7fTtcbiAgICAgICAgICAgIGZvciAodiBpbiBkKVxuICAgICAgICAgICAgICB3W2Rbdl1dID0gcGFyc2VJbnQodik7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTnQoZCwgdiwgdywgaywgSSwgTikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZS5SZWNvcmQoXCJOYW1lUmVjb3JkXCIsIFt7IG5hbWU6IFwicGxhdGZvcm1JRFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogZCB9LCB7IG5hbWU6IFwiZW5jb2RpbmdJRFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogdiB9LCB7IG5hbWU6IFwibGFuZ3VhZ2VJRFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogdyB9LCB7IG5hbWU6IFwibmFtZUlEXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiBrIH0sIHsgbmFtZTogXCJsZW5ndGhcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IEkgfSwgeyBuYW1lOiBcIm9mZnNldFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogTiB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEt0KGQsIHYpIHtcbiAgICAgICAgICAgIGlmICgodyA9IGZ1bmN0aW9uKE4sIHopIHtcbiAgICAgICAgICAgICAgdmFyIFEgPSBOLmxlbmd0aCwgc2UgPSB6Lmxlbmd0aCAtIFEgKyAxO1xuICAgICAgICAgICAgICBlOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9lID0gMDsgb2UgPCBzZTsgb2UrKylcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBvZSA8IHNlOyBvZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHllID0gMDsgeWUgPCBROyB5ZSsrKVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh6W29lICsgeWVdICE9PSBOW3llXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfShkLCB2KSkgPCAwKVxuICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gdi5sZW5ndGgsIGsgPSAwLCBJID0gZC5sZW5ndGg7IGsgPCBJOyArK2spXG4gICAgICAgICAgICAgICAgdi5wdXNoKGRba10pO1xuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBYdCA9IHsgcGFyc2U6IGZ1bmN0aW9uKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSB7fSwgSSA9IG5ldyB3ZS5QYXJzZXIoZCwgdiksIHYgPSBJLnBhcnNlVVNob3J0KCksIE4gPSBJLnBhcnNlVVNob3J0KCksIHogPSBJLm9mZnNldCArIEkucGFyc2VVU2hvcnQoKSwgUSA9IDA7IFEgPCBOOyBRKyspIHtcbiAgICAgICAgICAgICAgdmFyIEllID0gSS5wYXJzZVVTaG9ydCgpLCBzZSA9IEkucGFyc2VVU2hvcnQoKSwgb2UgPSBJLnBhcnNlVVNob3J0KCksIHllID0gSS5wYXJzZVVTaG9ydCgpLCB5ZSA9IHJ0W3llXSB8fCB5ZSwgU2UgPSBJLnBhcnNlVVNob3J0KCksIGJlID0gSS5wYXJzZVVTaG9ydCgpLCBkZSA9IGZ1bmN0aW9uKEFlLCBUZSwgRWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKEFlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZSA9PT0gNjU1MzUpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWVbVGVdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlW1RlXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFlW1RlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0oSWUsIG9lLCB3KSwgSWUgPSBVdChJZSwgc2UsIG9lKTtcbiAgICAgICAgICAgICAgSWUgIT09IHZvaWQgMCAmJiBkZSAhPT0gdm9pZCAwICYmIChzZSA9IHZvaWQgMCwgKHNlID0gSWUgPT09IHV0ID8gRC5VVEYxNihkLCB6ICsgYmUsIFNlKSA6IEQuTUFDU1RSSU5HKGQsIHogKyBiZSwgU2UsIEllKSkgJiYgKChvZSA9IChvZSA9IGtbeWVdKSA9PT0gdm9pZCAwID8ga1t5ZV0gPSB7fSA6IG9lKVtkZV0gPSBzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYgPT09IDEgJiYgSS5wYXJzZVVTaG9ydCgpLCBrO1xuICAgICAgICAgIH0sIG1ha2U6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBrID0gW10sIEkgPSB7fSwgTiA9IEN0KHJ0KTtcbiAgICAgICAgICAgIGZvciAodyBpbiBkKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gTlt3XTtcbiAgICAgICAgICAgICAgaWYgKHogPT09IHZvaWQgMCAmJiAoeiA9IHcpLCBiZSA9IHBhcnNlSW50KHopLCBpc05hTihiZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIHRhYmxlIGVudHJ5IFwiJyArIHcgKyAnXCIgZG9lcyBub3QgZXhpc3QsIHNlZSBuYW1lVGFibGVOYW1lcyBmb3IgY29tcGxldGUgbGlzdC4nKTtcbiAgICAgICAgICAgICAgSVtiZV0gPSBkW3ddLCBrLnB1c2goYmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgUSA9IEN0KFBlKSwgc2UgPSBDdChxZSksIG9lID0gW10sIHllID0gW10sIFNlID0gMDsgU2UgPCBrLmxlbmd0aDsgU2UrKykge1xuICAgICAgICAgICAgICB2YXIgYmUsIGRlLCBJZSA9IElbYmUgPSBrW1NlXV07XG4gICAgICAgICAgICAgIGZvciAoZGUgaW4gSWUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2UgPSBJZVtkZV0sIGx0ID0gMSwgQWUgPSBRW2RlXSwgVGUgPSBjdFtBZV0sIEVlID0gVXQobHQsIFRlLCBBZSksIEVlID0gQi5NQUNTVFJJTkcoa2UsIEVlKSwgJGUgPSAoRWUgPT09IHZvaWQgMCAmJiAobHQgPSAwLCAoQWUgPSB2LmluZGV4T2YoZGUpKSA8IDAgJiYgKEFlID0gdi5sZW5ndGgsIHYucHVzaChkZSkpLCBUZSA9IDQsIEVlID0gQi5VVEYxNihrZSkpLCBLdChFZSwgeWUpKSwgbHQgPSAob2UucHVzaChOdChsdCwgVGUsIEFlLCBiZSwgRWUubGVuZ3RoLCAkZSkpLCBzZVtkZV0pO1xuICAgICAgICAgICAgICAgIGx0ICE9PSB2b2lkIDAgJiYgKEFlID0gS3QoVGUgPSBCLlVURjE2KGtlKSwgeWUpLCBvZS5wdXNoKE50KDMsIDEsIGx0LCBiZSwgVGUubGVuZ3RoLCBBZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Uuc29ydChmdW5jdGlvbihkdCwgd3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGR0LnBsYXRmb3JtSUQgLSB3dC5wbGF0Zm9ybUlEIHx8IGR0LmVuY29kaW5nSUQgLSB3dC5lbmNvZGluZ0lEIHx8IGR0Lmxhbmd1YWdlSUQgLSB3dC5sYW5ndWFnZUlEIHx8IGR0Lm5hbWVJRCAtIHd0Lm5hbWVJRDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgZXQgPSBuZXcgTWUuVGFibGUoXCJuYW1lXCIsIFt7IG5hbWU6IFwiZm9ybWF0XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJjb3VudFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogb2UubGVuZ3RoIH0sIHsgbmFtZTogXCJzdHJpbmdPZmZzZXRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDYgKyAxMiAqIG9lLmxlbmd0aCB9XSksIHR0ID0gMDsgdHQgPCBvZS5sZW5ndGg7IHR0KyspXG4gICAgICAgICAgICAgIGV0LmZpZWxkcy5wdXNoKHsgbmFtZTogXCJyZWNvcmRfXCIgKyB0dCwgdHlwZTogXCJSRUNPUkRcIiwgdmFsdWU6IG9lW3R0XSB9KTtcbiAgICAgICAgICAgIHJldHVybiBldC5maWVsZHMucHVzaCh7IG5hbWU6IFwic3RyaW5nc1wiLCB0eXBlOiBcIkxJVEVSQUxcIiwgdmFsdWU6IHllIH0pLCBldDtcbiAgICAgICAgICB9IH0sIEp0ID0gW3sgYmVnaW46IDAsIGVuZDogMTI3IH0sIHsgYmVnaW46IDEyOCwgZW5kOiAyNTUgfSwgeyBiZWdpbjogMjU2LCBlbmQ6IDM4MyB9LCB7IGJlZ2luOiAzODQsIGVuZDogNTkxIH0sIHsgYmVnaW46IDU5MiwgZW5kOiA2ODcgfSwgeyBiZWdpbjogNjg4LCBlbmQ6IDc2NyB9LCB7IGJlZ2luOiA3NjgsIGVuZDogODc5IH0sIHsgYmVnaW46IDg4MCwgZW5kOiAxMDIzIH0sIHsgYmVnaW46IDExMzkyLCBlbmQ6IDExNTE5IH0sIHsgYmVnaW46IDEwMjQsIGVuZDogMTI3OSB9LCB7IGJlZ2luOiAxMzI4LCBlbmQ6IDE0MjMgfSwgeyBiZWdpbjogMTQyNCwgZW5kOiAxNTM1IH0sIHsgYmVnaW46IDQyMjQwLCBlbmQ6IDQyNTU5IH0sIHsgYmVnaW46IDE1MzYsIGVuZDogMTc5MSB9LCB7IGJlZ2luOiAxOTg0LCBlbmQ6IDIwNDcgfSwgeyBiZWdpbjogMjMwNCwgZW5kOiAyNDMxIH0sIHsgYmVnaW46IDI0MzIsIGVuZDogMjU1OSB9LCB7IGJlZ2luOiAyNTYwLCBlbmQ6IDI2ODcgfSwgeyBiZWdpbjogMjY4OCwgZW5kOiAyODE1IH0sIHsgYmVnaW46IDI4MTYsIGVuZDogMjk0MyB9LCB7IGJlZ2luOiAyOTQ0LCBlbmQ6IDMwNzEgfSwgeyBiZWdpbjogMzA3MiwgZW5kOiAzMTk5IH0sIHsgYmVnaW46IDMyMDAsIGVuZDogMzMyNyB9LCB7IGJlZ2luOiAzMzI4LCBlbmQ6IDM0NTUgfSwgeyBiZWdpbjogMzU4NCwgZW5kOiAzNzExIH0sIHsgYmVnaW46IDM3MTIsIGVuZDogMzgzOSB9LCB7IGJlZ2luOiA0MjU2LCBlbmQ6IDQzNTEgfSwgeyBiZWdpbjogNjkxMiwgZW5kOiA3MDM5IH0sIHsgYmVnaW46IDQzNTIsIGVuZDogNDYwNyB9LCB7IGJlZ2luOiA3NjgwLCBlbmQ6IDc5MzUgfSwgeyBiZWdpbjogNzkzNiwgZW5kOiA4MTkxIH0sIHsgYmVnaW46IDgxOTIsIGVuZDogODMwMyB9LCB7IGJlZ2luOiA4MzA0LCBlbmQ6IDgzNTEgfSwgeyBiZWdpbjogODM1MiwgZW5kOiA4Mzk5IH0sIHsgYmVnaW46IDg0MDAsIGVuZDogODQ0NyB9LCB7IGJlZ2luOiA4NDQ4LCBlbmQ6IDg1MjcgfSwgeyBiZWdpbjogODUyOCwgZW5kOiA4NTkxIH0sIHsgYmVnaW46IDg1OTIsIGVuZDogODcwMyB9LCB7IGJlZ2luOiA4NzA0LCBlbmQ6IDg5NTkgfSwgeyBiZWdpbjogODk2MCwgZW5kOiA5MjE1IH0sIHsgYmVnaW46IDkyMTYsIGVuZDogOTI3OSB9LCB7IGJlZ2luOiA5MjgwLCBlbmQ6IDkzMTEgfSwgeyBiZWdpbjogOTMxMiwgZW5kOiA5NDcxIH0sIHsgYmVnaW46IDk0NzIsIGVuZDogOTU5OSB9LCB7IGJlZ2luOiA5NjAwLCBlbmQ6IDk2MzEgfSwgeyBiZWdpbjogOTYzMiwgZW5kOiA5NzI3IH0sIHsgYmVnaW46IDk3MjgsIGVuZDogOTk4MyB9LCB7IGJlZ2luOiA5OTg0LCBlbmQ6IDEwMTc1IH0sIHsgYmVnaW46IDEyMjg4LCBlbmQ6IDEyMzUxIH0sIHsgYmVnaW46IDEyMzUyLCBlbmQ6IDEyNDQ3IH0sIHsgYmVnaW46IDEyNDQ4LCBlbmQ6IDEyNTQzIH0sIHsgYmVnaW46IDEyNTQ0LCBlbmQ6IDEyNTkxIH0sIHsgYmVnaW46IDEyNTkyLCBlbmQ6IDEyNjg3IH0sIHsgYmVnaW46IDQzMDcyLCBlbmQ6IDQzMTM1IH0sIHsgYmVnaW46IDEyODAwLCBlbmQ6IDEzMDU1IH0sIHsgYmVnaW46IDEzMDU2LCBlbmQ6IDEzMzExIH0sIHsgYmVnaW46IDQ0MDMyLCBlbmQ6IDU1MjE1IH0sIHsgYmVnaW46IDU1Mjk2LCBlbmQ6IDU3MzQzIH0sIHsgYmVnaW46IDY3ODQwLCBlbmQ6IDY3ODcxIH0sIHsgYmVnaW46IDE5OTY4LCBlbmQ6IDQwOTU5IH0sIHsgYmVnaW46IDU3MzQ0LCBlbmQ6IDYzNzQzIH0sIHsgYmVnaW46IDEyNzM2LCBlbmQ6IDEyNzgzIH0sIHsgYmVnaW46IDY0MjU2LCBlbmQ6IDY0MzM1IH0sIHsgYmVnaW46IDY0MzM2LCBlbmQ6IDY1MDIzIH0sIHsgYmVnaW46IDY1MDU2LCBlbmQ6IDY1MDcxIH0sIHsgYmVnaW46IDY1MDQwLCBlbmQ6IDY1MDU1IH0sIHsgYmVnaW46IDY1MTA0LCBlbmQ6IDY1MTM1IH0sIHsgYmVnaW46IDY1MTM2LCBlbmQ6IDY1Mjc5IH0sIHsgYmVnaW46IDY1MjgwLCBlbmQ6IDY1NTE5IH0sIHsgYmVnaW46IDY1NTIwLCBlbmQ6IDY1NTM1IH0sIHsgYmVnaW46IDM4NDAsIGVuZDogNDA5NSB9LCB7IGJlZ2luOiAxNzkyLCBlbmQ6IDE4NzEgfSwgeyBiZWdpbjogMTkyMCwgZW5kOiAxOTgzIH0sIHsgYmVnaW46IDM0NTYsIGVuZDogMzU4MyB9LCB7IGJlZ2luOiA0MDk2LCBlbmQ6IDQyNTUgfSwgeyBiZWdpbjogNDYwOCwgZW5kOiA0OTkxIH0sIHsgYmVnaW46IDUwMjQsIGVuZDogNTExOSB9LCB7IGJlZ2luOiA1MTIwLCBlbmQ6IDU3NTkgfSwgeyBiZWdpbjogNTc2MCwgZW5kOiA1NzkxIH0sIHsgYmVnaW46IDU3OTIsIGVuZDogNTg4NyB9LCB7IGJlZ2luOiA2MDE2LCBlbmQ6IDYxNDMgfSwgeyBiZWdpbjogNjE0NCwgZW5kOiA2MzE5IH0sIHsgYmVnaW46IDEwMjQwLCBlbmQ6IDEwNDk1IH0sIHsgYmVnaW46IDQwOTYwLCBlbmQ6IDQyMTI3IH0sIHsgYmVnaW46IDU4ODgsIGVuZDogNTkxOSB9LCB7IGJlZ2luOiA2NjMwNCwgZW5kOiA2NjM1MSB9LCB7IGJlZ2luOiA2NjM1MiwgZW5kOiA2NjM4MyB9LCB7IGJlZ2luOiA2NjU2MCwgZW5kOiA2NjYzOSB9LCB7IGJlZ2luOiAxMTg3ODQsIGVuZDogMTE5MDM5IH0sIHsgYmVnaW46IDExOTgwOCwgZW5kOiAxMjA4MzEgfSwgeyBiZWdpbjogMTA0NDQ4MCwgZW5kOiAxMDQ4NTczIH0sIHsgYmVnaW46IDY1MDI0LCBlbmQ6IDY1MDM5IH0sIHsgYmVnaW46IDkxNzUwNCwgZW5kOiA5MTc2MzEgfSwgeyBiZWdpbjogNjQwMCwgZW5kOiA2NDc5IH0sIHsgYmVnaW46IDY0ODAsIGVuZDogNjUyNyB9LCB7IGJlZ2luOiA2NTI4LCBlbmQ6IDY2MjMgfSwgeyBiZWdpbjogNjY1NiwgZW5kOiA2Njg3IH0sIHsgYmVnaW46IDExMjY0LCBlbmQ6IDExMzU5IH0sIHsgYmVnaW46IDExNTY4LCBlbmQ6IDExNjQ3IH0sIHsgYmVnaW46IDE5OTA0LCBlbmQ6IDE5OTY3IH0sIHsgYmVnaW46IDQzMDA4LCBlbmQ6IDQzMDU1IH0sIHsgYmVnaW46IDY1NTM2LCBlbmQ6IDY1NjYzIH0sIHsgYmVnaW46IDY1ODU2LCBlbmQ6IDY1OTM1IH0sIHsgYmVnaW46IDY2NDMyLCBlbmQ6IDY2NDYzIH0sIHsgYmVnaW46IDY2NDY0LCBlbmQ6IDY2NTI3IH0sIHsgYmVnaW46IDY2NjQwLCBlbmQ6IDY2Njg3IH0sIHsgYmVnaW46IDY2Njg4LCBlbmQ6IDY2NzM1IH0sIHsgYmVnaW46IDY3NTg0LCBlbmQ6IDY3NjQ3IH0sIHsgYmVnaW46IDY4MDk2LCBlbmQ6IDY4MTkxIH0sIHsgYmVnaW46IDExOTU1MiwgZW5kOiAxMTk2NDcgfSwgeyBiZWdpbjogNzM3MjgsIGVuZDogNzQ3NTEgfSwgeyBiZWdpbjogMTE5NjQ4LCBlbmQ6IDExOTY3OSB9LCB7IGJlZ2luOiA3MDQwLCBlbmQ6IDcxMDMgfSwgeyBiZWdpbjogNzE2OCwgZW5kOiA3MjQ3IH0sIHsgYmVnaW46IDcyNDgsIGVuZDogNzI5NSB9LCB7IGJlZ2luOiA0MzEzNiwgZW5kOiA0MzIzMSB9LCB7IGJlZ2luOiA0MzI2NCwgZW5kOiA0MzMxMSB9LCB7IGJlZ2luOiA0MzMxMiwgZW5kOiA0MzM1OSB9LCB7IGJlZ2luOiA0MzUyMCwgZW5kOiA0MzYxNSB9LCB7IGJlZ2luOiA2NTkzNiwgZW5kOiA2NTk5OSB9LCB7IGJlZ2luOiA2NmUzLCBlbmQ6IDY2MDQ3IH0sIHsgYmVnaW46IDY2MjA4LCBlbmQ6IDY2MjcxIH0sIHsgYmVnaW46IDEyNzAyNCwgZW5kOiAxMjcxMzUgfV0sIEJ0ID0geyBwYXJzZTogZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdmFyIHcgPSB7fSwgayA9IG5ldyB3ZS5QYXJzZXIoZCwgdik7XG4gICAgICAgICAgICB3LnZlcnNpb24gPSBrLnBhcnNlVVNob3J0KCksIHcueEF2Z0NoYXJXaWR0aCA9IGsucGFyc2VTaG9ydCgpLCB3LnVzV2VpZ2h0Q2xhc3MgPSBrLnBhcnNlVVNob3J0KCksIHcudXNXaWR0aENsYXNzID0gay5wYXJzZVVTaG9ydCgpLCB3LmZzVHlwZSA9IGsucGFyc2VVU2hvcnQoKSwgdy55U3Vic2NyaXB0WFNpemUgPSBrLnBhcnNlU2hvcnQoKSwgdy55U3Vic2NyaXB0WVNpemUgPSBrLnBhcnNlU2hvcnQoKSwgdy55U3Vic2NyaXB0WE9mZnNldCA9IGsucGFyc2VTaG9ydCgpLCB3LnlTdWJzY3JpcHRZT2Zmc2V0ID0gay5wYXJzZVNob3J0KCksIHcueVN1cGVyc2NyaXB0WFNpemUgPSBrLnBhcnNlU2hvcnQoKSwgdy55U3VwZXJzY3JpcHRZU2l6ZSA9IGsucGFyc2VTaG9ydCgpLCB3LnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBrLnBhcnNlU2hvcnQoKSwgdy55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gay5wYXJzZVNob3J0KCksIHcueVN0cmlrZW91dFNpemUgPSBrLnBhcnNlU2hvcnQoKSwgdy55U3RyaWtlb3V0UG9zaXRpb24gPSBrLnBhcnNlU2hvcnQoKSwgdy5zRmFtaWx5Q2xhc3MgPSBrLnBhcnNlU2hvcnQoKSwgdy5wYW5vc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgMTA7IEkrKylcbiAgICAgICAgICAgICAgdy5wYW5vc2VbSV0gPSBrLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHcudWxVbmljb2RlUmFuZ2UxID0gay5wYXJzZVVMb25nKCksIHcudWxVbmljb2RlUmFuZ2UyID0gay5wYXJzZVVMb25nKCksIHcudWxVbmljb2RlUmFuZ2UzID0gay5wYXJzZVVMb25nKCksIHcudWxVbmljb2RlUmFuZ2U0ID0gay5wYXJzZVVMb25nKCksIHcuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShrLnBhcnNlQnl0ZSgpLCBrLnBhcnNlQnl0ZSgpLCBrLnBhcnNlQnl0ZSgpLCBrLnBhcnNlQnl0ZSgpKSwgdy5mc1NlbGVjdGlvbiA9IGsucGFyc2VVU2hvcnQoKSwgdy51c0ZpcnN0Q2hhckluZGV4ID0gay5wYXJzZVVTaG9ydCgpLCB3LnVzTGFzdENoYXJJbmRleCA9IGsucGFyc2VVU2hvcnQoKSwgdy5zVHlwb0FzY2VuZGVyID0gay5wYXJzZVNob3J0KCksIHcuc1R5cG9EZXNjZW5kZXIgPSBrLnBhcnNlU2hvcnQoKSwgdy5zVHlwb0xpbmVHYXAgPSBrLnBhcnNlU2hvcnQoKSwgdy51c1dpbkFzY2VudCA9IGsucGFyc2VVU2hvcnQoKSwgdy51c1dpbkRlc2NlbnQgPSBrLnBhcnNlVVNob3J0KCksIDEgPD0gdy52ZXJzaW9uICYmICh3LnVsQ29kZVBhZ2VSYW5nZTEgPSBrLnBhcnNlVUxvbmcoKSwgdy51bENvZGVQYWdlUmFuZ2UyID0gay5wYXJzZVVMb25nKCkpLCAyIDw9IHcudmVyc2lvbiAmJiAody5zeEhlaWdodCA9IGsucGFyc2VTaG9ydCgpLCB3LnNDYXBIZWlnaHQgPSBrLnBhcnNlU2hvcnQoKSwgdy51c0RlZmF1bHRDaGFyID0gay5wYXJzZVVTaG9ydCgpLCB3LnVzQnJlYWtDaGFyID0gay5wYXJzZVVTaG9ydCgpLCB3LnVzTWF4Q29udGVudCA9IGsucGFyc2VVU2hvcnQoKSksIHc7XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZS5UYWJsZShcIk9TLzJcIiwgW3sgbmFtZTogXCJ2ZXJzaW9uXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAzIH0sIHsgbmFtZTogXCJ4QXZnQ2hhcldpZHRoXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVzV2VpZ2h0Q2xhc3NcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVzV2lkdGhDbGFzc1wiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiZnNUeXBlXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ5U3Vic2NyaXB0WFNpemVcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogNjUwIH0sIHsgbmFtZTogXCJ5U3Vic2NyaXB0WVNpemVcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogNjk5IH0sIHsgbmFtZTogXCJ5U3Vic2NyaXB0WE9mZnNldFwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ5U3Vic2NyaXB0WU9mZnNldFwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAxNDAgfSwgeyBuYW1lOiBcInlTdXBlcnNjcmlwdFhTaXplXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDY1MCB9LCB7IG5hbWU6IFwieVN1cGVyc2NyaXB0WVNpemVcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogNjk5IH0sIHsgbmFtZTogXCJ5U3VwZXJzY3JpcHRYT2Zmc2V0XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInlTdXBlcnNjcmlwdFlPZmZzZXRcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogNDc5IH0sIHsgbmFtZTogXCJ5U3RyaWtlb3V0U2l6ZVwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiA0OSB9LCB7IG5hbWU6IFwieVN0cmlrZW91dFBvc2l0aW9uXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDI1OCB9LCB7IG5hbWU6IFwic0ZhbWlseUNsYXNzXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImJGYW1pbHlUeXBlXCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiYlNlcmlmU3R5bGVcIiwgdHlwZTogXCJCWVRFXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJiV2VpZ2h0XCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiYlByb3BvcnRpb25cIiwgdHlwZTogXCJCWVRFXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJiQ29udHJhc3RcIiwgdHlwZTogXCJCWVRFXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJiU3Ryb2tlVmFyaWF0aW9uXCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiYkFybVN0eWxlXCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiYkxldHRlcmZvcm1cIiwgdHlwZTogXCJCWVRFXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJiTWlkbGluZVwiLCB0eXBlOiBcIkJZVEVcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImJYSGVpZ2h0XCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwidWxVbmljb2RlUmFuZ2UxXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVsVW5pY29kZVJhbmdlMlwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1bFVuaWNvZGVSYW5nZTNcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwidWxVbmljb2RlUmFuZ2U0XCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcImFjaFZlbmRJRFwiLCB0eXBlOiBcIkNIQVJBUlJBWVwiLCB2YWx1ZTogXCJYWFhYXCIgfSwgeyBuYW1lOiBcImZzU2VsZWN0aW9uXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1c0ZpcnN0Q2hhckluZGV4XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1c0xhc3RDaGFySW5kZXhcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInNUeXBvQXNjZW5kZXJcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwic1R5cG9EZXNjZW5kZXJcIiwgdHlwZTogXCJTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwic1R5cG9MaW5lR2FwXCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVzV2luQXNjZW50XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1c1dpbkRlc2NlbnRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVsQ29kZVBhZ2VSYW5nZTFcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwidWxDb2RlUGFnZVJhbmdlMlwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJzeEhlaWdodFwiLCB0eXBlOiBcIlNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJzQ2FwSGVpZ2h0XCIsIHR5cGU6IFwiU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVzRGVmYXVsdENoYXJcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcInVzQnJlYWtDaGFyXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1c01heENvbnRleHRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDAgfV0sIGQpO1xuICAgICAgICAgIH0sIHVuaWNvZGVSYW5nZXM6IEp0LCBnZXRVbmljb2RlUmFuZ2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgSnQubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHcgPSBKdFt2XTtcbiAgICAgICAgICAgICAgaWYgKGQgPj0gdy5iZWdpbiAmJiBkIDwgdy5lbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSB9LCBMciA9IHsgcGFyc2U6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0ge30sIGsgPSBuZXcgd2UuUGFyc2VyKGQsIHYpO1xuICAgICAgICAgICAgc3dpdGNoICh3LnZlcnNpb24gPSBrLnBhcnNlVmVyc2lvbigpLCB3Lml0YWxpY0FuZ2xlID0gay5wYXJzZUZpeGVkKCksIHcudW5kZXJsaW5lUG9zaXRpb24gPSBrLnBhcnNlU2hvcnQoKSwgdy51bmRlcmxpbmVUaGlja25lc3MgPSBrLnBhcnNlU2hvcnQoKSwgdy5pc0ZpeGVkUGl0Y2ggPSBrLnBhcnNlVUxvbmcoKSwgdy5taW5NZW1UeXBlNDIgPSBrLnBhcnNlVUxvbmcoKSwgdy5tYXhNZW1UeXBlNDIgPSBrLnBhcnNlVUxvbmcoKSwgdy5taW5NZW1UeXBlMSA9IGsucGFyc2VVTG9uZygpLCB3Lm1heE1lbVR5cGUxID0gay5wYXJzZVVMb25nKCksIHcudmVyc2lvbikge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdy5uYW1lcyA9IHBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB3Lm51bWJlck9mR2x5cGhzID0gay5wYXJzZVVTaG9ydCgpLCB3LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHcubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgdy5udW1iZXJPZkdseXBoczsgSSsrKVxuICAgICAgICAgICAgICAgICAgdy5nbHlwaE5hbWVJbmRleFtJXSA9IGsucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB3Lm5hbWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgTiwgeiA9IDA7IHogPCB3Lm51bWJlck9mR2x5cGhzOyB6KyspXG4gICAgICAgICAgICAgICAgICB3LmdseXBoTmFtZUluZGV4W3pdID49IHBlLmxlbmd0aCAmJiAoTiA9IGsucGFyc2VDaGFyKCksIHcubmFtZXMucHVzaChrLnBhcnNlU3RyaW5nKE4pKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgICAgIHcubnVtYmVyT2ZHbHlwaHMgPSBrLnBhcnNlVVNob3J0KCksIHcub2Zmc2V0ID0gbmV3IEFycmF5KHcubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFEgPSAwOyBRIDwgdy5udW1iZXJPZkdseXBoczsgUSsrKVxuICAgICAgICAgICAgICAgICAgdy5vZmZzZXRbUV0gPSBrLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lLlRhYmxlKFwicG9zdFwiLCBbeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJGSVhFRFwiLCB2YWx1ZTogMTk2NjA4IH0sIHsgbmFtZTogXCJpdGFsaWNBbmdsZVwiLCB0eXBlOiBcIkZJWEVEXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1bmRlcmxpbmVQb3NpdGlvblwiLCB0eXBlOiBcIkZXT1JEXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJ1bmRlcmxpbmVUaGlja25lc3NcIiwgdHlwZTogXCJGV09SRFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiaXNGaXhlZFBpdGNoXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IDAgfSwgeyBuYW1lOiBcIm1pbk1lbVR5cGU0MlwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJtYXhNZW1UeXBlNDJcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibWluTWVtVHlwZTFcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibWF4TWVtVHlwZTFcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9XSk7XG4gICAgICAgICAgfSB9LCBZdCA9IG5ldyBBcnJheSg5KSwgYXIgPSAoWXRbMV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LCB2ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHYgPT09IDEgPyB7IHN1YnN0Rm9ybWF0OiAxLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCBkZWx0YUdseXBoSWQ6IHRoaXMucGFyc2VVU2hvcnQoKSB9IDogdiA9PT0gMiA/IHsgc3Vic3RGb3JtYXQ6IDIsIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSksIHN1YnN0aXR1dGU6IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKSB9IDogdm9pZCBPLmFzc2VydCghMSwgXCIweFwiICsgZC50b1N0cmluZygxNikgKyBcIjogbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuXCIpO1xuICAgICAgICAgIH0sIFl0WzJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KGQgPT09IDEsIFwiR1NVQiBNdWx0aXBsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxXCIpLCB7IHN1YnN0Rm9ybWF0OiBkLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpIH07XG4gICAgICAgICAgfSwgWXRbM10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIE8uYXJndW1lbnQoZCA9PT0gMSwgXCJHU1VCIEFsdGVybmF0ZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxXCIpLCB7IHN1YnN0Rm9ybWF0OiBkLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKSB9O1xuICAgICAgICAgIH0sIFl0WzRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KGQgPT09IDEsIFwiR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDFcIiksIHsgc3Vic3RGb3JtYXQ6IGQsIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSksIGxpZ2F0dXJlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBsaWdHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLCBjb21wb25lbnRzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlVVNob3J0KCkgLSAxKSB9O1xuICAgICAgICAgICAgfSkgfTtcbiAgICAgICAgICB9LCB7IHNlcXVlbmNlSW5kZXg6IHZlLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiB2ZS51U2hvcnQgfSk7XG4gICAgICAgICAgWXRbNV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkLCB2LCB3ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LCBrID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDEgPyB7IHN1YnN0Rm9ybWF0OiBrLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgSSA9IHRoaXMucGFyc2VVU2hvcnQoKSwgTiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KEkgLSAxKSwgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QoTiwgYXIpIH07XG4gICAgICAgICAgICB9KSB9IDogayA9PT0gMiA/IHsgc3Vic3RGb3JtYXQ6IGssIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSksIGNsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jbGFzc0RlZiksIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgSSA9IHRoaXMucGFyc2VVU2hvcnQoKSwgTiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoSSAtIDEpLCBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChOLCBhcikgfTtcbiAgICAgICAgICAgIH0pIH0gOiBrID09PSAzID8gKGQgPSB0aGlzLnBhcnNlVVNob3J0KCksIHYgPSB0aGlzLnBhcnNlVVNob3J0KCksIHsgc3Vic3RGb3JtYXQ6IGssIGNvdmVyYWdlczogdGhpcy5wYXJzZUxpc3QoZCwgdmUucG9pbnRlcih2ZS5jb3ZlcmFnZSkpLCBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh2LCBhcikgfSkgOiB2b2lkIE8uYXNzZXJ0KCExLCBcIjB4XCIgKyB3LnRvU3RyaW5nKDE2KSArIFwiOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy5cIik7XG4gICAgICAgICAgfSwgWXRbNl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LCB2ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHYgPT09IDEgPyB7IHN1YnN0Rm9ybWF0OiAxLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCBjaGFpblJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSwgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSwgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QoYXIpIH07XG4gICAgICAgICAgICB9KSB9IDogdiA9PT0gMiA/IHsgc3Vic3RGb3JtYXQ6IDIsIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSksIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jbGFzc0RlZiksIGlucHV0Q2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKHZlLmNsYXNzRGVmKSwgbG9va2FoZWFkQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKHZlLmNsYXNzRGVmKSwgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLCBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGFyKSB9O1xuICAgICAgICAgICAgfSkgfSA6IHYgPT09IDMgPyB7IHN1YnN0Rm9ybWF0OiAzLCBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QodmUucG9pbnRlcih2ZS5jb3ZlcmFnZSkpLCBpbnB1dENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdCh2ZS5wb2ludGVyKHZlLmNvdmVyYWdlKSksIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdCh2ZS5wb2ludGVyKHZlLmNvdmVyYWdlKSksIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGFyKSB9IDogdm9pZCBPLmFzc2VydCghMSwgXCIweFwiICsgZC50b1N0cmluZygxNikgKyBcIjogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuXCIpO1xuICAgICAgICAgIH0sIFl0WzddID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMucGFyc2VVU2hvcnQoKSwgZCA9IChPLmFyZ3VtZW50KGQgPT09IDEsIFwiR1NVQiBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMVwiKSwgdGhpcy5wYXJzZVVTaG9ydCgpKSwgdiA9IG5ldyB2ZSh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3Vic3RGb3JtYXQ6IDEsIGxvb2t1cFR5cGU6IGQsIGV4dGVuc2lvbjogWXRbZF0uY2FsbCh2KSB9O1xuICAgICAgICAgIH0sIFl0WzhdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBPLmFyZ3VtZW50KGQgPT09IDEsIFwiR1NVQiBSZXZlcnNlIENoYWluaW5nIENvbnRleHR1YWwgU2luZ2xlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDFcIiksIHsgc3Vic3RGb3JtYXQ6IGQsIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSksIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdCh2ZS5wb2ludGVyKHZlLmNvdmVyYWdlKSksIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdCh2ZS5wb2ludGVyKHZlLmNvdmVyYWdlKSksIHN1YnN0aXR1dGVzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgeXIgPSBuZXcgQXJyYXkoOSk7XG4gICAgICAgICAgeXJbMV0gPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5zdWJzdEZvcm1hdCA9PT0gMSA/IG5ldyBNZS5UYWJsZShcInN1YnN0aXR1dGlvblRhYmxlXCIsIFt7IG5hbWU6IFwic3Vic3RGb3JtYXRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDEgfSwgeyBuYW1lOiBcImNvdmVyYWdlXCIsIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IG5ldyBNZS5Db3ZlcmFnZShkLmNvdmVyYWdlKSB9LCB7IG5hbWU6IFwiZGVsdGFHbHlwaElEXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiBkLmRlbHRhR2x5cGhJZCB9XSkgOiBuZXcgTWUuVGFibGUoXCJzdWJzdGl0dXRpb25UYWJsZVwiLCBbeyBuYW1lOiBcInN1YnN0Rm9ybWF0XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAyIH0sIHsgbmFtZTogXCJjb3ZlcmFnZVwiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgTWUuQ292ZXJhZ2UoZC5jb3ZlcmFnZSkgfV0uY29uY2F0KE1lLnVzaG9ydExpc3QoXCJzdWJzdGl0dXRlXCIsIGQuc3Vic3RpdHV0ZSkpKTtcbiAgICAgICAgICB9LCB5clszXSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBPLmFzc2VydChkLnN1YnN0Rm9ybWF0ID09PSAxLCBcIkxvb2t1cCB0eXBlIDMgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLlwiKSwgbmV3IE1lLlRhYmxlKFwic3Vic3RpdHV0aW9uVGFibGVcIiwgW3sgbmFtZTogXCJzdWJzdEZvcm1hdFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMSB9LCB7IG5hbWU6IFwiY292ZXJhZ2VcIiwgdHlwZTogXCJUQUJMRVwiLCB2YWx1ZTogbmV3IE1lLkNvdmVyYWdlKGQuY292ZXJhZ2UpIH1dLmNvbmNhdChNZS50YWJsZUxpc3QoXCJhbHRTZXRcIiwgZC5hbHRlcm5hdGVTZXRzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTWUuVGFibGUoXCJhbHRlcm5hdGVTZXRUYWJsZVwiLCBNZS51c2hvcnRMaXN0KFwiYWx0ZXJuYXRlXCIsIHYpKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfSwgeXJbNF0gPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5hc3NlcnQoZC5zdWJzdEZvcm1hdCA9PT0gMSwgXCJMb29rdXAgdHlwZSA0IHN1YnN0Rm9ybWF0IG11c3QgYmUgMS5cIiksIG5ldyBNZS5UYWJsZShcInN1YnN0aXR1dGlvblRhYmxlXCIsIFt7IG5hbWU6IFwic3Vic3RGb3JtYXRcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDEgfSwgeyBuYW1lOiBcImNvdmVyYWdlXCIsIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IG5ldyBNZS5Db3ZlcmFnZShkLmNvdmVyYWdlKSB9XS5jb25jYXQoTWUudGFibGVMaXN0KFwibGlnU2V0XCIsIGQubGlnYXR1cmVTZXRzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTWUuVGFibGUoXCJsaWdhdHVyZVNldFRhYmxlXCIsIE1lLnRhYmxlTGlzdChcImxpZ2F0dXJlXCIsIHYsIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lLlRhYmxlKFwibGlnYXR1cmVUYWJsZVwiLCBbeyBuYW1lOiBcImxpZ0dseXBoXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiB3LmxpZ0dseXBoIH1dLmNvbmNhdChNZS51c2hvcnRMaXN0KFwiY29tcG9uZW50XCIsIHcuY29tcG9uZW50cywgdy5jb21wb25lbnRzLmxlbmd0aCArIDEpKSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgUnIgPSB7IHBhcnNlOiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gdiA9IChkID0gbmV3IHZlKGQsIHYgPSB2IHx8IDApKS5wYXJzZVZlcnNpb24oMSksIE8uYXJndW1lbnQodiA9PT0gMSB8fCB2ID09PSAxLjEsIFwiVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLlwiKSwgdiA9PT0gMSA/IHsgdmVyc2lvbjogdiwgc2NyaXB0czogZC5wYXJzZVNjcmlwdExpc3QoKSwgZmVhdHVyZXM6IGQucGFyc2VGZWF0dXJlTGlzdCgpLCBsb29rdXBzOiBkLnBhcnNlTG9va3VwTGlzdChZdCkgfSA6IHsgdmVyc2lvbjogdiwgc2NyaXB0czogZC5wYXJzZVNjcmlwdExpc3QoKSwgZmVhdHVyZXM6IGQucGFyc2VGZWF0dXJlTGlzdCgpLCBsb29rdXBzOiBkLnBhcnNlTG9va3VwTGlzdChZdCksIHZhcmlhdGlvbnM6IGQucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKSB9O1xuICAgICAgICAgIH0sIG1ha2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWUuVGFibGUoXCJHU1VCXCIsIFt7IG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiA2NTUzNiB9LCB7IG5hbWU6IFwic2NyaXB0c1wiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgTWUuU2NyaXB0TGlzdChkLnNjcmlwdHMpIH0sIHsgbmFtZTogXCJmZWF0dXJlc1wiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgTWUuRmVhdHVyZUxpc3QoZC5mZWF0dXJlcykgfSwgeyBuYW1lOiBcImxvb2t1cHNcIiwgdHlwZTogXCJUQUJMRVwiLCB2YWx1ZTogbmV3IE1lLkxvb2t1cExpc3QoZC5sb29rdXBzLCB5cikgfV0pO1xuICAgICAgICAgIH0gfSwgSXIgPSB7IHBhcnNlOiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gbmV3IHdlLlBhcnNlcihkLCB2KSwgayA9IHcucGFyc2VVTG9uZygpLCBJID0gKE8uYXJndW1lbnQoayA9PT0gMSwgXCJVbnN1cHBvcnRlZCBNRVRBIHRhYmxlIHZlcnNpb24uXCIpLCB3LnBhcnNlVUxvbmcoKSwgdy5wYXJzZVVMb25nKCksIHcucGFyc2VVTG9uZygpKSwgTiA9IHt9LCB6ID0gMDsgeiA8IEk7IHorKykge1xuICAgICAgICAgICAgICB2YXIgUSA9IHcucGFyc2VUYWcoKSwgb2UgPSB3LnBhcnNlVUxvbmcoKSwgc2UgPSB3LnBhcnNlVUxvbmcoKSwgb2UgPSBELlVURjgoZCwgdiArIG9lLCBzZSk7XG4gICAgICAgICAgICAgIE5bUV0gPSBvZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOO1xuICAgICAgICAgIH0sIG1ha2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2LCB3ID0gT2JqZWN0LmtleXMoZCkubGVuZ3RoLCBrID0gXCJcIiwgSSA9IDE2ICsgMTIgKiB3LCBOID0gbmV3IE1lLlRhYmxlKFwibWV0YVwiLCBbeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMSB9LCB7IG5hbWU6IFwiZmxhZ3NcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwib2Zmc2V0XCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IEkgfSwgeyBuYW1lOiBcIm51bVRhZ3NcIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogdyB9XSk7XG4gICAgICAgICAgICBmb3IgKHYgaW4gZCkge1xuICAgICAgICAgICAgICB2YXIgeiA9IGsubGVuZ3RoO1xuICAgICAgICAgICAgICBrICs9IGRbdl0sIE4uZmllbGRzLnB1c2goeyBuYW1lOiBcInRhZyBcIiArIHYsIHR5cGU6IFwiVEFHXCIsIHZhbHVlOiB2IH0pLCBOLmZpZWxkcy5wdXNoKHsgbmFtZTogXCJvZmZzZXQgXCIgKyB2LCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiBJICsgeiB9KSwgTi5maWVsZHMucHVzaCh7IG5hbWU6IFwibGVuZ3RoIFwiICsgdiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogZFt2XS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTi5maWVsZHMucHVzaCh7IG5hbWU6IFwic3RyaW5nUG9vbFwiLCB0eXBlOiBcIkNIQVJBUlJBWVwiLCB2YWx1ZTogayB9KSwgTjtcbiAgICAgICAgICB9IH07XG4gICAgICAgICAgZnVuY3Rpb24gRHIoZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKGQpIC8gTWF0aC5sb2coMikgfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBTcihkKSB7XG4gICAgICAgICAgICBmb3IgKDsgZC5sZW5ndGggJSA0ICE9IDA7IClcbiAgICAgICAgICAgICAgZC5wdXNoKDApO1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IDAsIHcgPSAwOyB3IDwgZC5sZW5ndGg7IHcgKz0gNClcbiAgICAgICAgICAgICAgdiArPSAoZFt3XSA8PCAyNCkgKyAoZFt3ICsgMV0gPDwgMTYpICsgKGRbdyArIDJdIDw8IDgpICsgZFt3ICsgM107XG4gICAgICAgICAgICByZXR1cm4gdiAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEZyKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWUuUmVjb3JkKFwiVGFibGUgUmVjb3JkXCIsIFt7IG5hbWU6IFwidGFnXCIsIHR5cGU6IFwiVEFHXCIsIHZhbHVlOiBkICE9PSB2b2lkIDAgPyBkIDogXCJcIiB9LCB7IG5hbWU6IFwiY2hlY2tTdW1cIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogdiAhPT0gdm9pZCAwID8gdiA6IDAgfSwgeyBuYW1lOiBcIm9mZnNldFwiLCB0eXBlOiBcIlVMT05HXCIsIHZhbHVlOiB3ICE9PSB2b2lkIDAgPyB3IDogMCB9LCB7IG5hbWU6IFwibGVuZ3RoXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IGsgIT09IHZvaWQgMCA/IGsgOiAwIH1dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVXIoZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IG5ldyBNZS5UYWJsZShcInNmbnRcIiwgW3sgbmFtZTogXCJ2ZXJzaW9uXCIsIHR5cGU6IFwiVEFHXCIsIHZhbHVlOiBcIk9UVE9cIiB9LCB7IG5hbWU6IFwibnVtVGFibGVzXCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiAwIH0sIHsgbmFtZTogXCJzZWFyY2hSYW5nZVwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiZW50cnlTZWxlY3RvclwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwicmFuZ2VTaGlmdFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9XSksIHcgPSAodi50YWJsZXMgPSBkLCB2Lm51bVRhYmxlcyA9IGQubGVuZ3RoLCBNYXRoLnBvdygyLCBEcih2Lm51bVRhYmxlcykpKSwgayA9ICh2LnNlYXJjaFJhbmdlID0gMTYgKiB3LCB2LmVudHJ5U2VsZWN0b3IgPSBEcih3KSwgdi5yYW5nZVNoaWZ0ID0gMTYgKiB2Lm51bVRhYmxlcyAtIHYuc2VhcmNoUmFuZ2UsIFtdKSwgSSA9IFtdLCBOID0gdi5zaXplT2YoKSArIEZyKCkuc2l6ZU9mKCkgKiB2Lm51bVRhYmxlczsgTiAlIDQgIT0gMDsgKVxuICAgICAgICAgICAgICBOICs9IDEsIEkucHVzaCh7IG5hbWU6IFwicGFkZGluZ1wiLCB0eXBlOiBcIkJZVEVcIiwgdmFsdWU6IDAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGQubGVuZ3RoOyB6ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIFEgPSBkW3pdLCBzZSA9IChPLmFyZ3VtZW50KFEudGFibGVOYW1lLmxlbmd0aCA9PT0gNCwgXCJUYWJsZSBuYW1lXCIgKyBRLnRhYmxlTmFtZSArIFwiIGlzIGludmFsaWQuXCIpLCBRLnNpemVPZigpKSwgb2UgPSBGcihRLnRhYmxlTmFtZSwgU3IoUS5lbmNvZGUoKSksIE4sIHNlKTtcbiAgICAgICAgICAgICAgZm9yIChrLnB1c2goeyBuYW1lOiBvZS50YWcgKyBcIiBUYWJsZSBSZWNvcmRcIiwgdHlwZTogXCJSRUNPUkRcIiwgdmFsdWU6IG9lIH0pLCBJLnB1c2goeyBuYW1lOiBRLnRhYmxlTmFtZSArIFwiIHRhYmxlXCIsIHR5cGU6IFwiUkVDT1JEXCIsIHZhbHVlOiBRIH0pLCBOICs9IHNlLCBPLmFyZ3VtZW50KCFpc05hTihOKSwgXCJTb21ldGhpbmcgd2VudCB3cm9uZyBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0LlwiKTsgTiAlIDQgIT0gMDsgKVxuICAgICAgICAgICAgICAgIE4gKz0gMSwgSS5wdXNoKHsgbmFtZTogXCJwYWRkaW5nXCIsIHR5cGU6IFwiQllURVwiLCB2YWx1ZTogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrLnNvcnQoZnVuY3Rpb24oeWUsIFNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5ZS52YWx1ZS50YWcgPiBTZS52YWx1ZS50YWcgPyAxIDogLTE7XG4gICAgICAgICAgICB9KSwgdi5maWVsZHMgPSB2LmZpZWxkcy5jb25jYXQoayksIHYuZmllbGRzID0gdi5maWVsZHMuY29uY2F0KEkpLCB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBOcihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHYubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSBkLmNoYXJUb0dseXBoSW5kZXgodltrXSk7XG4gICAgICAgICAgICAgIGlmICgwIDwgSSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5nbHlwaHMuZ2V0KEkpLmdldE1ldHJpY3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgU24gPSB7IG1ha2U6IFVyLCBmb250VG9UYWJsZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiwgdyA9IFtdLCBrID0gW10sIEkgPSBbXSwgTiA9IFtdLCB6ID0gW10sIFEgPSBbXSwgc2UgPSBbXSwgb2UgPSAwLCB5ZSA9IDAsIFNlID0gMCwgYmUgPSAwLCBkZSA9IDAsIEllID0gMDsgSWUgPCBkLmdseXBocy5sZW5ndGg7IEllICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGtlID0gZC5nbHlwaHMuZ2V0KEllKSwgQWUgPSAwIHwga2UudW5pY29kZTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKGtlLmFkdmFuY2VXaWR0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2x5cGggXCIgKyBrZS5uYW1lICsgXCIgKFwiICsgSWUgKyBcIik6IGFkdmFuY2VXaWR0aCBpcyBub3QgYSBudW1iZXIuXCIpO1xuICAgICAgICAgICAgICAoQWUgPCB2IHx8IHYgPT09IHZvaWQgMCkgJiYgMCA8IEFlICYmICh2ID0gQWUpLCBvZSA8IEFlICYmIChvZSA9IEFlKTtcbiAgICAgICAgICAgICAgdmFyIEFlID0gQnQuZ2V0VW5pY29kZVJhbmdlKEFlKTtcbiAgICAgICAgICAgICAgaWYgKEFlIDwgMzIpXG4gICAgICAgICAgICAgICAgeWUgfD0gMSA8PCBBZTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoQWUgPCA2NClcbiAgICAgICAgICAgICAgICBTZSB8PSAxIDw8IEFlIC0gMzI7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKEFlIDwgOTYpXG4gICAgICAgICAgICAgICAgYmUgfD0gMSA8PCBBZSAtIDY0O1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIShBZSA8IDEyMykpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmljb2RlIHJhbmdlcyBiaXRzID4gMTIzIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2VcIik7XG4gICAgICAgICAgICAgICAgZGUgfD0gMSA8PCBBZSAtIDk2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtlLm5hbWUgIT09IFwiLm5vdGRlZlwiICYmIChBZSA9IGtlLmdldE1ldHJpY3MoKSwgdy5wdXNoKEFlLnhNaW4pLCBrLnB1c2goQWUueU1pbiksIEkucHVzaChBZS54TWF4KSwgTi5wdXNoKEFlLnlNYXgpLCBRLnB1c2goQWUubGVmdFNpZGVCZWFyaW5nKSwgc2UucHVzaChBZS5yaWdodFNpZGVCZWFyaW5nKSwgei5wdXNoKGtlLmFkdmFuY2VXaWR0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFRlLCBFZSA9IHsgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgdyksIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIGspLCB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCBJKSwgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgTiksIGFkdmFuY2VXaWR0aE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeiksIGFkdmFuY2VXaWR0aEF2ZzogZnVuY3Rpb24oR3QpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZnIgPSAwLCB1ciA9IDA7IHVyIDwgR3QubGVuZ3RoOyB1ciArPSAxKVxuICAgICAgICAgICAgICAgIGZyICs9IEd0W3VyXTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyIC8gR3QubGVuZ3RoO1xuICAgICAgICAgICAgfSh6KSwgbWluTGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCBRKSwgbWF4TGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1heC5hcHBseShudWxsLCBRKSwgbWluUmlnaHRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgc2UpIH0sICRlID0gKEVlLmFzY2VuZGVyID0gZC5hc2NlbmRlciwgRWUuZGVzY2VuZGVyID0gZC5kZXNjZW5kZXIsIHB0Lm1ha2UoeyBmbGFnczogMywgdW5pdHNQZXJFbTogZC51bml0c1BlckVtLCB4TWluOiBFZS54TWluLCB5TWluOiBFZS55TWluLCB4TWF4OiBFZS54TWF4LCB5TWF4OiBFZS55TWF4LCBsb3dlc3RSZWNQUEVNOiAzLCBjcmVhdGVkVGltZXN0YW1wOiBkLmNyZWF0ZWRUaW1lc3RhbXAgfSkpLCBsdCA9IGllLm1ha2UoeyBhc2NlbmRlcjogRWUuYXNjZW5kZXIsIGRlc2NlbmRlcjogRWUuZGVzY2VuZGVyLCBhZHZhbmNlV2lkdGhNYXg6IEVlLmFkdmFuY2VXaWR0aE1heCwgbWluTGVmdFNpZGVCZWFyaW5nOiBFZS5taW5MZWZ0U2lkZUJlYXJpbmcsIG1pblJpZ2h0U2lkZUJlYXJpbmc6IEVlLm1pblJpZ2h0U2lkZUJlYXJpbmcsIHhNYXhFeHRlbnQ6IEVlLm1heExlZnRTaWRlQmVhcmluZyArIChFZS54TWF4IC0gRWUueE1pbiksIG51bWJlck9mSE1ldHJpY3M6IGQuZ2x5cGhzLmxlbmd0aCB9KSwgZXQgPSBMZS5tYWtlKGQuZ2x5cGhzLmxlbmd0aCksIHR0ID0gQnQubWFrZSh7IHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoRWUuYWR2YW5jZVdpZHRoQXZnKSwgdXNXZWlnaHRDbGFzczogZC50YWJsZXMub3MyLnVzV2VpZ2h0Q2xhc3MsIHVzV2lkdGhDbGFzczogZC50YWJsZXMub3MyLnVzV2lkdGhDbGFzcywgdXNGaXJzdENoYXJJbmRleDogdiwgdXNMYXN0Q2hhckluZGV4OiBvZSwgdWxVbmljb2RlUmFuZ2UxOiB5ZSwgdWxVbmljb2RlUmFuZ2UyOiBTZSwgdWxVbmljb2RlUmFuZ2UzOiBiZSwgdWxVbmljb2RlUmFuZ2U0OiBkZSwgZnNTZWxlY3Rpb246IGQudGFibGVzLm9zMi5mc1NlbGVjdGlvbiwgc1R5cG9Bc2NlbmRlcjogRWUuYXNjZW5kZXIsIHNUeXBvRGVzY2VuZGVyOiBFZS5kZXNjZW5kZXIsIHNUeXBvTGluZUdhcDogMCwgdXNXaW5Bc2NlbnQ6IEVlLnlNYXgsIHVzV2luRGVzY2VudDogTWF0aC5hYnMoRWUueU1pbiksIHVsQ29kZVBhZ2VSYW5nZTE6IDEsIHN4SGVpZ2h0OiBOcihkLCBcInh5dndcIiwgeyB5TWF4OiBNYXRoLnJvdW5kKEVlLmFzY2VuZGVyIC8gMikgfSkueU1heCwgc0NhcEhlaWdodDogTnIoZCwgXCJISUtMRUZKTU5UWkJEUFJBR09RU1VWV1hZXCIsIEVlKS55TWF4LCB1c0RlZmF1bHRDaGFyOiBkLmhhc0NoYXIoXCIgXCIpID8gMzIgOiAwLCB1c0JyZWFrQ2hhcjogZC5oYXNDaGFyKFwiIFwiKSA/IDMyIDogMCB9KSwgZHQgPSBPZS5tYWtlKGQuZ2x5cGhzKSwgd3QgPSBaLm1ha2UoZC5nbHlwaHMpLCBTdCA9IGQuZ2V0RW5nbGlzaE5hbWUoXCJmb250RmFtaWx5XCIpLCB2dCA9IGQuZ2V0RW5nbGlzaE5hbWUoXCJmb250U3ViZmFtaWx5XCIpLCB4dCA9IFN0ICsgXCIgXCIgKyB2dCwgT3QgPSAoT3QgPSBkLmdldEVuZ2xpc2hOYW1lKFwicG9zdFNjcmlwdE5hbWVcIikpIHx8IFN0LnJlcGxhY2UoL1xccy9nLCBcIlwiKSArIFwiLVwiICsgdnQsIFJ0ID0ge307XG4gICAgICAgICAgICBmb3IgKFRlIGluIGQubmFtZXMpXG4gICAgICAgICAgICAgIFJ0W1RlXSA9IGQubmFtZXNbVGVdO1xuICAgICAgICAgICAgUnQudW5pcXVlSUQgfHwgKFJ0LnVuaXF1ZUlEID0geyBlbjogZC5nZXRFbmdsaXNoTmFtZShcIm1hbnVmYWN0dXJlclwiKSArIFwiOlwiICsgeHQgfSksIFJ0LnBvc3RTY3JpcHROYW1lIHx8IChSdC5wb3N0U2NyaXB0TmFtZSA9IHsgZW46IE90IH0pLCBSdC5wcmVmZXJyZWRGYW1pbHkgfHwgKFJ0LnByZWZlcnJlZEZhbWlseSA9IGQubmFtZXMuZm9udEZhbWlseSksIFJ0LnByZWZlcnJlZFN1YmZhbWlseSB8fCAoUnQucHJlZmVycmVkU3ViZmFtaWx5ID0gZC5uYW1lcy5mb250U3ViZmFtaWx5KTtcbiAgICAgICAgICAgIHZhciBXdCA9IFtdLCBIdCA9IFh0Lm1ha2UoUnQsIFd0KSwgV3QgPSAwIDwgV3QubGVuZ3RoID8gR2UubWFrZShXdCkgOiB2b2lkIDAsIFF0ID0gTHIubWFrZSgpLCB4dCA9IGZ0Lm1ha2UoZC5nbHlwaHMsIHsgdmVyc2lvbjogZC5nZXRFbmdsaXNoTmFtZShcInZlcnNpb25cIiksIGZ1bGxOYW1lOiB4dCwgZmFtaWx5TmFtZTogU3QsIHdlaWdodE5hbWU6IHZ0LCBwb3N0U2NyaXB0TmFtZTogT3QsIHVuaXRzUGVyRW06IGQudW5pdHNQZXJFbSwgZm9udEJCb3g6IFswLCBFZS55TWluLCBFZS5hc2NlbmRlciwgRWUuYWR2YW5jZVdpZHRoTWF4XSB9KSwgU3QgPSBkLm1ldGFzICYmIDAgPCBPYmplY3Qua2V5cyhkLm1ldGFzKS5sZW5ndGggPyBJci5tYWtlKGQubWV0YXMpIDogdm9pZCAwLCB2dCA9IFskZSwgbHQsIGV0LCB0dCwgSHQsIHd0LCBRdCwgeHQsIGR0XTtcbiAgICAgICAgICAgIFd0ICYmIHZ0LnB1c2goV3QpLCBkLnRhYmxlcy5nc3ViICYmIHZ0LnB1c2goUnIubWFrZShkLnRhYmxlcy5nc3ViKSksIFN0ICYmIHZ0LnB1c2goU3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgcXQgPSBTcigoT3QgPSBVcih2dCkpLmVuY29kZSgpKSwga3QgPSBPdC5maWVsZHMsIHp0ID0gITEsIFR0ID0gMDsgVHQgPCBrdC5sZW5ndGg7IFR0ICs9IDEpXG4gICAgICAgICAgICAgIGlmIChrdFtUdF0ubmFtZSA9PT0gXCJoZWFkIHRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBrdFtUdF0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMjk4MTE0NjU1NCAtIHF0LCB6dCA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoenQpXG4gICAgICAgICAgICAgIHJldHVybiBPdDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuXCIpO1xuICAgICAgICAgIH0sIGNvbXB1dGVDaGVja1N1bTogU3IgfTtcbiAgICAgICAgICBmdW5jdGlvbiBUcihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMCwgayA9IGQubGVuZ3RoIC0gMTsgdyA8PSBrOyApIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB3ICsgayA+Pj4gMSwgTiA9IGRbSV0udGFnO1xuICAgICAgICAgICAgICBpZiAoTiA9PT0gdilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgICAgTiA8IHYgPyB3ID0gMSArIEkgOiBrID0gSSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLXcgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBCcihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMCwgayA9IGQubGVuZ3RoIC0gMTsgdyA8PSBrOyApIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB3ICsgayA+Pj4gMSwgTiA9IGRbSV07XG4gICAgICAgICAgICAgIGlmIChOID09PSB2KVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgICBOIDwgdiA/IHcgPSAxICsgSSA6IGsgPSBJIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtdyAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEdyKGQsIHYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwLCBrID0gZC5sZW5ndGggLSAxOyB3IDw9IGs7ICkge1xuICAgICAgICAgICAgICB2YXIgSSwgTiA9IHcgKyBrID4+PiAxLCB6ID0gKEkgPSBkW05dKS5zdGFydDtcbiAgICAgICAgICAgICAgaWYgKHogPT09IHYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICAgIHogPCB2ID8gdyA9IDEgKyBOIDogayA9IE4gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPCB3KVxuICAgICAgICAgICAgICByZXR1cm4gdiA+IChJID0gZFt3IC0gMV0pLmVuZCA/IDAgOiBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBncihkLCB2KSB7XG4gICAgICAgICAgICB0aGlzLmZvbnQgPSBkLCB0aGlzLnRhYmxlTmFtZSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHZyKGQpIHtcbiAgICAgICAgICAgIGdyLmNhbGwodGhpcywgZCwgXCJncG9zXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiAkdChkKSB7XG4gICAgICAgICAgICBnci5jYWxsKHRoaXMsIGQsIFwiZ3N1YlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVnIoZCwgdiwgdykge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IGQuc3VidGFibGVzLCBJID0gMDsgSSA8IGsubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgICAgICAgdmFyIE4gPSBrW0ldO1xuICAgICAgICAgICAgICBpZiAoTi5zdWJzdEZvcm1hdCA9PT0gdilcbiAgICAgICAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3KVxuICAgICAgICAgICAgICByZXR1cm4gay5wdXNoKHcpLCB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB6cihkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gbmV3IEFycmF5QnVmZmVyKGQubGVuZ3RoKSwgdyA9IG5ldyBVaW50OEFycmF5KHYpLCBrID0gMDsgayA8IGQubGVuZ3RoOyArK2spXG4gICAgICAgICAgICAgIHdba10gPSBkW2tdO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGlyKGQsIHYpIHtcbiAgICAgICAgICAgIGlmICghZClcbiAgICAgICAgICAgICAgdGhyb3cgdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSHIoZCwgdiwgdywgaywgSSkge1xuICAgICAgICAgICAgdmFyIE4gPSAwIDwgKHYgJiBrKSA/IChOID0gZC5wYXJzZUJ5dGUoKSwgdyArIChOID0gdiAmIEkgPyBOIDogLU4pKSA6IDAgPCAodiAmIEkpID8gdyA6IHcgKyBkLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBUbihkLCB2LCB3KSB7XG4gICAgICAgICAgICB2YXIgaywgSSA9IG5ldyB3ZS5QYXJzZXIodiwgdyk7XG4gICAgICAgICAgICBpZiAoZC5udW1iZXJPZkNvbnRvdXJzID0gSS5wYXJzZVNob3J0KCksIGQuX3hNaW4gPSBJLnBhcnNlU2hvcnQoKSwgZC5feU1pbiA9IEkucGFyc2VTaG9ydCgpLCBkLl94TWF4ID0gSS5wYXJzZVNob3J0KCksIGQuX3lNYXggPSBJLnBhcnNlU2hvcnQoKSwgMCA8IGQubnVtYmVyT2ZDb250b3Vycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBOID0gZC5lbmRQb2ludEluZGljZXMgPSBbXSwgeiA9IDA7IHogPCBkLm51bWJlck9mQ29udG91cnM7IHogKz0gMSlcbiAgICAgICAgICAgICAgICBOLnB1c2goSS5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgICAgICAgZC5pbnN0cnVjdGlvbkxlbmd0aCA9IEkucGFyc2VVU2hvcnQoKSwgZC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgUSA9IDA7IFEgPCBkLmluc3RydWN0aW9uTGVuZ3RoOyBRICs9IDEpXG4gICAgICAgICAgICAgICAgZC5pbnN0cnVjdGlvbnMucHVzaChJLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2UgPSBOW04ubGVuZ3RoIC0gMV0gKyAxLCBvZSA9IFtdLCB5ZSA9IDA7IHllIDwgc2U7IHllICs9IDEpXG4gICAgICAgICAgICAgICAgaWYgKGsgPSBJLnBhcnNlQnl0ZSgpLCBvZS5wdXNoKGspLCAwIDwgKDggJiBrKSlcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIFNlID0gSS5wYXJzZUJ5dGUoKSwgYmUgPSAwOyBiZSA8IFNlOyBiZSArPSAxKVxuICAgICAgICAgICAgICAgICAgICBvZS5wdXNoKGspLCB5ZSArPSAxO1xuICAgICAgICAgICAgICBpZiAoTy5hcmd1bWVudChvZS5sZW5ndGggPT09IHNlLCBcIkJhZCBmbGFncy5cIiksIDAgPCBOLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBkZSwgSWUgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHNlKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZSA9IDA7IGtlIDwgc2U7IGtlICs9IDEpXG4gICAgICAgICAgICAgICAgICAgIGsgPSBvZVtrZV0sIChkZSA9IHt9KS5vbkN1cnZlID0gISEoMSAmIGspLCBkZS5sYXN0UG9pbnRPZkNvbnRvdXIgPSAwIDw9IE4uaW5kZXhPZihrZSksIEllLnB1c2goZGUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgQWUgPSAwLCBUZSA9IDA7IFRlIDwgc2U7IFRlICs9IDEpXG4gICAgICAgICAgICAgICAgICAgIGsgPSBvZVtUZV0sIChkZSA9IEllW1RlXSkueCA9IEhyKEksIGssIEFlLCAyLCAxNiksIEFlID0gZGUueDtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIEVlID0gMCwgJGUgPSAwOyAkZSA8IHNlOyAkZSArPSAxKVxuICAgICAgICAgICAgICAgICAgICBrID0gb2VbJGVdLCAoZGUgPSBJZVskZV0pLnkgPSBIcihJLCBrLCBFZSwgNCwgMzIpLCBFZSA9IGRlLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQucG9pbnRzID0gSWU7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGQucG9pbnRzID0gW107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGQubnVtYmVyT2ZDb250b3VycyA9PT0gMClcbiAgICAgICAgICAgICAgZC5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkLmlzQ29tcG9zaXRlID0gITAsIGQucG9pbnRzID0gW10sIGQuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBsdCA9ICEwOyBsdDsgKSB7XG4gICAgICAgICAgICAgICAgb2UgPSBJLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGV0ID0geyBnbHlwaEluZGV4OiBJLnBhcnNlVVNob3J0KCksIHhTY2FsZTogMSwgc2NhbGUwMTogMCwgc2NhbGUxMDogMCwgeVNjYWxlOiAxLCBkeDogMCwgZHk6IDAgfTtcbiAgICAgICAgICAgICAgICAwIDwgKDEgJiBvZSkgPyAwIDwgKDIgJiBvZSkgPyAoZXQuZHggPSBJLnBhcnNlU2hvcnQoKSwgZXQuZHkgPSBJLnBhcnNlU2hvcnQoKSkgOiBldC5tYXRjaGVkUG9pbnRzID0gW0kucGFyc2VVU2hvcnQoKSwgSS5wYXJzZVVTaG9ydCgpXSA6IDAgPCAoMiAmIG9lKSA/IChldC5keCA9IEkucGFyc2VDaGFyKCksIGV0LmR5ID0gSS5wYXJzZUNoYXIoKSkgOiBldC5tYXRjaGVkUG9pbnRzID0gW0kucGFyc2VCeXRlKCksIEkucGFyc2VCeXRlKCldLCAwIDwgKDggJiBvZSkgPyBldC54U2NhbGUgPSBldC55U2NhbGUgPSBJLnBhcnNlRjJEb3QxNCgpIDogMCA8ICg2NCAmIG9lKSA/IChldC54U2NhbGUgPSBJLnBhcnNlRjJEb3QxNCgpLCBldC55U2NhbGUgPSBJLnBhcnNlRjJEb3QxNCgpKSA6IDAgPCAoMTI4ICYgb2UpICYmIChldC54U2NhbGUgPSBJLnBhcnNlRjJEb3QxNCgpLCBldC5zY2FsZTAxID0gSS5wYXJzZUYyRG90MTQoKSwgZXQuc2NhbGUxMCA9IEkucGFyc2VGMkRvdDE0KCksIGV0LnlTY2FsZSA9IEkucGFyc2VGMkRvdDE0KCkpLCBkLmNvbXBvbmVudHMucHVzaChldCksIGx0ID0gISEoMzIgJiBvZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDI1NiAmIG9lKSB7XG4gICAgICAgICAgICAgICAgZC5pbnN0cnVjdGlvbkxlbmd0aCA9IEkucGFyc2VVU2hvcnQoKSwgZC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0dCA9IDA7IHR0IDwgZC5pbnN0cnVjdGlvbkxlbmd0aDsgdHQgKz0gMSlcbiAgICAgICAgICAgICAgICAgIGQuaW5zdHJ1Y3Rpb25zLnB1c2goSS5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRXIoZCwgdikge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IFtdLCBrID0gMDsgayA8IGQubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSBkW2tdLCBJID0geyB4OiB2LnhTY2FsZSAqIEkueCArIHYuc2NhbGUwMSAqIEkueSArIHYuZHgsIHk6IHYuc2NhbGUxMCAqIEkueCArIHYueVNjYWxlICogSS55ICsgdi5keSwgb25DdXJ2ZTogSS5vbkN1cnZlLCBsYXN0UG9pbnRPZkNvbnRvdXI6IEkubGFzdFBvaW50T2ZDb250b3VyIH07XG4gICAgICAgICAgICAgIHcucHVzaChJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBYKCk7XG4gICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IGZ1bmN0aW9uKFNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmUgPSBbXSwgZGUgPSBbXSwgSWUgPSAwOyBJZSA8IFNlLmxlbmd0aDsgSWUgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGtlID0gU2VbSWVdO1xuICAgICAgICAgICAgICAgICAgZGUucHVzaChrZSksIGtlLmxhc3RQb2ludE9mQ29udG91ciAmJiAoYmUucHVzaChkZSksIGRlID0gW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTy5hcmd1bWVudChkZS5sZW5ndGggPT09IDAsIFwiVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuXCIpLCBiZTtcbiAgICAgICAgICAgICAgfShkKSwgayA9IDA7IGsgPCB3Lmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgdmFyIEksIE4gPSB3W2tdLCB6ID0gTltOLmxlbmd0aCAtIDFdLCBRID0gTlswXTtcbiAgICAgICAgICAgICAgICB6Lm9uQ3VydmUgPyB2Lm1vdmVUbyh6LngsIHoueSkgOiBRLm9uQ3VydmUgPyB2Lm1vdmVUbyhRLngsIFEueSkgOiAoSSA9IHsgeDogMC41ICogKHoueCArIFEueCksIHk6IDAuNSAqICh6LnkgKyBRLnkpIH0sIHYubW92ZVRvKEkueCwgSS55KSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2UgPSAwOyBzZSA8IE4ubGVuZ3RoOyArK3NlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2UsIHllID0geiwgeiA9IFEsIFEgPSBOWyhzZSArIDEpICUgTi5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgei5vbkN1cnZlID8gdi5saW5lVG8oei54LCB6LnkpIDogKG9lID0gUSwgeWUub25DdXJ2ZSB8fCAoei54LCB5ZS54LCB6LnksIHllLnkpLCBRLm9uQ3VydmUgfHwgKG9lID0geyB4OiAwLjUgKiAoei54ICsgUS54KSwgeTogMC41ICogKHoueSArIFEueSkgfSksIHYucXVhZHJhdGljQ3VydmVUbyh6LngsIHoueSwgb2UueCwgb2UueSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRW4oZCwgdikge1xuICAgICAgICAgICAgaWYgKHYuaXNDb21wb3NpdGUpXG4gICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgdi5jb21wb25lbnRzLmxlbmd0aDsgdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSB2LmNvbXBvbmVudHNbd10sIEkgPSBkLmdldChrLmdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChJLmdldFBhdGgoKSwgSS5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBOID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgaWYgKGsubWF0Y2hlZFBvaW50cyA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICBOID0gRXIoSS5wb2ludHMsIGspO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrLm1hdGNoZWRQb2ludHNbMF0gPiB2LnBvaW50cy5sZW5ndGggLSAxIHx8IGsubWF0Y2hlZFBvaW50c1sxXSA+IEkucG9pbnRzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gXCIgKyB2Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeiA9IHYucG9pbnRzW2subWF0Y2hlZFBvaW50c1swXV0sIFEgPSBJLnBvaW50c1trLm1hdGNoZWRQb2ludHNbMV1dLCBrID0geyB4U2NhbGU6IGsueFNjYWxlLCBzY2FsZTAxOiBrLnNjYWxlMDEsIHNjYWxlMTA6IGsuc2NhbGUxMCwgeVNjYWxlOiBrLnlTY2FsZSwgZHg6IDAsIGR5OiAwIH0sIFEgPSBFcihbUV0sIGspWzBdO1xuICAgICAgICAgICAgICAgICAgICBrLmR4ID0gei54IC0gUS54LCBrLmR5ID0gei55IC0gUS55LCBOID0gRXIoSS5wb2ludHMsIGspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdi5wb2ludHMgPSB2LnBvaW50cy5jb25jYXQoTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3Iodi5wb2ludHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAodnIucHJvdG90eXBlID0gZ3IucHJvdG90eXBlID0geyBzZWFyY2hUYWc6IFRyLCBiaW5TZWFyY2g6IEJyLCBnZXRUYWJsZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB2ID0gIXYgJiYgZCA/IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKSA6IHY7XG4gICAgICAgICAgfSwgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmdldFRhYmxlKCk7XG4gICAgICAgICAgICByZXR1cm4gZCA/IGQuc2NyaXB0cy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gdi50YWc7XG4gICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgIH0sIGdldERlZmF1bHRTY3JpcHROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdiA9ICExLCB3ID0gMDsgdyA8IGQuc2NyaXB0cy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gZC5zY3JpcHRzW3ddLnRhZztcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gXCJERkxUXCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICBrID09PSBcImxhdG5cIiAmJiAodiA9ICEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdiA/IFwibGF0blwiIDogdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGdldFNjcmlwdFRhYmxlOiBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdywgayA9IHRoaXMuZ2V0VGFibGUodik7XG4gICAgICAgICAgICBpZiAoaylcbiAgICAgICAgICAgICAgcmV0dXJuIHcgPSBrLnNjcmlwdHMsIDAgPD0gKGsgPSBUcihrLnNjcmlwdHMsIGQgPSBkIHx8IFwiREZMVFwiKSkgPyB3W2tdLnNjcmlwdCA6IHYgPyAody5zcGxpY2UoLTEgLSBrLCAwLCB2ID0geyB0YWc6IGQsIHNjcmlwdDogeyBkZWZhdWx0TGFuZ1N5czogeyByZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiA2NTUzNSwgZmVhdHVyZUluZGV4ZXM6IFtdIH0sIGxhbmdTeXNSZWNvcmRzOiBbXSB9IH0pLCB2LnNjcmlwdCkgOiB2b2lkIDA7XG4gICAgICAgICAgfSwgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihJLCB2LCB3KSB7XG4gICAgICAgICAgICB2YXIgaywgSSA9IHRoaXMuZ2V0U2NyaXB0VGFibGUoSSwgdyk7XG4gICAgICAgICAgICBpZiAoSSlcbiAgICAgICAgICAgICAgcmV0dXJuIHYgJiYgdiAhPT0gXCJkZmx0XCIgJiYgdiAhPT0gXCJERkxUXCIgPyAwIDw9IChrID0gVHIoSS5sYW5nU3lzUmVjb3JkcywgdikpID8gSS5sYW5nU3lzUmVjb3Jkc1trXS5sYW5nU3lzIDogdyA/IChJLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIGssIDAsIHcgPSB7IHRhZzogdiwgbGFuZ1N5czogeyByZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiA2NTUzNSwgZmVhdHVyZUluZGV4ZXM6IFtdIH0gfSksIHcubGFuZ1N5cykgOiB2b2lkIDAgOiBJLmRlZmF1bHRMYW5nU3lzO1xuICAgICAgICAgIH0sIGdldEZlYXR1cmVUYWJsZTogZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgaWYgKGQgPSB0aGlzLmdldExhbmdTeXNUYWJsZShkLCB2LCBrKSwgZCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBJLCBOID0gZC5mZWF0dXJlSW5kZXhlcywgeiA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmZlYXR1cmVzLCBRID0gMDsgUSA8IE4ubGVuZ3RoOyBRKyspXG4gICAgICAgICAgICAgICAgaWYgKChJID0geltOW1FdXSkudGFnID09PSB3KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIEkuZmVhdHVyZTtcbiAgICAgICAgICAgICAgaWYgKGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPSB6Lmxlbmd0aCwgTy5hc3NlcnQodiA9PT0gMCB8fCB3ID49IHpbdiAtIDFdLnRhZywgXCJGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci5cIiksIHoucHVzaChJID0geyB0YWc6IHcsIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfSB9KSwgTi5wdXNoKHYpLCBJLmZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZ2V0TG9va3VwVGFibGVzOiBmdW5jdGlvbihOLCB2LCB3LCBrLCBJKSB7XG4gICAgICAgICAgICB2YXIgTiA9IHRoaXMuZ2V0RmVhdHVyZVRhYmxlKE4sIHYsIHcsIEkpLCB6ID0gW107XG4gICAgICAgICAgICBpZiAoTikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBRLCBzZSA9IE4ubG9va3VwTGlzdEluZGV4ZXMsIG9lID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0ubG9va3VwcywgeWUgPSAwOyB5ZSA8IHNlLmxlbmd0aDsgeWUrKylcbiAgICAgICAgICAgICAgICAoUSA9IG9lW3NlW3llXV0pLmxvb2t1cFR5cGUgPT09IGsgJiYgei5wdXNoKFEpO1xuICAgICAgICAgICAgICBpZiAoei5sZW5ndGggPT09IDAgJiYgSSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdiA9IG9lLmxlbmd0aCwgb2UucHVzaChRID0geyBsb29rdXBUeXBlOiBrLCBsb29rdXBGbGFnOiAwLCBzdWJ0YWJsZXM6IFtdLCBtYXJrRmlsdGVyaW5nU2V0OiB2b2lkIDAgfSksIHNlLnB1c2godiksIFtRXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6O1xuICAgICAgICAgIH0sIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZC5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBkLnN0YXJ0R2x5cGggPD0gdiAmJiB2IDwgZC5zdGFydEdseXBoICsgZC5jbGFzc2VzLmxlbmd0aCA/IGQuY2xhc3Nlc1t2IC0gZC5zdGFydEdseXBoXSA6IDA7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgdyA9IEdyKGQucmFuZ2VzLCB2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdyA/IHcuY2xhc3NJZCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZ2V0Q292ZXJhZ2VJbmRleDogZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgc3dpdGNoIChkLmZvcm1hdCkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBCcihkLmdseXBocywgdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgPD0gdyA/IHcgOiAtMTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB3ID0gR3IoZC5yYW5nZXMsIHYpLCB3ID8gdy5pbmRleCArIHYgLSB3LnN0YXJ0IDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZXhwYW5kQ292ZXJhZ2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChkLmZvcm1hdCA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGQuZ2x5cGhzO1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IFtdLCB3ID0gZC5yYW5nZXMsIGsgPSAwOyBrIDwgdy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgSSA9IHdba10sIE4gPSBJLnN0YXJ0LCB6ID0gSS5lbmQsIFEgPSBOOyBRIDw9IHo7IFErKylcbiAgICAgICAgICAgICAgICB2LnB1c2goUSk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9IH0pLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0S2VybmluZ1RhYmxlcyA9IHRoaXMuZ2V0S2VybmluZ1RhYmxlcyhkKTtcbiAgICAgICAgICB9LCB2ci5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24oZCwgdiwgdykge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICBmb3IgKHZhciBJID0gZFtrXS5zdWJ0YWJsZXMsIE4gPSAwOyBOIDwgSS5sZW5ndGg7IE4rKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gSVtOXSwgUSA9IHRoaXMuZ2V0Q292ZXJhZ2VJbmRleCh6LmNvdmVyYWdlLCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoIShRIDwgMCkpXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHoucG9zRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzZSA9IHoucGFpclNldHNbUV0sIG9lID0gMDsgb2UgPCBzZS5sZW5ndGg7IG9lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ZSA9IHNlW29lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ZS5zZWNvbmRHbHlwaCA9PT0gdylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHllLnZhbHVlMSAmJiB5ZS52YWx1ZTEueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYmUgPSB0aGlzLmdldEdseXBoQ2xhc3Moei5jbGFzc0RlZjEsIHYpLCBTZSA9IHRoaXMuZ2V0R2x5cGhDbGFzcyh6LmNsYXNzRGVmMiwgdyksIGJlID0gei5jbGFzc1JlY29yZHNbYmVdW1NlXTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmUudmFsdWUxICYmIGJlLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LCB2ci5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnQudGFibGVzLmdwb3MpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhkLCB2LCBcImtlcm5cIiwgMik7XG4gICAgICAgICAgfSwgKCR0LnByb3RvdHlwZSA9IGdyLnByb3RvdHlwZSkuY3JlYXRlRGVmYXVsdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2ZXJzaW9uOiAxLCBzY3JpcHRzOiBbeyB0YWc6IFwiREZMVFwiLCBzY3JpcHQ6IHsgZGVmYXVsdExhbmdTeXM6IHsgcmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogNjU1MzUsIGZlYXR1cmVJbmRleGVzOiBbXSB9LCBsYW5nU3lzUmVjb3JkczogW10gfSB9XSwgZmVhdHVyZXM6IFtdLCBsb29rdXBzOiBbXSB9O1xuICAgICAgICAgIH0sICR0LnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gW10sIEkgPSB0aGlzLmdldExvb2t1cFRhYmxlcyh2LCB3LCBkLCAxKSwgTiA9IDA7IE4gPCBJLmxlbmd0aDsgTisrKVxuICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gSVtOXS5zdWJ0YWJsZXMsIFEgPSAwOyBRIDwgei5sZW5ndGg7IFErKykge1xuICAgICAgICAgICAgICAgIHZhciBzZSA9IHpbUV0sIG9lID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzZS5jb3ZlcmFnZSksIHllID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChzZS5zdWJzdEZvcm1hdCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIFNlID0gc2UuZGVsdGFHbHlwaElkLCB5ZSA9IDA7IHllIDwgb2UubGVuZ3RoOyB5ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZSA9IG9lW3llXTtcbiAgICAgICAgICAgICAgICAgICAgay5wdXNoKHsgc3ViOiBiZSwgYnk6IGJlICsgU2UgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGUgPSBzZS5zdWJzdGl0dXRlO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZSA9IDA7IHllIDwgb2UubGVuZ3RoOyB5ZSsrKVxuICAgICAgICAgICAgICAgICAgICBrLnB1c2goeyBzdWI6IG9lW3llXSwgYnk6IGRlW3llXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgIH0sICR0LnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24oZCwgdiwgdykge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IFtdLCBJID0gdGhpcy5nZXRMb29rdXBUYWJsZXModiwgdywgZCwgMyksIE4gPSAwOyBOIDwgSS5sZW5ndGg7IE4rKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IElbTl0uc3VidGFibGVzLCBRID0gMDsgUSA8IHoubGVuZ3RoOyBRKyspXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2UgPSB6W1FdLCBvZSA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc2UuY292ZXJhZ2UpLCB5ZSA9IHNlLmFsdGVybmF0ZVNldHMsIFNlID0gMDsgU2UgPCBvZS5sZW5ndGg7IFNlKyspXG4gICAgICAgICAgICAgICAgICBrLnB1c2goeyBzdWI6IG9lW1NlXSwgYnk6IHllW1NlXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgIH0sICR0LnByb3RvdHlwZS5nZXRMaWdhdHVyZXMgPSBmdW5jdGlvbihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gW10sIEkgPSB0aGlzLmdldExvb2t1cFRhYmxlcyh2LCB3LCBkLCA0KSwgTiA9IDA7IE4gPCBJLmxlbmd0aDsgTisrKVxuICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gSVtOXS5zdWJ0YWJsZXMsIFEgPSAwOyBRIDwgei5sZW5ndGg7IFErKylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzZSA9IHpbUV0sIG9lID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzZS5jb3ZlcmFnZSksIHllID0gc2UubGlnYXR1cmVTZXRzLCBTZSA9IDA7IFNlIDwgb2UubGVuZ3RoOyBTZSsrKVxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYmUgPSBvZVtTZV0sIGRlID0geWVbU2VdLCBJZSA9IDA7IEllIDwgZGUubGVuZ3RoOyBJZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZSA9IGRlW0llXTtcbiAgICAgICAgICAgICAgICAgICAgay5wdXNoKHsgc3ViOiBbYmVdLmNvbmNhdChrZS5jb21wb25lbnRzKSwgYnk6IGtlLmxpZ0dseXBoIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfSwgJHQucHJvdG90eXBlLmFkZFNpbmdsZSA9IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHcgPSBWcih0aGlzLmdldExvb2t1cFRhYmxlcyh3LCBrLCBkLCAxLCAhMClbMF0sIDIsIHsgc3Vic3RGb3JtYXQ6IDIsIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LCBzdWJzdGl0dXRlOiBbXSB9KSwgTy5hc3NlcnQody5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsIFwiTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0IFwiICsgdy5jb3ZlcmFnZS5mb3JtYXQpLCBrID0gdi5zdWIsIGQgPSB0aGlzLmJpblNlYXJjaCh3LmNvdmVyYWdlLmdseXBocywgayksIGQgPCAwICYmICh3LmNvdmVyYWdlLmdseXBocy5zcGxpY2UoZCA9IC0xIC0gZCwgMCwgayksIHcuc3Vic3RpdHV0ZS5zcGxpY2UoZCwgMCwgMCkpLCB3LnN1YnN0aXR1dGVbZF0gPSB2LmJ5O1xuICAgICAgICAgIH0sICR0LnByb3RvdHlwZS5hZGRBbHRlcm5hdGUgPSBmdW5jdGlvbihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICB3ID0gVnIodGhpcy5nZXRMb29rdXBUYWJsZXModywgaywgZCwgMywgITApWzBdLCAxLCB7IHN1YnN0Rm9ybWF0OiAxLCBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSwgYWx0ZXJuYXRlU2V0czogW10gfSksIE8uYXNzZXJ0KHcuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCBcIkxpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCBcIiArIHcuY292ZXJhZ2UuZm9ybWF0KSwgayA9IHYuc3ViLCBkID0gdGhpcy5iaW5TZWFyY2gody5jb3ZlcmFnZS5nbHlwaHMsIGspLCBkIDwgMCAmJiAody5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKGQgPSAtMSAtIGQsIDAsIGspLCB3LmFsdGVybmF0ZVNldHMuc3BsaWNlKGQsIDAsIDApKSwgdy5hbHRlcm5hdGVTZXRzW2RdID0gdi5ieTtcbiAgICAgICAgICB9LCAkdC5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihOLCBzZSwgUSwgSSkge1xuICAgICAgICAgICAgdmFyIFEgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhRLCBJLCBOLCA0LCAhMClbMF0sIEkgPSBRLnN1YnRhYmxlc1swXSwgTiA9IChJIHx8IChRLnN1YnRhYmxlc1swXSA9IEkgPSB7IHN1YnN0Rm9ybWF0OiAxLCBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSwgbGlnYXR1cmVTZXRzOiBbXSB9KSwgTy5hc3NlcnQoSS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsIFwiTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0IFwiICsgSS5jb3ZlcmFnZS5mb3JtYXQpLCBzZS5zdWJbMF0pLCB6ID0gc2Uuc3ViLnNsaWNlKDEpLCBRID0geyBsaWdHbHlwaDogc2UuYnksIGNvbXBvbmVudHM6IHogfSwgc2UgPSB0aGlzLmJpblNlYXJjaChJLmNvdmVyYWdlLmdseXBocywgTik7XG4gICAgICAgICAgICBpZiAoMCA8PSBzZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBvZSA9IEkubGlnYXR1cmVTZXRzW3NlXSwgeWUgPSAwOyB5ZSA8IG9lLmxlbmd0aDsgeWUrKylcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24oU2UsIGJlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGUgPSBTZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpZiAoZGUgPT09IGJlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBJZSA9IDA7IEllIDwgZGU7IEllKyspXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFNlW0llXSAhPT0gYmVbSWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KG9lW3llXS5jb21wb25lbnRzLCB6KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgb2UucHVzaChRKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBJLmNvdmVyYWdlLmdseXBocy5zcGxpY2Uoc2UgPSAtMSAtIHNlLCAwLCBOKSwgSS5saWdhdHVyZVNldHMuc3BsaWNlKHNlLCAwLCBbUV0pO1xuICAgICAgICAgIH0sICR0LnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24oZCwgdiwgdykge1xuICAgICAgICAgICAgaWYgKC9zc1xcZFxcZC8udGVzdChkKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGQsIHYsIHcpO1xuICAgICAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJhYWx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzYWx0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGQsIHYsIHcpLmNvbmNhdCh0aGlzLmdldEFsdGVybmF0ZXMoZCwgdiwgdykpO1xuICAgICAgICAgICAgICBjYXNlIFwiZGxpZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibGlnYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmxpZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpZ2F0dXJlcyhkLCB2LCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAkdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgaWYgKC9zc1xcZFxcZC8udGVzdChkKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGQsIHYsIHcsIGspO1xuICAgICAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJhYWx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzYWx0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2LmJ5ID09IFwibnVtYmVyXCIgPyB0aGlzLmFkZFNpbmdsZShkLCB2LCB3LCBrKSA6IHRoaXMuYWRkQWx0ZXJuYXRlKGQsIHYsIHcsIGspO1xuICAgICAgICAgICAgICBjYXNlIFwiZGxpZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibGlnYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmxpZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGQsIHYsIHcsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHFyID0geyBnZXRQYXRoOiBXciwgcGFyc2U6IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSBuZXcgS2UuR2x5cGhTZXQoayksIE4gPSAwOyBOIDwgdy5sZW5ndGggLSAxOyBOICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHogPSB3W05dO1xuICAgICAgICAgICAgICB6ICE9PSB3W04gKyAxXSA/IEkucHVzaChOLCBLZS50dGZHbHlwaExvYWRlcihrLCBOLCBUbiwgZCwgdiArIHosIEVuKSkgOiBJLnB1c2goTiwgS2UuZ2x5cGhMb2FkZXIoaywgTikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgfSB9O1xuICAgICAgICAgIGZ1bmN0aW9uIFhyKGQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udCA9IGQsIHRoaXMuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBxci5nZXRQYXRoKHYpLmNvbW1hbmRzO1xuICAgICAgICAgICAgfSwgdGhpcy5fZnBnbVN0YXRlID0gdGhpcy5fcHJlcFN0YXRlID0gdm9pZCAwLCB0aGlzLl9lcnJvclN0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTW4oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFlyKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpZ24oZCkgKiBNYXRoLnJvdW5kKE1hdGguYWJzKGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24ga24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2lnbihkKSAqIE1hdGgucm91bmQoTWF0aC5hYnMoMiAqIGQpKSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIENuKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpZ24oZCkgKiAoTWF0aC5yb3VuZChNYXRoLmFicyhkKSArIDAuNSkgLSAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBPbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaWduKGQpICogTWF0aC5jZWlsKE1hdGguYWJzKGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQW4oZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2lnbihkKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMoZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBacihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuc3JQZXJpb2QsIHcgPSB0aGlzLnNyUGhhc2UsIGsgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGQgPCAwICYmIChkID0gLWQsIGsgPSAtMSksIGQgKz0gdGhpcy5zclRocmVzaG9sZCAtIHcsIGQgPSBNYXRoLnRydW5jKGQgLyB2KSAqIHYsIChkICs9IHcpIDwgMCA/IHcgKiBrIDogZCAqIGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlciA9IHsgeDogMSwgeTogMCwgYXhpczogXCJ4XCIsIGRpc3RhbmNlOiBmdW5jdGlvbihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICByZXR1cm4gKHcgPyBkLnhvIDogZC54KSAtIChrID8gdi54byA6IHYueCk7XG4gICAgICAgICAgfSwgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHZhciBJLCBOLCB6LCBRLCBzZSwgb2UsIHllO1xuICAgICAgICAgICAgaWYgKCFrIHx8IGsgPT09IHRoaXMpXG4gICAgICAgICAgICAgIHJldHVybiBJID0gZC54byAtIHYueG8sIE4gPSBkLnhvIC0gdy54bywgc2UgPSB2LnggLSB2LnhvLCBvZSA9IHcueCAtIHcueG8sICh5ZSA9ICh6ID0gTWF0aC5hYnMoSSkpICsgKFEgPSBNYXRoLmFicyhOKSkpID09PSAwID8gdm9pZCAoZC54ID0gZC54byArIChzZSArIG9lKSAvIDIpIDogdm9pZCAoZC54ID0gZC54byArIChzZSAqIFEgKyBvZSAqIHopIC8geWUpO1xuICAgICAgICAgICAgSSA9IGsuZGlzdGFuY2UoZCwgdiwgITAsICEwKSwgTiA9IGsuZGlzdGFuY2UoZCwgdywgITAsICEwKSwgc2UgPSBrLmRpc3RhbmNlKHYsIHYsICExLCAhMCksIG9lID0gay5kaXN0YW5jZSh3LCB3LCAhMSwgITApLCAoeWUgPSAoeiA9IE1hdGguYWJzKEkpKSArIChRID0gTWF0aC5hYnMoTikpKSA9PT0gMCA/IGVyLnNldFJlbGF0aXZlKGQsIGQsIChzZSArIG9lKSAvIDIsIGssICEwKSA6IGVyLnNldFJlbGF0aXZlKGQsIGQsIChzZSAqIFEgKyBvZSAqIHopIC8geWUsIGssICEwKTtcbiAgICAgICAgICB9LCBub3JtYWxTbG9wZTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBzZXRSZWxhdGl2ZTogZnVuY3Rpb24oZCwgdiwgdywgaywgSSkge1xuICAgICAgICAgICAgdmFyIE4sIHo7XG4gICAgICAgICAgICBrICYmIGsgIT09IHRoaXMgPyAoTiA9IEkgPyB2LnhvIDogdi54LCB6ID0gSSA/IHYueW8gOiB2LnksIE4gKz0gdyAqIGsueCwgeiArPSB3ICogay55LCBkLnggPSBOICsgKGQueSAtIHopIC8gay5ub3JtYWxTbG9wZSkgOiBkLnggPSAoSSA/IHYueG8gOiB2LngpICsgdztcbiAgICAgICAgICB9LCBzbG9wZTogMCwgdG91Y2g6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQueFRvdWNoZWQgPSAhMDtcbiAgICAgICAgICB9LCB0b3VjaGVkOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC54VG91Y2hlZDtcbiAgICAgICAgICB9LCB1bnRvdWNoOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLnhUb3VjaGVkID0gITE7XG4gICAgICAgICAgfSB9LCB0ciA9IHsgeDogMCwgeTogMSwgYXhpczogXCJ5XCIsIGRpc3RhbmNlOiBmdW5jdGlvbihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICByZXR1cm4gKHcgPyBkLnlvIDogZC55KSAtIChrID8gdi55byA6IHYueSk7XG4gICAgICAgICAgfSwgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGQsIHYsIHcsIGspIHtcbiAgICAgICAgICAgIHZhciBJLCBOLCB6LCBRLCBzZSwgb2UsIHllO1xuICAgICAgICAgICAgaWYgKCFrIHx8IGsgPT09IHRoaXMpXG4gICAgICAgICAgICAgIHJldHVybiBJID0gZC55byAtIHYueW8sIE4gPSBkLnlvIC0gdy55bywgc2UgPSB2LnkgLSB2LnlvLCBvZSA9IHcueSAtIHcueW8sICh5ZSA9ICh6ID0gTWF0aC5hYnMoSSkpICsgKFEgPSBNYXRoLmFicyhOKSkpID09PSAwID8gdm9pZCAoZC55ID0gZC55byArIChzZSArIG9lKSAvIDIpIDogdm9pZCAoZC55ID0gZC55byArIChzZSAqIFEgKyBvZSAqIHopIC8geWUpO1xuICAgICAgICAgICAgSSA9IGsuZGlzdGFuY2UoZCwgdiwgITAsICEwKSwgTiA9IGsuZGlzdGFuY2UoZCwgdywgITAsICEwKSwgc2UgPSBrLmRpc3RhbmNlKHYsIHYsICExLCAhMCksIG9lID0gay5kaXN0YW5jZSh3LCB3LCAhMSwgITApLCAoeWUgPSAoeiA9IE1hdGguYWJzKEkpKSArIChRID0gTWF0aC5hYnMoTikpKSA9PT0gMCA/IHRyLnNldFJlbGF0aXZlKGQsIGQsIChzZSArIG9lKSAvIDIsIGssICEwKSA6IHRyLnNldFJlbGF0aXZlKGQsIGQsIChzZSAqIFEgKyBvZSAqIHopIC8geWUsIGssICEwKTtcbiAgICAgICAgICB9LCBub3JtYWxTbG9wZTogMCwgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEkpIHtcbiAgICAgICAgICAgIHZhciBOLCB6O1xuICAgICAgICAgICAgayAmJiBrICE9PSB0aGlzID8gKE4gPSBJID8gdi54byA6IHYueCwgeiA9IEkgPyB2LnlvIDogdi55LCBOICs9IHcgKiBrLngsIHogKz0gdyAqIGsueSwgZC55ID0geiArIGsubm9ybWFsU2xvcGUgKiAoZC54IC0gTikpIDogZC55ID0gKEkgPyB2LnlvIDogdi55KSArIHc7XG4gICAgICAgICAgfSwgc2xvcGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdG91Y2g6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQueVRvdWNoZWQgPSAhMDtcbiAgICAgICAgICB9LCB0b3VjaGVkOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC55VG91Y2hlZDtcbiAgICAgICAgICB9LCB1bnRvdWNoOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLnlUb3VjaGVkID0gITE7XG4gICAgICAgICAgfSB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGNyKGQsIHYpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IGQsIHRoaXMueSA9IHYsIHRoaXMuYXhpcyA9IHZvaWQgMCwgdGhpcy5zbG9wZSA9IHYgLyBkLCB0aGlzLm5vcm1hbFNsb3BlID0gLWQgLyB2LCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkcihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IE1hdGguc3FydChkICogZCArIHYgKiB2KTtcbiAgICAgICAgICAgIHJldHVybiB2IC89IHcsIChkIC89IHcpID09PSAxICYmIHYgPT09IDAgPyBlciA6IGQgPT09IDAgJiYgdiA9PT0gMSA/IHRyIDogbmV3IGNyKGQsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBycihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnhvID0gTWF0aC5yb3VuZCg2NCAqIGQpIC8gNjQsIHRoaXMueSA9IHRoaXMueW8gPSBNYXRoLnJvdW5kKDY0ICogdikgLyA2NCwgdGhpcy5sYXN0UG9pbnRPZkNvbnRvdXIgPSB3LCB0aGlzLm9uQ3VydmUgPSBrLCB0aGlzLnByZXZQb2ludE9uQ29udG91ciA9IHZvaWQgMCwgdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXIgPSB2b2lkIDAsIHRoaXMueFRvdWNoZWQgPSAhMSwgdGhpcy55VG91Y2hlZCA9ICExLCBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5mcmVlemUoZXIpLCBPYmplY3QuZnJlZXplKHRyKSwgY3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIGVyLmRpc3RhbmNlKGQsIHYsIHcsIGspICsgdGhpcy55ICogdHIuZGlzdGFuY2UoZCwgdiwgdywgayk7XG4gICAgICAgICAgfSwgY3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oZCwgSSwgTiwgaykge1xuICAgICAgICAgICAgdmFyIHogPSBrLmRpc3RhbmNlKGQsIEksICEwLCAhMCksIFEgPSBrLmRpc3RhbmNlKGQsIE4sICEwLCAhMCksIEkgPSBrLmRpc3RhbmNlKEksIEksICExLCAhMCksIE4gPSBrLmRpc3RhbmNlKE4sIE4sICExLCAhMCksIHogPSBNYXRoLmFicyh6KSwgUSA9IE1hdGguYWJzKFEpLCBzZSA9IHogKyBRO1xuICAgICAgICAgICAgc2UgPT09IDAgPyB0aGlzLnNldFJlbGF0aXZlKGQsIGQsIChJICsgTikgLyAyLCBrLCAhMCkgOiB0aGlzLnNldFJlbGF0aXZlKGQsIGQsIChJICogUSArIE4gKiB6KSAvIHNlLCBrLCAhMCk7XG4gICAgICAgICAgfSwgY3IucHJvdG90eXBlLnNldFJlbGF0aXZlID0gZnVuY3Rpb24oZCwgTiwgc2UsIG9lLCBRKSB7XG4gICAgICAgICAgICB2YXIgeiA9IFEgPyBOLnhvIDogTi54LCBRID0gUSA/IE4ueW8gOiBOLnksIE4gPSB6ICsgc2UgKiAob2UgPSBvZSB8fCB0aGlzKS54LCB6ID0gUSArIHNlICogb2UueSwgUSA9IG9lLm5vcm1hbFNsb3BlLCBzZSA9IHRoaXMuc2xvcGUsIG9lID0gZC54LCB5ZSA9IGQueTtcbiAgICAgICAgICAgIGQueCA9IChzZSAqIG9lIC0gUSAqIE4gKyB6IC0geWUpIC8gKHNlIC0gUSksIGQueSA9IHNlICogKGQueCAtIG9lKSArIHllO1xuICAgICAgICAgIH0sIGNyLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQueFRvdWNoZWQgPSAhMCwgZC55VG91Y2hlZCA9ICEwO1xuICAgICAgICAgIH0sIHJyLnByb3RvdHlwZS5uZXh0VG91Y2hlZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSB0aGlzLm5leHRQb2ludE9uQ29udG91cjsgIWQudG91Y2hlZCh2KSAmJiB2ICE9PSB0aGlzOyApXG4gICAgICAgICAgICAgIHYgPSB2Lm5leHRQb2ludE9uQ29udG91cjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIHJyLnByb3RvdHlwZS5wcmV2VG91Y2hlZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSB0aGlzLnByZXZQb2ludE9uQ29udG91cjsgIWQudG91Y2hlZCh2KSAmJiB2ICE9PSB0aGlzOyApXG4gICAgICAgICAgICAgIHYgPSB2LnByZXZQb2ludE9uQ29udG91cjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGhyID0gT2JqZWN0LmZyZWV6ZShuZXcgcnIoMCwgMCkpLCBQbiA9IHsgY3ZDdXRJbjogMTcgLyAxNiwgZGVsdGFCYXNlOiA5LCBkZWx0YVNoaWZ0OiAwLjEyNSwgbG9vcDogMSwgbWluRGlzOiAxLCBhdXRvRmxpcDogITAgfTtcbiAgICAgICAgICBmdW5jdGlvbiBucihkLCB2KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZW52ID0gZCwgdGhpcy5zdGFjayA9IFtdLCB0aGlzLnByb2cgPSB2LCBkKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJnbHlmXCI6XG4gICAgICAgICAgICAgICAgdGhpcy56cDAgPSB0aGlzLnpwMSA9IHRoaXMuenAyID0gMSwgdGhpcy5ycDAgPSB0aGlzLnJwMSA9IHRoaXMucnAyID0gMDtcbiAgICAgICAgICAgICAgY2FzZSBcInByZXBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZ2ID0gdGhpcy5wdiA9IHRoaXMuZHB2ID0gZXIsIHRoaXMucm91bmQgPSBZcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYnIoZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IGQudFpvbmUgPSBuZXcgQXJyYXkoZC5nWm9uZS5sZW5ndGgpLCB3ID0gMDsgdyA8IHYubGVuZ3RoOyB3KyspXG4gICAgICAgICAgICAgIHZbd10gPSBuZXcgcnIoMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFFyKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBrID0gZC5wcm9nLCBJID0gZC5pcCwgTiA9IDE7XG4gICAgICAgICAgICBkb1xuICAgICAgICAgICAgICBpZiAoKHcgPSBrWysrSV0pID09PSA4OClcbiAgICAgICAgICAgICAgICBOKys7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHcgPT09IDg5KVxuICAgICAgICAgICAgICAgIE4tLTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAodyA9PT0gNjQpXG4gICAgICAgICAgICAgICAgSSArPSBrW0kgKyAxXSArIDE7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHcgPT09IDY1KVxuICAgICAgICAgICAgICAgIEkgKz0gMiAqIGtbSSArIDFdICsgMTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoMTc2IDw9IHcgJiYgdyA8PSAxODMpXG4gICAgICAgICAgICAgICAgSSArPSB3IC0gMTc2ICsgMTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoMTg0IDw9IHcgJiYgdyA8PSAxOTEpXG4gICAgICAgICAgICAgICAgSSArPSAyICogKHcgLSAxODQgKyAxKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAodiAmJiBOID09PSAxICYmIHcgPT09IDI3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKDAgPCBOKTtcbiAgICAgICAgICAgIGQuaXAgPSBJO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBLcihkLCB2KSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJTVlRDQVtcIiArIGQuYXhpcyArIFwiXVwiKSwgdi5mdiA9IHYucHYgPSB2LmRwdiA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEpyKGQsIHYpIHtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCBcIlNQVlRDQVtcIiArIGQuYXhpcyArIFwiXVwiKSwgdi5wdiA9IHYuZHB2ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gJHIoZCwgdikge1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyh2LnN0ZXAsIFwiU0ZWVENBW1wiICsgZC5heGlzICsgXCJdXCIpLCB2LmZ2ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZW4oZCwgdikge1xuICAgICAgICAgICAgdmFyIHcsIEkgPSB2LnN0YWNrLCBrID0gSS5wb3AoKSwgSSA9IEkucG9wKCksIE4gPSB2LnoyW2tdLCB6ID0gdi56MVtJXTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coXCJTUFZUTFtcIiArIGQgKyBcIl1cIiwgaywgSSksIGsgPSBkID8gKHcgPSBOLnkgLSB6LnksIHoueCAtIE4ueCkgOiAodyA9IHoueCAtIE4ueCwgei55IC0gTi55KSwgdi5wdiA9IHYuZHB2ID0gZHIodywgayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHRuKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBJID0gdi5zdGFjaywgayA9IEkucG9wKCksIEkgPSBJLnBvcCgpLCBOID0gdi56MltrXSwgeiA9IHYuejFbSV07XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKFwiU0ZWVExbXCIgKyBkICsgXCJdXCIsIGssIEkpLCBrID0gZCA/ICh3ID0gTi55IC0gei55LCB6LnggLSBOLngpIDogKHcgPSB6LnggLSBOLngsIHoueSAtIE4ueSksIHYuZnYgPSBkcih3LCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTXIoZCkge1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiUE9QW11cIiksIGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJuKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdi5zdGFjay5wb3AoKSwgayA9IHYuejBbd10sIEkgPSB2LmZ2LCBOID0gdi5wdiwgeiA9IChoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJNREFQW1wiICsgZCArIFwiXVwiLCB3KSwgTi5kaXN0YW5jZShrLCBocikpO1xuICAgICAgICAgICAgZCAmJiAoeiA9IHYucm91bmQoeikpLCBJLnNldFJlbGF0aXZlKGssIGhyLCB6LCBOKSwgSS50b3VjaChrKSwgdi5ycDAgPSB2LnJwMSA9IHc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG5uKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBrLCBJLCBOID0gdi56MiwgeiA9IE4ubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCBcIklVUFtcIiArIGQuYXhpcyArIFwiXVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIFEgPSAwOyBRIDwgejsgUSsrKVxuICAgICAgICAgICAgICB3ID0gTltRXSwgZC50b3VjaGVkKHcpIHx8IChrID0gdy5wcmV2VG91Y2hlZChkKSkgIT09IHcgJiYgKGsgPT09IChJID0gdy5uZXh0VG91Y2hlZChkKSkgJiYgZC5zZXRSZWxhdGl2ZSh3LCB3LCBkLmRpc3RhbmNlKGssIGssICExLCAhMCksIGQsICEwKSwgZC5pbnRlcnBvbGF0ZSh3LCBrLCBJLCBkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG9uKGQsIHYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSB2LnN0YWNrLCBrID0gZCA/IHYucnAxIDogdi5ycDIsIEkgPSAoZCA/IHYuejAgOiB2LnoxKVtrXSwgTiA9IHYuZnYsIHogPSB2LnB2LCBRID0gdi5sb29wLCBzZSA9IHYuejI7IFEtLTsgKSB7XG4gICAgICAgICAgICAgIHZhciBvZSA9IHcucG9wKCksIHllID0gc2Vbb2VdLCBTZSA9IHouZGlzdGFuY2UoSSwgSSwgITEsICEwKTtcbiAgICAgICAgICAgICAgTi5zZXRSZWxhdGl2ZSh5ZSwgeWUsIFNlLCB6KSwgTi50b3VjaCh5ZSksIGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCAoMSA8IHYubG9vcCA/IFwibG9vcCBcIiArICh2Lmxvb3AgLSBRKSArIFwiOiBcIiA6IFwiXCIpICsgXCJTSFBbXCIgKyAoZCA/IFwicnAxXCIgOiBcInJwMlwiKSArIFwiXVwiLCBvZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2Lmxvb3AgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBzbihkLCB2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gdi5zdGFjaywgeiA9IGQgPyB2LnJwMSA6IHYucnAyLCBrID0gKGQgPyB2LnowIDogdi56MSlbel0sIEkgPSB2LmZ2LCBOID0gdi5wdiwgeiA9IHcucG9wKCksIFEgPSB2LnoyW3YuY29udG91cnNbel1dLCBzZSA9IFEsIG9lID0gKGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCBcIlNIQ1tcIiArIGQgKyBcIl1cIiwgeiksIE4uZGlzdGFuY2UoaywgaywgITEsICEwKSk7IHNlICE9PSBrICYmIEkuc2V0UmVsYXRpdmUoc2UsIHNlLCBvZSwgTiksIChzZSA9IHNlLm5leHRQb2ludE9uQ29udG91cikgIT09IFE7IClcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBhbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdywgaywgUSA9IHYuc3RhY2ssIEkgPSBkID8gdi5ycDEgOiB2LnJwMiwgSSA9IChkID8gdi56MCA6IHYuejEpW0ldLCBOID0gdi5mdiwgeiA9IHYucHYsIFEgPSBRLnBvcCgpO1xuICAgICAgICAgICAgc3dpdGNoIChoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJTSFpbXCIgKyBkICsgXCJdXCIsIFEpLCBRKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB3ID0gdi50Wm9uZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHcgPSB2Lmdab25lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgem9uZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHNlID0gei5kaXN0YW5jZShJLCBJLCAhMSwgITApLCBvZSA9IHcubGVuZ3RoIC0gMiwgeWUgPSAwOyB5ZSA8IG9lOyB5ZSsrKVxuICAgICAgICAgICAgICBrID0gd1t5ZV0sIE4uc2V0UmVsYXRpdmUoaywgaywgc2UsIHopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBsbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgayA9IHYuc3RhY2ssIHcgPSBrLnBvcCgpIC8gNjQsIGsgPSBrLnBvcCgpLCBJID0gdi56MVtrXSwgTiA9IHYuejBbdi5ycDBdLCB6ID0gdi5mdiwgUSA9IHYucHY7XG4gICAgICAgICAgICB6LnNldFJlbGF0aXZlKEksIE4sIHcsIFEpLCB6LnRvdWNoKEkpLCBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJNU0lSUFtcIiArIGQgKyBcIl1cIiwgdywgayksIHYucnAxID0gdi5ycDAsIHYucnAyID0gaywgZCAmJiAodi5ycDAgPSBrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdW4oZCwgdikge1xuICAgICAgICAgICAgdmFyIHcgPSB2LnN0YWNrLCBRID0gdy5wb3AoKSwgdyA9IHcucG9wKCksIGsgPSB2LnowW3ddLCBJID0gdi5mdiwgTiA9IHYucHYsIHogPSB2LmN2dFtRXSwgUSA9IChoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJNSUFQW1wiICsgZCArIFwiXVwiLCBRLCBcIihcIiwgeiwgXCIpXCIsIHcpLCBOLmRpc3RhbmNlKGssIGhyKSk7XG4gICAgICAgICAgICBkICYmIChNYXRoLmFicyhRIC0geikgPCB2LmN2Q3V0SW4gJiYgKFEgPSB6KSwgUSA9IHYucm91bmQoUSkpLCBJLnNldFJlbGF0aXZlKGssIGhyLCBRLCBOKSwgdi56cDAgPT09IDAgJiYgKGsueG8gPSBrLngsIGsueW8gPSBrLnkpLCBJLnRvdWNoKGspLCB2LnJwMCA9IHYucnAxID0gdztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY24oZCwgdikge1xuICAgICAgICAgICAgdmFyIHcgPSB2LnN0YWNrLCBrID0gdy5wb3AoKSwgSSA9IHYuejJba107XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJHQ1tcIiArIGQgKyBcIl1cIiwgayksIHcucHVzaCg2NCAqIHYuZHB2LmRpc3RhbmNlKEksIGhyLCBkLCAhMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgayA9IHYuc3RhY2ssIHcgPSBrLnBvcCgpLCBrID0gay5wb3AoKSwgSSA9IHYuejFbd10sIE4gPSB2LnowW2tdLCBOID0gdi5kcHYuZGlzdGFuY2UoTiwgSSwgZCwgZCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJNRFtcIiArIGQgKyBcIl1cIiwgdywgaywgXCItPlwiLCBOKSwgdi5zdGFjay5wdXNoKE1hdGgucm91bmQoNjQgKiBOKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGtyKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdi5zdGFjaywgayA9IHcucG9wKCksIEkgPSB2LmZ2LCBOID0gdi5wdiwgeiA9IHYucHBlbSwgUSA9IHYuZGVsdGFCYXNlICsgMTYgKiAoZCAtIDEpLCBzZSA9IHYuZGVsdGFTaGlmdCwgb2UgPSB2LnowO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyh2LnN0ZXAsIFwiREVMVEFQW1wiICsgZCArIFwiXVwiLCBrLCB3KTtcbiAgICAgICAgICAgIGZvciAodmFyIHllID0gMDsgeWUgPCBrOyB5ZSsrKSB7XG4gICAgICAgICAgICAgIHZhciBTZSA9IHcucG9wKCksIGJlID0gdy5wb3AoKTtcbiAgICAgICAgICAgICAgUSArICgoMjQwICYgYmUpID4+IDQpID09PSB6ICYmICgwIDw9IChiZSA9ICgxNSAmIGJlKSAtIDgpICYmIGJlKyssIGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCBcIkRFTFRBUEZJWFwiLCBTZSwgXCJieVwiLCBiZSAqIHNlKSwgU2UgPSBvZVtTZV0sIEkuc2V0UmVsYXRpdmUoU2UsIFNlLCBiZSAqIHNlLCBOKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGpyKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdi5zdGFjaywgayA9IHcucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJST1VORFtdXCIpLCB3LnB1c2goNjQgKiB2LnJvdW5kKGsgLyA2NCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBDcihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IHYuc3RhY2ssIGsgPSB3LnBvcCgpLCBJID0gdi5wcGVtLCBOID0gdi5kZWx0YUJhc2UgKyAxNiAqIChkIC0gMSksIHogPSB2LmRlbHRhU2hpZnQ7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJERUxUQUNbXCIgKyBkICsgXCJdXCIsIGssIHcpO1xuICAgICAgICAgICAgZm9yICh2YXIgUSA9IDA7IFEgPCBrOyBRKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNlID0gdy5wb3AoKSwgb2UgPSB3LnBvcCgpO1xuICAgICAgICAgICAgICBOICsgKCgyNDAgJiBvZSkgPj4gNCkgPT09IEkgJiYgKDAgPD0gKG9lID0gKDE1ICYgb2UpIC0gOCkgJiYgb2UrKywgb2UgPSBvZSAqIHosIGguREVCVUcgJiYgY29uc29sZS5sb2codi5zdGVwLCBcIkRFTFRBQ0ZJWFwiLCBzZSwgXCJieVwiLCBvZSksIHYuY3Z0W3NlXSArPSBvZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGhuKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBJID0gdi5zdGFjaywgayA9IEkucG9wKCksIEkgPSBJLnBvcCgpLCBOID0gdi56MltrXSwgeiA9IHYuejFbSV07XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJTRFBWVExbXCIgKyBkICsgXCJdXCIsIGssIEkpLCBrID0gZCA/ICh3ID0gTi55IC0gei55LCB6LnggLSBOLngpIDogKHcgPSB6LnggLSBOLngsIHoueSAtIE4ueSksIHYuZHB2ID0gZHIodywgayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG9yKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdi5zdGFjaywgayA9IHYucHJvZywgSSA9IHYuaXA7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKHYuc3RlcCwgXCJQVVNIQltcIiArIGQgKyBcIl1cIik7XG4gICAgICAgICAgICBmb3IgKHZhciBOID0gMDsgTiA8IGQ7IE4rKylcbiAgICAgICAgICAgICAgdy5wdXNoKGtbKytJXSk7XG4gICAgICAgICAgICB2LmlwID0gSTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3IoZCwgdikge1xuICAgICAgICAgICAgdmFyIHcgPSB2LmlwLCBrID0gdi5wcm9nLCBJID0gdi5zdGFjaztcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2codi5pcCwgXCJQVVNIV1tcIiArIGQgKyBcIl1cIik7XG4gICAgICAgICAgICBmb3IgKHZhciBOID0gMDsgTiA8IGQ7IE4rKykge1xuICAgICAgICAgICAgICB2YXIgeiA9IGtbKyt3XSA8PCA4IHwga1srK3ddO1xuICAgICAgICAgICAgICAzMjc2OCAmIHogJiYgKHogPSAtKDEgKyAoNjU1MzUgXiB6KSkpLCBJLnB1c2goeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LmlwID0gdztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSmUoZCwgdiwgdywgaywgSSwgTikge1xuICAgICAgICAgICAgdmFyIHosIFEsIG9lID0gTi5zdGFjaywgc2UgPSBkICYmIG9lLnBvcCgpLCBvZSA9IG9lLnBvcCgpLCB5ZSA9IE4ucnAwLCB5ZSA9IE4uejBbeWVdLCBTZSA9IE4uejFbb2VdLCBiZSA9IE4ubWluRGlzLCBkZSA9IE4uZnYsIEllID0gTi5kcHYsIGtlID0geiA9IEllLmRpc3RhbmNlKFNlLCB5ZSwgITAsICEwKSwgQWUgPSAwIDw9IGtlID8gMSA6IC0xO1xuICAgICAgICAgICAga2UgPSBNYXRoLmFicyhrZSksIGQgJiYgKFEgPSBOLmN2dFtzZV0sIGsgJiYgTWF0aC5hYnMoa2UgLSBRKSA8IE4uY3ZDdXRJbiAmJiAoa2UgPSBRKSksIHcgJiYga2UgPCBiZSAmJiAoa2UgPSBiZSksIGsgJiYgKGtlID0gTi5yb3VuZChrZSkpLCBkZS5zZXRSZWxhdGl2ZShTZSwgeWUsIEFlICoga2UsIEllKSwgZGUudG91Y2goU2UpLCBoLkRFQlVHICYmIGNvbnNvbGUubG9nKE4uc3RlcCwgKGQgPyBcIk1JUlBbXCIgOiBcIk1EUlBbXCIpICsgKHYgPyBcIk1cIiA6IFwibVwiKSArICh3ID8gXCI+XCIgOiBcIl9cIikgKyAoayA/IFwiUlwiIDogXCJfXCIpICsgKEkgPT09IDAgPyBcIkdyXCIgOiBJID09PSAxID8gXCJCbFwiIDogSSA9PT0gMiA/IFwiV2hcIiA6IFwiXCIpICsgXCJdXCIsIGQgPyBzZSArIFwiKFwiICsgTi5jdnRbc2VdICsgXCIsXCIgKyBRICsgXCIpXCIgOiBcIlwiLCBvZSwgXCIoZCA9XCIsIHosIFwiLT5cIiwgQWUgKiBrZSwgXCIpXCIpLCBOLnJwMSA9IE4ucnAwLCBOLnJwMiA9IG9lLCB2ICYmIChOLnJwMCA9IG9lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgWHIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgc2l6ZSBpcyBub3QgYSBudW1iZXIhXCIpO1xuICAgICAgICAgICAgaWYgKCEoMiA8IHRoaXMuX2Vycm9yU3RhdGUpKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5mb250LCBrID0gdGhpcy5fcHJlcFN0YXRlO1xuICAgICAgICAgICAgICBpZiAoIWsgfHwgay5wcGVtICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLl9mcGdtU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKCFJKSB7XG4gICAgICAgICAgICAgICAgICBuci5wcm90b3R5cGUgPSBQbiwgKEkgPSB0aGlzLl9mcGdtU3RhdGUgPSBuZXcgbnIoXCJmcGdtXCIsIHcudGFibGVzLmZwZ20pKS5mdW5jcyA9IFtdLCBJLmZvbnQgPSB3LCBoLkRFQlVHICYmIChjb25zb2xlLmxvZyhcIi0tLUVYRUMgRlBHTS0tLVwiKSwgSS5zdGVwID0gLTEpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbHIoSSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChvZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJIaW50aW5nIGVycm9yIGluIEZQR006XCIgKyBvZSksIHZvaWQgKHRoaXMuX2Vycm9yU3RhdGUgPSAzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnIucHJvdG90eXBlID0gSSwgKGsgPSB0aGlzLl9wcmVwU3RhdGUgPSBuZXcgbnIoXCJwcmVwXCIsIHcudGFibGVzLnByZXApKS5wcGVtID0gdjtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IHcudGFibGVzLmN2dDtcbiAgICAgICAgICAgICAgICBpZiAoTilcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHogPSBrLmN2dCA9IG5ldyBBcnJheShOLmxlbmd0aCksIFEgPSB2IC8gdy51bml0c1BlckVtLCBzZSA9IDA7IHNlIDwgTi5sZW5ndGg7IHNlKyspXG4gICAgICAgICAgICAgICAgICAgIHpbc2VdID0gTltzZV0gKiBRO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGsuY3Z0ID0gW107XG4gICAgICAgICAgICAgICAgaC5ERUJVRyAmJiAoY29uc29sZS5sb2coXCItLS1FWEVDIFBSRVAtLS1cIiksIGsuc3RlcCA9IC0xKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbHIoayk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAob2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPCAyICYmIGNvbnNvbGUubG9nKFwiSGludGluZyBlcnJvciBpbiBQUkVQOlwiICsgb2UpLCB0aGlzLl9lcnJvclN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEoMSA8IHRoaXMuX2Vycm9yU3RhdGUpKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTG4oZCwgayk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAob2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPCAxICYmIChjb25zb2xlLmxvZyhcIkhpbnRpbmcgZXJyb3I6XCIgKyBvZSksIGNvbnNvbGUubG9nKFwiTm90ZTogZnVydGhlciBoaW50aW5nIGVycm9ycyBhcmUgc2lsZW5jZWRcIikpLCB0aGlzLl9lcnJvclN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgTG4gPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IHYucHBlbSAvIHYuZm9udC51bml0c1BlckVtLCBrID0gdywgSSA9IGQuY29tcG9uZW50cztcbiAgICAgICAgICAgIGlmIChuci5wcm90b3R5cGUgPSB2LCBJKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIE4gPSB2LmZvbnQsIHogPSBbXSwgUSA9IFtdLCBzZSA9IDA7IHNlIDwgSS5sZW5ndGg7IHNlKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2UgPSBJW3NlXSwgeWUgPSBOLmdseXBocy5nZXQob2UuZ2x5cGhJbmRleCksIFNlID0gbmV3IG5yKFwiZ2x5ZlwiLCB5ZS5pbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGguREVCVUcgJiYgKGNvbnNvbGUubG9nKFwiLS0tRVhFQyBDT01QIFwiICsgc2UgKyBcIi0tLVwiKSwgU2Uuc3RlcCA9IC0xKSwgZm4oeWUsIFNlLCB3LCBrKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiZSA9IE1hdGgucm91bmQob2UuZHggKiB3KSwgZGUgPSBNYXRoLnJvdW5kKG9lLmR5ICogayksIEllID0gU2UuZ1pvbmUsIGtlID0gU2UuY29udG91cnMsIEFlID0gMDsgQWUgPCBJZS5sZW5ndGg7IEFlKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBUZSA9IEllW0FlXTtcbiAgICAgICAgICAgICAgICAgIFRlLnhUb3VjaGVkID0gVGUueVRvdWNoZWQgPSAhMSwgVGUueG8gPSBUZS54ID0gVGUueCArIGJlLCBUZS55byA9IFRlLnkgPSBUZS55ICsgZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBFZSA9IHoubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHoucHVzaC5hcHBseSh6LCBJZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgJGUgPSAwOyAkZSA8IGtlLmxlbmd0aDsgJGUrKylcbiAgICAgICAgICAgICAgICAgIFEucHVzaChrZVskZV0gKyBFZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZC5pbnN0cnVjdGlvbnMgJiYgIVNlLmluaGliaXRHcmlkRml0ICYmICgoU2UgPSBuZXcgbnIoXCJnbHlmXCIsIGQuaW5zdHJ1Y3Rpb25zKSkuZ1pvbmUgPSBTZS56MCA9IFNlLnoxID0gU2UuejIgPSB6LCBTZS5jb250b3VycyA9IFEsIHoucHVzaChuZXcgcnIoMCwgMCksIG5ldyBycihNYXRoLnJvdW5kKGQuYWR2YW5jZVdpZHRoICogdyksIDApKSwgaC5ERUJVRyAmJiAoY29uc29sZS5sb2coXCItLS1FWEVDIENPTVBPU0lURS0tLVwiKSwgU2Uuc3RlcCA9IC0xKSwgbHIoU2UpLCB6Lmxlbmd0aCAtPSAyKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBTZSA9IG5ldyBucihcImdseWZcIiwgZC5pbnN0cnVjdGlvbnMpLCBoLkRFQlVHICYmIChjb25zb2xlLmxvZyhcIi0tLUVYRUMgR0xZUEgtLS1cIiksIFNlLnN0ZXAgPSAtMSksIGZuKGQsIFNlLCB3LCBrKSwgeiA9IFNlLmdab25lO1xuICAgICAgICAgICAgcmV0dXJuIHo7XG4gICAgICAgICAgfSwgZm4gPSBmdW5jdGlvbihkLCB2LCB3LCBrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBJLCBOLCB6LCBRID0gZC5wb2ludHMgfHwgW10sIHNlID0gUS5sZW5ndGgsIG9lID0gdi5nWm9uZSA9IHYuejAgPSB2LnoxID0gdi56MiA9IFtdLCB5ZSA9IHYuY29udG91cnMgPSBbXSwgU2UgPSAwOyBTZSA8IHNlOyBTZSsrKVxuICAgICAgICAgICAgICBJID0gUVtTZV0sIG9lW1NlXSA9IG5ldyBycihJLnggKiB3LCBJLnkgKiBrLCBJLmxhc3RQb2ludE9mQ29udG91ciwgSS5vbkN1cnZlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGJlID0gMDsgYmUgPCBzZTsgYmUrKylcbiAgICAgICAgICAgICAgSSA9IG9lW2JlXSwgTiB8fCAoTiA9IEksIHllLnB1c2goYmUpKSwgSS5sYXN0UG9pbnRPZkNvbnRvdXIgPyAoKEkubmV4dFBvaW50T25Db250b3VyID0gTikucHJldlBvaW50T25Db250b3VyID0gSSwgTiA9IHZvaWQgMCkgOiAoeiA9IG9lW2JlICsgMV0sIChJLm5leHRQb2ludE9uQ29udG91ciA9IHopLnByZXZQb2ludE9uQ29udG91ciA9IEkpO1xuICAgICAgICAgICAgaWYgKCF2LmluaGliaXRHcmlkRml0KSB7XG4gICAgICAgICAgICAgIGlmIChoLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQUk9DRVNTSU5HIEdMWVBIXCIsIHYuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRlID0gMDsgZGUgPCBzZTsgZGUrKylcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRlLCBvZVtkZV0ueCwgb2VbZGVdLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvZS5wdXNoKG5ldyBycigwLCAwKSwgbmV3IHJyKE1hdGgucm91bmQoZC5hZHZhbmNlV2lkdGggKiB3KSwgMCkpLCBscih2KSwgb2UubGVuZ3RoIC09IDIsIGguREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZJTklTSEVEIEdMWVBIXCIsIHYuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEllID0gMDsgSWUgPCBzZTsgSWUrKylcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKEllLCBvZVtJZV0ueCwgb2VbSWVdLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbHIgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQucHJvZztcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgIHZhciB3LCBrID0gdi5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAoZC5pcCA9IDA7IGQuaXAgPCBrOyBkLmlwKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaC5ERUJVRyAmJiBkLnN0ZXArKywgISh3ID0gUm5bdltkLmlwXV0pKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBpbnN0cnVjdGlvbjogMHhcIiArIE51bWJlcih2W2QuaXBdKS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIHcoZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBSbiA9IFtLci5iaW5kKHZvaWQgMCwgdHIpLCBLci5iaW5kKHZvaWQgMCwgZXIpLCBKci5iaW5kKHZvaWQgMCwgdHIpLCBKci5iaW5kKHZvaWQgMCwgZXIpLCAkci5iaW5kKHZvaWQgMCwgdHIpLCAkci5iaW5kKHZvaWQgMCwgZXIpLCBlbi5iaW5kKHZvaWQgMCwgMCksIGVuLmJpbmQodm9pZCAwLCAxKSwgdG4uYmluZCh2b2lkIDAsIDApLCB0bi5iaW5kKHZvaWQgMCwgMSksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gKHcgPSBkLnN0YWNrKS5wb3AoKSwgdyA9IHcucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTUFZGU1tdXCIsIHYsIHcpLCBkLnB2ID0gZC5kcHYgPSBkcih3LCB2KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9ICh3ID0gZC5zdGFjaykucG9wKCksIHcgPSB3LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiU1BWRlNbXVwiLCB2LCB3KSwgZC5mdiA9IGRyKHcsIHYpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IGQucHY7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJHUFZbXVwiKSwgdi5wdXNoKDE2Mzg0ICogdy54KSwgdi5wdXNoKDE2Mzg0ICogdy55KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSBkLmZ2O1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiR0ZWW11cIiksIHYucHVzaCgxNjM4NCAqIHcueCksIHYucHVzaCgxNjM4NCAqIHcueSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZC5mdiA9IGQucHYsIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNGVlRQVltdXCIpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gKHogPSB2LnN0YWNrKS5wb3AoKSwgayA9IHoucG9wKCksIEkgPSB6LnBvcCgpLCBOID0gei5wb3AoKSwgeiA9IHoucG9wKCksIHNlID0gdi56MCwgeWUgPSB2LnoxLCBRID0gc2Vbd10sIHNlID0gc2Vba10sIG9lID0geWVbSV0sIHllID0geWVbTl0sIHYgPSB2LnoyW3pdLCB3ID0gKGguREVCVUcgJiYgY29uc29sZS5sb2coXCJJU0VDVFtdLCBcIiwgdywgaywgSSwgTiwgeiksIFEueCksIGsgPSBRLnksIEkgPSBzZS54LCBOID0gc2UueSwgeiA9IG9lLngsIFEgPSBvZS55LCBzZSA9IHllLngsIG9lID0geWUueSwgeWUgPSAodyAtIEkpICogKFEgLSBvZSkgLSAoayAtIE4pICogKHogLSBzZSksIFNlID0gdyAqIE4gLSBrICogSSwgYmUgPSB6ICogb2UgLSBRICogc2U7XG4gICAgICAgICAgICB2LnggPSAoU2UgKiAoeiAtIHNlKSAtIGJlICogKHcgLSBJKSkgLyB5ZSwgdi55ID0gKFNlICogKFEgLSBvZSkgLSBiZSAqIChrIC0gTikpIC8geWU7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZC5ycDAgPSBkLnN0YWNrLnBvcCgpLCBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTUlAwW11cIiwgZC5ycDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQucnAxID0gZC5zdGFjay5wb3AoKSwgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiU1JQMVtdXCIsIGQucnAxKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLnJwMiA9IGQuc3RhY2sucG9wKCksIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNSUDJbXVwiLCBkLnJwMik7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3dpdGNoIChoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTWlAwW11cIiwgdiksIGQuenAwID0gdikge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZC50Wm9uZSB8fCBicihkKSwgZC56MCA9IGQudFpvbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBkLnowID0gZC5nWm9uZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHpvbmUgcG9pbnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNaUDFbXVwiLCB2KSwgZC56cDEgPSB2KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkLnRab25lIHx8IGJyKGQpLCBkLnoxID0gZC50Wm9uZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGQuejEgPSBkLmdab25lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgem9uZSBwb2ludGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiU1pQMltdXCIsIHYpLCBkLnpwMiA9IHYpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGQudFpvbmUgfHwgYnIoZCksIGQuejIgPSBkLnRab25lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZC56MiA9IGQuZ1pvbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB6b25lIHBvaW50ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3dpdGNoIChoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTWlBTW11cIiwgdiksIGQuenAwID0gZC56cDEgPSBkLnpwMiA9IHYpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGQudFpvbmUgfHwgYnIoZCksIGQuejAgPSBkLnoxID0gZC56MiA9IGQudFpvbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBkLnowID0gZC56MSA9IGQuejIgPSBkLmdab25lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgem9uZSBwb2ludGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQubG9vcCA9IGQuc3RhY2sucG9wKCksIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNMT09QW11cIiwgZC5sb29wKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJSVEdbXVwiKSwgZC5yb3VuZCA9IFlyO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlJUSEdbXVwiKSwgZC5yb3VuZCA9IENuO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNNRFtdXCIsIHYpLCBkLm1pbkRpcyA9IHYgLyA2NDtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJFTFNFW11cIiksIFFyKGQsICExKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJKTVBSW11cIiwgdiksIGQuaXAgKz0gdiAtIDE7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiU0NWVENJW11cIiwgdiksIGQuY3ZDdXRJbiA9IHYgLyA2NDtcbiAgICAgICAgICB9LCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiRFVQW11cIiksIHYucHVzaCh2W3YubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0sIE1yLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJDTEVBUltdXCIpLCBkLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTV0FQW11cIiksIHYucHVzaCh3KSwgdi5wdXNoKGspO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaztcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkRFUFRIW11cIiksIHYucHVzaCh2Lmxlbmd0aCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkNJTkRFWFtdXCIsIHcpLCB2LnB1c2godlt2Lmxlbmd0aCAtIHddKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiTUlOREVYW11cIiwgdyksIHYucHVzaCh2LnNwbGljZSh2Lmxlbmd0aCAtIHcsIDEpWzBdKTtcbiAgICAgICAgICB9LCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IChrID0gZC5zdGFjaykucG9wKCksIHcgPSBrLnBvcCgpLCBrID0gKGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkxPT1BDQUxMW11cIiwgdiwgdyksIGQuaXApLCBJID0gZC5wcm9nO1xuICAgICAgICAgICAgZC5wcm9nID0gZC5mdW5jc1t2XTtcbiAgICAgICAgICAgIGZvciAodmFyIE4gPSAwOyBOIDwgdzsgTisrKVxuICAgICAgICAgICAgICBscihkKSwgaC5ERUJVRyAmJiBjb25zb2xlLmxvZygrK2Quc3RlcCwgTiArIDEgPCB3ID8gXCJuZXh0IGxvb3BjYWxsXCIgOiBcImRvbmUgbG9vcGNhbGxcIiwgTik7XG4gICAgICAgICAgICBkLmlwID0gaywgZC5wcm9nID0gSTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCksIHcgPSAoaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiQ0FMTFtdXCIsIHYpLCBkLmlwKSwgayA9IGQucHJvZztcbiAgICAgICAgICAgIGQucHJvZyA9IGQuZnVuY3Nbdl0sIGxyKGQpLCBkLmlwID0gdywgZC5wcm9nID0gaywgaC5ERUJVRyAmJiBjb25zb2xlLmxvZygrK2Quc3RlcCwgXCJyZXR1cm5pbmcgZnJvbVwiLCB2KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZC5lbnYgIT09IFwiZnBnbVwiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGREVGIG5vdCBhbGxvd2VkIGhlcmVcIik7XG4gICAgICAgICAgICB2YXIgayA9IGQuc3RhY2ssIHYgPSBkLnByb2csIHcgPSBkLmlwLCBrID0gay5wb3AoKSwgSSA9IHc7XG4gICAgICAgICAgICBmb3IgKGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkZERUZbXVwiLCBrKTsgdlsrK3ddICE9PSA0NTsgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBkLmlwID0gdywgZC5mdW5jc1trXSA9IHYuc2xpY2UoSSArIDEsIHcpO1xuICAgICAgICAgIH0sIHZvaWQgMCwgcm4uYmluZCh2b2lkIDAsIDApLCBybi5iaW5kKHZvaWQgMCwgMSksIG5uLmJpbmQodm9pZCAwLCB0ciksIG5uLmJpbmQodm9pZCAwLCBlciksIG9uLmJpbmQodm9pZCAwLCAwKSwgb24uYmluZCh2b2lkIDAsIDEpLCBzbi5iaW5kKHZvaWQgMCwgMCksIHNuLmJpbmQodm9pZCAwLCAxKSwgYW4uYmluZCh2b2lkIDAsIDApLCBhbi5iaW5kKHZvaWQgMCwgMSksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBkLnN0YWNrLCB3ID0gZC5sb29wLCBrID0gZC5mdiwgSSA9IHYucG9wKCkgLyA2NCwgTiA9IGQuejI7IHctLTsgKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gdi5wb3AoKSwgUSA9IE5bel07XG4gICAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCAoMSA8IGQubG9vcCA/IFwibG9vcCBcIiArIChkLmxvb3AgLSB3KSArIFwiOiBcIiA6IFwiXCIpICsgXCJTSFBJWFtdXCIsIHosIEkpLCBrLnNldFJlbGF0aXZlKFEsIFEsIEkpLCBrLnRvdWNoKFEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5sb29wID0gMTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gZC5zdGFjaywgdyA9IGQucnAxLCBrID0gZC5ycDIsIEkgPSBkLmxvb3AsIE4gPSBkLnowW3ddLCB6ID0gZC56MVtrXSwgUSA9IGQuZnYsIHNlID0gZC5kcHYsIG9lID0gZC56MjsgSS0tOyApIHtcbiAgICAgICAgICAgICAgdmFyIHllID0gdi5wb3AoKSwgU2UgPSBvZVt5ZV07XG4gICAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCAoMSA8IGQubG9vcCA/IFwibG9vcCBcIiArIChkLmxvb3AgLSBJKSArIFwiOiBcIiA6IFwiXCIpICsgXCJJUFtdXCIsIHllLCB3LCBcIjwtPlwiLCBrKSwgUS5pbnRlcnBvbGF0ZShTZSwgTiwgeiwgc2UpLCBRLnRvdWNoKFNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQubG9vcCA9IDE7XG4gICAgICAgICAgfSwgbG4uYmluZCh2b2lkIDAsIDApLCBsbi5iaW5kKHZvaWQgMCwgMSksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBkLnN0YWNrLCB3ID0gZC5ycDAsIGsgPSBkLnowW3ddLCBJID0gZC5sb29wLCBOID0gZC5mdiwgeiA9IGQucHYsIFEgPSBkLnoxOyBJLS07ICkge1xuICAgICAgICAgICAgICB2YXIgc2UgPSB2LnBvcCgpLCBvZSA9IFFbc2VdO1xuICAgICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgKDEgPCBkLmxvb3AgPyBcImxvb3AgXCIgKyAoZC5sb29wIC0gSSkgKyBcIjogXCIgOiBcIlwiKSArIFwiQUxJR05SUFtdXCIsIHNlKSwgTi5zZXRSZWxhdGl2ZShvZSwgaywgMCwgeiksIE4udG91Y2gob2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5sb29wID0gMTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJSVERHW11cIiksIGQucm91bmQgPSBrbjtcbiAgICAgICAgICB9LCB1bi5iaW5kKHZvaWQgMCwgMCksIHVuLmJpbmQodm9pZCAwLCAxKSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnByb2csIHcgPSBkLmlwLCBrID0gZC5zdGFjaywgSSA9IHZbKyt3XTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIk5QVVNIQltdXCIsIEkpO1xuICAgICAgICAgICAgZm9yICh2YXIgTiA9IDA7IE4gPCBJOyBOKyspXG4gICAgICAgICAgICAgIGsucHVzaCh2Wysrd10pO1xuICAgICAgICAgICAgZC5pcCA9IHc7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLmlwLCB3ID0gZC5wcm9nLCBrID0gZC5zdGFjaywgSSA9IHdbKyt2XTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIk5QVVNIV1tdXCIsIEkpO1xuICAgICAgICAgICAgZm9yICh2YXIgTiA9IDA7IE4gPCBJOyBOKyspIHtcbiAgICAgICAgICAgICAgdmFyIHogPSB3Wysrdl0gPDwgOCB8IHdbKyt2XTtcbiAgICAgICAgICAgICAgMzI3NjggJiB6ICYmICh6ID0gLSgxICsgKDY1NTM1IF4geikpKSwgay5wdXNoKHopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5pcCA9IHY7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIGsgPSBkLnN0YWNrLCB2ID0gKHYgPSBkLnN0b3JlKSB8fCAoZC5zdG9yZSA9IFtdKSwgdyA9IGsucG9wKCksIGsgPSBrLnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiV1NcIiwgdywgayksIHZba10gPSB3O1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKEkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gSS5zdGFjaywgdyA9IEkuc3RvcmUsIGsgPSB2LnBvcCgpLCBJID0gKGguREVCVUcgJiYgY29uc29sZS5sb2coSS5zdGVwLCBcIlJTXCIsIGspLCB3ICYmIHdba10gfHwgMCk7XG4gICAgICAgICAgICB2LnB1c2goSSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSAodyA9IGQuc3RhY2spLnBvcCgpLCB3ID0gdy5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIldDVlRQXCIsIHYsIHcpLCBkLmN2dFt3XSA9IHYgLyA2NDtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiUkNWVFwiLCB3KSwgdi5wdXNoKDY0ICogZC5jdnRbd10pO1xuICAgICAgICAgIH0sIGNuLmJpbmQodm9pZCAwLCAwKSwgY24uYmluZCh2b2lkIDAsIDEpLCB2b2lkIDAsIGRuLmJpbmQodm9pZCAwLCAwKSwgZG4uYmluZCh2b2lkIDAsIDEpLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJNUFBFTVtdXCIpLCBkLnN0YWNrLnB1c2goZC5wcGVtKTtcbiAgICAgICAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkZMSVBPTltdXCIpLCBkLmF1dG9GbGlwID0gITA7XG4gICAgICAgICAgfSwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiTFRbXVwiLCB3LCBrKSwgdi5wdXNoKGsgPCB3ID8gMSA6IDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiTFRFUVtdXCIsIHcsIGspLCB2LnB1c2goayA8PSB3ID8gMSA6IDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiR1RbXVwiLCB3LCBrKSwgdi5wdXNoKHcgPCBrID8gMSA6IDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiR1RFUVtdXCIsIHcsIGspLCB2LnB1c2godyA8PSBrID8gMSA6IDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiRVFbXVwiLCB3LCBrKSwgdi5wdXNoKHcgPT09IGsgPyAxIDogMCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJORVFbXVwiLCB3LCBrKSwgdi5wdXNoKHcgIT09IGsgPyAxIDogMCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIk9ERFtdXCIsIHcpLCB2LnB1c2goTWF0aC50cnVuYyh3KSAlIDIgPyAxIDogMCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkVWRU5bXVwiLCB3KSwgdi5wdXNoKE1hdGgudHJ1bmModykgJSAyID8gMCA6IDEpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIklGW11cIiwgdiksIHYgfHwgKFFyKGQsICEwKSwgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiRUlGW11cIikpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkVJRltdXCIpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiQU5EW11cIiwgdywgayksIHYucHVzaCh3ICYmIGsgPyAxIDogMCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJPUltdXCIsIHcsIGspLCB2LnB1c2godyB8fCBrID8gMSA6IDApO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJOT1RbXVwiLCB3KSwgdi5wdXNoKHcgPyAwIDogMSk7XG4gICAgICAgICAgfSwga3IuYmluZCh2b2lkIDAsIDEpLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTREJbXVwiLCB2KSwgZC5kZWx0YUJhc2UgPSB2O1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIlNEU1tdXCIsIHYpLCBkLmRlbHRhU2hpZnQgPSBNYXRoLnBvdygwLjUsIHYpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiQUREW11cIiwgdywgayksIHYucHVzaChrICsgdyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTVUJbXVwiLCB3LCBrKSwgdi5wdXNoKGsgLSB3KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSB2LnBvcCgpLCBrID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkRJVltdXCIsIHcsIGspLCB2LnB1c2goNjQgKiBrIC8gdyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJNVUxbXVwiLCB3LCBrKSwgdi5wdXNoKGsgKiB3IC8gNjQpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJBQlNbXVwiLCB3KSwgdi5wdXNoKE1hdGguYWJzKHcpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiTkVHW11cIiwgdyksIHYucHVzaCgtdyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkZMT09SW11cIiwgdyksIHYucHVzaCg2NCAqIE1hdGguZmxvb3IodyAvIDY0KSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKTtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkNFSUxJTkdbXVwiLCB3KSwgdi5wdXNoKDY0ICogTWF0aC5jZWlsKHcgLyA2NCkpO1xuICAgICAgICAgIH0sIGpyLmJpbmQodm9pZCAwLCAwKSwganIuYmluZCh2b2lkIDAsIDEpLCBqci5iaW5kKHZvaWQgMCwgMiksIGpyLmJpbmQodm9pZCAwLCAzKSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9ICh3ID0gZC5zdGFjaykucG9wKCksIHcgPSB3LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiV0NWVEZbXVwiLCB2LCB3KSwgZC5jdnRbd10gPSB2ICogZC5wcGVtIC8gZC5mb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgfSwga3IuYmluZCh2b2lkIDAsIDIpLCBrci5iaW5kKHZvaWQgMCwgMyksIENyLmJpbmQodm9pZCAwLCAxKSwgQ3IuYmluZCh2b2lkIDAsIDIpLCBDci5iaW5kKHZvaWQgMCwgMyksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2LCB3ID0gZC5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiU1JPVU5EW11cIiwgdyksIGQucm91bmQgPSBaciwgMTkyICYgdykge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdiA9IDAuNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICB2ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgdiA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBTUk9VTkQgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGQuc3JQZXJpb2QgPSB2LCA0OCAmIHcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGQuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgZC5zclBoYXNlID0gMC4yNSAqIHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgZC5zclBoYXNlID0gMC41ICogdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgICBkLnNyUGhhc2UgPSAwLjc1ICogdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFNST1VORCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQuc3JUaHJlc2hvbGQgPSAodyAmPSAxNSkgPT09IDAgPyAwIDogKHcgLyA4IC0gMC41KSAqIHY7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYsIHcgPSBkLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3dpdGNoIChoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTNDVST1VORFtdXCIsIHcpLCBkLnJvdW5kID0gWnIsIDE5MiAmIHcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHYgPSBNYXRoLnNxcnQoMikgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIHYgPSBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIHYgPSAyICogTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUzQ1Uk9VTkQgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGQuc3JQZXJpb2QgPSB2LCA0OCAmIHcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGQuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgZC5zclBoYXNlID0gMC4yNSAqIHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgZC5zclBoYXNlID0gMC41ICogdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgICBkLnNyUGhhc2UgPSAwLjc1ICogdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFM0NVJPVU5EIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5zclRocmVzaG9sZCA9ICh3ICY9IDE1KSA9PT0gMCA/IDAgOiAodyAvIDggLSAwLjUpICogdjtcbiAgICAgICAgICB9LCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiUk9GRltdXCIpLCBkLnJvdW5kID0gTW47XG4gICAgICAgICAgfSwgdm9pZCAwLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJSVVRHW11cIiksIGQucm91bmQgPSBPbjtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJSRFRHW11cIiksIGQucm91bmQgPSBBbjtcbiAgICAgICAgICB9LCBNciwgTXIsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTQ0FOQ1RSTFtdXCIsIHYpO1xuICAgICAgICAgIH0sIGhuLmJpbmQodm9pZCAwLCAwKSwgaG4uYmluZCh2b2lkIDAsIDEpLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2ssIHcgPSB2LnBvcCgpLCBrID0gMDtcbiAgICAgICAgICAgIGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIkdFVElORk9bXVwiLCB3KSwgMSAmIHcgJiYgKGsgPSAzNSksIDMyICYgdyAmJiAoayB8PSA0MDk2KSwgdi5wdXNoKGspO1xuICAgICAgICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCksIEkgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiUk9MTFtdXCIpLCB2LnB1c2goayksIHYucHVzaCh3KSwgdi5wdXNoKEkpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjaywgdyA9IHYucG9wKCksIGsgPSB2LnBvcCgpO1xuICAgICAgICAgICAgaC5ERUJVRyAmJiBjb25zb2xlLmxvZyhkLnN0ZXAsIFwiTUFYW11cIiwgdywgayksIHYucHVzaChNYXRoLm1heChrLCB3KSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIHYgPSBkLnN0YWNrLCB3ID0gdi5wb3AoKSwgayA9IHYucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJNSU5bXVwiLCB3LCBrKSwgdi5wdXNoKE1hdGgubWluKGssIHcpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoLkRFQlVHICYmIGNvbnNvbGUubG9nKGQuc3RlcCwgXCJTQ0FOVFlQRVtdXCIsIHYpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gZC5zdGFjay5wb3AoKSwgdyA9IGQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGguREVCVUcgJiYgY29uc29sZS5sb2coZC5zdGVwLCBcIklOU1RDVFJMW11cIiwgdiwgdyksIHYpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChkLmluaGliaXRHcmlkRml0ID0gISF3KTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChkLmlnbm9yZUN2dCA9ICEhdyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBJTlNUQ1RSTFtdIHNlbGVjdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIG9yLmJpbmQodm9pZCAwLCAxKSwgb3IuYmluZCh2b2lkIDAsIDIpLCBvci5iaW5kKHZvaWQgMCwgMyksIG9yLmJpbmQodm9pZCAwLCA0KSwgb3IuYmluZCh2b2lkIDAsIDUpLCBvci5iaW5kKHZvaWQgMCwgNiksIG9yLmJpbmQodm9pZCAwLCA3KSwgb3IuYmluZCh2b2lkIDAsIDgpLCBzci5iaW5kKHZvaWQgMCwgMSksIHNyLmJpbmQodm9pZCAwLCAyKSwgc3IuYmluZCh2b2lkIDAsIDMpLCBzci5iaW5kKHZvaWQgMCwgNCksIHNyLmJpbmQodm9pZCAwLCA1KSwgc3IuYmluZCh2b2lkIDAsIDYpLCBzci5iaW5kKHZvaWQgMCwgNyksIHNyLmJpbmQodm9pZCAwLCA4KSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDAsIDAsIDApLCBKZS5iaW5kKHZvaWQgMCwgMCwgMCwgMCwgMCwgMSksIEplLmJpbmQodm9pZCAwLCAwLCAwLCAwLCAwLCAyKSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDAsIDAsIDMpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMCwgMCwgMSwgMCksIEplLmJpbmQodm9pZCAwLCAwLCAwLCAwLCAxLCAxKSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDAsIDEsIDIpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMCwgMCwgMSwgMyksIEplLmJpbmQodm9pZCAwLCAwLCAwLCAxLCAwLCAwKSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDEsIDAsIDEpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMCwgMSwgMCwgMiksIEplLmJpbmQodm9pZCAwLCAwLCAwLCAxLCAwLCAzKSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDEsIDEsIDApLCBKZS5iaW5kKHZvaWQgMCwgMCwgMCwgMSwgMSwgMSksIEplLmJpbmQodm9pZCAwLCAwLCAwLCAxLCAxLCAyKSwgSmUuYmluZCh2b2lkIDAsIDAsIDAsIDEsIDEsIDMpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMCwgMCwgMCksIEplLmJpbmQodm9pZCAwLCAwLCAxLCAwLCAwLCAxKSwgSmUuYmluZCh2b2lkIDAsIDAsIDEsIDAsIDAsIDIpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMCwgMCwgMyksIEplLmJpbmQodm9pZCAwLCAwLCAxLCAwLCAxLCAwKSwgSmUuYmluZCh2b2lkIDAsIDAsIDEsIDAsIDEsIDEpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMCwgMSwgMiksIEplLmJpbmQodm9pZCAwLCAwLCAxLCAwLCAxLCAzKSwgSmUuYmluZCh2b2lkIDAsIDAsIDEsIDEsIDAsIDApLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMSwgMCwgMSksIEplLmJpbmQodm9pZCAwLCAwLCAxLCAxLCAwLCAyKSwgSmUuYmluZCh2b2lkIDAsIDAsIDEsIDEsIDAsIDMpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMSwgMSwgMCksIEplLmJpbmQodm9pZCAwLCAwLCAxLCAxLCAxLCAxKSwgSmUuYmluZCh2b2lkIDAsIDAsIDEsIDEsIDEsIDIpLCBKZS5iaW5kKHZvaWQgMCwgMCwgMSwgMSwgMSwgMyksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAwLCAwLCAwKSwgSmUuYmluZCh2b2lkIDAsIDEsIDAsIDAsIDAsIDEpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMCwgMCwgMCwgMiksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAwLCAwLCAzKSwgSmUuYmluZCh2b2lkIDAsIDEsIDAsIDAsIDEsIDApLCBKZS5iaW5kKHZvaWQgMCwgMSwgMCwgMCwgMSwgMSksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAwLCAxLCAyKSwgSmUuYmluZCh2b2lkIDAsIDEsIDAsIDAsIDEsIDMpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMCwgMSwgMCwgMCksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAxLCAwLCAxKSwgSmUuYmluZCh2b2lkIDAsIDEsIDAsIDEsIDAsIDIpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMCwgMSwgMCwgMyksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAxLCAxLCAwKSwgSmUuYmluZCh2b2lkIDAsIDEsIDAsIDEsIDEsIDEpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMCwgMSwgMSwgMiksIEplLmJpbmQodm9pZCAwLCAxLCAwLCAxLCAxLCAzKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDAsIDAsIDApLCBKZS5iaW5kKHZvaWQgMCwgMSwgMSwgMCwgMCwgMSksIEplLmJpbmQodm9pZCAwLCAxLCAxLCAwLCAwLCAyKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDAsIDAsIDMpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMSwgMCwgMSwgMCksIEplLmJpbmQodm9pZCAwLCAxLCAxLCAwLCAxLCAxKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDAsIDEsIDIpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMSwgMCwgMSwgMyksIEplLmJpbmQodm9pZCAwLCAxLCAxLCAxLCAwLCAwKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDEsIDAsIDEpLCBKZS5iaW5kKHZvaWQgMCwgMSwgMSwgMSwgMCwgMiksIEplLmJpbmQodm9pZCAwLCAxLCAxLCAxLCAwLCAzKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDEsIDEsIDApLCBKZS5iaW5kKHZvaWQgMCwgMSwgMSwgMSwgMSwgMSksIEplLmJpbmQodm9pZCAwLCAxLCAxLCAxLCAxLCAyKSwgSmUuYmluZCh2b2lkIDAsIDEsIDEsIDEsIDEsIDMpXSwgSW4gPSBBcnJheS5mcm9tIHx8IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm1hdGNoKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdP3xbXlxcdUQ4MDAtXFx1REZGRl18Li9nKSB8fCBbXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIF90KGQpIHtcbiAgICAgICAgICAgIChkID0gZCB8fCB7fSkuZW1wdHkgfHwgKGlyKGQuZmFtaWx5TmFtZSwgXCJXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLlwiKSwgaXIoZC5zdHlsZU5hbWUsIFwiV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgc3R5bGVOYW1lIGlzIHJlcXVpcmVkLlwiKSwgaXIoZC51bml0c1BlckVtLCBcIldoZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHVuaXRzUGVyRW0gaXMgcmVxdWlyZWQuXCIpLCBpcihkLmFzY2VuZGVyLCBcIldoZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLlwiKSwgaXIoZC5kZXNjZW5kZXIsIFwiV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgZGVzY2VuZGVyIGlzIHJlcXVpcmVkLlwiKSwgaXIoZC5kZXNjZW5kZXIgPCAwLCBcIkRlc2NlbmRlciBzaG91bGQgYmUgbmVnYXRpdmUgKGUuZy4gLTUxMikuXCIpLCB0aGlzLm5hbWVzID0geyBmb250RmFtaWx5OiB7IGVuOiBkLmZhbWlseU5hbWUgfHwgXCIgXCIgfSwgZm9udFN1YmZhbWlseTogeyBlbjogZC5zdHlsZU5hbWUgfHwgXCIgXCIgfSwgZnVsbE5hbWU6IHsgZW46IGQuZnVsbE5hbWUgfHwgZC5mYW1pbHlOYW1lICsgXCIgXCIgKyBkLnN0eWxlTmFtZSB9LCBwb3N0U2NyaXB0TmFtZTogeyBlbjogZC5wb3N0U2NyaXB0TmFtZSB8fCAoZC5mYW1pbHlOYW1lICsgZC5zdHlsZU5hbWUpLnJlcGxhY2UoL1xccy9nLCBcIlwiKSB9LCBkZXNpZ25lcjogeyBlbjogZC5kZXNpZ25lciB8fCBcIiBcIiB9LCBkZXNpZ25lclVSTDogeyBlbjogZC5kZXNpZ25lclVSTCB8fCBcIiBcIiB9LCBtYW51ZmFjdHVyZXI6IHsgZW46IGQubWFudWZhY3R1cmVyIHx8IFwiIFwiIH0sIG1hbnVmYWN0dXJlclVSTDogeyBlbjogZC5tYW51ZmFjdHVyZXJVUkwgfHwgXCIgXCIgfSwgbGljZW5zZTogeyBlbjogZC5saWNlbnNlIHx8IFwiIFwiIH0sIGxpY2Vuc2VVUkw6IHsgZW46IGQubGljZW5zZVVSTCB8fCBcIiBcIiB9LCB2ZXJzaW9uOiB7IGVuOiBkLnZlcnNpb24gfHwgXCJWZXJzaW9uIDAuMVwiIH0sIGRlc2NyaXB0aW9uOiB7IGVuOiBkLmRlc2NyaXB0aW9uIHx8IFwiIFwiIH0sIGNvcHlyaWdodDogeyBlbjogZC5jb3B5cmlnaHQgfHwgXCIgXCIgfSwgdHJhZGVtYXJrOiB7IGVuOiBkLnRyYWRlbWFyayB8fCBcIiBcIiB9IH0sIHRoaXMudW5pdHNQZXJFbSA9IGQudW5pdHNQZXJFbSB8fCAxZTMsIHRoaXMuYXNjZW5kZXIgPSBkLmFzY2VuZGVyLCB0aGlzLmRlc2NlbmRlciA9IGQuZGVzY2VuZGVyLCB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBkLmNyZWF0ZWRUaW1lc3RhbXAsIHRoaXMudGFibGVzID0geyBvczI6IHsgdXNXZWlnaHRDbGFzczogZC53ZWlnaHRDbGFzcyB8fCB0aGlzLnVzV2VpZ2h0Q2xhc3Nlcy5NRURJVU0sIHVzV2lkdGhDbGFzczogZC53aWR0aENsYXNzIHx8IHRoaXMudXNXaWR0aENsYXNzZXMuTUVESVVNLCBmc1NlbGVjdGlvbjogZC5mc1NlbGVjdGlvbiB8fCB0aGlzLmZzU2VsZWN0aW9uVmFsdWVzLlJFR1VMQVIgfSB9KSwgdGhpcy5zdXBwb3J0ZWQgPSAhMCwgdGhpcy5nbHlwaHMgPSBuZXcgS2UuR2x5cGhTZXQodGhpcywgZC5nbHlwaHMgfHwgW10pLCB0aGlzLmVuY29kaW5nID0gbmV3IGplKHRoaXMpLCB0aGlzLnBvc2l0aW9uID0gbmV3IHZyKHRoaXMpLCB0aGlzLnN1YnN0aXR1dGlvbiA9IG5ldyAkdCh0aGlzKSwgdGhpcy50YWJsZXMgPSB0aGlzLnRhYmxlcyB8fCB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGludGluZ1wiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oaW50aW5nIHx8ICh0aGlzLm91dGxpbmVzRm9ybWF0ID09PSBcInRydWV0eXBlXCIgPyB0aGlzLl9oaW50aW5nID0gbmV3IFhyKHRoaXMpIDogdm9pZCAwKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHBuKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3LCBrID0gSlNPTi5zdHJpbmdpZnkoZCksIEkgPSAyNTY7XG4gICAgICAgICAgICBmb3IgKHcgaW4gdikge1xuICAgICAgICAgICAgICB2YXIgTiA9IHBhcnNlSW50KHcpO1xuICAgICAgICAgICAgICBpZiAoTiAmJiAhKE4gPCAyNTYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHZbd10pID09PSBrKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE47XG4gICAgICAgICAgICAgICAgSSA8PSBOICYmIChJID0gTiArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdltJXSA9IGQsIEk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChkKSAhPT0gbnVsbDtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoZCk7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLmNoYXJUb0dseXBoID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoZCksIHRoaXMuZ2x5cGhzLmdldChkKSB8fCB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLnN0cmluZ1RvR2x5cGhzID0gZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgdiA9IHYgfHwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucztcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBJbihkKSwgayA9IFtdLCBJID0gMDsgSSA8IHcubGVuZ3RoOyBJICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIE4gPSB3W0ldO1xuICAgICAgICAgICAgICBrLnB1c2godGhpcy5jaGFyVG9HbHlwaEluZGV4KE4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB6ID0gay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodi5mZWF0dXJlcykge1xuICAgICAgICAgICAgICB2YXIgZCA9IHYuc2NyaXB0IHx8IHRoaXMuc3Vic3RpdHV0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCksIFEgPSBbXTtcbiAgICAgICAgICAgICAgdi5mZWF0dXJlcy5saWdhICYmIChRID0gUS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZShcImxpZ2FcIiwgZCwgdi5sYW5ndWFnZSkpKSwgdi5mZWF0dXJlcy5ybGlnICYmIChRID0gUS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZShcInJsaWdcIiwgZCwgdi5sYW5ndWFnZSkpKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2UgPSAwOyBzZSA8IHo7IHNlICs9IDEpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2UgPSAwOyBvZSA8IFEubGVuZ3RoOyBvZSsrKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ZSA9IFFbb2VdLCBTZSA9IHllLnN1YiwgYmUgPSBTZS5sZW5ndGgsIGRlID0gMDsgZGUgPCBiZSAmJiBTZVtkZV0gPT09IGtbc2UgKyBkZV07IClcbiAgICAgICAgICAgICAgICAgICAgZGUrKztcbiAgICAgICAgICAgICAgICAgIGRlID09PSBiZSAmJiAoay5zcGxpY2Uoc2UsIGJlLCB5ZS5ieSksIHogPSB6IC0gYmUgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBJZSA9IG5ldyBBcnJheSh6KSwga2UgPSB0aGlzLmdseXBocy5nZXQoMCksIEFlID0gMDsgQWUgPCB6OyBBZSArPSAxKVxuICAgICAgICAgICAgICBJZVtBZV0gPSB0aGlzLmdseXBocy5nZXQoa1tBZV0pIHx8IGtlO1xuICAgICAgICAgICAgcmV0dXJuIEllO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KGQpO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5uYW1lVG9HbHlwaCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkID0gdGhpcy5uYW1lVG9HbHlwaEluZGV4KGQpLCB0aGlzLmdseXBocy5nZXQoZCkgfHwgdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lID8gdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoZCkgOiBcIlwiO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICBkID0gZC5pbmRleCB8fCBkLCB2ID0gdi5pbmRleCB8fCB2O1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLnBvc2l0aW9uLmRlZmF1bHRLZXJuaW5nVGFibGVzO1xuICAgICAgICAgICAgcmV0dXJuIHcgPyB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZSh3LCBkLCB2KSA6IHRoaXMua2VybmluZ1BhaXJzW2QgKyBcIixcIiArIHZdIHx8IDA7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLmRlZmF1bHRSZW5kZXJPcHRpb25zID0geyBrZXJuaW5nOiAhMCwgZmVhdHVyZXM6IHsgbGlnYTogITAsIHJsaWc6ICEwIH0gfSwgX3QucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEksIE4pIHtcbiAgICAgICAgICAgIHYgPSB2ICE9PSB2b2lkIDAgPyB2IDogMCwgdyA9IHcgIT09IHZvaWQgMCA/IHcgOiAwLCBJID0gSSB8fCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zO1xuICAgICAgICAgICAgdmFyIHosIFEgPSAxIC8gdGhpcy51bml0c1BlckVtICogKGsgPSBrICE9PSB2b2lkIDAgPyBrIDogNzIpLCBzZSA9IHRoaXMuc3RyaW5nVG9HbHlwaHMoZCwgSSk7XG4gICAgICAgICAgICBJLmtlcm5pbmcgJiYgKGQgPSBJLnNjcmlwdCB8fCB0aGlzLnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCksIHogPSB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdUYWJsZXMoZCwgSS5sYW5ndWFnZSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgb2UgPSAwOyBvZSA8IHNlLmxlbmd0aDsgb2UgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeWUgPSBzZVtvZV07XG4gICAgICAgICAgICAgIE4uY2FsbCh0aGlzLCB5ZSwgdiwgdywgaywgSSksIHllLmFkdmFuY2VXaWR0aCAmJiAodiArPSB5ZS5hZHZhbmNlV2lkdGggKiBRKSwgSS5rZXJuaW5nICYmIG9lIDwgc2UubGVuZ3RoIC0gMSAmJiAodiArPSAoeiA/IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKHosIHllLmluZGV4LCBzZVtvZSArIDFdLmluZGV4KSA6IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKHllLCBzZVtvZSArIDFdKSkgKiBRKSwgSS5sZXR0ZXJTcGFjaW5nID8gdiArPSBJLmxldHRlclNwYWNpbmcgKiBrIDogSS50cmFja2luZyAmJiAodiArPSBJLnRyYWNraW5nIC8gMWUzICogayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEkpIHtcbiAgICAgICAgICAgIHZhciBOID0gbmV3IFgoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hHbHlwaChkLCB2LCB3LCBrLCBJLCBmdW5jdGlvbih6LCBRLCBzZSwgb2UpIHtcbiAgICAgICAgICAgICAgeiA9IHouZ2V0UGF0aChRLCBzZSwgb2UsIEksIHRoaXMpLCBOLmV4dGVuZCh6KTtcbiAgICAgICAgICAgIH0pLCBOO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5nZXRQYXRocyA9IGZ1bmN0aW9uKGQsIHYsIHcsIGssIEkpIHtcbiAgICAgICAgICAgIHZhciBOID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoR2x5cGgoZCwgdiwgdywgaywgSSwgZnVuY3Rpb24oeiwgUSwgc2UsIG9lKSB7XG4gICAgICAgICAgICAgIHogPSB6LmdldFBhdGgoUSwgc2UsIG9lLCBJLCB0aGlzKSwgTi5wdXNoKHopO1xuICAgICAgICAgICAgfSksIE47XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLmdldEFkdmFuY2VXaWR0aCA9IGZ1bmN0aW9uKGQsIHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hHbHlwaChkLCAwLCAwLCB2LCB3LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZCwgdiwgdywgaywgSSwgTikge1xuICAgICAgICAgICAgdGhpcy5nZXRQYXRoKHYsIHcsIGssIEksIE4pLmRyYXcoZCk7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihkLCB2LCB3LCBrLCBJLCBOKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hHbHlwaCh2LCB3LCBrLCBJLCBOLCBmdW5jdGlvbih6LCBRLCBzZSwgb2UpIHtcbiAgICAgICAgICAgICAgei5kcmF3UG9pbnRzKGQsIFEsIHNlLCBvZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUuZHJhd01ldHJpY3MgPSBmdW5jdGlvbihkLCB2LCB3LCBrLCBJLCBOKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hHbHlwaCh2LCB3LCBrLCBJLCBOLCBmdW5jdGlvbih6LCBRLCBzZSwgb2UpIHtcbiAgICAgICAgICAgICAgei5kcmF3TWV0cmljcyhkLCBRLCBzZSwgb2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKGQgPSB0aGlzLm5hbWVzW2RdLCBkKVxuICAgICAgICAgICAgICByZXR1cm4gZC5lbjtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIHYodykge1xuICAgICAgICAgICAgICB3ID0gZC5nZXRFbmdsaXNoTmFtZSh3KSwgdyAmJiB3LnRyaW0oKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2KFwiZm9udEZhbWlseVwiKSwgdihcIndlaWdodE5hbWVcIiksIHYoXCJtYW51ZmFjdHVyZXJcIiksIHYoXCJjb3B5cmlnaHRcIiksIHYoXCJ2ZXJzaW9uXCIpLCB0aGlzLnVuaXRzUGVyRW07XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gU24uZm9udFRvVGFibGUodGhpcyk7XG4gICAgICAgICAgfSwgX3QucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRm9udC50b0J1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgRm9udC50b0FycmF5QnVmZmVyIGluc3RlYWQuXCIpLCB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IHRoaXMudG9UYWJsZXMoKS5lbmNvZGUoKSwgdiA9IG5ldyBBcnJheUJ1ZmZlcihkLmxlbmd0aCksIHcgPSBuZXcgVWludDhBcnJheSh2KSwgayA9IDA7IGsgPCBkLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICB3W2tdID0gZFtrXTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sIF90LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRFbmdsaXNoTmFtZShcImZvbnRGYW1pbHlcIiksIHcgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKFwiZm9udFN1YmZhbWlseVwiKSwgayA9IChkID0gZCB8fCB2LnJlcGxhY2UoL1xccy9nLCBcIlwiKSArIFwiLVwiICsgdyArIFwiLm90ZlwiLCB0aGlzLnRvQXJyYXlCdWZmZXIoKSk7XG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyAod2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSwgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKHdpbmRvdy5URU1QT1JBUlksIGsuYnl0ZUxlbmd0aCwgZnVuY3Rpb24oSSkge1xuICAgICAgICAgICAgICBJLnJvb3QuZ2V0RmlsZShkLCB7IGNyZWF0ZTogITAgfSwgZnVuY3Rpb24oTikge1xuICAgICAgICAgICAgICAgIE4uY3JlYXRlV3JpdGVyKGZ1bmN0aW9uKHopIHtcbiAgICAgICAgICAgICAgICAgIHZhciBRID0gbmV3IERhdGFWaWV3KGspLCBRID0gbmV3IEJsb2IoW1FdLCB7IHR5cGU6IFwiZm9udC9vcGVudHlwZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgei53cml0ZShRKSwgei5hZGRFdmVudExpc3RlbmVyKFwid3JpdGVlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSBOLnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgICB9LCAhMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oSSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSS5uYW1lICsgXCI6IFwiICsgSS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pKSA6ICh2ID0gdChcImZzXCIpLCB3ID0gZnVuY3Rpb24oSSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBOID0gbmV3IG0oSS5ieXRlTGVuZ3RoKSwgeiA9IG5ldyBVaW50OEFycmF5KEkpLCBRID0gMDsgUSA8IE4ubGVuZ3RoOyArK1EpXG4gICAgICAgICAgICAgICAgTltRXSA9IHpbUV07XG4gICAgICAgICAgICAgIHJldHVybiBOO1xuICAgICAgICAgICAgfShrKSwgdi53cml0ZUZpbGVTeW5jKGQsIHcpKTtcbiAgICAgICAgICB9LCBfdC5wcm90b3R5cGUuZnNTZWxlY3Rpb25WYWx1ZXMgPSB7IElUQUxJQzogMSwgVU5ERVJTQ09SRTogMiwgTkVHQVRJVkU6IDQsIE9VVExJTkVEOiA4LCBTVFJJS0VPVVQ6IDE2LCBCT0xEOiAzMiwgUkVHVUxBUjogNjQsIFVTRVJfVFlQT19NRVRSSUNTOiAxMjgsIFdXUzogMjU2LCBPQkxJUVVFOiA1MTIgfSwgX3QucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0geyBVTFRSQV9DT05ERU5TRUQ6IDEsIEVYVFJBX0NPTkRFTlNFRDogMiwgQ09OREVOU0VEOiAzLCBTRU1JX0NPTkRFTlNFRDogNCwgTUVESVVNOiA1LCBTRU1JX0VYUEFOREVEOiA2LCBFWFBBTkRFRDogNywgRVhUUkFfRVhQQU5ERUQ6IDgsIFVMVFJBX0VYUEFOREVEOiA5IH0sIF90LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7IFRISU46IDEwMCwgRVhUUkFfTElHSFQ6IDIwMCwgTElHSFQ6IDMwMCwgTk9STUFMOiA0MDAsIE1FRElVTTogNTAwLCBTRU1JX0JPTEQ6IDYwMCwgQk9MRDogNzAwLCBFWFRSQV9CT0xEOiA4MDAsIEJMQUNLOiA5MDAgfTtcbiAgICAgICAgICB2YXIgRG4gPSB7IG1ha2U6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIHZhciB3ID0gbmV3IE1lLlRhYmxlKFwiZnZhclwiLCBbeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJVTE9OR1wiLCB2YWx1ZTogNjU1MzYgfSwgeyBuYW1lOiBcIm9mZnNldFRvRGF0YVwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwiY291bnRTaXplUGFpcnNcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDIgfSwgeyBuYW1lOiBcImF4aXNDb3VudFwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogZC5heGVzLmxlbmd0aCB9LCB7IG5hbWU6IFwiYXhpc1NpemVcIiwgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IDIwIH0sIHsgbmFtZTogXCJpbnN0YW5jZUNvdW50XCIsIHR5cGU6IFwiVVNIT1JUXCIsIHZhbHVlOiBkLmluc3RhbmNlcy5sZW5ndGggfSwgeyBuYW1lOiBcImluc3RhbmNlU2l6ZVwiLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogNCArIDQgKiBkLmF4ZXMubGVuZ3RoIH1dKTtcbiAgICAgICAgICAgIHcub2Zmc2V0VG9EYXRhID0gdy5zaXplT2YoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGssIEksIE4sIHogPSAwOyB6IDwgZC5heGVzLmxlbmd0aDsgeisrKVxuICAgICAgICAgICAgICB3LmZpZWxkcyA9IHcuZmllbGRzLmNvbmNhdCgoayA9IHosIEkgPSBkLmF4ZXNbel0sIE4gPSB2LCBOID0gcG4oSS5uYW1lLCB2KSwgW3sgbmFtZTogXCJ0YWdfXCIgKyBrLCB0eXBlOiBcIlRBR1wiLCB2YWx1ZTogSS50YWcgfSwgeyBuYW1lOiBcIm1pblZhbHVlX1wiICsgaywgdHlwZTogXCJGSVhFRFwiLCB2YWx1ZTogSS5taW5WYWx1ZSA8PCAxNiB9LCB7IG5hbWU6IFwiZGVmYXVsdFZhbHVlX1wiICsgaywgdHlwZTogXCJGSVhFRFwiLCB2YWx1ZTogSS5kZWZhdWx0VmFsdWUgPDwgMTYgfSwgeyBuYW1lOiBcIm1heFZhbHVlX1wiICsgaywgdHlwZTogXCJGSVhFRFwiLCB2YWx1ZTogSS5tYXhWYWx1ZSA8PCAxNiB9LCB7IG5hbWU6IFwiZmxhZ3NfXCIgKyBrLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9LCB7IG5hbWU6IFwibmFtZUlEX1wiICsgaywgdHlwZTogXCJVU0hPUlRcIiwgdmFsdWU6IE4gfV0pKTtcbiAgICAgICAgICAgIGZvciAodmFyIFEgPSAwOyBRIDwgZC5pbnN0YW5jZXMubGVuZ3RoOyBRKyspXG4gICAgICAgICAgICAgIHcuZmllbGRzID0gdy5maWVsZHMuY29uY2F0KGZ1bmN0aW9uKHNlLCBvZSwgeWUsIFNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmUgPSBbeyBuYW1lOiBcIm5hbWVJRF9cIiArIHNlLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogcG4ob2UubmFtZSwgU2UpIH0sIHsgbmFtZTogXCJmbGFnc19cIiArIHNlLCB0eXBlOiBcIlVTSE9SVFwiLCB2YWx1ZTogMCB9XSwgZGUgPSAwOyBkZSA8IHllLmxlbmd0aDsgKytkZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIEllID0geWVbZGVdLnRhZztcbiAgICAgICAgICAgICAgICAgIGJlLnB1c2goeyBuYW1lOiBcImF4aXNfXCIgKyBzZSArIFwiIFwiICsgSWUsIHR5cGU6IFwiRklYRURcIiwgdmFsdWU6IG9lLmNvb3JkaW5hdGVzW0llXSA8PCAxNiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlO1xuICAgICAgICAgICAgICB9KFEsIGQuaW5zdGFuY2VzW1FdLCBkLmF4ZXMsIHYpKTtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH0sIHBhcnNlOiBmdW5jdGlvbihkLCB2LCB3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrLCBJLCBOLCB6LCBRID0gbmV3IHdlLlBhcnNlcihkLCB2KSwgc2UgPSBRLnBhcnNlVUxvbmcoKSwgb2UgPSAoTy5hcmd1bWVudChzZSA9PT0gNjU1MzYsIFwiVW5zdXBwb3J0ZWQgZnZhciB0YWJsZSB2ZXJzaW9uLlwiKSwgUS5wYXJzZU9mZnNldDE2KCkpLCB5ZSA9IChRLnNraXAoXCJ1U2hvcnRcIiwgMSksIFEucGFyc2VVU2hvcnQoKSksIFNlID0gUS5wYXJzZVVTaG9ydCgpLCBiZSA9IFEucGFyc2VVU2hvcnQoKSwgZGUgPSBRLnBhcnNlVVNob3J0KCksIEllID0gW10sIGtlID0gMDsga2UgPCB5ZTsga2UrKylcbiAgICAgICAgICAgICAgSWUucHVzaCgoayA9IGQsIEkgPSB2ICsgb2UgKyBrZSAqIFNlLCBOID0gdywgeiA9IHt9LCBrID0gbmV3IHdlLlBhcnNlcihrLCBJKSwgei50YWcgPSBrLnBhcnNlVGFnKCksIHoubWluVmFsdWUgPSBrLnBhcnNlRml4ZWQoKSwgei5kZWZhdWx0VmFsdWUgPSBrLnBhcnNlRml4ZWQoKSwgei5tYXhWYWx1ZSA9IGsucGFyc2VGaXhlZCgpLCBrLnNraXAoXCJ1U2hvcnRcIiwgMSksIHoubmFtZSA9IE5bay5wYXJzZVVTaG9ydCgpXSB8fCB7fSwgeikpO1xuICAgICAgICAgICAgZm9yICh2YXIgQWUgPSBbXSwgVGUgPSB2ICsgb2UgKyB5ZSAqIFNlLCBFZSA9IDA7IEVlIDwgYmU7IEVlKyspXG4gICAgICAgICAgICAgIEFlLnB1c2goZnVuY3Rpb24oJGUsIGx0LCBldCwgdHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSB7fSwgd3QgPSBuZXcgd2UuUGFyc2VyKCRlLCBsdCk7XG4gICAgICAgICAgICAgICAgZHQubmFtZSA9IHR0W3d0LnBhcnNlVVNob3J0KCldIHx8IHt9LCB3dC5za2lwKFwidVNob3J0XCIsIDEpLCBkdC5jb29yZGluYXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIE90ID0gMDsgT3QgPCBldC5sZW5ndGg7ICsrT3QpXG4gICAgICAgICAgICAgICAgICBkdC5jb29yZGluYXRlc1tldFtPdF0udGFnXSA9IHd0LnBhcnNlRml4ZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHQ7XG4gICAgICAgICAgICAgIH0oZCwgVGUgKyBFZSAqIGRlLCBJZSwgdykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYXhlczogSWUsIGluc3RhbmNlczogQWUgfTtcbiAgICAgICAgICB9IH0sIFp0ID0gbmV3IEFycmF5KDEwKTtcbiAgICAgICAgICBadFsxXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQsIHYgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gMSA/IHsgcG9zRm9ybWF0OiAxLCBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIodmUuY292ZXJhZ2UpLCB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKCkgfSA6IHYgPT09IDIgPyB7IHBvc0Zvcm1hdDogMiwgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKHZlLmNvdmVyYWdlKSwgdmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmRMaXN0KCkgfSA6IHZvaWQgTy5hc3NlcnQoITEsIFwiMHhcIiArIGQudG9TdHJpbmcoMTYpICsgXCI6IEdQT1MgbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuXCIpO1xuICAgICAgICAgIH0sIFp0WzJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCwgdiwgdywgaywgTiA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCwgSSA9IHRoaXMucGFyc2VVU2hvcnQoKSwgTiA9IChPLmFzc2VydChJID09PSAxIHx8IEkgPT09IDIsIFwiMHhcIiArIE4udG9TdHJpbmcoMTYpICsgXCI6IEdQT1MgbG9va3VwIHR5cGUgMiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuXCIpLCB0aGlzLnBhcnNlUG9pbnRlcih2ZS5jb3ZlcmFnZSkpLCB6ID0gdGhpcy5wYXJzZVVTaG9ydCgpLCBRID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIEkgPT09IDEgPyB7IHBvc0Zvcm1hdDogSSwgY292ZXJhZ2U6IE4sIHZhbHVlRm9ybWF0MTogeiwgdmFsdWVGb3JtYXQyOiBRLCBwYWlyU2V0czogdGhpcy5wYXJzZUxpc3QodmUucG9pbnRlcih2ZS5saXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBzZWNvbmRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLCB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh6KSwgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoUSkgfTtcbiAgICAgICAgICAgIH0pKSkgfSA6IEkgPT09IDIgPyAoZCA9IHRoaXMucGFyc2VQb2ludGVyKHZlLmNsYXNzRGVmKSwgdiA9IHRoaXMucGFyc2VQb2ludGVyKHZlLmNsYXNzRGVmKSwgdyA9IHRoaXMucGFyc2VVU2hvcnQoKSwgayA9IHRoaXMucGFyc2VVU2hvcnQoKSwgeyBwb3NGb3JtYXQ6IEksIGNvdmVyYWdlOiBOLCB2YWx1ZUZvcm1hdDE6IHosIHZhbHVlRm9ybWF0MjogUSwgY2xhc3NEZWYxOiBkLCBjbGFzc0RlZjI6IHYsIGNsYXNzMUNvdW50OiB3LCBjbGFzczJDb3VudDogaywgY2xhc3NSZWNvcmRzOiB0aGlzLnBhcnNlTGlzdCh3LCB2ZS5saXN0KGssIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh6KSwgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoUSkgfTtcbiAgICAgICAgICAgIH0pKSB9KSA6IHZvaWQgMDtcbiAgICAgICAgICB9LCBadFszXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgNCBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs1XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgNSBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs2XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs3XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgNyBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs4XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgOCBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9LCBadFs5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkXCIgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBGbiA9IG5ldyBBcnJheSgxMCksIFVuID0geyBwYXJzZTogZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPSAoZCA9IG5ldyB2ZShkLCB2ID0gdiB8fCAwKSkucGFyc2VWZXJzaW9uKDEpLCBPLmFyZ3VtZW50KHYgPT09IDEgfHwgdiA9PT0gMS4xLCBcIlVuc3VwcG9ydGVkIEdQT1MgdGFibGUgdmVyc2lvbiBcIiArIHYpLCB2ID09PSAxID8geyB2ZXJzaW9uOiB2LCBzY3JpcHRzOiBkLnBhcnNlU2NyaXB0TGlzdCgpLCBmZWF0dXJlczogZC5wYXJzZUZlYXR1cmVMaXN0KCksIGxvb2t1cHM6IGQucGFyc2VMb29rdXBMaXN0KFp0KSB9IDogeyB2ZXJzaW9uOiB2LCBzY3JpcHRzOiBkLnBhcnNlU2NyaXB0TGlzdCgpLCBmZWF0dXJlczogZC5wYXJzZUZlYXR1cmVMaXN0KCksIGxvb2t1cHM6IGQucGFyc2VMb29rdXBMaXN0KFp0KSwgdmFyaWF0aW9uczogZC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpIH07XG4gICAgICAgICAgfSwgbWFrZTogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZS5UYWJsZShcIkdQT1NcIiwgW3sgbmFtZTogXCJ2ZXJzaW9uXCIsIHR5cGU6IFwiVUxPTkdcIiwgdmFsdWU6IDY1NTM2IH0sIHsgbmFtZTogXCJzY3JpcHRzXCIsIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IG5ldyBNZS5TY3JpcHRMaXN0KGQuc2NyaXB0cykgfSwgeyBuYW1lOiBcImZlYXR1cmVzXCIsIHR5cGU6IFwiVEFCTEVcIiwgdmFsdWU6IG5ldyBNZS5GZWF0dXJlTGlzdChkLmZlYXR1cmVzKSB9LCB7IG5hbWU6IFwibG9va3Vwc1wiLCB0eXBlOiBcIlRBQkxFXCIsIHZhbHVlOiBuZXcgTWUuTG9va3VwTGlzdChkLmxvb2t1cHMsIEZuKSB9XSk7XG4gICAgICAgICAgfSB9LCBObiA9IHsgcGFyc2U6IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgICAgIGlmIChkID0gbmV3IHdlLlBhcnNlcihkLCB2KSwgKHYgPSBkLnBhcnNlVVNob3J0KCkpID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gZCwgayA9IHt9LCBTZSA9ICh3LnNraXAoXCJ1U2hvcnRcIiksIHcucGFyc2VVU2hvcnQoKSksIEkgPSAoTy5hcmd1bWVudChTZSA9PT0gMCwgXCJVbnN1cHBvcnRlZCBrZXJuIHN1Yi10YWJsZSB2ZXJzaW9uLlwiKSwgdy5za2lwKFwidVNob3J0XCIsIDIpLCB3LnBhcnNlVVNob3J0KCkpO1xuICAgICAgICAgICAgICB3LnNraXAoXCJ1U2hvcnRcIiwgMyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIE4gPSAwOyBOIDwgSTsgTiArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB3LnBhcnNlVVNob3J0KCksIFEgPSB3LnBhcnNlVVNob3J0KCksIHNlID0gdy5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAga1t6ICsgXCIsXCIgKyBRXSA9IHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYgIT09IDEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbiAoXCIgKyB2ICsgXCIpLlwiKTtcbiAgICAgICAgICAgIHZhciBvZSA9IGQsIHllID0ge30sIFNlID0gKG9lLnNraXAoXCJ1U2hvcnRcIiksIDEgPCBvZS5wYXJzZVVMb25nKCkgJiYgY29uc29sZS53YXJuKFwiT25seSB0aGUgZmlyc3Qga2VybiBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQuXCIpLCBvZS5za2lwKFwidUxvbmdcIiksIDI1NSAmIG9lLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICAgICAgaWYgKG9lLnNraXAoXCJ1U2hvcnRcIiksIFNlID09IDApIHtcbiAgICAgICAgICAgICAgdmFyIGJlID0gb2UucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgb2Uuc2tpcChcInVTaG9ydFwiLCAzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZGUgPSAwOyBkZSA8IGJlOyBkZSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIEllID0gb2UucGFyc2VVU2hvcnQoKSwga2UgPSBvZS5wYXJzZVVTaG9ydCgpLCBBZSA9IG9lLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB5ZVtJZSArIFwiLFwiICsga2VdID0gQWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5ZTtcbiAgICAgICAgICB9IH0sIEJuID0geyBwYXJzZTogZnVuY3Rpb24oZCwgdiwgdywgaykge1xuICAgICAgICAgICAgZm9yICh2YXIgSSA9IG5ldyB3ZS5QYXJzZXIoZCwgdiksIE4gPSBrID8gSS5wYXJzZVVTaG9ydCA6IEkucGFyc2VVTG9uZywgeiA9IFtdLCBRID0gMDsgUSA8IHcgKyAxOyBRICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHNlID0gTi5jYWxsKEkpO1xuICAgICAgICAgICAgICBrICYmIChzZSAqPSAyKSwgei5wdXNoKHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6O1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgICBmdW5jdGlvbiBHbihkLCB2KSB7XG4gICAgICAgICAgICB0KFwiZnNcIikucmVhZEZpbGUoZCwgZnVuY3Rpb24odywgaykge1xuICAgICAgICAgICAgICBpZiAodylcbiAgICAgICAgICAgICAgICByZXR1cm4gdih3Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB2KG51bGwsIHpyKGspKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBWbihkLCB2KSB7XG4gICAgICAgICAgICB2YXIgdyA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgdy5vcGVuKFwiZ2V0XCIsIGQsICEwKSwgdy5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCIsIHcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3LnJlc3BvbnNlID8gdihudWxsLCB3LnJlc3BvbnNlKSA6IHYoXCJGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6IFwiICsgdy5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgIH0sIHcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2KFwiRm9udCBjb3VsZCBub3QgYmUgbG9hZGVkXCIpO1xuICAgICAgICAgICAgfSwgdy5zZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG1uKGQsIHYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBbXSwgayA9IDEyLCBJID0gMDsgSSA8IHY7IEkgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgTiA9IHdlLmdldFRhZyhkLCBrKSwgeiA9IHdlLmdldFVMb25nKGQsIGsgKyA0KSwgUSA9IHdlLmdldFVMb25nKGQsIGsgKyA4KSwgc2UgPSB3ZS5nZXRVTG9uZyhkLCBrICsgMTIpO1xuICAgICAgICAgICAgICB3LnB1c2goeyB0YWc6IE4sIGNoZWNrc3VtOiB6LCBvZmZzZXQ6IFEsIGxlbmd0aDogc2UsIGNvbXByZXNzaW9uOiAhMSB9KSwgayArPSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBMdCh3LCB2KSB7XG4gICAgICAgICAgICBpZiAodi5jb21wcmVzc2lvbiAhPT0gXCJXT0ZGXCIpXG4gICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHcsIG9mZnNldDogdi5vZmZzZXQgfTtcbiAgICAgICAgICAgIHZhciB3ID0gbmV3IFVpbnQ4QXJyYXkody5idWZmZXIsIHYub2Zmc2V0ICsgMiwgdi5jb21wcmVzc2VkTGVuZ3RoIC0gMiksIGsgPSBuZXcgVWludDhBcnJheSh2Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoRyh3LCBrKSwgay5ieXRlTGVuZ3RoICE9PSB2Lmxlbmd0aClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjb21wcmVzc2lvbiBlcnJvcjogXCIgKyB2LnRhZyArIFwiIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc24ndCBtYXRjaCByZWNvcmRlZCBsZW5ndGhcIik7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBuZXcgRGF0YVZpZXcoay5idWZmZXIsIDApLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gT3IoRWUpIHtcbiAgICAgICAgICAgIHZhciB2LCB3LCBrLCBJLCBOLCB6LCBRLCBzZSwgb2UsIHllLCBTZSwgYmUsIGRlLCBJZSwga2UgPSBuZXcgX3QoeyBlbXB0eTogITAgfSksIEFlID0gbmV3IERhdGFWaWV3KEVlLCAwKSwgVGUgPSBbXSwgRWUgPSB3ZS5nZXRUYWcoQWUsIDApO1xuICAgICAgICAgICAgaWYgKEVlID09PSBcIlxcMFx1MDAwMVxcMFxcMFwiIHx8IEVlID09PSBcInRydWVcIiB8fCBFZSA9PT0gXCJ0eXAxXCIpXG4gICAgICAgICAgICAgIGtlLm91dGxpbmVzRm9ybWF0ID0gXCJ0cnVldHlwZVwiLCBUZSA9IG1uKEFlLCBrID0gd2UuZ2V0VVNob3J0KEFlLCA0KSk7XG4gICAgICAgICAgICBlbHNlIGlmIChFZSA9PT0gXCJPVFRPXCIpXG4gICAgICAgICAgICAgIGtlLm91dGxpbmVzRm9ybWF0ID0gXCJjZmZcIiwgVGUgPSBtbihBZSwgayA9IHdlLmdldFVTaG9ydChBZSwgNCkpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChFZSAhPT0gXCJ3T0ZGXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgT3BlblR5cGUgc2lnbmF0dXJlIFwiICsgRWUpO1xuICAgICAgICAgICAgICB2YXIgJGUgPSB3ZS5nZXRUYWcoQWUsIDQpO1xuICAgICAgICAgICAgICBpZiAoJGUgPT09IFwiXFwwXHUwMDAxXFwwXFwwXCIpXG4gICAgICAgICAgICAgICAga2Uub3V0bGluZXNGb3JtYXQgPSBcInRydWV0eXBlXCI7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkZSAhPT0gXCJPVFRPXCIpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBPcGVuVHlwZSBmbGF2b3IgXCIgKyBFZSk7XG4gICAgICAgICAgICAgICAga2Uub3V0bGluZXNGb3JtYXQgPSBcImNmZlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFRlID0gZnVuY3Rpb24oU3QsIHZ0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcXQgPSBbXSwga3QgPSA0NCwgenQgPSAwOyB6dCA8IHZ0OyB6dCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgVHQgPSB3ZS5nZXRUYWcoU3QsIGt0KSwgR3QgPSB3ZS5nZXRVTG9uZyhTdCwga3QgKyA0KSwgZnIgPSB3ZS5nZXRVTG9uZyhTdCwga3QgKyA4KSwgdXIgPSB3ZS5nZXRVTG9uZyhTdCwga3QgKyAxMiksIHluID0gdm9pZCAwLCB5biA9IGZyIDwgdXIgJiYgXCJXT0ZGXCI7XG4gICAgICAgICAgICAgICAgICBxdC5wdXNoKHsgdGFnOiBUdCwgb2Zmc2V0OiBHdCwgY29tcHJlc3Npb246IHluLCBjb21wcmVzc2VkTGVuZ3RoOiBmciwgbGVuZ3RoOiB1ciB9KSwga3QgKz0gMjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxdDtcbiAgICAgICAgICAgICAgfShBZSwgayA9IHdlLmdldFVTaG9ydChBZSwgMTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGx0ID0gMDsgbHQgPCBrOyBsdCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBldCA9IFRlW2x0XSwgdHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZXQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNtYXBcIjpcbiAgICAgICAgICAgICAgICAgIHR0ID0gTHQoQWUsIGV0KSwga2UudGFibGVzLmNtYXAgPSBaLnBhcnNlKHR0LmRhdGEsIHR0Lm9mZnNldCksIGtlLmVuY29kaW5nID0gbmV3IENlKGtlLnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjdnQgXCI6XG4gICAgICAgICAgICAgICAgICB0dCA9IEx0KEFlLCBldCksIEllID0gbmV3IHdlLlBhcnNlcih0dC5kYXRhLCB0dC5vZmZzZXQpLCBrZS50YWJsZXMuY3Z0ID0gSWUucGFyc2VTaG9ydExpc3QoZXQubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnZhclwiOlxuICAgICAgICAgICAgICAgICAgTiA9IGV0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZwZ21cIjpcbiAgICAgICAgICAgICAgICAgIHR0ID0gTHQoQWUsIGV0KSwgSWUgPSBuZXcgd2UuUGFyc2VyKHR0LmRhdGEsIHR0Lm9mZnNldCksIGtlLnRhYmxlcy5mcGdtID0gSWUucGFyc2VCeXRlTGlzdChldC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICAgICAgICAgIHR0ID0gTHQoQWUsIGV0KSwga2UudGFibGVzLmhlYWQgPSBwdC5wYXJzZSh0dC5kYXRhLCB0dC5vZmZzZXQpLCBrZS51bml0c1BlckVtID0ga2UudGFibGVzLmhlYWQudW5pdHNQZXJFbSwgdiA9IGtlLnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGhlYVwiOlxuICAgICAgICAgICAgICAgICAgdHQgPSBMdChBZSwgZXQpLCBrZS50YWJsZXMuaGhlYSA9IGllLnBhcnNlKHR0LmRhdGEsIHR0Lm9mZnNldCksIGtlLmFzY2VuZGVyID0ga2UudGFibGVzLmhoZWEuYXNjZW5kZXIsIGtlLmRlc2NlbmRlciA9IGtlLnRhYmxlcy5oaGVhLmRlc2NlbmRlciwga2UubnVtYmVyT2ZITWV0cmljcyA9IGtlLnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaG10eFwiOlxuICAgICAgICAgICAgICAgICAgb2UgPSBldDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsdGFnXCI6XG4gICAgICAgICAgICAgICAgICB0dCA9IEx0KEFlLCBldCksIHcgPSBHZS5wYXJzZSh0dC5kYXRhLCB0dC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1heHBcIjpcbiAgICAgICAgICAgICAgICAgIHR0ID0gTHQoQWUsIGV0KSwga2UudGFibGVzLm1heHAgPSBMZS5wYXJzZSh0dC5kYXRhLCB0dC5vZmZzZXQpLCBrZS5udW1HbHlwaHMgPSBrZS50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgYmUgPSBldDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJPUy8yXCI6XG4gICAgICAgICAgICAgICAgICB0dCA9IEx0KEFlLCBldCksIGtlLnRhYmxlcy5vczIgPSBCdC5wYXJzZSh0dC5kYXRhLCB0dC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBvc3RcIjpcbiAgICAgICAgICAgICAgICAgIHR0ID0gTHQoQWUsIGV0KSwga2UudGFibGVzLnBvc3QgPSBMci5wYXJzZSh0dC5kYXRhLCB0dC5vZmZzZXQpLCBrZS5nbHlwaE5hbWVzID0gbmV3IE5lKGtlLnRhYmxlcy5wb3N0KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVwXCI6XG4gICAgICAgICAgICAgICAgICB0dCA9IEx0KEFlLCBldCksIEllID0gbmV3IHdlLlBhcnNlcih0dC5kYXRhLCB0dC5vZmZzZXQpLCBrZS50YWJsZXMucHJlcCA9IEllLnBhcnNlQnl0ZUxpc3QoZXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnbHlmXCI6XG4gICAgICAgICAgICAgICAgICB6ID0gZXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibG9jYVwiOlxuICAgICAgICAgICAgICAgICAgU2UgPSBldDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDRkYgXCI6XG4gICAgICAgICAgICAgICAgICBJID0gZXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwia2VyblwiOlxuICAgICAgICAgICAgICAgICAgeWUgPSBldDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHUE9TXCI6XG4gICAgICAgICAgICAgICAgICBRID0gZXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiR1NVQlwiOlxuICAgICAgICAgICAgICAgICAgc2UgPSBldDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgICAgICAgICBkZSA9IGV0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJGUgPSBMdChBZSwgYmUpLCBrZS50YWJsZXMubmFtZSA9IFh0LnBhcnNlKCRlLmRhdGEsICRlLm9mZnNldCwgdyksIGtlLm5hbWVzID0ga2UudGFibGVzLm5hbWUsIHogJiYgU2UpXG4gICAgICAgICAgICAgIEVlID0gdiA9PT0gMCwgJGUgPSBMdChBZSwgU2UpLCAkZSA9IEJuLnBhcnNlKCRlLmRhdGEsICRlLm9mZnNldCwga2UubnVtR2x5cGhzLCBFZSksIEVlID0gTHQoQWUsIHopLCBrZS5nbHlwaHMgPSBxci5wYXJzZShFZS5kYXRhLCBFZS5vZmZzZXQsICRlLCBrZSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFJKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZG9lc24ndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy5cIik7XG4gICAgICAgICAgICAgIEVlID0gTHQoQWUsIEkpLCBmdC5wYXJzZShFZS5kYXRhLCBFZS5vZmZzZXQsIGtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyICRlID0gTHQoQWUsIG9lKSwgZHQgPSAoT2UucGFyc2UoJGUuZGF0YSwgJGUub2Zmc2V0LCBrZS5udW1iZXJPZkhNZXRyaWNzLCBrZS5udW1HbHlwaHMsIGtlLmdseXBocyksIGtlKSwgd3QgPSBkdC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwLCBPdCA9IE9iamVjdC5rZXlzKHd0KSwgUnQgPSAwOyBSdCA8IE90Lmxlbmd0aDsgUnQgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgSHQsIFd0ID0gT3RbUnRdLCBRdCA9IHd0W1d0XTtcbiAgICAgICAgICAgICAgKEh0ID0gZHQuZ2x5cGhzLmdldChRdCkpLmFkZFVuaWNvZGUocGFyc2VJbnQoV3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHh0ID0gMDsgeHQgPCBkdC5nbHlwaHMubGVuZ3RoOyB4dCArPSAxKVxuICAgICAgICAgICAgICBIdCA9IGR0LmdseXBocy5nZXQoeHQpLCBkdC5jZmZFbmNvZGluZyA/IGR0LmlzQ0lERm9udCA/IEh0Lm5hbWUgPSBcImdpZFwiICsgeHQgOiBIdC5uYW1lID0gZHQuY2ZmRW5jb2RpbmcuY2hhcnNldFt4dF0gOiBkdC5nbHlwaE5hbWVzLm5hbWVzICYmIChIdC5uYW1lID0gZHQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKHh0KSk7XG4gICAgICAgICAgICByZXR1cm4geWUgPyAoRWUgPSBMdChBZSwgeWUpLCBrZS5rZXJuaW5nUGFpcnMgPSBObi5wYXJzZShFZS5kYXRhLCBFZS5vZmZzZXQpKSA6IGtlLmtlcm5pbmdQYWlycyA9IHt9LCBRICYmICgkZSA9IEx0KEFlLCBRKSwga2UudGFibGVzLmdwb3MgPSBVbi5wYXJzZSgkZS5kYXRhLCAkZS5vZmZzZXQpLCBrZS5wb3NpdGlvbi5pbml0KCkpLCBzZSAmJiAoRWUgPSBMdChBZSwgc2UpLCBrZS50YWJsZXMuZ3N1YiA9IFJyLnBhcnNlKEVlLmRhdGEsIEVlLm9mZnNldCkpLCBOICYmICgkZSA9IEx0KEFlLCBOKSwga2UudGFibGVzLmZ2YXIgPSBEbi5wYXJzZSgkZS5kYXRhLCAkZS5vZmZzZXQsIGtlLm5hbWVzKSksIGRlICYmIChFZSA9IEx0KEFlLCBkZSksIGtlLnRhYmxlcy5tZXRhID0gSXIucGFyc2UoRWUuZGF0YSwgRWUub2Zmc2V0KSwga2UubWV0YXMgPSBrZS50YWJsZXMubWV0YSksIGtlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoLkZvbnQgPSBfdCwgaC5HbHlwaCA9IFdlLCBoLlBhdGggPSBYLCBoLkJvdW5kaW5nQm94ID0gVywgaC5fcGFyc2UgPSB3ZSwgaC5wYXJzZSA9IE9yLCBoLmxvYWQgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgICAodHlwZW9mIHdpbmRvdyA+IFwidVwiID8gR24gOiBWbikoZCwgZnVuY3Rpb24odywgaykge1xuICAgICAgICAgICAgICBpZiAodylcbiAgICAgICAgICAgICAgICByZXR1cm4gdih3KTtcbiAgICAgICAgICAgICAgdmFyIEk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgSSA9IE9yKGspO1xuICAgICAgICAgICAgICB9IGNhdGNoIChOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYoTiwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHYobnVsbCwgSSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBoLmxvYWRTeW5jID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9yKHpyKHQoXCJmc1wiKS5yZWFkRmlsZVN5bmMoZCkpKTtcbiAgICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgICB9LCB1KHR5cGVvZiBDID09IFwib2JqZWN0XCIgJiYgSCAhPT0gdm9pZCAwID8gQyA6IHkub3BlbnR5cGUgPSB7fSk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHQoXCJidWZmZXJcIikuQnVmZmVyKTtcbiAgICB9LCB7IGJ1ZmZlcjogNCwgZnM6IDIgfV0sIDI1NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIChmdW5jdGlvbihtKSB7XG4gICAgICAgIGZ1bmN0aW9uIHkoZywgZikge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBzID0gZy5sZW5ndGggLSAxOyAwIDw9IHM7IHMtLSkge1xuICAgICAgICAgICAgdmFyIG8gPSBnW3NdO1xuICAgICAgICAgICAgbyA9PT0gXCIuXCIgPyBnLnNwbGljZShzLCAxKSA6IG8gPT09IFwiLi5cIiA/IChnLnNwbGljZShzLCAxKSwgcisrKSA6IHIgJiYgKGcuc3BsaWNlKHMsIDEpLCByLS0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIGZvciAoOyByLS07IClcbiAgICAgICAgICAgICAgZy51bnNoaWZ0KFwiLi5cIik7XG4gICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdShnLCBmKSB7XG4gICAgICAgICAgaWYgKGcuZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIGcuZmlsdGVyKGYpO1xuICAgICAgICAgIGZvciAodmFyIHIgPSBbXSwgcyA9IDA7IHMgPCBnLmxlbmd0aDsgcysrKVxuICAgICAgICAgICAgZihnW3NdLCBzLCBnKSAmJiByLnB1c2goZ1tzXSk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgQy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgZyA9IFwiXCIsIGYgPSAhMSwgciA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyAtMSA8PSByICYmICFmOyByLS0pIHtcbiAgICAgICAgICAgIHZhciBzID0gMCA8PSByID8gYXJndW1lbnRzW3JdIDogbS5jd2QoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcIik7XG4gICAgICAgICAgICBzICYmIChnID0gcyArIFwiL1wiICsgZywgZiA9IHMuY2hhckF0KDApID09PSBcIi9cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoZiA/IFwiL1wiIDogXCJcIikgKyAoZyA9IHkodShnLnNwbGl0KFwiL1wiKSwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgcmV0dXJuICEhbztcbiAgICAgICAgICB9KSwgIWYpLmpvaW4oXCIvXCIpKSB8fCBcIi5cIjtcbiAgICAgICAgfSwgQy5ub3JtYWxpemUgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgdmFyIGYgPSBDLmlzQWJzb2x1dGUoZyksIHIgPSBoKGcsIC0xKSA9PT0gXCIvXCI7XG4gICAgICAgICAgcmV0dXJuIChnID0gKGcgPSB5KHUoZy5zcGxpdChcIi9cIiksIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXM7XG4gICAgICAgICAgfSksICFmKS5qb2luKFwiL1wiKSkgfHwgZiA/IGcgOiBcIi5cIikgJiYgciAmJiAoZyArPSBcIi9cIiksIChmID8gXCIvXCIgOiBcIlwiKSArIGc7XG4gICAgICAgIH0sIEMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICByZXR1cm4gZy5jaGFyQXQoMCkgPT09IFwiL1wiO1xuICAgICAgICB9LCBDLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgcmV0dXJuIEMubm9ybWFsaXplKHUoZywgZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgIH0pLmpvaW4oXCIvXCIpKTtcbiAgICAgICAgfSwgQy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgICBmdW5jdGlvbiByKGMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYy5sZW5ndGggJiYgY1twXSA9PT0gXCJcIjsgcCsrKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gYy5sZW5ndGggLSAxOyAwIDw9IGogJiYgY1tqXSA9PT0gXCJcIjsgai0tKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gaiA8IHAgPyBbXSA6IGMuc2xpY2UocCwgaiAtIHAgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZyA9IEMucmVzb2x2ZShnKS5zdWJzdHIoMSksIGYgPSBDLnJlc29sdmUoZikuc3Vic3RyKDEpO1xuICAgICAgICAgIGZvciAodmFyIHMgPSByKGcuc3BsaXQoXCIvXCIpKSwgbyA9IHIoZi5zcGxpdChcIi9cIikpLCBpID0gTWF0aC5taW4ocy5sZW5ndGgsIG8ubGVuZ3RoKSwgbCA9IGksIG4gPSAwOyBuIDwgaTsgbisrKVxuICAgICAgICAgICAgaWYgKHNbbl0gIT09IG9bbl0pIHtcbiAgICAgICAgICAgICAgbCA9IG47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbiA9IGw7IG4gPCBzLmxlbmd0aDsgbisrKVxuICAgICAgICAgICAgYS5wdXNoKFwiLi5cIik7XG4gICAgICAgICAgcmV0dXJuIChhID0gYS5jb25jYXQoby5zbGljZShsKSkpLmpvaW4oXCIvXCIpO1xuICAgICAgICB9LCBDLnNlcCA9IFwiL1wiLCBDLmRlbGltaXRlciA9IFwiOlwiLCBDLmRpcm5hbWUgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBnICE9IFwic3RyaW5nXCIgJiYgKGcgKz0gXCJcIiksIGcubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xuICAgICAgICAgIGZvciAodmFyIGYgPSBnLmNoYXJDb2RlQXQoMCkgPT09IDQ3LCByID0gLTEsIHMgPSAhMCwgbyA9IGcubGVuZ3RoIC0gMTsgMSA8PSBvOyAtLW8pXG4gICAgICAgICAgICBpZiAoZy5jaGFyQ29kZUF0KG8pID09PSA0Nykge1xuICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICByID0gbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHMgPSAhMTtcbiAgICAgICAgICByZXR1cm4gciA9PT0gLTEgPyBmID8gXCIvXCIgOiBcIi5cIiA6IGYgJiYgciA9PT0gMSA/IFwiL1wiIDogZy5zbGljZSgwLCByKTtcbiAgICAgICAgfSwgQy5iYXNlbmFtZSA9IGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgICByZXR1cm4gZyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHR5cGVvZiByICE9IFwic3RyaW5nXCIgJiYgKHIgKz0gXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgbyA9IC0xLCBpID0gITAsIGwgPSByLmxlbmd0aCAtIDE7IDAgPD0gbDsgLS1sKVxuICAgICAgICAgICAgICBpZiAoci5jaGFyQ29kZUF0KGwpID09PSA0Nykge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgcyA9IGwgKyAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBvID09PSAtMSAmJiAoaSA9ICExLCBvID0gbCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG8gPT09IC0xID8gXCJcIiA6IHIuc2xpY2Uocywgbyk7XG4gICAgICAgICAgfShnKSwgZyA9IGYgJiYgZy5zdWJzdHIoLTEgKiBmLmxlbmd0aCkgPT09IGYgPyBnLnN1YnN0cigwLCBnLmxlbmd0aCAtIGYubGVuZ3RoKSA6IGc7XG4gICAgICAgIH0sIEMuZXh0bmFtZSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICB0eXBlb2YgZyAhPSBcInN0cmluZ1wiICYmIChnICs9IFwiXCIpO1xuICAgICAgICAgIGZvciAodmFyIGYgPSAtMSwgciA9IDAsIHMgPSAtMSwgbyA9ICEwLCBpID0gMCwgbCA9IGcubGVuZ3RoIC0gMTsgMCA8PSBsOyAtLWwpIHtcbiAgICAgICAgICAgIHZhciBuID0gZy5jaGFyQ29kZUF0KGwpO1xuICAgICAgICAgICAgaWYgKG4gPT09IDQ3KSB7XG4gICAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByID0gbCArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9PT0gLTEgJiYgKG8gPSAhMSwgcyA9IGwgKyAxKSwgbiA9PT0gNDYgPyBmID09PSAtMSA/IGYgPSBsIDogaSAhPT0gMSAmJiAoaSA9IDEpIDogZiAhPT0gLTEgJiYgKGkgPSAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmID09PSAtMSB8fCBzID09PSAtMSB8fCBpID09PSAwIHx8IGkgPT09IDEgJiYgZiA9PT0gcyAtIDEgJiYgZiA9PT0gciArIDEgPyBcIlwiIDogZy5zbGljZShmLCBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGggPSBcImFiXCIuc3Vic3RyKC0xKSA9PT0gXCJiXCIgPyBmdW5jdGlvbihnLCBmLCByKSB7XG4gICAgICAgICAgcmV0dXJuIGcuc3Vic3RyKGYsIHIpO1xuICAgICAgICB9IDogZnVuY3Rpb24oZywgZiwgcikge1xuICAgICAgICAgIHJldHVybiBmIDwgMCAmJiAoZiA9IGcubGVuZ3RoICsgZiksIGcuc3Vic3RyKGYsIHIpO1xuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0KFwiX3Byb2Nlc3NcIikpO1xuICAgIH0sIHsgX3Byb2Nlc3M6IDI1NiB9XSwgMjU2OiBbZnVuY3Rpb24odCwgdSwgQykge1xuICAgICAgdmFyIG0sIHksIHUgPSB1LmV4cG9ydHMgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBtID0gdHlwZW9mIHNldFRpbWVvdXQgPT0gXCJmdW5jdGlvblwiID8gc2V0VGltZW91dCA6IGg7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgbSA9IGg7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PSBcImZ1bmN0aW9uXCIgPyBjbGVhclRpbWVvdXQgOiBnO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHkgPSBnO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihwKSB7XG4gICAgICAgIGlmIChtID09PSBzZXRUaW1lb3V0KVxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHAsIDApO1xuICAgICAgICBpZiAoKG0gPT09IGggfHwgIW0pICYmIHNldFRpbWVvdXQpXG4gICAgICAgICAgcmV0dXJuIChtID0gc2V0VGltZW91dCkocCwgMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG0ocCwgMCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbS5jYWxsKG51bGwsIHAsIDApO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG0uY2FsbCh0aGlzLCBwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByLCBzID0gW10sIG8gPSAhMSwgaSA9IC0xO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgbyAmJiByICYmIChvID0gITEsIHIubGVuZ3RoID8gcyA9IHIuY29uY2F0KHMpIDogaSA9IC0xLCBzLmxlbmd0aCAmJiBuKCkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCA9IGYobCksIGogPSAobyA9ICEwLCBzLmxlbmd0aCk7IGo7ICkge1xuICAgICAgICAgICAgZm9yIChyID0gcywgcyA9IFtdOyArK2kgPCBqOyApXG4gICAgICAgICAgICAgIHIgJiYgcltpXS5ydW4oKTtcbiAgICAgICAgICAgIGkgPSAtMSwgaiA9IHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByID0gbnVsbCwgbyA9ICExLCBmdW5jdGlvbihUKSB7XG4gICAgICAgICAgICBpZiAoeSA9PT0gY2xlYXJUaW1lb3V0KVxuICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KFQpO1xuICAgICAgICAgICAgaWYgKCh5ID09PSBnIHx8ICF5KSAmJiBjbGVhclRpbWVvdXQpXG4gICAgICAgICAgICAgIHJldHVybiAoeSA9IGNsZWFyVGltZW91dCkoVCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB5KFQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkuY2FsbChudWxsLCBUKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkuY2FsbCh0aGlzLCBUKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0ocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGEocCwgaikge1xuICAgICAgICB0aGlzLmZ1biA9IHAsIHRoaXMuYXJyYXkgPSBqO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgIH1cbiAgICAgIHUubmV4dFRpY2sgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBqID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgIGZvciAodmFyIFQgPSAxOyBUIDwgYXJndW1lbnRzLmxlbmd0aDsgVCsrKVxuICAgICAgICAgICAgaltUIC0gMV0gPSBhcmd1bWVudHNbVF07XG4gICAgICAgIHMucHVzaChuZXcgYShwLCBqKSksIHMubGVuZ3RoICE9PSAxIHx8IG8gfHwgZihuKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbiAgICAgIH0sIHUudGl0bGUgPSBcImJyb3dzZXJcIiwgdS5icm93c2VyID0gITAsIHUuZW52ID0ge30sIHUuYXJndiA9IFtdLCB1LnZlcnNpb24gPSBcIlwiLCB1LnZlcnNpb25zID0ge30sIHUub24gPSBjLCB1LmFkZExpc3RlbmVyID0gYywgdS5vbmNlID0gYywgdS5vZmYgPSBjLCB1LnJlbW92ZUxpc3RlbmVyID0gYywgdS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBjLCB1LmVtaXQgPSBjLCB1LnByZXBlbmRMaXN0ZW5lciA9IGMsIHUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGMsIHUubGlzdGVuZXJzID0gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LCB1LmJpbmRpbmcgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfSwgdS5jd2QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgICAgfSwgdS5jaGRpciA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfSwgdS51bWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfSwge31dLCAyNTc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBIID0gZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeSwgdSA9IE9iamVjdC5wcm90b3R5cGUsIGggPSB1Lmhhc093blByb3BlcnR5LCBfID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fSwgZyA9IF8uaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGYgPSBfLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgciA9IF8udG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gICAgICAgIGZ1bmN0aW9uIHMoViwgRCwgVSwgQikge1xuICAgICAgICAgIHZhciBYLCBuZSwgYiwgTywgRCA9IEQgJiYgRC5wcm90b3R5cGUgaW5zdGFuY2VvZiBwID8gRCA6IHAsIEQgPSBPYmplY3QuY3JlYXRlKEQucHJvdG90eXBlKSwgQiA9IG5ldyBSKEIgfHwgW10pO1xuICAgICAgICAgIHJldHVybiBELl9pbnZva2UgPSAoWCA9IFYsIG5lID0gVSwgYiA9IEIsIE8gPSBpLCBmdW5jdGlvbihZLCBKKSB7XG4gICAgICAgICAgICBpZiAoTyA9PT0gbilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICAgIGlmIChPID09PSBhKSB7XG4gICAgICAgICAgICAgIGlmIChZID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgSjtcbiAgICAgICAgICAgICAgcmV0dXJuIEYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoYi5tZXRob2QgPSBZLCBiLmFyZyA9IEo7IDsgKSB7XG4gICAgICAgICAgICAgIHZhciB0ZSA9IGIuZGVsZWdhdGU7XG4gICAgICAgICAgICAgIGlmICh0ZSAmJiAodGUgPSBmdW5jdGlvbiBjZShyZSwgdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGUgPSByZS5pdGVyYXRvclt1ZS5tZXRob2RdO1xuICAgICAgICAgICAgICAgIGlmIChsZSA9PT0geSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHVlLmRlbGVnYXRlID0gbnVsbCwgdWUubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlLml0ZXJhdG9yLnJldHVybiAmJiAodWUubWV0aG9kID0gXCJyZXR1cm5cIiwgdWUuYXJnID0geSwgY2UocmUsIHVlKSwgdWUubWV0aG9kID09PSBcInRocm93XCIpKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICB1ZS5tZXRob2QgPSBcInRocm93XCIsIHVlLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZSA9IG8obGUsIHJlLml0ZXJhdG9yLCB1ZS5hcmcpLCBsZS50eXBlID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdWUubWV0aG9kID0gXCJ0aHJvd1wiLCB1ZS5hcmcgPSBsZS5hcmcsIHVlLmRlbGVnYXRlID0gbnVsbCwgYztcbiAgICAgICAgICAgICAgICBpZiAobGUgPSBsZS5hcmcsICFsZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1ZS5tZXRob2QgPSBcInRocm93XCIsIHVlLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgdWUuZGVsZWdhdGUgPSBudWxsLCBjO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbGUuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlO1xuICAgICAgICAgICAgICAgICAgdWVbcmUucmVzdWx0TmFtZV0gPSBsZS52YWx1ZSwgdWUubmV4dCA9IHJlLm5leHRMb2MsIHVlLm1ldGhvZCAhPT0gXCJyZXR1cm5cIiAmJiAodWUubWV0aG9kID0gXCJuZXh0XCIsIHVlLmFyZyA9IHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdWUuZGVsZWdhdGUgPSBudWxsLCBjO1xuICAgICAgICAgICAgICB9KHRlLCBiKSwgdGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlID09PSBjKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChiLm1ldGhvZCA9PT0gXCJuZXh0XCIpXG4gICAgICAgICAgICAgICAgYi5zZW50ID0gYi5fc2VudCA9IGIuYXJnO1xuICAgICAgICAgICAgICBlbHNlIGlmIChiLm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKE8gPT09IGkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBPID0gYSwgYi5hcmc7XG4gICAgICAgICAgICAgICAgYi5kaXNwYXRjaEV4Y2VwdGlvbihiLmFyZyk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGIubWV0aG9kID09PSBcInJldHVyblwiICYmIGIuYWJydXB0KFwicmV0dXJuXCIsIGIuYXJnKTtcbiAgICAgICAgICAgICAgaWYgKE8gPSBuLCB0ZSA9IG8oWCwgbmUsIGIpLCB0ZS50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKE8gPSBiLmRvbmUgPyBhIDogbCwgdGUuYXJnICE9PSBjKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRlLmFyZywgZG9uZTogYi5kb25lIH07XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRlLnR5cGUgPT09IFwidGhyb3dcIiAmJiAoTyA9IGEsIGIubWV0aG9kID0gXCJ0aHJvd1wiLCBiLmFyZyA9IHRlLmFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIEQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbyhWLCBHLCBVKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogVi5jYWxsKEcsIFUpIH07XG4gICAgICAgICAgfSBjYXRjaCAoVykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IFcgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbS53cmFwID0gcztcbiAgICAgICAgdmFyIGkgPSBcInN1c3BlbmRlZFN0YXJ0XCIsIGwgPSBcInN1c3BlbmRlZFlpZWxkXCIsIG4gPSBcImV4ZWN1dGluZ1wiLCBhID0gXCJjb21wbGV0ZWRcIiwgYyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGooKSB7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgfVxuICAgICAgICB2YXIgXyA9IHt9LCBTID0gKF9bZ10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKSwgUyA9IFMgJiYgUyhTKEwoW10pKSksIEUgPSAoUyAmJiBTICE9PSB1ICYmIGguY2FsbChTLCBnKSAmJiAoXyA9IFMpLCBULnByb3RvdHlwZSA9IHAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfKSk7XG4gICAgICAgIGZ1bmN0aW9uIEEoVikge1xuICAgICAgICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICAgIFZbR10gPSBmdW5jdGlvbihVKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoRywgVSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHgoVikge1xuICAgICAgICAgIHZhciBHO1xuICAgICAgICAgIHRoaXMuX2ludm9rZSA9IGZ1bmN0aW9uKFUsIFcpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFgoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuZSwgYikge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBPKGNlLCBCLCBZLCBKKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGUsIGNlID0gbyhWW2NlXSwgViwgQik7XG4gICAgICAgICAgICAgICAgICBpZiAoY2UudHlwZSAhPT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKEIgPSAodGUgPSBjZS5hcmcpLnZhbHVlKSAmJiB0eXBlb2YgQiA9PSBcIm9iamVjdFwiICYmIGguY2FsbChCLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlLnJlc29sdmUoQi5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgTyhcIm5leHRcIiwgcmUsIFksIEopO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZSkge1xuICAgICAgICAgICAgICAgICAgICAgIE8oXCJ0aHJvd1wiLCByZSwgWSwgSik7XG4gICAgICAgICAgICAgICAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKEIpLnRoZW4oZnVuY3Rpb24ocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZS52YWx1ZSA9IHJlLCBZKHRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTyhcInRocm93XCIsIHJlLCBZLCBKKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBKKGNlLmFyZyk7XG4gICAgICAgICAgICAgICAgfSkoVSwgVywgbmUsIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHID0gRyA/IEcudGhlbihYLCBYKSA6IFgoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFAoVikge1xuICAgICAgICAgIHZhciBHID0geyB0cnlMb2M6IFZbMF0gfTtcbiAgICAgICAgICAxIGluIFYgJiYgKEcuY2F0Y2hMb2MgPSBWWzFdKSwgMiBpbiBWICYmIChHLmZpbmFsbHlMb2MgPSBWWzJdLCBHLmFmdGVyTG9jID0gVlszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKEcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE0oVikge1xuICAgICAgICAgIHZhciBHID0gVi5jb21wbGV0aW9uIHx8IHt9O1xuICAgICAgICAgIEcudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBHLmFyZywgVi5jb21wbGV0aW9uID0gRztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBSKFYpIHtcbiAgICAgICAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCBWLmZvckVhY2goUCwgdGhpcyksIHRoaXMucmVzZXQoITApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEwoVikge1xuICAgICAgICAgIGlmIChWKSB7XG4gICAgICAgICAgICB2YXIgRywgVSA9IFZbZ107XG4gICAgICAgICAgICBpZiAoVSlcbiAgICAgICAgICAgICAgcmV0dXJuIFUuY2FsbChWKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgVi5uZXh0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFY7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKFYubGVuZ3RoKSlcbiAgICAgICAgICAgICAgcmV0dXJuIEcgPSAtMSwgKFUgPSBmdW5jdGlvbiBXKCkge1xuICAgICAgICAgICAgICAgIGZvciAoOyArK0cgPCBWLmxlbmd0aDsgKVxuICAgICAgICAgICAgICAgICAgaWYgKGguY2FsbChWLCBHKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFcudmFsdWUgPSBWW0ddLCBXLmRvbmUgPSAhMSwgVztcbiAgICAgICAgICAgICAgICByZXR1cm4gVy52YWx1ZSA9IHksIFcuZG9uZSA9ICEwLCBXO1xuICAgICAgICAgICAgICB9KS5uZXh0ID0gVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgbmV4dDogRiB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHksIGRvbmU6ICEwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChqLnByb3RvdHlwZSA9IEUuY29uc3RydWN0b3IgPSBUKS5jb25zdHJ1Y3RvciA9IGosIFRbcl0gPSBqLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiLCBtLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihWKSB7XG4gICAgICAgICAgcmV0dXJuIFYgPSB0eXBlb2YgViA9PSBcImZ1bmN0aW9uXCIgJiYgVi5jb25zdHJ1Y3RvciwgISFWICYmIChWID09PSBqIHx8IChWLmRpc3BsYXlOYW1lIHx8IFYubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgICAgIH0sIG0ubWFyayA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKFYsIFQpIDogKFYuX19wcm90b19fID0gVCwgciBpbiBWIHx8IChWW3JdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIFYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFKSwgVjtcbiAgICAgICAgfSwgbS5hd3JhcCA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgICAgICByZXR1cm4geyBfX2F3YWl0OiBWIH07XG4gICAgICAgIH0sIEEoeC5wcm90b3R5cGUpLCB4LnByb3RvdHlwZVtmXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBtLkFzeW5jSXRlcmF0b3IgPSB4LCBtLmFzeW5jID0gZnVuY3Rpb24oViwgRywgVSwgVykge1xuICAgICAgICAgIHZhciBYID0gbmV3IHgocyhWLCBHLCBVLCBXKSk7XG4gICAgICAgICAgcmV0dXJuIG0uaXNHZW5lcmF0b3JGdW5jdGlvbihHKSA/IFggOiBYLm5leHQoKS50aGVuKGZ1bmN0aW9uKG5lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmUuZG9uZSA/IG5lLnZhbHVlIDogWC5uZXh0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIEEoRSksIEVbcl0gPSBcIkdlbmVyYXRvclwiLCBFW2ddID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIEUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgICAgICAgfSwgbS5rZXlzID0gZnVuY3Rpb24oVikge1xuICAgICAgICAgIHZhciBHLCBVID0gW107XG4gICAgICAgICAgZm9yIChHIGluIFYpXG4gICAgICAgICAgICBVLnB1c2goRyk7XG4gICAgICAgICAgcmV0dXJuIFUucmV2ZXJzZSgpLCBmdW5jdGlvbiBXKCkge1xuICAgICAgICAgICAgZm9yICg7IFUubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgdmFyIFggPSBVLnBvcCgpO1xuICAgICAgICAgICAgICBpZiAoWCBpbiBWKVxuICAgICAgICAgICAgICAgIHJldHVybiBXLnZhbHVlID0gWCwgVy5kb25lID0gITEsIFc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVy5kb25lID0gITAsIFc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgbS52YWx1ZXMgPSBMLCBSLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IFIsIHJlc2V0OiBmdW5jdGlvbihWKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB5LCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0geSwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2goTSksICFWKVxuICAgICAgICAgICAgZm9yICh2YXIgRyBpbiB0aGlzKVxuICAgICAgICAgICAgICBHLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaC5jYWxsKHRoaXMsIEcpICYmICFpc05hTigrRy5zbGljZSgxKSkgJiYgKHRoaXNbR10gPSB5KTtcbiAgICAgICAgfSwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5kb25lID0gITA7XG4gICAgICAgICAgdmFyIFYgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAoVi50eXBlID09PSBcInRocm93XCIpXG4gICAgICAgICAgICB0aHJvdyBWLmFyZztcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgICAgICB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oVikge1xuICAgICAgICAgIGlmICh0aGlzLmRvbmUpXG4gICAgICAgICAgICB0aHJvdyBWO1xuICAgICAgICAgIHZhciBHID0gdGhpcztcbiAgICAgICAgICBmdW5jdGlvbiBVKEQsIEIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZS50eXBlID0gXCJ0aHJvd1wiLCBuZS5hcmcgPSBWLCBHLm5leHQgPSBELCBCICYmIChHLm1ldGhvZCA9IFwibmV4dFwiLCBHLmFyZyA9IHkpLCAhIUI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIFcgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgMCA8PSBXOyAtLVcpIHtcbiAgICAgICAgICAgIHZhciBYID0gdGhpcy50cnlFbnRyaWVzW1ddLCBuZSA9IFguY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChYLnRyeUxvYyA9PT0gXCJyb290XCIpXG4gICAgICAgICAgICAgIHJldHVybiBVKFwiZW5kXCIpO1xuICAgICAgICAgICAgaWYgKFgudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgICB2YXIgYiA9IGguY2FsbChYLCBcImNhdGNoTG9jXCIpLCBPID0gaC5jYWxsKFgsIFwiZmluYWxseUxvY1wiKTtcbiAgICAgICAgICAgICAgaWYgKGIgJiYgTykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBYLmNhdGNoTG9jKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFUoWC5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBYLmZpbmFsbHlMb2MpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gVShYLmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgWC5jYXRjaExvYylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBVKFguY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIU8pXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgWC5maW5hbGx5TG9jKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFUoWC5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgYWJydXB0OiBmdW5jdGlvbihWLCBHKSB7XG4gICAgICAgICAgZm9yICh2YXIgVSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyAwIDw9IFU7IC0tVSkge1xuICAgICAgICAgICAgdmFyIFcgPSB0aGlzLnRyeUVudHJpZXNbVV07XG4gICAgICAgICAgICBpZiAoVy50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGguY2FsbChXLCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgVy5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHZhciBYID0gVztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZSA9IChYID0gWCAmJiAoViA9PT0gXCJicmVha1wiIHx8IFYgPT09IFwiY29udGludWVcIikgJiYgWC50cnlMb2MgPD0gRyAmJiBHIDw9IFguZmluYWxseUxvYyA/IG51bGwgOiBYKSA/IFguY29tcGxldGlvbiA6IHt9O1xuICAgICAgICAgIHJldHVybiBuZS50eXBlID0gViwgbmUuYXJnID0gRywgWCA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBYLmZpbmFsbHlMb2MsIGMpIDogdGhpcy5jb21wbGV0ZShuZSk7XG4gICAgICAgIH0sIGNvbXBsZXRlOiBmdW5jdGlvbihWLCBHKSB7XG4gICAgICAgICAgaWYgKFYudHlwZSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgdGhyb3cgVi5hcmc7XG4gICAgICAgICAgcmV0dXJuIFYudHlwZSA9PT0gXCJicmVha1wiIHx8IFYudHlwZSA9PT0gXCJjb250aW51ZVwiID8gdGhpcy5uZXh0ID0gVi5hcmcgOiBWLnR5cGUgPT09IFwicmV0dXJuXCIgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSBWLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFYudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBHICYmICh0aGlzLm5leHQgPSBHKSwgYztcbiAgICAgICAgfSwgZmluaXNoOiBmdW5jdGlvbihWKSB7XG4gICAgICAgICAgZm9yICh2YXIgRyA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyAwIDw9IEc7IC0tRykge1xuICAgICAgICAgICAgdmFyIFUgPSB0aGlzLnRyeUVudHJpZXNbR107XG4gICAgICAgICAgICBpZiAoVS5maW5hbGx5TG9jID09PSBWKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShVLmNvbXBsZXRpb24sIFUuYWZ0ZXJMb2MpLCBNKFUpLCBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgY2F0Y2g6IGZ1bmN0aW9uKFYpIHtcbiAgICAgICAgICBmb3IgKHZhciBHID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IDAgPD0gRzsgLS1HKSB7XG4gICAgICAgICAgICB2YXIgVSwgVywgWCA9IHRoaXMudHJ5RW50cmllc1tHXTtcbiAgICAgICAgICAgIGlmIChYLnRyeUxvYyA9PT0gVilcbiAgICAgICAgICAgICAgcmV0dXJuIChVID0gWC5jb21wbGV0aW9uKS50eXBlID09PSBcInRocm93XCIgJiYgKFcgPSBVLmFyZywgTShYKSksIFc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICAgICAgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oViwgRywgVSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogTChWKSwgcmVzdWx0TmFtZTogRywgbmV4dExvYzogVSB9LCB0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIgJiYgKHRoaXMuYXJnID0geSksIGM7XG4gICAgICAgIH0gfSwgbTtcbiAgICAgIH0odHlwZW9mIEggPT0gXCJvYmplY3RcIiA/IEguZXhwb3J0cyA6IHt9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IEg7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShIKTtcbiAgICAgIH1cbiAgICB9LCB7fV0sIDI1ODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIChmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB5LCB1LCBoLCBnLCBmLCByLCBzLCBvLCBpLCBsO1xuICAgICAgICBmdW5jdGlvbiBuKE0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE0gIT0gXCJzdHJpbmdcIiAmJiAoTSA9IFN0cmluZyhNKSksIC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KE0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lXCIpO1xuICAgICAgICAgIHJldHVybiBNLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYShNKSB7XG4gICAgICAgICAgcmV0dXJuIE0gPSB0eXBlb2YgTSAhPSBcInN0cmluZ1wiID8gU3RyaW5nKE0pIDogTTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjKE0pIHtcbiAgICAgICAgICB2YXIgUiA9IHsgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgTCA9IE0uc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IEwgPT09IHZvaWQgMCwgdmFsdWU6IEwgfTtcbiAgICAgICAgICB9IH07XG4gICAgICAgICAgcmV0dXJuIHUgJiYgKFJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgICAgfSksIFI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcChNKSB7XG4gICAgICAgICAgdGhpcy5tYXAgPSB7fSwgTSBpbnN0YW5jZW9mIHAgPyBNLmZvckVhY2goZnVuY3Rpb24oUiwgTCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoTCwgUik7XG4gICAgICAgICAgfSwgdGhpcykgOiBBcnJheS5pc0FycmF5KE0pID8gTS5mb3JFYWNoKGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKFJbMF0sIFJbMV0pO1xuICAgICAgICAgIH0sIHRoaXMpIDogTSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNKS5mb3JFYWNoKGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKFIsIE1bUl0pO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGooTSkge1xuICAgICAgICAgIGlmIChNLmJvZHlVc2VkKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJBbHJlYWR5IHJlYWRcIikpO1xuICAgICAgICAgIE0uYm9keVVzZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBUKE0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oUiwgTCkge1xuICAgICAgICAgICAgTS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgUihNLnJlc3VsdCk7XG4gICAgICAgICAgICB9LCBNLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgTChNLmVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gXyhNKSB7XG4gICAgICAgICAgdmFyIFIgPSBuZXcgRmlsZVJlYWRlcigpLCBMID0gVChSKTtcbiAgICAgICAgICByZXR1cm4gUi5yZWFkQXNBcnJheUJ1ZmZlcihNKSwgTDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBTKE0pIHtcbiAgICAgICAgICB2YXIgUjtcbiAgICAgICAgICByZXR1cm4gTS5zbGljZSA/IE0uc2xpY2UoMCkgOiAoKFIgPSBuZXcgVWludDhBcnJheShNLmJ5dGVMZW5ndGgpKS5zZXQobmV3IFVpbnQ4QXJyYXkoTSkpLCBSLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gRSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5VXNlZCA9ICExLCB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5SW5pdCA9IE0pXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgTSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gTTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoaCAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKE0pKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlCbG9iID0gTTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZyAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihNKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBNO1xuICAgICAgICAgICAgICBlbHNlIGlmICh5ICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihNKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IE0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZiAmJiBoICYmIHMoTSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gUyhNLmJ1ZmZlciksIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWYgfHwgIUFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKE0pICYmICFvKE0pKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBTKE0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgKHR5cGVvZiBNID09IFwic3RyaW5nXCIgPyB0aGlzLmhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpIDogdGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSA/IHRoaXMuaGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgdGhpcy5fYm9keUJsb2IudHlwZSkgOiB5ICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihNKSAmJiB0aGlzLmhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThcIikpO1xuICAgICAgICAgIH0sIGggJiYgKHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIE0gPSBqKHRoaXMpO1xuICAgICAgICAgICAgaWYgKE0pXG4gICAgICAgICAgICAgIHJldHVybiBNO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYlwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpO1xuICAgICAgICAgIH0sIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPyBqKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIDogdGhpcy5ibG9iKCkudGhlbihfKTtcbiAgICAgICAgICB9KSwgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgTSwgUiwgTCA9IGoodGhpcyk7XG4gICAgICAgICAgICBpZiAoTClcbiAgICAgICAgICAgICAgcmV0dXJuIEw7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpXG4gICAgICAgICAgICAgIHJldHVybiBMID0gdGhpcy5fYm9keUJsb2IsIE0gPSBuZXcgRmlsZVJlYWRlcigpLCBSID0gVChNKSwgTS5yZWFkQXNUZXh0KEwpLCBSO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmdW5jdGlvbihGKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgViA9IG5ldyBVaW50OEFycmF5KEYpLCBHID0gbmV3IEFycmF5KFYubGVuZ3RoKSwgVSA9IDA7IFUgPCBWLmxlbmd0aDsgVSsrKVxuICAgICAgICAgICAgICAgICAgR1tVXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoVltVXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEcuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgfSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dFwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpO1xuICAgICAgICAgIH0sIGcgJiYgKHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKHgpO1xuICAgICAgICAgIH0pLCB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpO1xuICAgICAgICAgIH0sIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQShNLCBSKSB7XG4gICAgICAgICAgdmFyIEwsIEYgPSAoUiA9IFIgfHwge30pLmJvZHk7XG4gICAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBBKSB7XG4gICAgICAgICAgICBpZiAoTS5ib2R5VXNlZClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscmVhZHkgcmVhZFwiKTtcbiAgICAgICAgICAgIHRoaXMudXJsID0gTS51cmwsIHRoaXMuY3JlZGVudGlhbHMgPSBNLmNyZWRlbnRpYWxzLCBSLmhlYWRlcnMgfHwgKHRoaXMuaGVhZGVycyA9IG5ldyBwKE0uaGVhZGVycykpLCB0aGlzLm1ldGhvZCA9IE0ubWV0aG9kLCB0aGlzLm1vZGUgPSBNLm1vZGUsIEYgfHwgTS5fYm9keUluaXQgPT0gbnVsbCB8fCAoRiA9IE0uX2JvZHlJbml0LCBNLmJvZHlVc2VkID0gITApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhpcy51cmwgPSBTdHJpbmcoTSk7XG4gICAgICAgICAgaWYgKHRoaXMuY3JlZGVudGlhbHMgPSBSLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgXCJvbWl0XCIsICFSLmhlYWRlcnMgJiYgdGhpcy5oZWFkZXJzIHx8ICh0aGlzLmhlYWRlcnMgPSBuZXcgcChSLmhlYWRlcnMpKSwgdGhpcy5tZXRob2QgPSAoTSA9IFIubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8IFwiR0VUXCIsIEwgPSBNLnRvVXBwZXJDYXNlKCksIC0xIDwgaS5pbmRleE9mKEwpID8gTCA6IE0pLCB0aGlzLm1vZGUgPSBSLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGwsIHRoaXMucmVmZXJyZXIgPSBudWxsLCAodGhpcy5tZXRob2QgPT09IFwiR0VUXCIgfHwgdGhpcy5tZXRob2QgPT09IFwiSEVBRFwiKSAmJiBGKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzXCIpO1xuICAgICAgICAgIHRoaXMuX2luaXRCb2R5KEYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHgoTSkge1xuICAgICAgICAgIHZhciBSID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgcmV0dXJuIE0udHJpbSgpLnNwbGl0KFwiJlwiKS5mb3JFYWNoKGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICAgIHZhciBGO1xuICAgICAgICAgICAgTCAmJiAoRiA9IChMID0gTC5zcGxpdChcIj1cIikpLnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csIFwiIFwiKSwgTCA9IEwuam9pbihcIj1cIikucmVwbGFjZSgvXFwrL2csIFwiIFwiKSwgUi5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KEYpLCBkZWNvZGVVUklDb21wb25lbnQoTCkpKTtcbiAgICAgICAgICB9KSwgUjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBQKE0sIFIpIHtcbiAgICAgICAgICBSID0gUiB8fCB7fSwgdGhpcy50eXBlID0gXCJkZWZhdWx0XCIsIHRoaXMuc3RhdHVzID0gUi5zdGF0dXMgPT09IHZvaWQgMCA/IDIwMCA6IFIuc3RhdHVzLCB0aGlzLm9rID0gMjAwIDw9IHRoaXMuc3RhdHVzICYmIHRoaXMuc3RhdHVzIDwgMzAwLCB0aGlzLnN0YXR1c1RleHQgPSBcInN0YXR1c1RleHRcIiBpbiBSID8gUi5zdGF0dXNUZXh0IDogXCJPS1wiLCB0aGlzLmhlYWRlcnMgPSBuZXcgcChSLmhlYWRlcnMpLCB0aGlzLnVybCA9IFIudXJsIHx8IFwiXCIsIHRoaXMuX2luaXRCb2R5KE0pO1xuICAgICAgICB9XG4gICAgICAgIG0uZmV0Y2ggfHwgKHkgPSBcIlVSTFNlYXJjaFBhcmFtc1wiIGluIG0sIHUgPSBcIlN5bWJvbFwiIGluIG0gJiYgXCJpdGVyYXRvclwiIGluIFN5bWJvbCwgaCA9IFwiRmlsZVJlYWRlclwiIGluIG0gJiYgXCJCbG9iXCIgaW4gbSAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKCksICEwO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpLCBnID0gXCJGb3JtRGF0YVwiIGluIG0sIChmID0gXCJBcnJheUJ1ZmZlclwiIGluIG0pICYmIChyID0gW1wiW29iamVjdCBJbnQ4QXJyYXldXCIsIFwiW29iamVjdCBVaW50OEFycmF5XVwiLCBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBcIltvYmplY3QgVWludDE2QXJyYXldXCIsIFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCBcIltvYmplY3QgVWludDMyQXJyYXldXCIsIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCJdLCBzID0gZnVuY3Rpb24oTSkge1xuICAgICAgICAgIHJldHVybiBNICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKE0pO1xuICAgICAgICB9LCBvID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICByZXR1cm4gTSAmJiAtMSA8IHIuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoTSkpO1xuICAgICAgICB9KSwgcC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oTSwgUikge1xuICAgICAgICAgIE0gPSBuKE0pLCBSID0gYShSKTtcbiAgICAgICAgICB2YXIgTCA9IHRoaXMubWFwW01dO1xuICAgICAgICAgIHRoaXMubWFwW01dID0gTCA/IEwgKyBcIixcIiArIFIgOiBSO1xuICAgICAgICB9LCBwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubWFwW24oTSldO1xuICAgICAgICB9LCBwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgcmV0dXJuIE0gPSBuKE0pLCB0aGlzLmhhcyhNKSA/IHRoaXMubWFwW01dIDogbnVsbDtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oTSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuKE0pKTtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oTSwgUikge1xuICAgICAgICAgIHRoaXMubWFwW24oTSldID0gYShSKTtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKE0sIFIpIHtcbiAgICAgICAgICBmb3IgKHZhciBMIGluIHRoaXMubWFwKVxuICAgICAgICAgICAgdGhpcy5tYXAuaGFzT3duUHJvcGVydHkoTCkgJiYgTS5jYWxsKFIsIHRoaXMubWFwW0xdLCBMLCB0aGlzKTtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBNID0gW107XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihSLCBMKSB7XG4gICAgICAgICAgICBNLnB1c2goTCk7XG4gICAgICAgICAgfSksIGMoTSk7XG4gICAgICAgIH0sIHAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBNID0gW107XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICBNLnB1c2goUik7XG4gICAgICAgICAgfSksIGMoTSk7XG4gICAgICAgIH0sIHAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgTSA9IFtdO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oUiwgTCkge1xuICAgICAgICAgICAgTS5wdXNoKFtMLCBSXSk7XG4gICAgICAgICAgfSksIGMoTSk7XG4gICAgICAgIH0sIHUgJiYgKHAucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBwLnByb3RvdHlwZS5lbnRyaWVzKSwgaSA9IFtcIkRFTEVURVwiLCBcIkdFVFwiLCBcIkhFQURcIiwgXCJPUFRJT05TXCIsIFwiUE9TVFwiLCBcIlBVVFwiXSwgQS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEEodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KTtcbiAgICAgICAgfSwgRS5jYWxsKEEucHJvdG90eXBlKSwgRS5jYWxsKFAucHJvdG90eXBlKSwgUC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFAodGhpcy5fYm9keUluaXQsIHsgc3RhdHVzOiB0aGlzLnN0YXR1cywgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LCBoZWFkZXJzOiBuZXcgcCh0aGlzLmhlYWRlcnMpLCB1cmw6IHRoaXMudXJsIH0pO1xuICAgICAgICB9LCBQLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIE0gPSBuZXcgUChudWxsLCB7IHN0YXR1czogMCwgc3RhdHVzVGV4dDogXCJcIiB9KTtcbiAgICAgICAgICByZXR1cm4gTS50eXBlID0gXCJlcnJvclwiLCBNO1xuICAgICAgICB9LCBsID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSwgUC5yZWRpcmVjdCA9IGZ1bmN0aW9uKE0sIFIpIHtcbiAgICAgICAgICBpZiAobC5pbmRleE9mKFIpID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZVwiKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFAobnVsbCwgeyBzdGF0dXM6IFIsIGhlYWRlcnM6IHsgbG9jYXRpb246IE0gfSB9KTtcbiAgICAgICAgfSwgbS5IZWFkZXJzID0gcCwgbS5SZXF1ZXN0ID0gQSwgbS5SZXNwb25zZSA9IFAsIG0uZmV0Y2ggPSBmdW5jdGlvbihNLCBSKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKEwsIEYpIHtcbiAgICAgICAgICAgIHZhciBWID0gbmV3IEEoTSwgUiksIEcgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIEcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBVLCBXID0geyBzdGF0dXM6IEcuc3RhdHVzLCBzdGF0dXNUZXh0OiBHLnN0YXR1c1RleHQsIGhlYWRlcnM6IChXID0gRy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCBcIlwiLCBVID0gbmV3IHAoKSwgVy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCBcIiBcIikuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGIuc3BsaXQoXCI6XCIpLCBPID0gYi5zaGlmdCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBPICYmIChiID0gYi5qb2luKFwiOlwiKS50cmltKCksIFUuYXBwZW5kKE8sIGIpKTtcbiAgICAgICAgICAgICAgfSksIFUpIH0sIFggPSAoVy51cmwgPSBcInJlc3BvbnNlVVJMXCIgaW4gRyA/IEcucmVzcG9uc2VVUkwgOiBXLmhlYWRlcnMuZ2V0KFwiWC1SZXF1ZXN0LVVSTFwiKSwgXCJyZXNwb25zZVwiIGluIEcgPyBHLnJlc3BvbnNlIDogRy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICBMKG5ldyBQKFgsIFcpKTtcbiAgICAgICAgICAgIH0sIEcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBGKG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIpKTtcbiAgICAgICAgICAgIH0sIEcub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIEYobmV3IFR5cGVFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIikpO1xuICAgICAgICAgICAgfSwgRy5vcGVuKFYubWV0aG9kLCBWLnVybCwgITApLCBWLmNyZWRlbnRpYWxzID09PSBcImluY2x1ZGVcIiA/IEcud2l0aENyZWRlbnRpYWxzID0gITAgOiBWLmNyZWRlbnRpYWxzID09PSBcIm9taXRcIiAmJiAoRy53aXRoQ3JlZGVudGlhbHMgPSAhMSksIFwicmVzcG9uc2VUeXBlXCIgaW4gRyAmJiBoICYmIChHLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiKSwgVi5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oVSwgVykge1xuICAgICAgICAgICAgICBHLnNldFJlcXVlc3RIZWFkZXIoVywgVSk7XG4gICAgICAgICAgICB9KSwgRy5zZW5kKFYuX2JvZHlJbml0ID09PSB2b2lkIDAgPyBudWxsIDogVi5fYm9keUluaXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBtLmZldGNoLnBvbHlmaWxsID0gITApO1xuICAgICAgfSkodHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB0aGlzKTtcbiAgICB9LCB7fV0sIDI1OTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0sIHkgPSBoKHQoXCIuLi9jb3JlL21haW5cIikpLCB1ID0gaCh0KFwiLi4vY29sb3IvY29sb3JfY29udmVyc2lvblwiKSk7XG4gICAgICBmdW5jdGlvbiBoKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgJiYgci5fX2VzTW9kdWxlID8gciA6IHsgZGVmYXVsdDogciB9O1xuICAgICAgfVxuICAgICAgdmFyIGcgPSBbeyBoOiAwLCBzOiAwLCBiOiAwLjgyNzUsIG5hbWU6IFwiZ3JheVwiIH0sIHsgaDogMCwgczogMCwgYjogMC44NjI3LCBuYW1lOiBcImdyYXlcIiB9LCB7IGg6IDAsIHM6IDAsIGI6IDAuNzUyOSwgbmFtZTogXCJncmF5XCIgfSwgeyBoOiAwLjAxNjcsIHM6IDAuMTE3NiwgYjogMSwgbmFtZTogXCJsaWdodCBwaW5rXCIgfV0sIGYgPSBbeyBoOiAwLCBzOiAwLCBiOiAwLCBuYW1lOiBcImJsYWNrXCIgfSwgeyBoOiAwLCBzOiAwLCBiOiAwLjUsIG5hbWU6IFwiZ3JheVwiIH0sIHsgaDogMCwgczogMCwgYjogMSwgbmFtZTogXCJ3aGl0ZVwiIH0sIHsgaDogMCwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwiZGFyayBtYXJvb25cIiB9LCB7IGg6IDAsIHM6IDAuNSwgYjogMSwgbmFtZTogXCJzYWxtb24gcGlua1wiIH0sIHsgaDogMCwgczogMSwgYjogMCwgbmFtZTogXCJibGFja1wiIH0sIHsgaDogMCwgczogMSwgYjogMC41LCBuYW1lOiBcImRhcmsgcmVkXCIgfSwgeyBoOiAwLCBzOiAxLCBiOiAxLCBuYW1lOiBcInJlZFwiIH0sIHsgaDogNSwgczogMCwgYjogMSwgbmFtZTogXCJ2ZXJ5IGxpZ2h0IHBlYWNoXCIgfSwgeyBoOiA1LCBzOiAwLjUsIGI6IDAuNSwgbmFtZTogXCJicm93blwiIH0sIHsgaDogNSwgczogMC41LCBiOiAxLCBuYW1lOiBcInBlYWNoXCIgfSwgeyBoOiA1LCBzOiAxLCBiOiAwLjUsIG5hbWU6IFwiYnJpY2sgcmVkXCIgfSwgeyBoOiA1LCBzOiAxLCBiOiAxLCBuYW1lOiBcImNyaW1zb25cIiB9LCB7IGg6IDEwLCBzOiAwLCBiOiAxLCBuYW1lOiBcImxpZ2h0IHBlYWNoXCIgfSwgeyBoOiAxMCwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwiYnJvd25cIiB9LCB7IGg6IDEwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgb3JhbmdlXCIgfSwgeyBoOiAxMCwgczogMSwgYjogMC41LCBuYW1lOiBcImJyb3duXCIgfSwgeyBoOiAxMCwgczogMSwgYjogMSwgbmFtZTogXCJvcmFuZ2VcIiB9LCB7IGg6IDE1LCBzOiAwLCBiOiAxLCBuYW1lOiBcInZlcnkgbGlnaHQgeWVsbG93XCIgfSwgeyBoOiAxNSwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwib2xpdmUgZ3JlZW5cIiB9LCB7IGg6IDE1LCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgeWVsbG93XCIgfSwgeyBoOiAxNSwgczogMSwgYjogMCwgbmFtZTogXCJkYXJrIG9saXZlIGdyZWVuXCIgfSwgeyBoOiAxNSwgczogMSwgYjogMC41LCBuYW1lOiBcIm9saXZlIGdyZWVuXCIgfSwgeyBoOiAxNSwgczogMSwgYjogMSwgbmFtZTogXCJ5ZWxsb3dcIiB9LCB7IGg6IDIwLCBzOiAwLCBiOiAxLCBuYW1lOiBcInZlcnkgbGlnaHQgeWVsbG93XCIgfSwgeyBoOiAyMCwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwib2xpdmUgZ3JlZW5cIiB9LCB7IGg6IDIwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgeWVsbG93IGdyZWVuXCIgfSwgeyBoOiAyMCwgczogMSwgYjogMCwgbmFtZTogXCJkYXJrIG9saXZlIGdyZWVuXCIgfSwgeyBoOiAyMCwgczogMSwgYjogMC41LCBuYW1lOiBcImRhcmsgeWVsbG93IGdyZWVuXCIgfSwgeyBoOiAyMCwgczogMSwgYjogMSwgbmFtZTogXCJ5ZWxsb3cgZ3JlZW5cIiB9LCB7IGg6IDI1LCBzOiAwLjUsIGI6IDAuNSwgbmFtZTogXCJkYXJrIHllbGxvdyBncmVlblwiIH0sIHsgaDogMjUsIHM6IDAuNSwgYjogMSwgbmFtZTogXCJsaWdodCBncmVlblwiIH0sIHsgaDogMjUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGdyZWVuXCIgfSwgeyBoOiAyNSwgczogMSwgYjogMSwgbmFtZTogXCJncmVlblwiIH0sIHsgaDogMzAsIHM6IDAuNSwgYjogMSwgbmFtZTogXCJsaWdodCBncmVlblwiIH0sIHsgaDogMzAsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGdyZWVuXCIgfSwgeyBoOiAzMCwgczogMSwgYjogMSwgbmFtZTogXCJncmVlblwiIH0sIHsgaDogMzUsIHM6IDAsIGI6IDAuNSwgbmFtZTogXCJsaWdodCBncmVlblwiIH0sIHsgaDogMzUsIHM6IDAsIGI6IDEsIG5hbWU6IFwidmVyeSBsaWdodCBncmVlblwiIH0sIHsgaDogMzUsIHM6IDAuNSwgYjogMC41LCBuYW1lOiBcImRhcmsgZ3JlZW5cIiB9LCB7IGg6IDM1LCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgZ3JlZW5cIiB9LCB7IGg6IDM1LCBzOiAxLCBiOiAwLCBuYW1lOiBcInZlcnkgZGFyayBncmVlblwiIH0sIHsgaDogMzUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGdyZWVuXCIgfSwgeyBoOiAzNSwgczogMSwgYjogMSwgbmFtZTogXCJncmVlblwiIH0sIHsgaDogNDAsIHM6IDAsIGI6IDEsIG5hbWU6IFwidmVyeSBsaWdodCBncmVlblwiIH0sIHsgaDogNDAsIHM6IDAuNSwgYjogMC41LCBuYW1lOiBcImRhcmsgZ3JlZW5cIiB9LCB7IGg6IDQwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgZ3JlZW5cIiB9LCB7IGg6IDQwLCBzOiAxLCBiOiAwLjUsIG5hbWU6IFwiZGFyayBncmVlblwiIH0sIHsgaDogNDAsIHM6IDEsIGI6IDEsIG5hbWU6IFwiZ3JlZW5cIiB9LCB7IGg6IDQ1LCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgdHVycXVvaXNlXCIgfSwgeyBoOiA0NSwgczogMSwgYjogMC41LCBuYW1lOiBcImRhcmsgdHVycXVvaXNlXCIgfSwgeyBoOiA0NSwgczogMSwgYjogMSwgbmFtZTogXCJ0dXJxdW9pc2VcIiB9LCB7IGg6IDUwLCBzOiAwLCBiOiAxLCBuYW1lOiBcImxpZ2h0IHNreSBibHVlXCIgfSwgeyBoOiA1MCwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwiZGFyayBjeWFuXCIgfSwgeyBoOiA1MCwgczogMC41LCBiOiAxLCBuYW1lOiBcImxpZ2h0IGN5YW5cIiB9LCB7IGg6IDUwLCBzOiAxLCBiOiAwLjUsIG5hbWU6IFwiZGFyayBjeWFuXCIgfSwgeyBoOiA1MCwgczogMSwgYjogMSwgbmFtZTogXCJjeWFuXCIgfSwgeyBoOiA1NSwgczogMCwgYjogMSwgbmFtZTogXCJsaWdodCBza3kgYmx1ZVwiIH0sIHsgaDogNTUsIHM6IDAuNSwgYjogMSwgbmFtZTogXCJsaWdodCBza3kgYmx1ZVwiIH0sIHsgaDogNTUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGJsdWVcIiB9LCB7IGg6IDU1LCBzOiAxLCBiOiAxLCBuYW1lOiBcInNreSBibHVlXCIgfSwgeyBoOiA2MCwgczogMCwgYjogMC41LCBuYW1lOiBcImdyYXlcIiB9LCB7IGg6IDYwLCBzOiAwLCBiOiAxLCBuYW1lOiBcInZlcnkgbGlnaHQgYmx1ZVwiIH0sIHsgaDogNjAsIHM6IDAuNSwgYjogMC41LCBuYW1lOiBcImJsdWVcIiB9LCB7IGg6IDYwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgYmx1ZVwiIH0sIHsgaDogNjAsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJuYXZ5IGJsdWVcIiB9LCB7IGg6IDYwLCBzOiAxLCBiOiAxLCBuYW1lOiBcImJsdWVcIiB9LCB7IGg6IDY1LCBzOiAwLCBiOiAxLCBuYW1lOiBcImxhdmVuZGVyXCIgfSwgeyBoOiA2NSwgczogMC41LCBiOiAwLjUsIG5hbWU6IFwibmF2eSBibHVlXCIgfSwgeyBoOiA2NSwgczogMC41LCBiOiAxLCBuYW1lOiBcImxpZ2h0IHB1cnBsZVwiIH0sIHsgaDogNjUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIG5hdnkgYmx1ZVwiIH0sIHsgaDogNjUsIHM6IDEsIGI6IDEsIG5hbWU6IFwiYmx1ZVwiIH0sIHsgaDogNzAsIHM6IDAsIGI6IDEsIG5hbWU6IFwibGF2ZW5kZXJcIiB9LCB7IGg6IDcwLCBzOiAwLjUsIGI6IDAuNSwgbmFtZTogXCJuYXZ5IGJsdWVcIiB9LCB7IGg6IDcwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGF2ZW5kZXIgYmx1ZVwiIH0sIHsgaDogNzAsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIG5hdnkgYmx1ZVwiIH0sIHsgaDogNzAsIHM6IDEsIGI6IDEsIG5hbWU6IFwiYmx1ZVwiIH0sIHsgaDogNzUsIHM6IDAuNSwgYjogMSwgbmFtZTogXCJsYXZlbmRlclwiIH0sIHsgaDogNzUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIHB1cnBsZVwiIH0sIHsgaDogNzUsIHM6IDEsIGI6IDEsIG5hbWU6IFwicHVycGxlXCIgfSwgeyBoOiA4MCwgczogMC41LCBiOiAxLCBuYW1lOiBcInBpbmtpc2ggcHVycGxlXCIgfSwgeyBoOiA4MCwgczogMSwgYjogMC41LCBuYW1lOiBcImRhcmsgcHVycGxlXCIgfSwgeyBoOiA4MCwgczogMSwgYjogMSwgbmFtZTogXCJwdXJwbGVcIiB9LCB7IGg6IDg1LCBzOiAwLCBiOiAxLCBuYW1lOiBcImxpZ2h0IHBpbmtcIiB9LCB7IGg6IDg1LCBzOiAwLjUsIGI6IDAuNSwgbmFtZTogXCJwdXJwbGVcIiB9LCB7IGg6IDg1LCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwibGlnaHQgZnVjaHNpYVwiIH0sIHsgaDogODUsIHM6IDEsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGZ1Y2hzaWFcIiB9LCB7IGg6IDg1LCBzOiAxLCBiOiAxLCBuYW1lOiBcImZ1Y2hzaWFcIiB9LCB7IGg6IDkwLCBzOiAwLjUsIGI6IDAuNSwgbmFtZTogXCJkYXJrIGZ1Y2hzaWFcIiB9LCB7IGg6IDkwLCBzOiAwLjUsIGI6IDEsIG5hbWU6IFwiaG90IHBpbmtcIiB9LCB7IGg6IDkwLCBzOiAxLCBiOiAwLjUsIG5hbWU6IFwiZGFyayBmdWNoc2lhXCIgfSwgeyBoOiA5MCwgczogMSwgYjogMSwgbmFtZTogXCJmdWNoc2lhXCIgfSwgeyBoOiA5NSwgczogMCwgYjogMSwgbmFtZTogXCJwaW5rXCIgfSwgeyBoOiA5NSwgczogMC41LCBiOiAxLCBuYW1lOiBcImxpZ2h0IHBpbmtcIiB9LCB7IGg6IDk1LCBzOiAxLCBiOiAwLjUsIG5hbWU6IFwiZGFyayBtYWdlbnRhXCIgfSwgeyBoOiA5NSwgczogMSwgYjogMSwgbmFtZTogXCJtYWdlbnRhXCIgfV07XG4gICAgICB5LmRlZmF1bHQucHJvdG90eXBlLl9yZ2JDb2xvck5hbWUgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBzLCBvLCBpID0gdS5kZWZhdWx0Ll9yZ2JhVG9IU0JBKGkpLCBsID0gWyhtID0gaSlbMF0sIGlbMV0sIGlbMl1dO1xuICAgICAgICBsWzBdICE9PSAwICYmIChsWzBdID0gTWF0aC5yb3VuZCgxMDAgKiBsWzBdKSwgKGkgPSBsWzBdLnRvU3RyaW5nKCkuc3BsaXQoXCJcIikpW28gPSBpLmxlbmd0aCAtIDFdID0gcGFyc2VJbnQoaVtvXSksIGlbb10gPCAyLjUgPyBpW29dID0gMCA6IDIuNSA8PSBpW29dICYmIGlbb10gPCA3LjUgJiYgKGlbb10gPSA1KSwgaS5sZW5ndGggPT09IDIgPyAoaVswXSA9IHBhcnNlSW50KGlbMF0pLCA3LjUgPD0gaVtvXSAmJiAoaVtvXSA9IDAsIGlbMF0gPSBpWzBdICsgMSksIGxbMF0gPSAxMCAqIGlbMF0gKyBpWzFdKSA6IDcuNSA8PSBpW29dID8gbFswXSA9IDEwIDogbFswXSA9IGlbb10pLCBsWzJdID0gbFsyXSAvIDI1NTtcbiAgICAgICAgZm9yICh2YXIgbiA9IGwubGVuZ3RoIC0gMTsgMSA8PSBuOyBuLS0pXG4gICAgICAgICAgbFtuXSA8PSAwLjI1ID8gbFtuXSA9IDAgOiAwLjI1IDwgbFtuXSAmJiBsW25dIDwgMC43NSA/IGxbbl0gPSAwLjUgOiBsW25dID0gMTtcbiAgICAgICAgaWYgKGxbMF0gPT09IDAgJiYgbFsxXSA9PT0gMCAmJiBsWzJdID09PSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDI7IDAgPD0gYTsgYS0tKVxuICAgICAgICAgICAgbVthXSA9IE1hdGgucm91bmQoMWU0ICogbVthXSkgLyAxZTQ7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBnLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBpZiAoZ1tjXS5oID09PSBtWzBdICYmIGdbY10ucyA9PT0gbVsxXSAmJiBnW2NdLmIgPT09IG1bMl0pIHtcbiAgICAgICAgICAgICAgcyA9IGdbY10ubmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBmLmxlbmd0aDsgcCsrKVxuICAgICAgICAgICAgaWYgKGZbcF0uaCA9PT0gbFswXSAmJiBmW3BdLnMgPT09IGxbMV0gJiYgZltwXS5iID09PSBsWzJdKSB7XG4gICAgICAgICAgICAgIHMgPSBmW3BdLm5hbWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIHQgPSB5LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvbG9yL2NvbG9yX2NvbnZlcnNpb25cIjogMjY1LCBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIjogMTczLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMyB9XSwgMjYwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfSwgeSA9IFwiX0Rlc2NyaXB0aW9uXCIsIHUgPSBcIl9mYWxsYmFja0Rlc2NcIiwgaCA9IFwiX2ZhbGxiYWNrVGFibGVcIiwgZyA9IFwiX0xhYmVsXCIsIGYgPSBcIl9sYWJlbERlc2NcIiwgciA9IFwiX2xhYmVsVGFibGVcIjtcbiAgICAgIGZ1bmN0aW9uIHMobykge1xuICAgICAgICBpZiAobyA9PT0gXCJsYWJlbFwiIHx8IG8gPT09IFwiZmFsbGJhY2tcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXNjcmlwdGlvbiBzaG91bGQgbm90IGJlIExBQkVMIG9yIEZBTExCQUNLXCIpO1xuICAgICAgICByZXR1cm4gby5lbmRzV2l0aChcIi5cIikgfHwgby5lbmRzV2l0aChcIjtcIikgfHwgby5lbmRzV2l0aChcIixcIikgfHwgby5lbmRzV2l0aChcIj9cIikgfHwgby5lbmRzV2l0aChcIiFcIikgfHwgKG8gKz0gXCIuXCIpLCBvO1xuICAgICAgfVxuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZGVzY3JpYmVcIiwgYXJndW1lbnRzKSwgdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAobCA9IHRoaXMuY2FudmFzLmlkLCBvID0gcyhvKSwgdGhpcy5kdW1teURPTSB8fCAodGhpcy5kdW1teURPTSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGwpLnBhcmVudE5vZGUpLCB0aGlzLmRlc2NyaXB0aW9ucyB8fCAodGhpcy5kZXNjcmlwdGlvbnMgPSB7fSksIHRoaXMuZGVzY3JpcHRpb25zLmZhbGxiYWNrID8gdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2suaW5uZXJIVE1MICE9PSBvICYmICh0aGlzLmRlc2NyaXB0aW9ucy5mYWxsYmFjay5pbm5lckhUTUwgPSBvKSA6IHRoaXMuX2Rlc2NyaWJlSFRNTChcImZhbGxiYWNrXCIsIG8pLCBpID09PSB0aGlzLkxBQkVMICYmICh0aGlzLmRlc2NyaXB0aW9ucy5sYWJlbCA/IHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsLmlubmVySFRNTCAhPT0gbyAmJiAodGhpcy5kZXNjcmlwdGlvbnMubGFiZWwuaW5uZXJIVE1MID0gbykgOiB0aGlzLl9kZXNjcmliZUhUTUwoXCJsYWJlbFwiLCBvKSkpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5kZXNjcmliZUVsZW1lbnQgPSBmdW5jdGlvbihvLCBpLCBsKSB7XG4gICAgICAgIHZhciBuLCBhO1xuICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImRlc2NyaWJlRWxlbWVudFwiLCBhcmd1bWVudHMpLCB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgKG4gPSB0aGlzLmNhbnZhcy5pZCwgaSA9IHMoaSksIGEgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgaWYgKGMgPT09IFwibGFiZWxcIiB8fCBjID09PSBcImZhbGxiYWNrXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50IG5hbWUgc2hvdWxkIG5vdCBiZSBMQUJFTCBvciBGQUxMQkFDS1wiKTtcbiAgICAgICAgICByZXR1cm4gYy5lbmRzV2l0aChcIi5cIikgfHwgYy5lbmRzV2l0aChcIjtcIikgfHwgYy5lbmRzV2l0aChcIixcIikgPyBjID0gYy5yZXBsYWNlKC8uJC8sIFwiOlwiKSA6IGMuZW5kc1dpdGgoXCI6XCIpIHx8IChjICs9IFwiOlwiKSwgYztcbiAgICAgICAgfShvKSwgbyA9IG8ucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLCBhID0gJzx0aCBzY29wZT1cInJvd1wiPicuY29uY2F0KGEsIFwiPC90aD48dGQ+XCIpLmNvbmNhdChpLCBcIjwvdGQ+XCIpLCB0aGlzLmR1bW15RE9NIHx8ICh0aGlzLmR1bW15RE9NID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobikucGFyZW50Tm9kZSksIHRoaXMuZGVzY3JpcHRpb25zID8gdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2tFbGVtZW50cyB8fCAodGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2tFbGVtZW50cyA9IHt9KSA6IHRoaXMuZGVzY3JpcHRpb25zID0geyBmYWxsYmFja0VsZW1lbnRzOiB7fSB9LCB0aGlzLmRlc2NyaXB0aW9ucy5mYWxsYmFja0VsZW1lbnRzW29dID8gdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2tFbGVtZW50c1tvXS5pbm5lckhUTUwgIT09IGEgJiYgKHRoaXMuZGVzY3JpcHRpb25zLmZhbGxiYWNrRWxlbWVudHNbb10uaW5uZXJIVE1MID0gYSkgOiB0aGlzLl9kZXNjcmliZUVsZW1lbnRIVE1MKFwiZmFsbGJhY2tcIiwgbywgYSksIGwgPT09IHRoaXMuTEFCRUwgJiYgKHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsRWxlbWVudHMgfHwgKHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsRWxlbWVudHMgPSB7fSksIHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsRWxlbWVudHNbb10gPyB0aGlzLmRlc2NyaXB0aW9ucy5sYWJlbEVsZW1lbnRzW29dLmlubmVySFRNTCAhPT0gYSAmJiAodGhpcy5kZXNjcmlwdGlvbnMubGFiZWxFbGVtZW50c1tvXS5pbm5lckhUTUwgPSBhKSA6IHRoaXMuX2Rlc2NyaWJlRWxlbWVudEhUTUwoXCJsYWJlbFwiLCBvLCBhKSkpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fZGVzY3JpYmVIVE1MID0gZnVuY3Rpb24obywgaSkge1xuICAgICAgICB2YXIgbCwgbiA9IHRoaXMuY2FudmFzLmlkO1xuICAgICAgICBvID09PSBcImZhbGxiYWNrXCIgPyAodGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChuICsgeSkpID8gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiICsgbiArIGgpLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsICc8cCBpZD1cIicuY29uY2F0KG4gKyB1LCAnXCI+PC9wPicpKSA6IChsID0gJzxkaXYgaWQ9XCInLmNvbmNhdChuKS5jb25jYXQoeSwgJ1wiIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiQ2FudmFzIERlc2NyaXB0aW9uXCI+PHAgaWQ9XCInKS5jb25jYXQobikuY29uY2F0KHUsICdcIj48L3A+PC9kaXY+JyksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobiwgXCJhY2Nlc3NpYmxlT3V0cHV0XCIpKSA/IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobiwgXCJhY2Nlc3NpYmxlT3V0cHV0XCIpKS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBsKSA6IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobikpLmlubmVySFRNTCA9IGwpLCB0aGlzLmRlc2NyaXB0aW9ucy5mYWxsYmFjayA9IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobikuY29uY2F0KHUpKSwgdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2suaW5uZXJIVE1MID0gaSkgOiBvID09PSBcImxhYmVsXCIgJiYgKHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobiArIGcpKSA/IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobiArIHIpKSAmJiB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KG4gKyByKSkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgJzxwIGlkPVwiJy5jb25jYXQobikuY29uY2F0KGYsICdcIj48L3A+JykpIDogKGwgPSAnPGRpdiBpZD1cIicuY29uY2F0KG4pLmNvbmNhdChnLCAnXCIgY2xhc3M9XCJwNUxhYmVsXCI+PHAgaWQ9XCInKS5jb25jYXQobikuY29uY2F0KGYsICdcIj48L3A+PC9kaXY+JyksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobiwgXCJhY2Nlc3NpYmxlT3V0cHV0TGFiZWxcIikpID8gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChuLCBcImFjY2Vzc2libGVPdXRwdXRMYWJlbFwiKSkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgbCkgOiB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBuKS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCBsKSksIHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsID0gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiICsgbiArIGYpLCB0aGlzLmRlc2NyaXB0aW9ucy5sYWJlbC5pbm5lckhUTUwgPSBpKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2Rlc2NyaWJlRWxlbWVudEhUTUwgPSBmdW5jdGlvbihvLCBpLCBsKSB7XG4gICAgICAgIHZhciBuLCBhID0gdGhpcy5jYW52YXMuaWQ7XG4gICAgICAgIG8gPT09IFwiZmFsbGJhY2tcIiA/ICh0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGEgKyB5KSkgPyB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBhICsgaCkgfHwgdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiICsgYSArIHUpLmluc2VydEFkamFjZW50SFRNTChcImFmdGVyZW5kXCIsICc8dGFibGUgaWQ9XCInLmNvbmNhdChhKS5jb25jYXQoaCwgJ1wiPjxjYXB0aW9uPkNhbnZhcyBlbGVtZW50cyBhbmQgdGhlaXIgZGVzY3JpcHRpb25zPC9jYXB0aW9uPjwvdGFibGU+JykpIDogKG4gPSAnPGRpdiBpZD1cIicuY29uY2F0KGEpLmNvbmNhdCh5LCAnXCIgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJDYW52YXMgRGVzY3JpcHRpb25cIj48dGFibGUgaWQ9XCInKS5jb25jYXQoYSkuY29uY2F0KGgsICdcIj48Y2FwdGlvbj5DYW52YXMgZWxlbWVudHMgYW5kIHRoZWlyIGRlc2NyaXB0aW9uczwvY2FwdGlvbj48L3RhYmxlPjwvZGl2PicpLCB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGEsIFwiYWNjZXNzaWJsZU91dHB1dFwiKSkgPyB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGEsIFwiYWNjZXNzaWJsZU91dHB1dFwiKSkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgbikgOiB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBhKS5pbm5lckhUTUwgPSBuKSwgKG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIikpLmlkID0gYSArIFwiX2Z0ZV9cIiArIGksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIiArIGEgKyBoKS5hcHBlbmRDaGlsZChuKSwgdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2tFbGVtZW50c1tpXSA9IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQoYSkuY29uY2F0KFwiX2Z0ZV9cIikuY29uY2F0KGkpKSwgdGhpcy5kZXNjcmlwdGlvbnMuZmFsbGJhY2tFbGVtZW50c1tpXS5pbm5lckhUTUwgPSBsKSA6IG8gPT09IFwibGFiZWxcIiAmJiAodGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChhICsgZykpID8gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChhICsgcikpIHx8IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIiArIGEgKyBmKS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCAnPHRhYmxlIGlkPVwiJy5jb25jYXQoYSArIHIsICdcIj48L3RhYmxlPicpKSA6IChuID0gJzxkaXYgaWQ9XCInLmNvbmNhdChhKS5jb25jYXQoZywgJ1wiIGNsYXNzPVwicDVMYWJlbFwiPjx0YWJsZSBpZD1cIicpLmNvbmNhdChhKS5jb25jYXQociwgJ1wiPjwvdGFibGU+PC9kaXY+JyksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQoYSwgXCJhY2Nlc3NpYmxlT3V0cHV0TGFiZWxcIikpID8gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChhLCBcImFjY2Vzc2libGVPdXRwdXRMYWJlbFwiKSkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgbikgOiB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBhKS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCBuKSksIChvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpKS5pZCA9IGEgKyBcIl9sdGVfXCIgKyBpLCB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBhICsgcikuYXBwZW5kQ2hpbGQobyksIHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsRWxlbWVudHNbaV0gPSB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGEpLmNvbmNhdChcIl9sdGVfXCIpLmNvbmNhdChpKSksIHRoaXMuZGVzY3JpcHRpb25zLmxhYmVsRWxlbWVudHNbaV0uaW5uZXJIVE1MID0gbCk7XG4gICAgICB9LCB0ID0gbS5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiOiAxOTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGhcIjogMTk1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiOiAyMDEgfV0sIDI2MTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQgPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5fdXBkYXRlR3JpZE91dHB1dCA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHksIHUsIGgsIGc7XG4gICAgICAgIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobSwgXCJfc3VtbWFyeVwiKSkgJiYgKHkgPSB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0c1ttXSwgaCA9IGZ1bmN0aW9uKGYsIHIsIHMsIG8pIHtcbiAgICAgICAgICByZXR1cm4gciA9IFwiXCIuY29uY2F0KHIsIFwiIGNhbnZhcywgXCIpLmNvbmNhdChzLCBcIiBieSBcIikuY29uY2F0KG8sIFwiIHBpeGVscywgY29udGFpbnMgXCIpLmNvbmNhdChmWzBdKSwgciA9IChmWzBdID09PSAxID8gXCJcIi5jb25jYXQociwgXCIgc2hhcGU6IFwiKSA6IFwiXCIuY29uY2F0KHIsIFwiIHNoYXBlczogXCIpKS5jb25jYXQoZlsxXSksIHI7XG4gICAgICAgIH0oKHUgPSBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgdmFyIHMsIG8gPSBcIlwiLCBpID0gXCJcIiwgbCA9IDA7XG4gICAgICAgICAgZm9yIChzIGluIHIpIHtcbiAgICAgICAgICAgIHZhciBuLCBhID0gMDtcbiAgICAgICAgICAgIGZvciAobiBpbiByW3NdKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gJzxsaSBpZD1cIicuY29uY2F0KGYsIFwic2hhcGVcIikuY29uY2F0KGwsICdcIj4nKS5jb25jYXQocltzXVtuXS5jb2xvciwgXCIgXCIpLmNvbmNhdChzLCBcIixcIik7XG4gICAgICAgICAgICAgIHMgPT09IFwibGluZVwiID8gYyArPSBcIiBsb2NhdGlvbiA9IFwiLmNvbmNhdChyW3NdW25dLnBvcywgXCIsIGxlbmd0aCA9IFwiKS5jb25jYXQocltzXVtuXS5sZW5ndGgsIFwiIHBpeGVsc1wiKSA6IChjICs9IFwiIGxvY2F0aW9uID0gXCIuY29uY2F0KHJbc11bbl0ucG9zKSwgcyAhPT0gXCJwb2ludFwiICYmIChjICs9IFwiLCBhcmVhID0gXCIuY29uY2F0KHJbc11bbl0uYXJlYSwgXCIgJVwiKSksIGMgKz0gXCI8L2xpPlwiKSwgbyArPSBjLCBhKyssIGwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSAxIDwgYSA/IFwiXCIuY29uY2F0KGksIFwiIFwiKS5jb25jYXQoYSwgXCIgXCIpLmNvbmNhdChzLCBcInNcIikgOiBcIlwiLmNvbmNhdChpLCBcIiBcIikuY29uY2F0KGEsIFwiIFwiKS5jb25jYXQocyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IG51bVNoYXBlczogW2wsIGldLCBkZXRhaWxzOiBvIH07XG4gICAgICAgIH0obSwgdGhpcy5pbmdyZWRpZW50cy5zaGFwZXMpKS5udW1TaGFwZXMsIHRoaXMuaW5ncmVkaWVudHMuY29sb3JzLmJhY2tncm91bmQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgZyA9IGZ1bmN0aW9uKGYsIHIpIHtcbiAgICAgICAgICB2YXIgcywgbywgaSA9IDAsIGwgPSBcIlwiLCBuID0gQXJyYXkuZnJvbShBcnJheSgxMCksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KDEwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHMgaW4gcilcbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4gcltzXSkge1xuICAgICAgICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgYyA9IHMgIT09IFwibGluZVwiID8gJzxhIGhyZWY9XCIjJy5jb25jYXQoZiwgXCJzaGFwZVwiKS5jb25jYXQoaSwgJ1wiPicpLmNvbmNhdChyW3NdW2FdLmNvbG9yLCBcIiBcIikuY29uY2F0KHMsIFwiPC9hPlwiKSA6ICc8YSBocmVmPVwiIycuY29uY2F0KGYsIFwic2hhcGVcIikuY29uY2F0KGksICdcIj4nKS5jb25jYXQocltzXVthXS5jb2xvciwgXCIgXCIpLmNvbmNhdChzLCBcIiBtaWRwb2ludDwvYT5cIiksIG5bcltzXVthXS5sb2MubG9jWV1bcltzXVthXS5sb2MubG9jWF0gPyBuW3Jbc11bYV0ubG9jLmxvY1ldW3Jbc11bYV0ubG9jLmxvY1hdID0gbltyW3NdW2FdLmxvYy5sb2NZXVtyW3NdW2FdLmxvYy5sb2NYXSArIFwiICBcIiArIGMgOiBuW3Jbc11bYV0ubG9jLmxvY1ldW3Jbc11bYV0ubG9jLmxvY1hdID0gYywgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZvciAobyBpbiBuKSB7XG4gICAgICAgICAgICB2YXIgcCwgaiA9IFwiPHRyPlwiO1xuICAgICAgICAgICAgZm9yIChwIGluIG5bb10pXG4gICAgICAgICAgICAgIGogKz0gXCI8dGQ+XCIsIG5bb11bcF0gIT09IHZvaWQgMCAmJiAoaiArPSBuW29dW3BdKSwgaiArPSBcIjwvdGQ+XCI7XG4gICAgICAgICAgICBsID0gbCArIGogKyBcIjwvdHI+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9KG0sIHRoaXMuaW5ncmVkaWVudHMuc2hhcGVzKSwgaCAhPT0geS5zdW1tYXJ5LmlubmVySFRNTCAmJiAoeS5zdW1tYXJ5LmlubmVySFRNTCA9IGgpLCBnICE9PSB5Lm1hcC5pbm5lckhUTUwgJiYgKHkubWFwLmlubmVySFRNTCA9IGcpLCB1LmRldGFpbHMgIT09IHkuc2hhcGVEZXRhaWxzLmlubmVySFRNTCAmJiAoeS5zaGFwZURldGFpbHMuaW5uZXJIVE1MID0gdS5kZXRhaWxzKSwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHNbbV0gPSB5KTtcbiAgICAgIH0sIHQgPSB0LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3IH1dLCAyNjI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIHkoaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGcpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gMCwgciA9IG5ldyBBcnJheShnLmxlbmd0aCk7IGYgPCBnLmxlbmd0aDsgZisrKVxuICAgICAgICAgICAgICByW2ZdID0gZ1tmXTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfShoKSB8fCBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZykgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGcpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZyk7XG4gICAgICAgIH0oaCkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgICAgICB9KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KGgsIGcsIGYpIHtcbiAgICAgICAgcmV0dXJuIGcgPSBNYXRoLmZsb29yKGhbMF0gLyBnICogMTApLCBoID0gTWF0aC5mbG9vcihoWzFdIC8gZiAqIDEwKSwgZyA9PT0gMTAgJiYgKGcgLT0gMSksIGggPT09IDEwICYmIChoIC09IDEpLCB7IGxvY1g6IGcsIGxvY1k6IGggfTtcbiAgICAgIH1cbiAgICAgIG0uZGVmYXVsdC5wcm90b3R5cGUudGV4dE91dHB1dCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0T3V0cHV0XCIsIGFyZ3VtZW50cyksIHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHQgfHwgKHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHQgPSAhMCwgdGhpcy5fY3JlYXRlT3V0cHV0KFwidGV4dE91dHB1dFwiLCBcIkZhbGxiYWNrXCIpLCBoID09PSB0aGlzLkxBQkVMICYmICh0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy50ZXh0TGFiZWwgPSAhMCwgdGhpcy5fY3JlYXRlT3V0cHV0KFwidGV4dE91dHB1dFwiLCBcIkxhYmVsXCIpKSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmdyaWRPdXRwdXQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZ3JpZE91dHB1dFwiLCBhcmd1bWVudHMpLCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy5ncmlkIHx8ICh0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy5ncmlkID0gITAsIHRoaXMuX2NyZWF0ZU91dHB1dChcImdyaWRPdXRwdXRcIiwgXCJGYWxsYmFja1wiKSwgaCA9PT0gdGhpcy5MQUJFTCAmJiAodGhpcy5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZExhYmVsID0gITAsIHRoaXMuX2NyZWF0ZU91dHB1dChcImdyaWRPdXRwdXRcIiwgXCJMYWJlbFwiKSkpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fYWRkQWNjc091dHB1dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMgfHwgKHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzID0geyB0ZXh0OiAhMSwgZ3JpZDogITEsIHRleHRMYWJlbDogITEsIGdyaWRMYWJlbDogITEgfSksIHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLmdyaWQgfHwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMudGV4dDtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2NyZWF0ZU91dHB1dCA9IGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgdmFyIGYsIHIsIHMsIG8gPSB0aGlzLmNhbnZhcy5pZCwgaSA9ICh0aGlzLmluZ3JlZGllbnRzIHx8ICh0aGlzLmluZ3JlZGllbnRzID0geyBzaGFwZXM6IHt9LCBjb2xvcnM6IHsgYmFja2dyb3VuZDogXCJ3aGl0ZVwiLCBmaWxsOiBcIndoaXRlXCIsIHN0cm9rZTogXCJibGFja1wiIH0sIHBTaGFwZXM6IFwiXCIsIHBCYWNrZ3JvdW5kOiBcIlwiIH0pLCB0aGlzLmR1bW15RE9NIHx8ICh0aGlzLmR1bW15RE9NID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobykucGFyZW50Tm9kZSksIFwiXCIpO1xuICAgICAgICBnID09PSBcIkZhbGxiYWNrXCIgPyAoZiA9IG8gKyBoLCB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KHIgPSBvICsgXCJhY2Nlc3NpYmxlT3V0cHV0XCIpKSB8fCAodGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChvLCBcIl9EZXNjcmlwdGlvblwiKSkgPyB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KG8sIFwiX0Rlc2NyaXB0aW9uXCIpKS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCAnPGRpdiBpZD1cIicuY29uY2F0KHIsICdcIiByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkNhbnZhcyBPdXRwdXRzXCI+PC9kaXY+JykpIDogdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChvKSkuaW5uZXJIVE1MID0gJzxkaXYgaWQ9XCInLmNvbmNhdChyLCAnXCIgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJDYW52YXMgT3V0cHV0c1wiPjwvZGl2PicpKSkgOiBnID09PSBcIkxhYmVsXCIgJiYgKGYgPSBvICsgaCArIChpID0gZyksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQociA9IG8gKyBcImFjY2Vzc2libGVPdXRwdXRcIiArIGcpKSB8fCAodGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChvLCBcIl9MYWJlbFwiKSkgPyB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KG8sIFwiX0xhYmVsXCIpKSA6IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQobykpKS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCAnPGRpdiBpZD1cIicuY29uY2F0KHIsICdcIj48L2Rpdj4nKSkpLCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0c1tmXSA9IHt9LCBoID09PSBcInRleHRPdXRwdXRcIiA/IChpID0gXCIjXCIuY29uY2F0KG8sIFwiZ3JpZE91dHB1dFwiKS5jb25jYXQoaSksIHMgPSAnPGRpdiBpZD1cIicuY29uY2F0KGYsICdcIj5UZXh0IE91dHB1dDxkaXYgaWQ9XCInKS5jb25jYXQoZiwgJ1N1bW1hcnlcIiBhcmlhLWxhYmVsPVwidGV4dCBvdXRwdXQgc3VtbWFyeVwiPjxwIGlkPVwiJykuY29uY2F0KGYsICdfc3VtbWFyeVwiPjwvcD48dWwgaWQ9XCInKS5jb25jYXQoZiwgJ19saXN0XCI+PC91bD48L2Rpdj48dGFibGUgaWQ9XCInKS5jb25jYXQoZiwgJ19zaGFwZURldGFpbHNcIiBzdW1tYXJ5PVwidGV4dCBvdXRwdXQgc2hhcGUgZGV0YWlsc1wiPjwvdGFibGU+PC9kaXY+JyksIHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihpKSA/IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihpKS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBzKSA6IHRoaXMuZHVtbXlET00ucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQocikpLmlubmVySFRNTCA9IHMsIHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzW2ZdLmxpc3QgPSB0aGlzLmR1bW15RE9NLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGYsIFwiX2xpc3RcIikpKSA6IGggPT09IFwiZ3JpZE91dHB1dFwiICYmIChpID0gXCIjXCIuY29uY2F0KG8sIFwidGV4dE91dHB1dFwiKS5jb25jYXQoaSksIHMgPSAnPGRpdiBpZD1cIicuY29uY2F0KGYsICdcIj5HcmlkIE91dHB1dDxwIGlkPVwiJykuY29uY2F0KGYsICdfc3VtbWFyeVwiIGFyaWEtbGFiZWw9XCJncmlkIG91dHB1dCBzdW1tYXJ5XCI+PHRhYmxlIGlkPVwiJykuY29uY2F0KGYsICdfbWFwXCIgc3VtbWFyeT1cImdyaWQgb3V0cHV0IGNvbnRlbnRcIj48L3RhYmxlPjx1bCBpZD1cIicpLmNvbmNhdChmLCAnX3NoYXBlRGV0YWlsc1wiIGFyaWEtbGFiZWw9XCJncmlkIG91dHB1dCBzaGFwZSBkZXRhaWxzXCI+PC91bD48L2Rpdj4nKSwgdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKGkpID8gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKGkpLmluc2VydEFkamFjZW50SFRNTChcImFmdGVyZW5kXCIsIHMpIDogdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChyKSkuaW5uZXJIVE1MID0gcywgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHNbZl0ubWFwID0gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChmLCBcIl9tYXBcIikpKSwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHNbZl0uc2hhcGVEZXRhaWxzID0gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChmLCBcIl9zaGFwZURldGFpbHNcIikpLCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0c1tmXS5zdW1tYXJ5ID0gdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChmLCBcIl9zdW1tYXJ5XCIpKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX3VwZGF0ZUFjY3NPdXRwdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNhbnZhcy5pZDtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5pbmdyZWRpZW50cy5zaGFwZXMpID09PSB0aGlzLmluZ3JlZGllbnRzLnBTaGFwZXMgJiYgdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuYmFja2dyb3VuZCA9PT0gdGhpcy5pbmdyZWRpZW50cy5wQmFja2dyb3VuZCB8fCAodGhpcy5pbmdyZWRpZW50cy5wU2hhcGVzID0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbmdyZWRpZW50cy5zaGFwZXMpLCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy50ZXh0ICYmIHRoaXMuX3VwZGF0ZVRleHRPdXRwdXQoaCArIFwidGV4dE91dHB1dFwiKSwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZCAmJiB0aGlzLl91cGRhdGVHcmlkT3V0cHV0KGggKyBcImdyaWRPdXRwdXRcIiksIHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHRMYWJlbCAmJiB0aGlzLl91cGRhdGVUZXh0T3V0cHV0KGggKyBcInRleHRPdXRwdXRMYWJlbFwiKSwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZExhYmVsICYmIHRoaXMuX3VwZGF0ZUdyaWRPdXRwdXQoaCArIFwiZ3JpZE91dHB1dExhYmVsXCIpKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2FjY3NCYWNrZ3JvdW5kID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB0aGlzLmluZ3JlZGllbnRzLnBTaGFwZXMgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmluZ3JlZGllbnRzLnNoYXBlcyksIHRoaXMuaW5ncmVkaWVudHMucEJhY2tncm91bmQgPSB0aGlzLmluZ3JlZGllbnRzLmNvbG9ycy5iYWNrZ3JvdW5kLCB0aGlzLmluZ3JlZGllbnRzLnNoYXBlcyA9IHt9LCB0aGlzLmluZ3JlZGllbnRzLmNvbG9ycy5iYWNrZ3JvdW5kUkdCQSAhPT0gaCAmJiAodGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuYmFja2dyb3VuZFJHQkEgPSBoLCB0aGlzLmluZ3JlZGllbnRzLmNvbG9ycy5iYWNrZ3JvdW5kID0gdGhpcy5fcmdiQ29sb3JOYW1lKGgpKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2FjY3NDYW52YXNDb2xvcnMgPSBmdW5jdGlvbihoLCBnKSB7XG4gICAgICAgIGggPT09IFwiZmlsbFwiID8gdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuZmlsbFJHQkEgIT09IGcgJiYgKHRoaXMuaW5ncmVkaWVudHMuY29sb3JzLmZpbGxSR0JBID0gZywgdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuZmlsbCA9IHRoaXMuX3JnYkNvbG9yTmFtZShnKSkgOiBoID09PSBcInN0cm9rZVwiICYmIHRoaXMuaW5ncmVkaWVudHMuY29sb3JzLnN0cm9rZVJHQkEgIT09IGcgJiYgKHRoaXMuaW5ncmVkaWVudHMuY29sb3JzLnN0cm9rZVJHQkEgPSBnLCB0aGlzLmluZ3JlZGllbnRzLmNvbG9ycy5zdHJva2UgPSB0aGlzLl9yZ2JDb2xvck5hbWUoZykpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fYWNjc091dHB1dCA9IGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgaCA9PT0gXCJlbGxpcHNlXCIgJiYgZ1syXSA9PT0gZ1szXSA/IGggPSBcImNpcmNsZVwiIDogaCA9PT0gXCJyZWN0YW5nbGVcIiAmJiBnWzJdID09PSBnWzNdICYmIChoID0gXCJzcXVhcmVcIik7XG4gICAgICAgIHZhciBmLCByLCBzID0ge30sIG8gPSAhMCwgaSA9IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICByZXR1cm4gbiA9IG4gPT09IFwicmVjdGFuZ2xlXCIgfHwgbiA9PT0gXCJlbGxpcHNlXCIgfHwgbiA9PT0gXCJhcmNcIiB8fCBuID09PSBcImNpcmNsZVwiIHx8IG4gPT09IFwic3F1YXJlXCIgPyAoYyA9IE1hdGgucm91bmQoYVswXSArIGFbMl0gLyAyKSwgTWF0aC5yb3VuZChhWzFdICsgYVszXSAvIDIpKSA6IG4gPT09IFwidHJpYW5nbGVcIiA/IChjID0gKGFbMF0gKyBhWzJdICsgYVs0XSkgLyAzLCAoYVsxXSArIGFbM10gKyBhWzVdKSAvIDMpIDogbiA9PT0gXCJxdWFkcmlsYXRlcmFsXCIgPyAoYyA9IChhWzBdICsgYVsyXSArIGFbNF0gKyBhWzZdKSAvIDQsIChhWzFdICsgYVszXSArIGFbNV0gKyBhWzddKSAvIDQpIDogbiA9PT0gXCJsaW5lXCIgPyAoYyA9IChhWzBdICsgYVsyXSkgLyAyLCAoYVsxXSArIGFbM10pIC8gMikgOiAoYyA9IGFbMF0sIGFbMV0pLCBbYywgbl07XG4gICAgICAgIH0oaCwgZyk7XG4gICAgICAgIGlmIChoID09PSBcImxpbmVcIiA/IChzLmNvbG9yID0gdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuc3Ryb2tlLCBzLmxlbmd0aCA9IE1hdGgucm91bmQodGhpcy5kaXN0KGdbMF0sIGdbMV0sIGdbMl0sIGdbM10pKSwgZiA9IHRoaXMuX2dldFBvcyhnWzBdLCBbMV0pLCByID0gdGhpcy5fZ2V0UG9zKGdbMl0sIFszXSksIHMubG9jID0gdShpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHMucG9zID0gZiA9PT0gciA/IFwiYXQgXCIuY29uY2F0KGYpIDogXCJmcm9tIFwiLmNvbmNhdChmLCBcIiB0byBcIikuY29uY2F0KHIpKSA6IChoID09PSBcInBvaW50XCIgPyBzLmNvbG9yID0gdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuc3Ryb2tlIDogKHMuY29sb3IgPSB0aGlzLmluZ3JlZGllbnRzLmNvbG9ycy5maWxsLCBzLmFyZWEgPSB0aGlzLl9nZXRBcmVhKGgsIGcpKSwgcy5wb3MgPSB0aGlzLl9nZXRQb3MuYXBwbHkodGhpcywgeShpKSksIHMubG9jID0gdShpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpLCB0aGlzLmluZ3JlZGllbnRzLnNoYXBlc1toXSkge1xuICAgICAgICAgIGlmICh0aGlzLmluZ3JlZGllbnRzLnNoYXBlc1toXSAhPT0gW3NdKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMuaW5ncmVkaWVudHMuc2hhcGVzW2hdKVxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmluZ3JlZGllbnRzLnNoYXBlc1toXVtsXSkgPT09IEpTT04uc3RyaW5naWZ5KHMpICYmIChvID0gITEpO1xuICAgICAgICAgICAgbyA9PT0gITAgJiYgdGhpcy5pbmdyZWRpZW50cy5zaGFwZXNbaF0ucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMuaW5ncmVkaWVudHMuc2hhcGVzW2hdID0gW3NdO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fZ2V0UG9zID0gZnVuY3Rpb24ociwgZikge1xuICAgICAgICB2YXIgciA9IG5ldyBET01Qb2ludFJlYWRPbmx5KHIsIGYpLCBmID0gdGhpcy5fcmVuZGVyZXIuaXNQM0QgPyBuZXcgRE9NTWF0cml4KHRoaXMuX3JlbmRlcmVyLnVNVk1hdHJpeC5tYXQ0KSA6IHRoaXMuZHJhd2luZ0NvbnRleHQuZ2V0VHJhbnNmb3JtKCksIHIgPSByLm1hdHJpeFRyYW5zZm9ybShmKSwgZiA9IHIueCwgciA9IHIueSwgcyA9IHRoaXMud2lkdGggKiB0aGlzLl9waXhlbERlbnNpdHksIG8gPSB0aGlzLmhlaWdodCAqIHRoaXMuX3BpeGVsRGVuc2l0eTtcbiAgICAgICAgcmV0dXJuIGYgPCAwLjQgKiBzID8gciA8IDAuNCAqIG8gPyBcInRvcCBsZWZ0XCIgOiAwLjYgKiBvIDwgciA/IFwiYm90dG9tIGxlZnRcIiA6IFwibWlkIGxlZnRcIiA6IDAuNiAqIHMgPCBmID8gciA8IDAuNCAqIG8gPyBcInRvcCByaWdodFwiIDogMC42ICogbyA8IHIgPyBcImJvdHRvbSByaWdodFwiIDogXCJtaWQgcmlnaHRcIiA6IHIgPCAwLjQgKiBvID8gXCJ0b3AgbWlkZGxlXCIgOiAwLjYgKiBvIDwgciA/IFwiYm90dG9tIG1pZGRsZVwiIDogXCJtaWRkbGVcIjtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2dldEFyZWEgPSBmdW5jdGlvbihoLCBnKSB7XG4gICAgICAgIHZhciBmLCByLCBzID0gMCwgbyA9IChoID09PSBcImFyY1wiID8gKHMgPSAoZiA9ICgoZ1s1XSAtIGdbNF0pICUgKDIgKiBNYXRoLlBJKSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkpICogZ1syXSAqIGdbM10gLyA4LCBnWzZdICE9PSBcIm9wZW5cIiAmJiBnWzZdICE9PSBcImNob3JkXCIgfHwgKHIgPSBnWzBdLCBhID0gZ1sxXSwgbyA9IGdbMF0gKyBnWzJdIC8gMiAqIE1hdGguY29zKGdbNF0pLnRvRml4ZWQoMiksIGMgPSBnWzFdICsgZ1szXSAvIDIgKiBNYXRoLnNpbihnWzRdKS50b0ZpeGVkKDIpLCBsID0gZ1swXSArIGdbMl0gLyAyICogTWF0aC5jb3MoZ1s1XSkudG9GaXhlZCgyKSwgaSA9IGdbMV0gKyBnWzNdIC8gMiAqIE1hdGguc2luKGdbNV0pLnRvRml4ZWQoMiksIHIgPSBNYXRoLmFicyhyICogKGMgLSBpKSArIG8gKiAoaSAtIGEpICsgbCAqIChhIC0gYykpIC8gMiwgZiA+IE1hdGguUEkgPyBzICs9IHIgOiBzIC09IHIpKSA6IGggPT09IFwiZWxsaXBzZVwiIHx8IGggPT09IFwiY2lyY2xlXCIgPyBzID0gMy4xNCAqIGdbMl0gLyAyICogZ1szXSAvIDIgOiBoID09PSBcImxpbmVcIiB8fCBoID09PSBcInBvaW50XCIgPyBzID0gMCA6IGggPT09IFwicXVhZHJpbGF0ZXJhbFwiID8gcyA9IE1hdGguYWJzKChnWzZdICsgZ1swXSkgKiAoZ1s3XSAtIGdbMV0pICsgKGdbMF0gKyBnWzJdKSAqIChnWzFdIC0gZ1szXSkgKyAoZ1syXSArIGdbNF0pICogKGdbM10gLSBnWzVdKSArIChnWzRdICsgZ1s2XSkgKiAoZ1s1XSAtIGdbN10pKSAvIDIgOiBoID09PSBcInJlY3RhbmdsZVwiIHx8IGggPT09IFwic3F1YXJlXCIgPyBzID0gZ1syXSAqIGdbM10gOiBoID09PSBcInRyaWFuZ2xlXCIgJiYgKHMgPSBNYXRoLmFicyhnWzBdICogKGdbM10gLSBnWzVdKSArIGdbMl0gKiAoZ1s1XSAtIGdbMV0pICsgZ1s0XSAqIChnWzFdIC0gZ1szXSkpIC8gMiksIHRoaXMud2lkdGggKiB0aGlzLl9waXhlbERlbnNpdHkpLCBpID0gdGhpcy5oZWlnaHQgKiB0aGlzLl9waXhlbERlbnNpdHksIGwgPSBbbmV3IERPTVBvaW50KDAsIDApLCBuZXcgRE9NUG9pbnQobywgMCksIG5ldyBET01Qb2ludChvLCBpKSwgbmV3IERPTVBvaW50KDAsIGkpXSwgbiA9ICh0aGlzLl9yZW5kZXJlci5pc1AzRCA/IG5ldyBET01NYXRyaXgodGhpcy5fcmVuZGVyZXIudU1WTWF0cml4Lm1hdDQpIDogdGhpcy5kcmF3aW5nQ29udGV4dC5nZXRUcmFuc2Zvcm0oKSkuaW52ZXJzZSgpLCBhID0gbC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwLm1hdHJpeFRyYW5zZm9ybShuKTtcbiAgICAgICAgfSksIGMgPSBNYXRoLmFicygoYVszXS54ICsgYVswXS54KSAqIChhWzNdLnkgLSBhWzBdLnkpICsgKGFbMF0ueCArIGFbMV0ueCkgKiAoYVswXS55IC0gYVsxXS55KSArIChhWzFdLnggKyBhWzJdLngpICogKGFbMV0ueSAtIGFbMl0ueSkgKyAoYVsyXS54ICsgYVszXS54KSAqIChhWzJdLnkgLSBhWzNdLnkpKSAvIDI7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKDEwMCAqIHMgLyBjKTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIjogMTU1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWRcIjogMTgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyNjM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9LCB0LmRlZmF1bHQucHJvdG90eXBlLl91cGRhdGVUZXh0T3V0cHV0ID0gZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeSwgdSwgaCwgZztcbiAgICAgICAgdGhpcy5kdW1teURPTS5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChtLCBcIl9zdW1tYXJ5XCIpKSAmJiAoeSA9IHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzW21dLCBoID0gZnVuY3Rpb24oZiwgciwgcywgbykge1xuICAgICAgICAgIHJldHVybiBzID0gXCJZb3VyIG91dHB1dCBpcyBhLCBcIi5jb25jYXQocywgXCIgYnkgXCIpLmNvbmNhdChvLCBcIiBwaXhlbHMsIFwiKS5jb25jYXQociwgXCIgY2FudmFzIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZ1wiKSwgcyA9IGYgPT09IDEgPyBcIlwiLmNvbmNhdChzLCBcIiBzaGFwZTpcIikgOiBcIlwiLmNvbmNhdChzLCBcIiBcIikuY29uY2F0KGYsIFwiIHNoYXBlczpcIiksIHM7XG4gICAgICAgIH0oKHUgPSBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgdmFyIHMsIG8gPSBcIlwiLCBpID0gMDtcbiAgICAgICAgICBmb3IgKHMgaW4gcilcbiAgICAgICAgICAgIGZvciAodmFyIGwgaW4gcltzXSkge1xuICAgICAgICAgICAgICB2YXIgbiA9ICc8bGk+PGEgaHJlZj1cIiMnLmNvbmNhdChmLCBcInNoYXBlXCIpLmNvbmNhdChpLCAnXCI+JykuY29uY2F0KHJbc11bbF0uY29sb3IsIFwiIFwiKS5jb25jYXQocywgXCI8L2E+XCIpO1xuICAgICAgICAgICAgICBzID09PSBcImxpbmVcIiA/IG4gKz0gXCIsIFwiLmNvbmNhdChyW3NdW2xdLnBvcywgXCIsIFwiKS5jb25jYXQocltzXVtsXS5sZW5ndGgsIFwiIHBpeGVscyBsb25nLjwvbGk+XCIpIDogKG4gKz0gXCIsIGF0IFwiLmNvbmNhdChyW3NdW2xdLnBvcyksIHMgIT09IFwicG9pbnRcIiAmJiAobiArPSBcIiwgY292ZXJpbmcgXCIuY29uY2F0KHJbc11bbF0uYXJlYSwgXCIlIG9mIHRoZSBjYW52YXNcIikpLCBuICs9IFwiLjwvbGk+XCIpLCBvICs9IG4sIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBudW1TaGFwZXM6IGksIGxpc3RTaGFwZXM6IG8gfTtcbiAgICAgICAgfShtLCB0aGlzLmluZ3JlZGllbnRzLnNoYXBlcykpLm51bVNoYXBlcywgdGhpcy5pbmdyZWRpZW50cy5jb2xvcnMuYmFja2dyb3VuZCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCBnID0gZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIHZhciBzLCBvID0gXCJcIiwgaSA9IDA7XG4gICAgICAgICAgZm9yIChzIGluIHIpXG4gICAgICAgICAgICBmb3IgKHZhciBsIGluIHJbc10pIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSAnPHRyIGlkPVwiJy5jb25jYXQoZiwgXCJzaGFwZVwiKS5jb25jYXQoaSwgJ1wiPjx0aD4nKS5jb25jYXQocltzXVtsXS5jb2xvciwgXCIgXCIpLmNvbmNhdChzLCBcIjwvdGg+XCIpO1xuICAgICAgICAgICAgICBzID09PSBcImxpbmVcIiA/IG4gKz0gXCI8dGQ+bG9jYXRpb24gPSBcIi5jb25jYXQocltzXVtsXS5wb3MsIFwiPC90ZD48dGQ+bGVuZ3RoID0gXCIpLmNvbmNhdChyW3NdW2xdLmxlbmd0aCwgXCIgcGl4ZWxzPC90ZD48L3RyPlwiKSA6IChuICs9IFwiPHRkPmxvY2F0aW9uID0gXCIuY29uY2F0KHJbc11bbF0ucG9zLCBcIjwvdGQ+XCIpLCBzICE9PSBcInBvaW50XCIgJiYgKG4gKz0gXCI8dGQ+IGFyZWEgPSBcIi5jb25jYXQocltzXVtsXS5hcmVhLCBcIiU8L3RkPlwiKSksIG4gKz0gXCI8L3RyPlwiKSwgbyArPSBuLCBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0obSwgdGhpcy5pbmdyZWRpZW50cy5zaGFwZXMpLCBoICE9PSB5LnN1bW1hcnkuaW5uZXJIVE1MICYmICh5LnN1bW1hcnkuaW5uZXJIVE1MID0gaCksIHUubGlzdFNoYXBlcyAhPT0geS5saXN0LmlubmVySFRNTCAmJiAoeS5saXN0LmlubmVySFRNTCA9IHUubGlzdFNoYXBlcyksIGcgIT09IHkuc2hhcGVEZXRhaWxzLmlubmVySFRNTCAmJiAoeS5zaGFwZURldGFpbHMuaW5uZXJIVE1MID0gZyksIHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzW21dID0geSk7XG4gICAgICB9LCB0ID0gdC5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyIH1dLCAyNjQ6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB2YXIgbSA9IChtID0gdChcIi4vY29yZS9tYWluXCIpKSAmJiBtLl9fZXNNb2R1bGUgPyBtIDogeyBkZWZhdWx0OiBtIH07XG4gICAgICB0KFwiLi9jb3JlL2NvbnN0YW50c1wiKSwgdChcIi4vY29yZS9lbnZpcm9ubWVudFwiKSwgdChcIi4vY29yZS9mcmllbmRseV9lcnJvcnMvc3RhY2t0cmFjZVwiKSwgdChcIi4vY29yZS9mcmllbmRseV9lcnJvcnMvdmFsaWRhdGVfcGFyYW1zXCIpLCB0KFwiLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiKSwgdChcIi4vY29yZS9mcmllbmRseV9lcnJvcnMvZmVzX2NvcmVcIiksIHQoXCIuL2NvcmUvZnJpZW5kbHlfZXJyb3JzL3NrZXRjaF9yZWFkZXJcIiksIHQoXCIuL2NvcmUvaGVscGVyc1wiKSwgdChcIi4vY29yZS9sZWdhY3lcIiksIHQoXCIuL2NvcmUvcHJlbG9hZFwiKSwgdChcIi4vY29yZS9wNS5FbGVtZW50XCIpLCB0KFwiLi9jb3JlL3A1LkdyYXBoaWNzXCIpLCB0KFwiLi9jb3JlL3A1LlJlbmRlcmVyXCIpLCB0KFwiLi9jb3JlL3A1LlJlbmRlcmVyMkRcIiksIHQoXCIuL2NvcmUvcmVuZGVyaW5nXCIpLCB0KFwiLi9jb3JlL3NoaW1cIiksIHQoXCIuL2NvcmUvc3RydWN0dXJlXCIpLCB0KFwiLi9jb3JlL3RyYW5zZm9ybVwiKSwgdChcIi4vY29yZS9zaGFwZS8yZF9wcmltaXRpdmVzXCIpLCB0KFwiLi9jb3JlL3NoYXBlL2F0dHJpYnV0ZXNcIiksIHQoXCIuL2NvcmUvc2hhcGUvY3VydmVzXCIpLCB0KFwiLi9jb3JlL3NoYXBlL3ZlcnRleFwiKSwgdChcIi4vYWNjZXNzaWJpbGl0eS9vdXRwdXRzXCIpLCB0KFwiLi9hY2Nlc3NpYmlsaXR5L3RleHRPdXRwdXRcIiksIHQoXCIuL2FjY2Vzc2liaWxpdHkvZ3JpZE91dHB1dFwiKSwgdChcIi4vYWNjZXNzaWJpbGl0eS9jb2xvcl9uYW1lclwiKSwgdChcIi4vY29sb3IvY29sb3JfY29udmVyc2lvblwiKSwgdChcIi4vY29sb3IvY3JlYXRpbmdfcmVhZGluZ1wiKSwgdChcIi4vY29sb3IvcDUuQ29sb3JcIiksIHQoXCIuL2NvbG9yL3NldHRpbmdcIiksIHQoXCIuL2RhdGEvcDUuVHlwZWREaWN0XCIpLCB0KFwiLi9kYXRhL2xvY2FsX3N0b3JhZ2UuanNcIiksIHQoXCIuL2RvbS9kb21cIiksIHQoXCIuL2FjY2Vzc2liaWxpdHkvZGVzY3JpYmVcIiksIHQoXCIuL2V2ZW50cy9hY2NlbGVyYXRpb25cIiksIHQoXCIuL2V2ZW50cy9rZXlib2FyZFwiKSwgdChcIi4vZXZlbnRzL21vdXNlXCIpLCB0KFwiLi9ldmVudHMvdG91Y2hcIiksIHQoXCIuL2ltYWdlL2ZpbHRlcnNcIiksIHQoXCIuL2ltYWdlL2ltYWdlXCIpLCB0KFwiLi9pbWFnZS9sb2FkaW5nX2Rpc3BsYXlpbmdcIiksIHQoXCIuL2ltYWdlL3A1LkltYWdlXCIpLCB0KFwiLi9pbWFnZS9waXhlbHNcIiksIHQoXCIuL2lvL2ZpbGVzXCIpLCB0KFwiLi9pby9wNS5UYWJsZVwiKSwgdChcIi4vaW8vcDUuVGFibGVSb3dcIiksIHQoXCIuL2lvL3A1LlhNTFwiKSwgdChcIi4vbWF0aC9jYWxjdWxhdGlvblwiKSwgdChcIi4vbWF0aC9tYXRoXCIpLCB0KFwiLi9tYXRoL25vaXNlXCIpLCB0KFwiLi9tYXRoL3A1LlZlY3RvclwiKSwgdChcIi4vbWF0aC9yYW5kb21cIiksIHQoXCIuL21hdGgvdHJpZ29ub21ldHJ5XCIpLCB0KFwiLi90eXBvZ3JhcGh5L2F0dHJpYnV0ZXNcIiksIHQoXCIuL3R5cG9ncmFwaHkvbG9hZGluZ19kaXNwbGF5aW5nXCIpLCB0KFwiLi90eXBvZ3JhcGh5L3A1LkZvbnRcIiksIHQoXCIuL3V0aWxpdGllcy9hcnJheV9mdW5jdGlvbnNcIiksIHQoXCIuL3V0aWxpdGllcy9jb252ZXJzaW9uXCIpLCB0KFwiLi91dGlsaXRpZXMvc3RyaW5nX2Z1bmN0aW9uc1wiKSwgdChcIi4vdXRpbGl0aWVzL3RpbWVfZGF0ZVwiKSwgdChcIi4vd2ViZ2wvM2RfcHJpbWl0aXZlc1wiKSwgdChcIi4vd2ViZ2wvaW50ZXJhY3Rpb25cIiksIHQoXCIuL3dlYmdsL2xpZ2h0XCIpLCB0KFwiLi93ZWJnbC9sb2FkaW5nXCIpLCB0KFwiLi93ZWJnbC9tYXRlcmlhbFwiKSwgdChcIi4vd2ViZ2wvcDUuQ2FtZXJhXCIpLCB0KFwiLi93ZWJnbC9wNS5EYXRhQXJyYXlcIiksIHQoXCIuL3dlYmdsL3A1Lkdlb21ldHJ5XCIpLCB0KFwiLi93ZWJnbC9wNS5NYXRyaXhcIiksIHQoXCIuL3dlYmdsL3A1LlJlbmRlcmVyR0wuSW1tZWRpYXRlXCIpLCB0KFwiLi93ZWJnbC9wNS5SZW5kZXJlckdMXCIpLCB0KFwiLi93ZWJnbC9wNS5SZW5kZXJlckdMLlJldGFpbmVkXCIpLCB0KFwiLi93ZWJnbC9wNS5GcmFtZWJ1ZmZlclwiKSwgdChcIi4vd2ViZ2wvcDUuU2hhZGVyXCIpLCB0KFwiLi93ZWJnbC9wNS5SZW5kZXJCdWZmZXJcIiksIHQoXCIuL3dlYmdsL3A1LlRleHR1cmVcIiksIHQoXCIuL3dlYmdsL3RleHRcIiksIHQoXCIuL2NvcmUvaW5pdFwiKSwgSC5leHBvcnRzID0gbS5kZWZhdWx0O1xuICAgIH0sIHsgXCIuL2FjY2Vzc2liaWxpdHkvY29sb3JfbmFtZXJcIjogMjU5LCBcIi4vYWNjZXNzaWJpbGl0eS9kZXNjcmliZVwiOiAyNjAsIFwiLi9hY2Nlc3NpYmlsaXR5L2dyaWRPdXRwdXRcIjogMjYxLCBcIi4vYWNjZXNzaWJpbGl0eS9vdXRwdXRzXCI6IDI2MiwgXCIuL2FjY2Vzc2liaWxpdHkvdGV4dE91dHB1dFwiOiAyNjMsIFwiLi9jb2xvci9jb2xvcl9jb252ZXJzaW9uXCI6IDI2NSwgXCIuL2NvbG9yL2NyZWF0aW5nX3JlYWRpbmdcIjogMjY2LCBcIi4vY29sb3IvcDUuQ29sb3JcIjogMjY3LCBcIi4vY29sb3Ivc2V0dGluZ1wiOiAyNjgsIFwiLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi9jb3JlL2Vudmlyb25tZW50XCI6IDI3MCwgXCIuL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCI6IDI3MSwgXCIuL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2ZpbGVfZXJyb3JzXCI6IDI3MiwgXCIuL2NvcmUvZnJpZW5kbHlfZXJyb3JzL3NrZXRjaF9yZWFkZXJcIjogMjczLCBcIi4vY29yZS9mcmllbmRseV9lcnJvcnMvc3RhY2t0cmFjZVwiOiAyNzQsIFwiLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIjogMjc1LCBcIi4vY29yZS9oZWxwZXJzXCI6IDI3NiwgXCIuL2NvcmUvaW5pdFwiOiAyNzcsIFwiLi9jb3JlL2xlZ2FjeVwiOiAyNzksIFwiLi9jb3JlL21haW5cIjogMjgwLCBcIi4vY29yZS9wNS5FbGVtZW50XCI6IDI4MSwgXCIuL2NvcmUvcDUuR3JhcGhpY3NcIjogMjgyLCBcIi4vY29yZS9wNS5SZW5kZXJlclwiOiAyODMsIFwiLi9jb3JlL3A1LlJlbmRlcmVyMkRcIjogMjg0LCBcIi4vY29yZS9wcmVsb2FkXCI6IDI4NSwgXCIuL2NvcmUvcmVuZGVyaW5nXCI6IDI4NiwgXCIuL2NvcmUvc2hhcGUvMmRfcHJpbWl0aXZlc1wiOiAyODcsIFwiLi9jb3JlL3NoYXBlL2F0dHJpYnV0ZXNcIjogMjg4LCBcIi4vY29yZS9zaGFwZS9jdXJ2ZXNcIjogMjg5LCBcIi4vY29yZS9zaGFwZS92ZXJ0ZXhcIjogMjkwLCBcIi4vY29yZS9zaGltXCI6IDI5MSwgXCIuL2NvcmUvc3RydWN0dXJlXCI6IDI5MiwgXCIuL2NvcmUvdHJhbnNmb3JtXCI6IDI5MywgXCIuL2RhdGEvbG9jYWxfc3RvcmFnZS5qc1wiOiAyOTQsIFwiLi9kYXRhL3A1LlR5cGVkRGljdFwiOiAyOTUsIFwiLi9kb20vZG9tXCI6IDI5NiwgXCIuL2V2ZW50cy9hY2NlbGVyYXRpb25cIjogMjk3LCBcIi4vZXZlbnRzL2tleWJvYXJkXCI6IDI5OCwgXCIuL2V2ZW50cy9tb3VzZVwiOiAyOTksIFwiLi9ldmVudHMvdG91Y2hcIjogMzAwLCBcIi4vaW1hZ2UvZmlsdGVyc1wiOiAzMDEsIFwiLi9pbWFnZS9pbWFnZVwiOiAzMDIsIFwiLi9pbWFnZS9sb2FkaW5nX2Rpc3BsYXlpbmdcIjogMzAzLCBcIi4vaW1hZ2UvcDUuSW1hZ2VcIjogMzA0LCBcIi4vaW1hZ2UvcGl4ZWxzXCI6IDMwNSwgXCIuL2lvL2ZpbGVzXCI6IDMwNiwgXCIuL2lvL3A1LlRhYmxlXCI6IDMwNywgXCIuL2lvL3A1LlRhYmxlUm93XCI6IDMwOCwgXCIuL2lvL3A1LlhNTFwiOiAzMDksIFwiLi9tYXRoL2NhbGN1bGF0aW9uXCI6IDMxMCwgXCIuL21hdGgvbWF0aFwiOiAzMTEsIFwiLi9tYXRoL25vaXNlXCI6IDMxMiwgXCIuL21hdGgvcDUuVmVjdG9yXCI6IDMxMywgXCIuL21hdGgvcmFuZG9tXCI6IDMxNCwgXCIuL21hdGgvdHJpZ29ub21ldHJ5XCI6IDMxNSwgXCIuL3R5cG9ncmFwaHkvYXR0cmlidXRlc1wiOiAzMTYsIFwiLi90eXBvZ3JhcGh5L2xvYWRpbmdfZGlzcGxheWluZ1wiOiAzMTcsIFwiLi90eXBvZ3JhcGh5L3A1LkZvbnRcIjogMzE4LCBcIi4vdXRpbGl0aWVzL2FycmF5X2Z1bmN0aW9uc1wiOiAzMTksIFwiLi91dGlsaXRpZXMvY29udmVyc2lvblwiOiAzMjAsIFwiLi91dGlsaXRpZXMvc3RyaW5nX2Z1bmN0aW9uc1wiOiAzMjEsIFwiLi91dGlsaXRpZXMvdGltZV9kYXRlXCI6IDMyMiwgXCIuL3dlYmdsLzNkX3ByaW1pdGl2ZXNcIjogMzIzLCBcIi4vd2ViZ2wvaW50ZXJhY3Rpb25cIjogMzI1LCBcIi4vd2ViZ2wvbGlnaHRcIjogMzI2LCBcIi4vd2ViZ2wvbG9hZGluZ1wiOiAzMjcsIFwiLi93ZWJnbC9tYXRlcmlhbFwiOiAzMjgsIFwiLi93ZWJnbC9wNS5DYW1lcmFcIjogMzI5LCBcIi4vd2ViZ2wvcDUuRGF0YUFycmF5XCI6IDMzMCwgXCIuL3dlYmdsL3A1LkZyYW1lYnVmZmVyXCI6IDMzMSwgXCIuL3dlYmdsL3A1Lkdlb21ldHJ5XCI6IDMzMiwgXCIuL3dlYmdsL3A1Lk1hdHJpeFwiOiAzMzMsIFwiLi93ZWJnbC9wNS5SZW5kZXJCdWZmZXJcIjogMzM0LCBcIi4vd2ViZ2wvcDUuUmVuZGVyZXJHTFwiOiAzMzcsIFwiLi93ZWJnbC9wNS5SZW5kZXJlckdMLkltbWVkaWF0ZVwiOiAzMzUsIFwiLi93ZWJnbC9wNS5SZW5kZXJlckdMLlJldGFpbmVkXCI6IDMzNiwgXCIuL3dlYmdsL3A1LlNoYWRlclwiOiAzMzgsIFwiLi93ZWJnbC9wNS5UZXh0dXJlXCI6IDMzOSwgXCIuL3dlYmdsL3RleHRcIjogMzQwIH1dLCAyNjU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQgPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfSwgdC5kZWZhdWx0LkNvbG9yQ29udmVyc2lvbiA9IHsgX2hzYmFUb0hTTEE6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHkgPSBtWzBdLCB1ID0gbVsxXSwgaCA9IG1bMl0sIGcgPSAoMiAtIHUpICogaCAvIDI7XG4gICAgICAgIHJldHVybiBnICE9IDAgJiYgKGcgPT0gMSA/IHUgPSAwIDogZyA8IDAuNSA/IHUgLz0gMiAtIHUgOiB1ID0gdSAqIGggLyAoMiAtIDIgKiBnKSksIFt5LCB1LCBnLCBtWzNdXTtcbiAgICAgIH0sIF9oc2JhVG9SR0JBOiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB5LCB1LCBoLCBnLCBmLCByID0gNiAqIG1bMF0sIHMgPSBtWzFdLCBvID0gbVsyXTtcbiAgICAgICAgcmV0dXJuIHMgPT09IDAgPyBbbywgbywgbywgbVszXV0gOiAodSA9IG8gKiAoMSAtIHMpLCBoID0gbyAqICgxIC0gcyAqIChyIC0gKHkgPSBNYXRoLmZsb29yKHIpKSkpLCBzID0gbyAqICgxIC0gcyAqICgxICsgeSAtIHIpKSwgciA9IHkgPT09IDEgPyAoZyA9IGgsIGYgPSBvLCB1KSA6IHkgPT09IDIgPyAoZyA9IHUsIGYgPSBvLCBzKSA6IHkgPT09IDMgPyAoZyA9IHUsIGYgPSBoLCBvKSA6IHkgPT09IDQgPyAoZyA9IHMsIGYgPSB1LCBvKSA6IHkgPT09IDUgPyAoZyA9IG8sIGYgPSB1LCBoKSA6IChnID0gbywgZiA9IHMsIHUpLCBbZywgZiwgciwgbVszXV0pO1xuICAgICAgfSwgX2hzbGFUb0hTQkE6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHkgPSBtWzBdLCB1ID0gbVsxXSwgaCA9IG1bMl0sIGcgPSBoIDwgMC41ID8gKDEgKyB1KSAqIGggOiBoICsgdSAtIGggKiB1O1xuICAgICAgICByZXR1cm4gW3ksIHUgPSAyICogKGcgLSBoKSAvIGcsIGcsIG1bM11dO1xuICAgICAgfSwgX2hzbGFUb1JHQkE6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHksIHUgPSA2ICogbVswXSwgaCA9IG1bMV0sIGcgPSBtWzJdO1xuICAgICAgICByZXR1cm4gaCA9PT0gMCA/IFtnLCBnLCBnLCBtWzNdXSA6IFsoeSA9IGZ1bmN0aW9uKGYsIHIsIHMpIHtcbiAgICAgICAgICByZXR1cm4gZiA8IDAgPyBmICs9IDYgOiA2IDw9IGYgJiYgKGYgLT0gNiksIGYgPCAxID8gciArIChzIC0gcikgKiBmIDogZiA8IDMgPyBzIDogZiA8IDQgPyByICsgKHMgLSByKSAqICg0IC0gZikgOiByO1xuICAgICAgICB9KSgyICsgdSwgaCA9IDIgKiBnIC0gKGcgPSBnIDwgMC41ID8gKDEgKyBoKSAqIGcgOiBnICsgaCAtIGcgKiBoKSwgZyksIHkodSwgaCwgZyksIHkodSAtIDIsIGgsIGcpLCBtWzNdXTtcbiAgICAgIH0sIF9yZ2JhVG9IU0JBOiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB5LCB1LCBoID0gbVswXSwgZyA9IG1bMV0sIGYgPSBtWzJdLCByID0gTWF0aC5tYXgoaCwgZywgZiksIHMgPSByIC0gTWF0aC5taW4oaCwgZywgZik7XG4gICAgICAgIHJldHVybiBzID09IDAgPyB1ID0geSA9IDAgOiAodSA9IHMgLyByLCBoID09PSByID8geSA9IChnIC0gZikgLyBzIDogZyA9PT0gciA/IHkgPSAyICsgKGYgLSBoKSAvIHMgOiBmID09PSByICYmICh5ID0gNCArIChoIC0gZykgLyBzKSwgeSA8IDAgPyB5ICs9IDYgOiA2IDw9IHkgJiYgKHkgLT0gNikpLCBbeSAvIDYsIHUsIHIsIG1bM11dO1xuICAgICAgfSwgX3JnYmFUb0hTTEE6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHksIHUsIGggPSBtWzBdLCBnID0gbVsxXSwgZiA9IG1bMl0sIHIgPSBNYXRoLm1heChoLCBnLCBmKSwgbyA9IE1hdGgubWluKGgsIGcsIGYpLCBzID0gciArIG8sIG8gPSByIC0gbztcbiAgICAgICAgcmV0dXJuIG8gPT0gMCA/IHUgPSB5ID0gMCA6ICh1ID0gcyA8IDEgPyBvIC8gcyA6IG8gLyAoMiAtIHMpLCBoID09PSByID8geSA9IChnIC0gZikgLyBvIDogZyA9PT0gciA/IHkgPSAyICsgKGYgLSBoKSAvIG8gOiBmID09PSByICYmICh5ID0gNCArIChoIC0gZykgLyBvKSwgeSA8IDAgPyB5ICs9IDYgOiA2IDw9IHkgJiYgKHkgLT0gNikpLCBbeSAvIDYsIHUsIHMgLyAyLCBtWzNdXTtcbiAgICAgIH0gfSwgdCA9IHQuZGVmYXVsdC5Db2xvckNvbnZlcnNpb24sIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAgfV0sIDI2NjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocikge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBzO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBzO1xuICAgICAgICB9KShyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocikge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIG0ocyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShzKTtcbiAgICAgICAgfSkocik7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChmID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgZi5fX2VzTW9kdWxlID8gZiA6IHsgZGVmYXVsdDogZiB9LCBoID0gZnVuY3Rpb24ocikge1xuICAgICAgICBpZiAociAmJiByLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGlmIChyID09PSBudWxsIHx8IHkocikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHIgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IHIgfTtcbiAgICAgICAgdmFyIHMgPSBnKCk7XG4gICAgICAgIGlmIChzICYmIHMuaGFzKHIpKVxuICAgICAgICAgIHJldHVybiBzLmdldChyKTtcbiAgICAgICAgdmFyIG8sIGkgPSB7fSwgbCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKG8gaW4gcikge1xuICAgICAgICAgIHZhciBuO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLCBvKSAmJiAoKG4gPSBsID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLCBvKSA6IG51bGwpICYmIChuLmdldCB8fCBuLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgbywgbikgOiBpW29dID0gcltvXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkuZGVmYXVsdCA9IHIsIHMgJiYgcy5zZXQociwgaSksIGk7XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAociA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIHIpO1xuICAgICAgfVxuICAgICAgdChcIi4vcDUuQ29sb3JcIiksIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIiksIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiKSwgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCIpLCB1LmRlZmF1bHQucHJvdG90eXBlLmFscGhhID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJhbHBoYVwiLCBhcmd1bWVudHMpLCB0aGlzLmNvbG9yKHIpLl9nZXRBbHBoYSgpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5ibHVlID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJibHVlXCIsIGFyZ3VtZW50cyksIHRoaXMuY29sb3IocikuX2dldEJsdWUoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuYnJpZ2h0bmVzcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYnJpZ2h0bmVzc1wiLCBhcmd1bWVudHMpLCB0aGlzLmNvbG9yKHIpLl9nZXRCcmlnaHRuZXNzKCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHIsIHMgPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KHMpLCBpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgICAgICBvW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjb2xvclwiLCBvKSwgb1swXSBpbnN0YW5jZW9mIHUuZGVmYXVsdC5Db2xvciA/IG9bMF0gOiAociA9IEFycmF5LmlzQXJyYXkob1swXSkgPyBvWzBdIDogbywgbmV3IHUuZGVmYXVsdC5Db2xvcih0aGlzLCByKSk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmdyZWVuID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJncmVlblwiLCBhcmd1bWVudHMpLCB0aGlzLmNvbG9yKHIpLl9nZXRHcmVlbigpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5odWUgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImh1ZVwiLCBhcmd1bWVudHMpLCB0aGlzLmNvbG9yKHIpLl9nZXRIdWUoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUubGVycENvbG9yID0gZnVuY3Rpb24ociwgcywgbykge1xuICAgICAgICB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImxlcnBDb2xvclwiLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgaSwgbCwgbiwgYSA9IHRoaXMuX2NvbG9yTW9kZSwgYyA9IHRoaXMuX2NvbG9yTWF4ZXM7XG4gICAgICAgIGlmIChhID09PSBoLlJHQilcbiAgICAgICAgICBsID0gci5sZXZlbHMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwIC8gMjU1O1xuICAgICAgICAgIH0pLCBuID0gcy5sZXZlbHMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwIC8gMjU1O1xuICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChhID09PSBoLkhTQilcbiAgICAgICAgICByLl9nZXRCcmlnaHRuZXNzKCksIHMuX2dldEJyaWdodG5lc3MoKSwgbCA9IHIuaHNiYSwgbiA9IHMuaHNiYTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGEgIT09IGguSFNMKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGEsIFwiIGNhbm5vdCBiZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9uLlwiKSk7XG4gICAgICAgICAgci5fZ2V0TGlnaHRuZXNzKCksIHMuX2dldExpZ2h0bmVzcygpLCBsID0gci5oc2xhLCBuID0gcy5oc2xhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvID0gTWF0aC5tYXgoTWF0aC5taW4obywgMSksIDApLCB0aGlzLmxlcnAgPT09IHZvaWQgMCAmJiAodGhpcy5sZXJwID0gZnVuY3Rpb24ocCwgaiwgVCkge1xuICAgICAgICAgIHJldHVybiBUICogKGogLSBwKSArIHA7XG4gICAgICAgIH0pLCBhID09PSBoLlJHQiA/IGkgPSB0aGlzLmxlcnAobFswXSwgblswXSwgbykgOiAoMC41IDwgTWF0aC5hYnMobFswXSAtIG5bMF0pICYmIChsWzBdID4gblswXSA/IG5bMF0gKz0gMSA6IGxbMF0gKz0gMSksIDEgPD0gKGkgPSB0aGlzLmxlcnAobFswXSwgblswXSwgbykpICYmIC0taSksIHIgPSB0aGlzLmxlcnAobFsxXSwgblsxXSwgbyksIHMgPSB0aGlzLmxlcnAobFsyXSwgblsyXSwgbyksIGwgPSB0aGlzLmxlcnAobFszXSwgblszXSwgbyksIGkgKj0gY1thXVswXSwgciAqPSBjW2FdWzFdLCBzICo9IGNbYV1bMl0sIGwgKj0gY1thXVszXSwgdGhpcy5jb2xvcihpLCByLCBzLCBsKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUubGlnaHRuZXNzID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsaWdodG5lc3NcIiwgYXJndW1lbnRzKSwgdGhpcy5jb2xvcihyKS5fZ2V0TGlnaHRuZXNzKCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnJlZCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwicmVkXCIsIGFyZ3VtZW50cyksIHRoaXMuY29sb3IocikuX2dldFJlZCgpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5zYXR1cmF0aW9uID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzYXR1cmF0aW9uXCIsIGFyZ3VtZW50cyksIHRoaXMuY29sb3IocikuX2dldFNhdHVyYXRpb24oKTtcbiAgICAgIH07XG4gICAgICB2YXIgZiA9IHUuZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IGY7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9mZXNfY29yZVwiOiAyNzEsIFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvZmlsZV9lcnJvcnNcIjogMjcyLCBcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL3ZhbGlkYXRlX3BhcmFtc1wiOiAyNzUsIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuL3A1LkNvbG9yXCI6IDI2NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI2NzogW2Z1bmN0aW9uKGksIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocCkge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBqO1xuICAgICAgICB9IDogZnVuY3Rpb24oaikge1xuICAgICAgICAgIHJldHVybiBqICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBqO1xuICAgICAgICB9KShwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocCkge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIG0oaik7XG4gICAgICAgIH0gOiBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIGogJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShqKTtcbiAgICAgICAgfSkocCk7XG4gICAgICB9XG4gICAgICBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCBpKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgaShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIGkoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gcihpKFwiLi4vY29yZS9tYWluXCIpKSwgaCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYgKHAgJiYgcC5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCB5KHApICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBwIH07XG4gICAgICAgIHZhciBqID0gZigpO1xuICAgICAgICBpZiAoaiAmJiBqLmhhcyhwKSlcbiAgICAgICAgICByZXR1cm4gai5nZXQocCk7XG4gICAgICAgIHZhciBULCBfID0ge30sIFMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChUIGluIHApIHtcbiAgICAgICAgICB2YXIgRTtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgVCkgJiYgKChFID0gUyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgVCkgOiBudWxsKSAmJiAoRS5nZXQgfHwgRS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFQsIEUpIDogX1tUXSA9IHBbVF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmRlZmF1bHQgPSBwLCBqICYmIGouc2V0KHAsIF8pLCBfO1xuICAgICAgfShpKFwiLi4vY29yZS9jb25zdGFudHNcIikpLCBnID0gcihpKFwiLi9jb2xvcl9jb252ZXJzaW9uXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIHZhciBwO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSwgcCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKHApIHtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC5fX2VzTW9kdWxlID8gcCA6IHsgZGVmYXVsdDogcCB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhwLCBqKSB7XG4gICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgai5sZW5ndGg7IFQrKykge1xuICAgICAgICAgIHZhciBfID0galtUXTtcbiAgICAgICAgICBfLmVudW1lcmFibGUgPSBfLmVudW1lcmFibGUgfHwgITEsIF8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBfICYmIChfLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXy5rZXksIF8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbyA9IHsgYWxpY2VibHVlOiBcIiNmMGY4ZmZcIiwgYW50aXF1ZXdoaXRlOiBcIiNmYWViZDdcIiwgYXF1YTogXCIjMDBmZmZmXCIsIGFxdWFtYXJpbmU6IFwiIzdmZmZkNFwiLCBhenVyZTogXCIjZjBmZmZmXCIsIGJlaWdlOiBcIiNmNWY1ZGNcIiwgYmlzcXVlOiBcIiNmZmU0YzRcIiwgYmxhY2s6IFwiIzAwMDAwMFwiLCBibGFuY2hlZGFsbW9uZDogXCIjZmZlYmNkXCIsIGJsdWU6IFwiIzAwMDBmZlwiLCBibHVldmlvbGV0OiBcIiM4YTJiZTJcIiwgYnJvd246IFwiI2E1MmEyYVwiLCBidXJseXdvb2Q6IFwiI2RlYjg4N1wiLCBjYWRldGJsdWU6IFwiIzVmOWVhMFwiLCBjaGFydHJldXNlOiBcIiM3ZmZmMDBcIiwgY2hvY29sYXRlOiBcIiNkMjY5MWVcIiwgY29yYWw6IFwiI2ZmN2Y1MFwiLCBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NWVkXCIsIGNvcm5zaWxrOiBcIiNmZmY4ZGNcIiwgY3JpbXNvbjogXCIjZGMxNDNjXCIsIGN5YW46IFwiIzAwZmZmZlwiLCBkYXJrYmx1ZTogXCIjMDAwMDhiXCIsIGRhcmtjeWFuOiBcIiMwMDhiOGJcIiwgZGFya2dvbGRlbnJvZDogXCIjYjg4NjBiXCIsIGRhcmtncmF5OiBcIiNhOWE5YTlcIiwgZGFya2dyZWVuOiBcIiMwMDY0MDBcIiwgZGFya2dyZXk6IFwiI2E5YTlhOVwiLCBkYXJra2hha2k6IFwiI2JkYjc2YlwiLCBkYXJrbWFnZW50YTogXCIjOGIwMDhiXCIsIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZiMmZcIiwgZGFya29yYW5nZTogXCIjZmY4YzAwXCIsIGRhcmtvcmNoaWQ6IFwiIzk5MzJjY1wiLCBkYXJrcmVkOiBcIiM4YjAwMDBcIiwgZGFya3NhbG1vbjogXCIjZTk5NjdhXCIsIGRhcmtzZWFncmVlbjogXCIjOGZiYzhmXCIsIGRhcmtzbGF0ZWJsdWU6IFwiIzQ4M2Q4YlwiLCBkYXJrc2xhdGVncmF5OiBcIiMyZjRmNGZcIiwgZGFya3NsYXRlZ3JleTogXCIjMmY0ZjRmXCIsIGRhcmt0dXJxdW9pc2U6IFwiIzAwY2VkMVwiLCBkYXJrdmlvbGV0OiBcIiM5NDAwZDNcIiwgZGVlcHBpbms6IFwiI2ZmMTQ5M1wiLCBkZWVwc2t5Ymx1ZTogXCIjMDBiZmZmXCIsIGRpbWdyYXk6IFwiIzY5Njk2OVwiLCBkaW1ncmV5OiBcIiM2OTY5NjlcIiwgZG9kZ2VyYmx1ZTogXCIjMWU5MGZmXCIsIGZpcmVicmljazogXCIjYjIyMjIyXCIsIGZsb3JhbHdoaXRlOiBcIiNmZmZhZjBcIiwgZm9yZXN0Z3JlZW46IFwiIzIyOGIyMlwiLCBmdWNoc2lhOiBcIiNmZjAwZmZcIiwgZ2FpbnNib3JvOiBcIiNkY2RjZGNcIiwgZ2hvc3R3aGl0ZTogXCIjZjhmOGZmXCIsIGdvbGQ6IFwiI2ZmZDcwMFwiLCBnb2xkZW5yb2Q6IFwiI2RhYTUyMFwiLCBncmF5OiBcIiM4MDgwODBcIiwgZ3JlZW46IFwiIzAwODAwMFwiLCBncmVlbnllbGxvdzogXCIjYWRmZjJmXCIsIGdyZXk6IFwiIzgwODA4MFwiLCBob25leWRldzogXCIjZjBmZmYwXCIsIGhvdHBpbms6IFwiI2ZmNjliNFwiLCBpbmRpYW5yZWQ6IFwiI2NkNWM1Y1wiLCBpbmRpZ286IFwiIzRiMDA4MlwiLCBpdm9yeTogXCIjZmZmZmYwXCIsIGtoYWtpOiBcIiNmMGU2OGNcIiwgbGF2ZW5kZXI6IFwiI2U2ZTZmYVwiLCBsYXZlbmRlcmJsdXNoOiBcIiNmZmYwZjVcIiwgbGF3bmdyZWVuOiBcIiM3Y2ZjMDBcIiwgbGVtb25jaGlmZm9uOiBcIiNmZmZhY2RcIiwgbGlnaHRibHVlOiBcIiNhZGQ4ZTZcIiwgbGlnaHRjb3JhbDogXCIjZjA4MDgwXCIsIGxpZ2h0Y3lhbjogXCIjZTBmZmZmXCIsIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNmYWZhZDJcIiwgbGlnaHRncmF5OiBcIiNkM2QzZDNcIiwgbGlnaHRncmVlbjogXCIjOTBlZTkwXCIsIGxpZ2h0Z3JleTogXCIjZDNkM2QzXCIsIGxpZ2h0cGluazogXCIjZmZiNmMxXCIsIGxpZ2h0c2FsbW9uOiBcIiNmZmEwN2FcIiwgbGlnaHRzZWFncmVlbjogXCIjMjBiMmFhXCIsIGxpZ2h0c2t5Ymx1ZTogXCIjODdjZWZhXCIsIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIiwgbGlnaHRzbGF0ZWdyZXk6IFwiIzc3ODg5OVwiLCBsaWdodHN0ZWVsYmx1ZTogXCIjYjBjNGRlXCIsIGxpZ2h0eWVsbG93OiBcIiNmZmZmZTBcIiwgbGltZTogXCIjMDBmZjAwXCIsIGxpbWVncmVlbjogXCIjMzJjZDMyXCIsIGxpbmVuOiBcIiNmYWYwZTZcIiwgbWFnZW50YTogXCIjZmYwMGZmXCIsIG1hcm9vbjogXCIjODAwMDAwXCIsIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Y2RhYVwiLCBtZWRpdW1ibHVlOiBcIiMwMDAwY2RcIiwgbWVkaXVtb3JjaGlkOiBcIiNiYTU1ZDNcIiwgbWVkaXVtcHVycGxlOiBcIiM5MzcwZGJcIiwgbWVkaXVtc2VhZ3JlZW46IFwiIzNjYjM3MVwiLCBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdiNjhlZVwiLCBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBmYTlhXCIsIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhkMWNjXCIsIG1lZGl1bXZpb2xldHJlZDogXCIjYzcxNTg1XCIsIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsIG1pbnRjcmVhbTogXCIjZjVmZmZhXCIsIG1pc3R5cm9zZTogXCIjZmZlNGUxXCIsIG1vY2Nhc2luOiBcIiNmZmU0YjVcIiwgbmF2YWpvd2hpdGU6IFwiI2ZmZGVhZFwiLCBuYXZ5OiBcIiMwMDAwODBcIiwgb2xkbGFjZTogXCIjZmRmNWU2XCIsIG9saXZlOiBcIiM4MDgwMDBcIiwgb2xpdmVkcmFiOiBcIiM2YjhlMjNcIiwgb3JhbmdlOiBcIiNmZmE1MDBcIiwgb3JhbmdlcmVkOiBcIiNmZjQ1MDBcIiwgb3JjaGlkOiBcIiNkYTcwZDZcIiwgcGFsZWdvbGRlbnJvZDogXCIjZWVlOGFhXCIsIHBhbGVncmVlbjogXCIjOThmYjk4XCIsIHBhbGV0dXJxdW9pc2U6IFwiI2FmZWVlZVwiLCBwYWxldmlvbGV0cmVkOiBcIiNkYjcwOTNcIiwgcGFwYXlhd2hpcDogXCIjZmZlZmQ1XCIsIHBlYWNocHVmZjogXCIjZmZkYWI5XCIsIHBlcnU6IFwiI2NkODUzZlwiLCBwaW5rOiBcIiNmZmMwY2JcIiwgcGx1bTogXCIjZGRhMGRkXCIsIHBvd2RlcmJsdWU6IFwiI2IwZTBlNlwiLCBwdXJwbGU6IFwiIzgwMDA4MFwiLCByZWJlY2NhcHVycGxlOiBcIiM2NjMzOTlcIiwgcmVkOiBcIiNmZjAwMDBcIiwgcm9zeWJyb3duOiBcIiNiYzhmOGZcIiwgcm95YWxibHVlOiBcIiM0MTY5ZTFcIiwgc2FkZGxlYnJvd246IFwiIzhiNDUxM1wiLCBzYWxtb246IFwiI2ZhODA3MlwiLCBzYW5keWJyb3duOiBcIiNmNGE0NjBcIiwgc2VhZ3JlZW46IFwiIzJlOGI1N1wiLCBzZWFzaGVsbDogXCIjZmZmNWVlXCIsIHNpZW5uYTogXCIjYTA1MjJkXCIsIHNpbHZlcjogXCIjYzBjMGMwXCIsIHNreWJsdWU6IFwiIzg3Y2VlYlwiLCBzbGF0ZWJsdWU6IFwiIzZhNWFjZFwiLCBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLCBzbGF0ZWdyZXk6IFwiIzcwODA5MFwiLCBzbm93OiBcIiNmZmZhZmFcIiwgc3ByaW5nZ3JlZW46IFwiIzAwZmY3ZlwiLCBzdGVlbGJsdWU6IFwiIzQ2ODJiNFwiLCB0YW46IFwiI2QyYjQ4Y1wiLCB0ZWFsOiBcIiMwMDgwODBcIiwgdGhpc3RsZTogXCIjZDhiZmQ4XCIsIHRvbWF0bzogXCIjZmY2MzQ3XCIsIHR1cnF1b2lzZTogXCIjNDBlMGQwXCIsIHZpb2xldDogXCIjZWU4MmVlXCIsIHdoZWF0OiBcIiNmNWRlYjNcIiwgd2hpdGU6IFwiI2ZmZmZmZlwiLCB3aGl0ZXNtb2tlOiBcIiNmNWY1ZjVcIiwgeWVsbG93OiBcIiNmZmZmMDBcIiwgeWVsbG93Z3JlZW46IFwiIzlhY2QzMlwiIH0sIGkgPSAvXFxzKi8sIGMgPSAvKFxcZHsxLDN9KS8sIGwgPSAvKCg/OlxcZCsoPzpcXC5cXGQrKT8pfCg/OlxcLlxcZCspKS8sIG4gPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KGwuc291cmNlLCBcIiVcIikpLCBhID0geyBIRVgzOiAvXiMoW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkkL2ksIEhFWDQ6IC9eIyhbYS1mMC05XSkoW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkkL2ksIEhFWDY6IC9eIyhbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KSQvaSwgSEVYODogL14jKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KSQvaSwgUkdCOiBuZXcgUmVnRXhwKFtcIl5yZ2JcXFxcKFwiLCBjLnNvdXJjZSwgXCIsXCIsIGMuc291cmNlLCBcIixcIiwgYy5zb3VyY2UsIFwiXFxcXCkkXCJdLmpvaW4oaS5zb3VyY2UpLCBcImlcIiksIFJHQl9QRVJDRU5UOiBuZXcgUmVnRXhwKFtcIl5yZ2JcXFxcKFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIixcIiwgbi5zb3VyY2UsIFwiXFxcXCkkXCJdLmpvaW4oaS5zb3VyY2UpLCBcImlcIiksIFJHQkE6IG5ldyBSZWdFeHAoW1wiXnJnYmFcXFxcKFwiLCBjLnNvdXJjZSwgXCIsXCIsIGMuc291cmNlLCBcIixcIiwgYy5zb3VyY2UsIFwiLFwiLCBsLnNvdXJjZSwgXCJcXFxcKSRcIl0uam9pbihpLnNvdXJjZSksIFwiaVwiKSwgUkdCQV9QRVJDRU5UOiBuZXcgUmVnRXhwKFtcIl5yZ2JhXFxcXChcIiwgbi5zb3VyY2UsIFwiLFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIixcIiwgbC5zb3VyY2UsIFwiXFxcXCkkXCJdLmpvaW4oaS5zb3VyY2UpLCBcImlcIiksIEhTTDogbmV3IFJlZ0V4cChbXCJeaHNsXFxcXChcIiwgYy5zb3VyY2UsIFwiLFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIlxcXFwpJFwiXS5qb2luKGkuc291cmNlKSwgXCJpXCIpLCBIU0xBOiBuZXcgUmVnRXhwKFtcIl5oc2xhXFxcXChcIiwgYy5zb3VyY2UsIFwiLFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIixcIiwgbC5zb3VyY2UsIFwiXFxcXCkkXCJdLmpvaW4oaS5zb3VyY2UpLCBcImlcIiksIEhTQjogbmV3IFJlZ0V4cChbXCJeaHNiXFxcXChcIiwgYy5zb3VyY2UsIFwiLFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIlxcXFwpJFwiXS5qb2luKGkuc291cmNlKSwgXCJpXCIpLCBIU0JBOiBuZXcgUmVnRXhwKFtcIl5oc2JhXFxcXChcIiwgYy5zb3VyY2UsIFwiLFwiLCBuLnNvdXJjZSwgXCIsXCIsIG4uc291cmNlLCBcIixcIiwgbC5zb3VyY2UsIFwiXFxcXCkkXCJdLmpvaW4oaS5zb3VyY2UpLCBcImlcIikgfSwgYyA9ICh1LmRlZmF1bHQuQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gcChTLCBFKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcmVNb2RlQW5kTWF4ZXMoUy5fY29sb3JNb2RlLCBTLl9jb2xvck1heGVzKSwgIVtoLlJHQiwgaC5IU0wsIGguSFNCXS5pbmNsdWRlcyh0aGlzLm1vZGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHRoaXMubW9kZSwgXCIgaXMgYW4gaW52YWxpZCBjb2xvck1vZGUuXCIpKTtcbiAgICAgICAgICB0aGlzLl9hcnJheSA9IHAuX3BhcnNlSW5wdXRzLmFwcGx5KHRoaXMsIEUpLCB0aGlzLl9jYWxjdWxhdGVMZXZlbHMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaiwgVCwgXztcbiAgICAgICAgcmV0dXJuIGogPSBwLCBfID0gW3sga2V5OiBcIl9wYXJzZUlucHV0c1wiLCB2YWx1ZTogZnVuY3Rpb24oUywgRSwgQSwgeCkge1xuICAgICAgICAgIHZhciBQLCBNID0gYXJndW1lbnRzLmxlbmd0aCwgUiA9IHRoaXMubW9kZSwgTCA9IHRoaXMubWF4ZXNbUl0sIEYgPSBbXTtcbiAgICAgICAgICBpZiAoMyA8PSBNKSB7XG4gICAgICAgICAgICBmb3IgKEZbMF0gPSBTIC8gTFswXSwgRlsxXSA9IEUgLyBMWzFdLCBGWzJdID0gQSAvIExbMl0sIEZbM10gPSB0eXBlb2YgeCA9PSBcIm51bWJlclwiID8geCAvIExbM10gOiAxLCBQID0gRi5sZW5ndGggLSAxOyAwIDw9IFA7IC0tUCkge1xuICAgICAgICAgICAgICB2YXIgViA9IEZbUF07XG4gICAgICAgICAgICAgIFYgPCAwID8gRltQXSA9IDAgOiAxIDwgViAmJiAoRltQXSA9IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFIgPT09IGguSFNMID8gZy5kZWZhdWx0Ll9oc2xhVG9SR0JBKEYpIDogUiA9PT0gaC5IU0IgPyBnLmRlZmF1bHQuX2hzYmFUb1JHQkEoRikgOiBGO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoTSA9PT0gMSAmJiB0eXBlb2YgUyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoQSA9IFMudHJpbSgpLnRvTG93ZXJDYXNlKCksIG9bQV0pXG4gICAgICAgICAgICAgIHJldHVybiBwLl9wYXJzZUlucHV0cy5jYWxsKHRoaXMsIG9bQV0pO1xuICAgICAgICAgICAgaWYgKGEuSEVYMy50ZXN0KEEpKVxuICAgICAgICAgICAgICByZXR1cm4gKEYgPSBhLkhFWDMuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChHICsgRywgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICB9KSlbM10gPSAxLCBGO1xuICAgICAgICAgICAgaWYgKGEuSEVYNi50ZXN0KEEpKVxuICAgICAgICAgICAgICByZXR1cm4gKEYgPSBhLkhFWDYuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChHLCAxNikgLyAyNTU7XG4gICAgICAgICAgICAgIH0pKVszXSA9IDEsIEY7XG4gICAgICAgICAgICBpZiAoYS5IRVg0LnRlc3QoQSkpXG4gICAgICAgICAgICAgIHJldHVybiBGID0gYS5IRVg0LmV4ZWMoQSkuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoRyArIEcsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYS5IRVg4LnRlc3QoQSkpXG4gICAgICAgICAgICAgIHJldHVybiBGID0gYS5IRVg4LmV4ZWMoQSkuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoRywgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhLlJHQi50ZXN0KEEpKVxuICAgICAgICAgICAgICByZXR1cm4gKEYgPSBhLlJHQi5leGVjKEEpLnNsaWNlKDEpLm1hcChmdW5jdGlvbihHKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEcgLyAyNTU7XG4gICAgICAgICAgICAgIH0pKVszXSA9IDEsIEY7XG4gICAgICAgICAgICBpZiAoYS5SR0JfUEVSQ0VOVC50ZXN0KEEpKVxuICAgICAgICAgICAgICByZXR1cm4gKEYgPSBhLlJHQl9QRVJDRU5ULmV4ZWMoQSkuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChHKSAvIDEwMDtcbiAgICAgICAgICAgICAgfSkpWzNdID0gMSwgRjtcbiAgICAgICAgICAgIGlmIChhLlJHQkEudGVzdChBKSlcbiAgICAgICAgICAgICAgcmV0dXJuIEYgPSBhLlJHQkEuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVID09PSAzID8gcGFyc2VGbG9hdChHKSA6IEcgLyAyNTU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGEuUkdCQV9QRVJDRU5ULnRlc3QoQSkpXG4gICAgICAgICAgICAgIHJldHVybiBGID0gYS5SR0JBX1BFUkNFTlQuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVID09PSAzID8gcGFyc2VGbG9hdChHKSA6IHBhcnNlRmxvYXQoRykgLyAxMDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGEuSFNMLnRlc3QoQSkgPyAoRiA9IGEuSFNMLmV4ZWMoQSkuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKEcsIFUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFUgPT09IDAgPyBwYXJzZUludChHLCAxMCkgLyAzNjAgOiBwYXJzZUludChHLCAxMCkgLyAxMDA7XG4gICAgICAgICAgICB9KSlbM10gPSAxIDogYS5IU0xBLnRlc3QoQSkgJiYgKEYgPSBhLkhTTEEuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgICByZXR1cm4gVSA9PT0gMCA/IHBhcnNlSW50KEcsIDEwKSAvIDM2MCA6IFUgPT09IDMgPyBwYXJzZUZsb2F0KEcpIDogcGFyc2VJbnQoRywgMTApIC8gMTAwO1xuICAgICAgICAgICAgfSkpLCAoRiA9IEYubWFwKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKEcsIDEpLCAwKTtcbiAgICAgICAgICAgIH0pKS5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBnLmRlZmF1bHQuX2hzbGFUb1JHQkEoRik7XG4gICAgICAgICAgICBpZiAoYS5IU0IudGVzdChBKSA/IChGID0gYS5IU0IuZXhlYyhBKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgICByZXR1cm4gVSA9PT0gMCA/IHBhcnNlSW50KEcsIDEwKSAvIDM2MCA6IHBhcnNlSW50KEcsIDEwKSAvIDEwMDtcbiAgICAgICAgICAgIH0pKVszXSA9IDEgOiBhLkhTQkEudGVzdChBKSAmJiAoRiA9IGEuSFNCQS5leGVjKEEpLnNsaWNlKDEpLm1hcChmdW5jdGlvbihHLCBVKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVID09PSAwID8gcGFyc2VJbnQoRywgMTApIC8gMzYwIDogVSA9PT0gMyA/IHBhcnNlRmxvYXQoRykgOiBwYXJzZUludChHLCAxMCkgLyAxMDA7XG4gICAgICAgICAgICB9KSksIEYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAoUCA9IEYubGVuZ3RoIC0gMTsgMCA8PSBQOyAtLVApXG4gICAgICAgICAgICAgICAgRltQXSA9IE1hdGgubWF4KE1hdGgubWluKEZbUF0sIDEpLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGcuZGVmYXVsdC5faHNiYVRvUkdCQShGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEYgPSBbMSwgMSwgMSwgMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChNICE9PSAxICYmIE0gIT09IDIgfHwgdHlwZW9mIFMgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGFyZ3VtZW50cywgXCJpcyBub3QgYSB2YWxpZCBjb2xvciByZXByZXNlbnRhdGlvbi5cIikpO1xuICAgICAgICAgICAgRlswXSA9IFMgLyBMWzJdLCBGWzFdID0gUyAvIExbMl0sIEZbMl0gPSBTIC8gTFsyXSwgRlszXSA9IHR5cGVvZiBFID09IFwibnVtYmVyXCIgPyBFIC8gTFszXSA6IDEsIEYgPSBGLm1hcChmdW5jdGlvbihHKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihHLCAxKSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEY7XG4gICAgICAgIH0gfV0sIChUID0gW3sga2V5OiBcInRvU3RyaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihTKSB7XG4gICAgICAgICAgdmFyIEUgPSB0aGlzLmxldmVscywgQSA9IHRoaXMuX2FycmF5LCB4ID0gQVszXTtcbiAgICAgICAgICBzd2l0Y2ggKFMpIHtcbiAgICAgICAgICAgIGNhc2UgXCIjcnJnZ2JiXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIiNcIi5jb25jYXQoRVswXSA8IDE2ID8gXCIwXCIuY29uY2F0KEVbMF0udG9TdHJpbmcoMTYpKSA6IEVbMF0udG9TdHJpbmcoMTYpLCBFWzFdIDwgMTYgPyBcIjBcIi5jb25jYXQoRVsxXS50b1N0cmluZygxNikpIDogRVsxXS50b1N0cmluZygxNiksIEVbMl0gPCAxNiA/IFwiMFwiLmNvbmNhdChFWzJdLnRvU3RyaW5nKDE2KSkgOiBFWzJdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBjYXNlIFwiI3JyZ2diYmFhXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIiNcIi5jb25jYXQoRVswXSA8IDE2ID8gXCIwXCIuY29uY2F0KEVbMF0udG9TdHJpbmcoMTYpKSA6IEVbMF0udG9TdHJpbmcoMTYpLCBFWzFdIDwgMTYgPyBcIjBcIi5jb25jYXQoRVsxXS50b1N0cmluZygxNikpIDogRVsxXS50b1N0cmluZygxNiksIEVbMl0gPCAxNiA/IFwiMFwiLmNvbmNhdChFWzJdLnRvU3RyaW5nKDE2KSkgOiBFWzJdLnRvU3RyaW5nKDE2KSwgRVszXSA8IDE2ID8gXCIwXCIuY29uY2F0KEVbM10udG9TdHJpbmcoMTYpKSA6IEVbM10udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGNhc2UgXCIjcmdiXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIiNcIi5jb25jYXQoTWF0aC5yb3VuZCgxNSAqIEFbMF0pLnRvU3RyaW5nKDE2KSwgTWF0aC5yb3VuZCgxNSAqIEFbMV0pLnRvU3RyaW5nKDE2KSwgTWF0aC5yb3VuZCgxNSAqIEFbMl0pLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBjYXNlIFwiI3JnYmFcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiLmNvbmNhdChNYXRoLnJvdW5kKDE1ICogQVswXSkudG9TdHJpbmcoMTYpLCBNYXRoLnJvdW5kKDE1ICogQVsxXSkudG9TdHJpbmcoMTYpLCBNYXRoLnJvdW5kKDE1ICogQVsyXSkudG9TdHJpbmcoMTYpLCBNYXRoLnJvdW5kKDE1ICogQVszXSkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdChFWzBdLCBcIiwgXCIsIEVbMV0sIFwiLCBcIiwgRVsyXSwgXCIpXCIpO1xuICAgICAgICAgICAgY2FzZSBcInJnYiVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdCgoMTAwICogQVswXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiBBWzFdKS50b1ByZWNpc2lvbigzKSwgXCIlLCBcIiwgKDEwMCAqIEFbMl0pLnRvUHJlY2lzaW9uKDMpLCBcIiUpXCIpO1xuICAgICAgICAgICAgY2FzZSBcInJnYmElXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KCgxMDAgKiBBWzBdKS50b1ByZWNpc2lvbigzKSwgXCIlLCBcIiwgKDEwMCAqIEFbMV0pLnRvUHJlY2lzaW9uKDMpLCBcIiUsIFwiLCAoMTAwICogQVsyXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiBBWzNdKS50b1ByZWNpc2lvbigzKSwgXCIlKVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJoc2JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoc3ZcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHNiYSB8fCAodGhpcy5oc2JhID0gZy5kZWZhdWx0Ll9yZ2JhVG9IU0JBKHRoaXMuX2FycmF5KSksIFwiaHNiKFwiLmNvbmNhdCh0aGlzLmhzYmFbMF0gKiB0aGlzLm1heGVzW2guSFNCXVswXSwgXCIsIFwiLCB0aGlzLmhzYmFbMV0gKiB0aGlzLm1heGVzW2guSFNCXVsxXSwgXCIsIFwiLCB0aGlzLmhzYmFbMl0gKiB0aGlzLm1heGVzW2guSFNCXVsyXSwgXCIpXCIpO1xuICAgICAgICAgICAgY2FzZSBcImhzYiVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoc3YlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmhzYmEgfHwgKHRoaXMuaHNiYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNCQSh0aGlzLl9hcnJheSkpLCBcImhzYihcIi5jb25jYXQoKDEwMCAqIHRoaXMuaHNiYVswXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiB0aGlzLmhzYmFbMV0pLnRvUHJlY2lzaW9uKDMpLCBcIiUsIFwiLCAoMTAwICogdGhpcy5oc2JhWzJdKS50b1ByZWNpc2lvbigzKSwgXCIlKVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJoc2JhXCI6XG4gICAgICAgICAgICBjYXNlIFwiaHN2YVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oc2JhIHx8ICh0aGlzLmhzYmEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTQkEodGhpcy5fYXJyYXkpKSwgXCJoc2JhKFwiLmNvbmNhdCh0aGlzLmhzYmFbMF0gKiB0aGlzLm1heGVzW2guSFNCXVswXSwgXCIsIFwiLCB0aGlzLmhzYmFbMV0gKiB0aGlzLm1heGVzW2guSFNCXVsxXSwgXCIsIFwiLCB0aGlzLmhzYmFbMl0gKiB0aGlzLm1heGVzW2guSFNCXVsyXSwgXCIsIFwiLCB4LCBcIilcIik7XG4gICAgICAgICAgICBjYXNlIFwiaHNiYSVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoc3ZhJVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oc2JhIHx8ICh0aGlzLmhzYmEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTQkEodGhpcy5fYXJyYXkpKSwgXCJoc2JhKFwiLmNvbmNhdCgoMTAwICogdGhpcy5oc2JhWzBdKS50b1ByZWNpc2lvbigzKSwgXCIlLCBcIiwgKDEwMCAqIHRoaXMuaHNiYVsxXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiB0aGlzLmhzYmFbMl0pLnRvUHJlY2lzaW9uKDMpLCBcIiUsIFwiLCAoMTAwICogeCkudG9QcmVjaXNpb24oMyksIFwiJSlcIik7XG4gICAgICAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmhzbGEgfHwgKHRoaXMuaHNsYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNMQSh0aGlzLl9hcnJheSkpLCBcImhzbChcIi5jb25jYXQodGhpcy5oc2xhWzBdICogdGhpcy5tYXhlc1toLkhTTF1bMF0sIFwiLCBcIiwgdGhpcy5oc2xhWzFdICogdGhpcy5tYXhlc1toLkhTTF1bMV0sIFwiLCBcIiwgdGhpcy5oc2xhWzJdICogdGhpcy5tYXhlc1toLkhTTF1bMl0sIFwiKVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJoc2wlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmhzbGEgfHwgKHRoaXMuaHNsYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNMQSh0aGlzLl9hcnJheSkpLCBcImhzbChcIi5jb25jYXQoKDEwMCAqIHRoaXMuaHNsYVswXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiB0aGlzLmhzbGFbMV0pLnRvUHJlY2lzaW9uKDMpLCBcIiUsIFwiLCAoMTAwICogdGhpcy5oc2xhWzJdKS50b1ByZWNpc2lvbigzKSwgXCIlKVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJoc2xhXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmhzbGEgfHwgKHRoaXMuaHNsYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNMQSh0aGlzLl9hcnJheSkpLCBcImhzbGEoXCIuY29uY2F0KHRoaXMuaHNsYVswXSAqIHRoaXMubWF4ZXNbaC5IU0xdWzBdLCBcIiwgXCIsIHRoaXMuaHNsYVsxXSAqIHRoaXMubWF4ZXNbaC5IU0xdWzFdLCBcIiwgXCIsIHRoaXMuaHNsYVsyXSAqIHRoaXMubWF4ZXNbaC5IU0xdWzJdLCBcIiwgXCIsIHgsIFwiKVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJoc2xhJVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oc2xhIHx8ICh0aGlzLmhzbGEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTTEEodGhpcy5fYXJyYXkpKSwgXCJoc2woXCIuY29uY2F0KCgxMDAgKiB0aGlzLmhzbGFbMF0pLnRvUHJlY2lzaW9uKDMpLCBcIiUsIFwiLCAoMTAwICogdGhpcy5oc2xhWzFdKS50b1ByZWNpc2lvbigzKSwgXCIlLCBcIiwgKDEwMCAqIHRoaXMuaHNsYVsyXSkudG9QcmVjaXNpb24oMyksIFwiJSwgXCIsICgxMDAgKiB4KS50b1ByZWNpc2lvbigzKSwgXCIlKVwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KEVbMF0sIFwiLFwiLCBFWzFdLCBcIixcIiwgRVsyXSwgXCIsXCIsIHgsIFwiKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0UmVkXCIsIHZhbHVlOiBmdW5jdGlvbihTKSB7XG4gICAgICAgICAgdGhpcy5fYXJyYXlbMF0gPSBTIC8gdGhpcy5tYXhlc1toLlJHQl1bMF0sIHRoaXMuX2NhbGN1bGF0ZUxldmVscygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldEdyZWVuXCIsIHZhbHVlOiBmdW5jdGlvbihTKSB7XG4gICAgICAgICAgdGhpcy5fYXJyYXlbMV0gPSBTIC8gdGhpcy5tYXhlc1toLlJHQl1bMV0sIHRoaXMuX2NhbGN1bGF0ZUxldmVscygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldEJsdWVcIiwgdmFsdWU6IGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICB0aGlzLl9hcnJheVsyXSA9IFMgLyB0aGlzLm1heGVzW2guUkdCXVsyXSwgdGhpcy5fY2FsY3VsYXRlTGV2ZWxzKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0QWxwaGFcIiwgdmFsdWU6IGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICB0aGlzLl9hcnJheVszXSA9IFMgLyB0aGlzLm1heGVzW3RoaXMubW9kZV1bM10sIHRoaXMuX2NhbGN1bGF0ZUxldmVscygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9jYWxjdWxhdGVMZXZlbHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIFMgPSB0aGlzLl9hcnJheSwgRSA9IHRoaXMubGV2ZWxzID0gbmV3IEFycmF5KFMubGVuZ3RoKSwgQSA9IFMubGVuZ3RoIC0gMTsgMCA8PSBBOyAtLUEpXG4gICAgICAgICAgICBFW0FdID0gTWF0aC5yb3VuZCgyNTUgKiBTW0FdKTtcbiAgICAgICAgICB0aGlzLmhzbGEgPSBudWxsLCB0aGlzLmhzYmEgPSBudWxsO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRBbHBoYVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5WzNdICogdGhpcy5tYXhlc1t0aGlzLm1vZGVdWzNdO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9zdG9yZU1vZGVBbmRNYXhlc1wiLCB2YWx1ZTogZnVuY3Rpb24oUywgRSkge1xuICAgICAgICAgIHRoaXMubW9kZSA9IFMsIHRoaXMubWF4ZXMgPSBFO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRNb2RlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRNYXhlc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWF4ZXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEJsdWVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheVsyXSAqIHRoaXMubWF4ZXNbaC5SR0JdWzJdO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRCcmlnaHRuZXNzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oc2JhIHx8ICh0aGlzLmhzYmEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTQkEodGhpcy5fYXJyYXkpKSwgdGhpcy5oc2JhWzJdICogdGhpcy5tYXhlc1toLkhTQl1bMl07XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEdyZWVuXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbMV0gKiB0aGlzLm1heGVzW2guUkdCXVsxXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0SHVlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBoLkhTQiA/ICh0aGlzLmhzYmEgfHwgKHRoaXMuaHNiYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNCQSh0aGlzLl9hcnJheSkpLCB0aGlzLmhzYmFbMF0gKiB0aGlzLm1heGVzW2guSFNCXVswXSkgOiAodGhpcy5oc2xhIHx8ICh0aGlzLmhzbGEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTTEEodGhpcy5fYXJyYXkpKSwgdGhpcy5oc2xhWzBdICogdGhpcy5tYXhlc1toLkhTTF1bMF0pO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRMaWdodG5lc3NcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhzbGEgfHwgKHRoaXMuaHNsYSA9IGcuZGVmYXVsdC5fcmdiYVRvSFNMQSh0aGlzLl9hcnJheSkpLCB0aGlzLmhzbGFbMl0gKiB0aGlzLm1heGVzW2guSFNMXVsyXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0UmVkXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbMF0gKiB0aGlzLm1heGVzW2guUkdCXVswXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0U2F0dXJhdGlvblwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gaC5IU0IgPyAodGhpcy5oc2JhIHx8ICh0aGlzLmhzYmEgPSBnLmRlZmF1bHQuX3JnYmFUb0hTQkEodGhpcy5fYXJyYXkpKSwgdGhpcy5oc2JhWzFdICogdGhpcy5tYXhlc1toLkhTQl1bMV0pIDogKHRoaXMuaHNsYSB8fCAodGhpcy5oc2xhID0gZy5kZWZhdWx0Ll9yZ2JhVG9IU0xBKHRoaXMuX2FycmF5KSksIHRoaXMuaHNsYVsxXSAqIHRoaXMubWF4ZXNbaC5IU0xdWzFdKTtcbiAgICAgICAgfSB9XSkgJiYgcyhqLnByb3RvdHlwZSwgVCksIF8gJiYgcyhqLCBfKSwgcDtcbiAgICAgIH0oKSwgdS5kZWZhdWx0LkNvbG9yKTtcbiAgICAgIEMuZGVmYXVsdCA9IGM7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vY29sb3JfY29udmVyc2lvblwiOiAyNjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCI6IDE2MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCI6IDE2NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCI6IDE2NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIjogMTY4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3RvclwiOiAxOTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCI6IDIwNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMjY4OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShyKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHM7XG4gICAgICAgIH0gOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHM7XG4gICAgICAgIH0pKHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShyKSB7XG4gICAgICAgIHJldHVybiAoeSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gbShzKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBzLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKHMpO1xuICAgICAgICB9KShyKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAoZiA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIGYuX19lc01vZHVsZSA/IGYgOiB7IGRlZmF1bHQ6IGYgfSwgaCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKHIgJiYgci5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBpZiAociA9PT0gbnVsbCB8fCB5KHIpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiByIH07XG4gICAgICAgIHZhciBzID0gZygpO1xuICAgICAgICBpZiAocyAmJiBzLmhhcyhyKSlcbiAgICAgICAgICByZXR1cm4gcy5nZXQocik7XG4gICAgICAgIHZhciBvLCBpID0ge30sIGwgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChvIGluIHIpIHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgbykgJiYgKChuID0gbCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgbykgOiBudWxsKSAmJiAobi5nZXQgfHwgbi5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIG4pIDogaVtvXSA9IHJbb10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpLmRlZmF1bHQgPSByLCBzICYmIHMuc2V0KHIsIGkpLCBpO1xuICAgICAgfSh0KFwiLi4vY29yZS9jb25zdGFudHNcIikpO1xuICAgICAgZnVuY3Rpb24gZygpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCByKTtcbiAgICAgIH1cbiAgICAgIHQoXCIuL3A1LkNvbG9yXCIpLCB1LmRlZmF1bHQucHJvdG90eXBlLmJlZ2luQ2xpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5iZWdpbkNsaXAoMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmVuZENsaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZW5kQ2xpcCgpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5iZWdpbkNsaXAocyksIHIoKSwgdGhpcy5fcmVuZGVyZXIuZW5kQ2xpcChzKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgcmV0dXJuIChyID0gdGhpcy5fcmVuZGVyZXIpLmJhY2tncm91bmQuYXBwbHkociwgYXJndW1lbnRzKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmNsZWFyKChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pIHx8IDAsIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pIHx8IDAsIChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0pIHx8IDAsIChhcmd1bWVudHMubGVuZ3RoIDw9IDMgPyB2b2lkIDAgOiBhcmd1bWVudHNbM10pIHx8IDApLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvck1vZGUgPSBmdW5jdGlvbihyLCBzLCBvLCBpLCBsKSB7XG4gICAgICAgIHJldHVybiB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNvbG9yTW9kZVwiLCBhcmd1bWVudHMpLCByICE9PSBoLlJHQiAmJiByICE9PSBoLkhTQiAmJiByICE9PSBoLkhTTCB8fCAodGhpcy5fY29sb3JNb2RlID0gciwgciA9IHRoaXMuX2NvbG9yTWF4ZXNbcl0sIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgPyAoclswXSA9IHMsIHJbMV0gPSBzLCByWzJdID0gcywgclszXSA9IHMpIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNCA/IChyWzBdID0gcywgclsxXSA9IG8sIHJbMl0gPSBpKSA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDUgJiYgKHJbMF0gPSBzLCByWzFdID0gbywgclsyXSA9IGksIHJbM10gPSBsKSksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5fc2V0UHJvcGVydHkoXCJfZmlsbFNldFwiLCAhMCksIHRoaXMuX3JlbmRlcmVyLl9zZXRQcm9wZXJ0eShcIl9kb0ZpbGxcIiwgITApLCAociA9IHRoaXMuX3JlbmRlcmVyKS5maWxsLmFwcGx5KHIsIGFyZ3VtZW50cyksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLm5vRmlsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX3NldFByb3BlcnR5KFwiX2RvRmlsbFwiLCAhMSksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLm5vU3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5fc2V0UHJvcGVydHkoXCJfZG9TdHJva2VcIiwgITEpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5fc2V0UHJvcGVydHkoXCJfc3Ryb2tlU2V0XCIsICEwKSwgdGhpcy5fcmVuZGVyZXIuX3NldFByb3BlcnR5KFwiX2RvU3Ryb2tlXCIsICEwKSwgKHIgPSB0aGlzLl9yZW5kZXJlcikuc3Ryb2tlLmFwcGx5KHIsIGFyZ3VtZW50cyksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5lcmFzZSgwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IDI1NSwgMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAyNTUpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5ub0VyYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5ub0VyYXNlKCksIHRoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGYgPSB1LmRlZmF1bHQ7XG4gICAgICBDLmRlZmF1bHQgPSBmO1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuL3A1LkNvbG9yXCI6IDI2NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiOiAxNTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyNjk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLlFVQURSQVRJQyA9IEMuTElORUFSID0gQy5fQ1RYX01JRERMRSA9IEMuX0RFRkFVTFRfTEVBRE1VTFQgPSBDLl9ERUZBVUxUX1RFWFRfRklMTCA9IEMuV09SRCA9IEMuQ0hBUiA9IEMuQk9MRElUQUxJQyA9IEMuQk9MRCA9IEMuSVRBTElDID0gQy5OT1JNQUwgPSBDLkJMVVIgPSBDLkVST0RFID0gQy5ESUxBVEUgPSBDLlBPU1RFUklaRSA9IEMuSU5WRVJUID0gQy5PUEFRVUUgPSBDLkdSQVkgPSBDLlRIUkVTSE9MRCA9IEMuQlVSTiA9IEMuRE9ER0UgPSBDLlNPRlRfTElHSFQgPSBDLkhBUkRfTElHSFQgPSBDLk9WRVJMQVkgPSBDLlJFUExBQ0UgPSBDLlNDUkVFTiA9IEMuTVVMVElQTFkgPSBDLkVYQ0xVU0lPTiA9IEMuU1VCVFJBQ1QgPSBDLkRJRkZFUkVOQ0UgPSBDLkxJR0hURVNUID0gQy5EQVJLRVNUID0gQy5BREQgPSBDLlJFTU9WRSA9IEMuQkxFTkQgPSBDLlVQX0FSUk9XID0gQy5UQUIgPSBDLlNISUZUID0gQy5SSUdIVF9BUlJPVyA9IEMuUkVUVVJOID0gQy5PUFRJT04gPSBDLkxFRlRfQVJST1cgPSBDLkVTQ0FQRSA9IEMuRU5URVIgPSBDLkRPV05fQVJST1cgPSBDLkRFTEVURSA9IEMuQ09OVFJPTCA9IEMuQkFDS1NQQUNFID0gQy5BTFQgPSBDLkFVVE8gPSBDLkhTTCA9IEMuSFNCID0gQy5SR0IgPSBDLk1JVEVSID0gQy5CRVZFTCA9IEMuUk9VTkQgPSBDLlNRVUFSRSA9IEMuUFJPSkVDVCA9IEMuUElFID0gQy5DSE9SRCA9IEMuT1BFTiA9IEMuQ0xPU0UgPSBDLlRFU1MgPSBDLlFVQURfU1RSSVAgPSBDLlFVQURTID0gQy5UUklBTkdMRV9TVFJJUCA9IEMuVFJJQU5HTEVfRkFOID0gQy5UUklBTkdMRVMgPSBDLkxJTkVfTE9PUCA9IEMuTElORV9TVFJJUCA9IEMuTElORVMgPSBDLlBPSU5UUyA9IEMuQkFTRUxJTkUgPSBDLkJPVFRPTSA9IEMuVE9QID0gQy5DRU5URVIgPSBDLkxFRlQgPSBDLlJJR0hUID0gQy5SQURJVVMgPSBDLkNPUk5FUlMgPSBDLkNPUk5FUiA9IEMuUkFEX1RPX0RFRyA9IEMuREVHX1RPX1JBRCA9IEMuUkFESUFOUyA9IEMuREVHUkVFUyA9IEMuVFdPX1BJID0gQy5UQVUgPSBDLlFVQVJURVJfUEkgPSBDLlBJID0gQy5IQUxGX1BJID0gQy5XQUlUID0gQy5URVhUID0gQy5NT1ZFID0gQy5IQU5EID0gQy5DUk9TUyA9IEMuQVJST1cgPSBDLldFQkdMMiA9IEMuV0VCR0wgPSBDLlAyRCA9IEMuVkVSU0lPTiA9IHZvaWQgMCwgQy5SR0JBID0gQy5IQUxGX0ZMT0FUID0gQy5GTE9BVCA9IEMuVU5TSUdORURfSU5UID0gQy5VTlNJR05FRF9CWVRFID0gQy5DT1ZFUiA9IEMuQ09OVEFJTiA9IEMuRkFMTEJBQ0sgPSBDLkxBQkVMID0gQy5BWEVTID0gQy5HUklEID0gQy5fREVGQVVMVF9GSUxMID0gQy5fREVGQVVMVF9TVFJPS0UgPSBDLlBPUlRSQUlUID0gQy5MQU5EU0NBUEUgPSBDLlNNT09USCA9IEMuRkxBVCA9IEMuTUlSUk9SID0gQy5DTEFNUCA9IEMuUkVQRUFUID0gQy5ORUFSRVNUID0gQy5JTUFHRSA9IEMuSU1NRURJQVRFID0gQy5URVhUVVJFID0gQy5GSUxMID0gQy5TVFJPS0UgPSBDLkNVUlZFID0gQy5CRVpJRVIgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IE1hdGguUEksIHkgPSAoQy5WRVJTSU9OID0gXCIxLjkuNFwiLCBDLlAyRCA9IFwicDJkXCIsIEMuV0VCR0wgPSBcIndlYmdsXCIsIEMuV0VCR0wyID0gXCJ3ZWJnbDJcIiwgQy5BUlJPVyA9IFwiZGVmYXVsdFwiLCBDLkNST1NTID0gXCJjcm9zc2hhaXJcIiwgQy5IQU5EID0gXCJwb2ludGVyXCIsIEMuTU9WRSA9IFwibW92ZVwiLCBDLlRFWFQgPSBcInRleHRcIiwgQy5XQUlUID0gXCJ3YWl0XCIsIG0gLyAyKSwgeSA9IChDLkhBTEZfUEkgPSB5LCBtKSwgeSA9IChDLlBJID0geSwgbSAvIDQpLCB5ID0gKEMuUVVBUlRFUl9QSSA9IHksIDIgKiBtKSwgeSA9IChDLlRBVSA9IHksIDIgKiBtKSwgeSA9IChDLlRXT19QSSA9IHksIEMuREVHUkVFUyA9IFwiZGVncmVlc1wiLCBDLlJBRElBTlMgPSBcInJhZGlhbnNcIiwgbSAvIDE4MCksIHkgPSAoQy5ERUdfVE9fUkFEID0geSwgMTgwIC8gbSk7XG4gICAgICBDLlJBRF9UT19ERUcgPSB5LCBDLkNPUk5FUiA9IFwiY29ybmVyXCIsIEMuQ09STkVSUyA9IFwiY29ybmVyc1wiLCBDLlJBRElVUyA9IFwicmFkaXVzXCIsIEMuUklHSFQgPSBcInJpZ2h0XCIsIEMuTEVGVCA9IFwibGVmdFwiLCBDLkNFTlRFUiA9IFwiY2VudGVyXCIsIEMuVE9QID0gXCJ0b3BcIiwgQy5CT1RUT00gPSBcImJvdHRvbVwiLCBDLkJBU0VMSU5FID0gXCJhbHBoYWJldGljXCIsIEMuUE9JTlRTID0gMCwgQy5MSU5FUyA9IDEsIEMuTElORV9TVFJJUCA9IDMsIEMuTElORV9MT09QID0gMiwgQy5UUklBTkdMRVMgPSA0LCBDLlRSSUFOR0xFX0ZBTiA9IDYsIEMuVFJJQU5HTEVfU1RSSVAgPSA1LCBDLlFVQURTID0gXCJxdWFkc1wiLCBDLlFVQURfU1RSSVAgPSBcInF1YWRfc3RyaXBcIiwgQy5URVNTID0gXCJ0ZXNzXCIsIEMuQ0xPU0UgPSBcImNsb3NlXCIsIEMuT1BFTiA9IFwib3BlblwiLCBDLkNIT1JEID0gXCJjaG9yZFwiLCBDLlBJRSA9IFwicGllXCIsIEMuUFJPSkVDVCA9IFwic3F1YXJlXCIsIEMuU1FVQVJFID0gXCJidXR0XCIsIEMuUk9VTkQgPSBcInJvdW5kXCIsIEMuQkVWRUwgPSBcImJldmVsXCIsIEMuTUlURVIgPSBcIm1pdGVyXCIsIEMuUkdCID0gXCJyZ2JcIiwgQy5IU0IgPSBcImhzYlwiLCBDLkhTTCA9IFwiaHNsXCIsIEMuQVVUTyA9IFwiYXV0b1wiLCBDLkFMVCA9IDE4LCBDLkJBQ0tTUEFDRSA9IDgsIEMuQ09OVFJPTCA9IDE3LCBDLkRFTEVURSA9IDQ2LCBDLkRPV05fQVJST1cgPSA0MCwgQy5FTlRFUiA9IDEzLCBDLkVTQ0FQRSA9IDI3LCBDLkxFRlRfQVJST1cgPSAzNywgQy5PUFRJT04gPSAxOCwgQy5SRVRVUk4gPSAxMywgQy5SSUdIVF9BUlJPVyA9IDM5LCBDLlNISUZUID0gMTYsIEMuVEFCID0gOSwgQy5VUF9BUlJPVyA9IDM4LCBDLkJMRU5EID0gXCJzb3VyY2Utb3ZlclwiLCBDLlJFTU9WRSA9IFwiZGVzdGluYXRpb24tb3V0XCIsIEMuQUREID0gXCJsaWdodGVyXCIsIEMuREFSS0VTVCA9IFwiZGFya2VuXCIsIEMuTElHSFRFU1QgPSBcImxpZ2h0ZW5cIiwgQy5ESUZGRVJFTkNFID0gXCJkaWZmZXJlbmNlXCIsIEMuU1VCVFJBQ1QgPSBcInN1YnRyYWN0XCIsIEMuRVhDTFVTSU9OID0gXCJleGNsdXNpb25cIiwgQy5NVUxUSVBMWSA9IFwibXVsdGlwbHlcIiwgQy5TQ1JFRU4gPSBcInNjcmVlblwiLCBDLlJFUExBQ0UgPSBcImNvcHlcIiwgQy5PVkVSTEFZID0gXCJvdmVybGF5XCIsIEMuSEFSRF9MSUdIVCA9IFwiaGFyZC1saWdodFwiLCBDLlNPRlRfTElHSFQgPSBcInNvZnQtbGlnaHRcIiwgQy5ET0RHRSA9IFwiY29sb3ItZG9kZ2VcIiwgQy5CVVJOID0gXCJjb2xvci1idXJuXCIsIEMuVEhSRVNIT0xEID0gXCJ0aHJlc2hvbGRcIiwgQy5HUkFZID0gXCJncmF5XCIsIEMuT1BBUVVFID0gXCJvcGFxdWVcIiwgQy5JTlZFUlQgPSBcImludmVydFwiLCBDLlBPU1RFUklaRSA9IFwicG9zdGVyaXplXCIsIEMuRElMQVRFID0gXCJkaWxhdGVcIiwgQy5FUk9ERSA9IFwiZXJvZGVcIiwgQy5CTFVSID0gXCJibHVyXCIsIEMuTk9STUFMID0gXCJub3JtYWxcIiwgQy5JVEFMSUMgPSBcIml0YWxpY1wiLCBDLkJPTEQgPSBcImJvbGRcIiwgQy5CT0xESVRBTElDID0gXCJib2xkIGl0YWxpY1wiLCBDLkNIQVIgPSBcIkNIQVJcIiwgQy5XT1JEID0gXCJXT1JEXCIsIEMuX0RFRkFVTFRfVEVYVF9GSUxMID0gXCIjMDAwMDAwXCIsIEMuX0RFRkFVTFRfTEVBRE1VTFQgPSAxLjI1LCBDLl9DVFhfTUlERExFID0gXCJtaWRkbGVcIiwgQy5MSU5FQVIgPSBcImxpbmVhclwiLCBDLlFVQURSQVRJQyA9IFwicXVhZHJhdGljXCIsIEMuQkVaSUVSID0gXCJiZXppZXJcIiwgQy5DVVJWRSA9IFwiY3VydmVcIiwgQy5TVFJPS0UgPSBcInN0cm9rZVwiLCBDLkZJTEwgPSBcImZpbGxcIiwgQy5URVhUVVJFID0gXCJ0ZXh0dXJlXCIsIEMuSU1NRURJQVRFID0gXCJpbW1lZGlhdGVcIiwgQy5JTUFHRSA9IFwiaW1hZ2VcIiwgQy5ORUFSRVNUID0gXCJuZWFyZXN0XCIsIEMuUkVQRUFUID0gXCJyZXBlYXRcIiwgQy5DTEFNUCA9IFwiY2xhbXBcIiwgQy5NSVJST1IgPSBcIm1pcnJvclwiLCBDLkZMQVQgPSBcImZsYXRcIiwgQy5TTU9PVEggPSBcInNtb290aFwiLCBDLkxBTkRTQ0FQRSA9IFwibGFuZHNjYXBlXCIsIEMuUE9SVFJBSVQgPSBcInBvcnRyYWl0XCIsIEMuX0RFRkFVTFRfU1RST0tFID0gXCIjMDAwMDAwXCIsIEMuX0RFRkFVTFRfRklMTCA9IFwiI0ZGRkZGRlwiLCBDLkdSSUQgPSBcImdyaWRcIiwgQy5BWEVTID0gXCJheGVzXCIsIEMuTEFCRUwgPSBcImxhYmVsXCIsIEMuRkFMTEJBQ0sgPSBcImZhbGxiYWNrXCIsIEMuQ09OVEFJTiA9IFwiY29udGFpblwiLCBDLkNPVkVSID0gXCJjb3ZlclwiLCBDLlVOU0lHTkVEX0JZVEUgPSBcInVuc2lnbmVkLWJ5dGVcIiwgQy5VTlNJR05FRF9JTlQgPSBcInVuc2lnbmVkLWludFwiLCBDLkZMT0FUID0gXCJmbG9hdFwiLCBDLkhBTEZfRkxPQVQgPSBcImhhbGYtZmxvYXRcIiwgQy5SR0JBID0gXCJyZ2JhXCI7XG4gICAgfSwge31dLCAyNzA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGwpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbjtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBuLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbjtcbiAgICAgICAgfSkobCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KGwpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBtKG4pO1xuICAgICAgICB9IDogZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG4uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBuICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0obik7XG4gICAgICAgIH0pKGwpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zZWFyY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNlYXJjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKGggPSB0KFwiLi9tYWluXCIpKSAmJiBoLl9fZXNNb2R1bGUgPyBoIDogeyBkZWZhdWx0OiBoIH0sIGggPSBmdW5jdGlvbihsKSB7XG4gICAgICAgIGlmIChsICYmIGwuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgaWYgKGwgPT09IG51bGwgfHwgeShsKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogbCB9O1xuICAgICAgICB2YXIgbiA9IGcoKTtcbiAgICAgICAgaWYgKG4gJiYgbi5oYXMobCkpXG4gICAgICAgICAgcmV0dXJuIG4uZ2V0KGwpO1xuICAgICAgICB2YXIgYSwgYyA9IHt9LCBwID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAoYSBpbiBsKSB7XG4gICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGwsIGEpICYmICgoaiA9IHAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGwsIGEpIDogbnVsbCkgJiYgKGouZ2V0IHx8IGouc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLCBhLCBqKSA6IGNbYV0gPSBsW2FdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYy5kZWZhdWx0ID0gbCwgbiAmJiBuLnNldChsLCBjKSwgYztcbiAgICAgIH0odChcIi4vY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciBsO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChsID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSwgbCk7XG4gICAgICB9XG4gICAgICB2YXIgZiA9IFtoLkFSUk9XLCBoLkNST1NTLCBoLkhBTkQsIGguTU9WRSwgaC5URVhULCBoLldBSVRdLCByID0gKHUuZGVmYXVsdC5wcm90b3R5cGUuX2ZyYW1lUmF0ZSA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUuX2xhc3RGcmFtZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIHUuZGVmYXVsdC5wcm90b3R5cGUuX3RhcmdldEZyYW1lUmF0ZSA9IDYwLCB3aW5kb3cucHJpbnQpLCBzID0gITE7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggfHwgMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgICAgdS5kZWZhdWx0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA/IChsID0gY29uc29sZSkubG9nLmFwcGx5KGwsIGFyZ3VtZW50cykgOiBzIHx8IChyKCksIHdpbmRvdy5jb25maXJtKFwiWW91IGp1c3QgdHJpZWQgdG8gcHJpbnQgdGhlIHdlYnBhZ2UuIERvIHlvdSB3YW50IHRvIHByZXZlbnQgdGhpcyBmcm9tIHJ1bm5pbmcgYWdhaW4/XCIpICYmIChzID0gITApKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZnJhbWVDb3VudCA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUuZGVsdGFUaW1lID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS5mb2N1c2VkID0gZG9jdW1lbnQuaGFzRm9jdXMoKSwgdS5kZWZhdWx0LnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbihsLCBuLCBhKSB7XG4gICAgICAgIHZhciBjLCBwID0gXCJhdXRvXCIsIGogPSB0aGlzLl9jdXJFbGVtZW50LmVsdDtcbiAgICAgICAgZi5pbmNsdWRlcyhsKSA/IHAgPSBsIDogdHlwZW9mIGwgPT0gXCJzdHJpbmdcIiAmJiAoYyA9IFwiXCIsIG4gJiYgYSAmJiB0eXBlb2YgbiA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBhID09IFwibnVtYmVyXCIgJiYgKGMgPSBcIlwiLmNvbmNhdChuLCBcIiBcIikuY29uY2F0KGEpKSwgcCA9IGwuc3Vic3RyaW5nKDAsIDcpID09PSBcImh0dHA6Ly9cIiB8fCBsLnN1YnN0cmluZygwLCA4KSA9PT0gXCJodHRwczovL1wiIHx8IC9cXC4oY3VyfGpwZ3xqcGVnfGdpZnxwbmd8Q1VSfEpQR3xKUEVHfEdJRnxQTkcpJC8udGVzdChsKSA/IFwidXJsKFwiLmNvbmNhdChsLCBcIikgXCIpLmNvbmNhdChjLCBcIiwgYXV0b1wiKSA6IGwpLCBqLnN0eWxlLmN1cnNvciA9IHA7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmZyYW1lUmF0ZSA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZnJhbWVSYXRlXCIsIGFyZ3VtZW50cyksIHR5cGVvZiBsICE9IFwibnVtYmVyXCIgfHwgbCA8IDAgPyB0aGlzLl9mcmFtZVJhdGUgOiAodGhpcy5fc2V0UHJvcGVydHkoXCJfdGFyZ2V0RnJhbWVSYXRlXCIsIGwpLCBsID09PSAwICYmIHRoaXMuX3NldFByb3BlcnR5KFwiX2ZyYW1lUmF0ZVwiLCBsKSwgdGhpcyk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmdldEZyYW1lUmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZVJhdGUoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuc2V0RnJhbWVSYXRlID0gZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZVJhdGUobCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmdldFRhcmdldEZyYW1lUmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RnJhbWVSYXRlO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5ub0N1cnNvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jdXJFbGVtZW50LmVsdC5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIjtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUud2ViZ2xWZXJzaW9uID0gaC5QMkQsIHUuZGVmYXVsdC5wcm90b3R5cGUuZGlzcGxheVdpZHRoID0gc2NyZWVuLndpZHRoLCB1LmRlZmF1bHQucHJvdG90eXBlLmRpc3BsYXlIZWlnaHQgPSBzY3JlZW4uaGVpZ2h0LCB1LmRlZmF1bHQucHJvdG90eXBlLndpbmRvd1dpZHRoID0gbygpLCB1LmRlZmF1bHQucHJvdG90eXBlLndpbmRvd0hlaWdodCA9IGkoKSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fb25yZXNpemUgPSBmdW5jdGlvbihsKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwid2luZG93V2lkdGhcIiwgbygpKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJ3aW5kb3dIZWlnaHRcIiwgaSgpKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9pc0dsb2JhbCA/IHdpbmRvdyA6IHRoaXM7XG4gICAgICAgIHR5cGVvZiBuLndpbmRvd1Jlc2l6ZWQgIT0gXCJmdW5jdGlvblwiIHx8IChuID0gbi53aW5kb3dSZXNpemVkKGwpKSA9PT0gdm9pZCAwIHx8IG4gfHwgbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS53aWR0aCA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUuaGVpZ2h0ID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS5mdWxsc2NyZWVuID0gZnVuY3Rpb24obCkge1xuICAgICAgICBpZiAodS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJmdWxsc2NyZWVuXCIsIGFyZ3VtZW50cyksIGwgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICBpZiAobCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgIShkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bGxzY3JlZW4gbm90IGVuYWJsZWQgaW4gdGhpcyBicm93c2VyLlwiKTtcbiAgICAgICAgICBsLnJlcXVlc3RGdWxsc2NyZWVuID8gbC5yZXF1ZXN0RnVsbHNjcmVlbigpIDogbC5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/IGwubW96UmVxdWVzdEZ1bGxTY3JlZW4oKSA6IGwud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gPyBsLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCkgOiBsLm1zUmVxdWVzdEZ1bGxzY3JlZW4gJiYgbC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuID8gZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKSA6IGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gPyBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCkgOiBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiA/IGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCkgOiBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuICYmIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucGl4ZWxEZW5zaXR5ID0gZnVuY3Rpb24obCkge1xuICAgICAgICB2YXIgbjtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwicGl4ZWxEZW5zaXR5XCIsIGFyZ3VtZW50cyksIHR5cGVvZiBsID09IFwibnVtYmVyXCIgPyAobCAhPT0gdGhpcy5fcGl4ZWxEZW5zaXR5ICYmICh0aGlzLl9waXhlbERlbnNpdHkgPSB0aGlzLl9tYXhBbGxvd2VkUGl4ZWxEaW1lbnNpb25zID0gbCksIChuID0gdGhpcykucmVzaXplQ2FudmFzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAhMCkpIDogbiA9IHRoaXMuX3BpeGVsRGVuc2l0eSwgbjtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZGlzcGxheURlbnNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5nZXRVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmdldFVSTFBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5maWx0ZXIoZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiBsICE9PSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZ2V0VVJMUGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGwsIG4gPSAvWz8mXShbXiY9XSspKD86WyY9XSkoW14mPV0rKS9naW0sIGEgPSB7fTsgKGwgPSBuLmV4ZWMobG9jYXRpb24uc2VhcmNoKSkgIT0gbnVsbDsgKVxuICAgICAgICAgIGwuaW5kZXggPT09IG4ubGFzdEluZGV4ICYmIG4ubGFzdEluZGV4KyssIGFbbFsxXV0gPSBsWzJdO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIHQgPSB1LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4vY29uc3RhbnRzXCI6IDI2OSwgXCIuL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiOiAxOTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zZWFyY2hcIjogMjAyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyNzE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IChmID0gdChcIi4uL21haW5cIikpICYmIGYuX19lc01vZHVsZSA/IGYgOiB7IGRlZmF1bHQ6IGYgfTtcbiAgICAgIHQoXCIuLi9pbnRlcm5hdGlvbmFsaXphdGlvblwiKTtcbiAgICAgIGZ1bmN0aW9uIHkociwgcykge1xuICAgICAgICBzID0gcyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLCB1IHx8IGcoKSwgdS5zb21lKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICBpZiAoci5tZXNzYWdlICYmIHIubWVzc2FnZS5tYXRjaChcIlxcXFxXP1wiLmNvbmNhdChvLm5hbWUsIFwiXFxcXFdcIikpICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGkgPSBvLnR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IFwiXCIuY29uY2F0KG8ubmFtZSwgXCIoKVwiKSA6IG8ubmFtZSwgcyhcIkRpZCB5b3UganVzdCB0cnkgdG8gdXNlIHA1LmpzJ3MgXCIuY29uY2F0KGksIFwiIFwiKS5jb25jYXQoby50eXBlLCBgPyBJZiBzbywgeW91IG1heSB3YW50IHRvIG1vdmUgaXQgaW50byB5b3VyIHNrZXRjaCdzIHNldHVwKCkgZnVuY3Rpb24uXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZTogYCkuY29uY2F0KGgpKSwgITA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSBudWxsLCBnID0gbnVsbCwgaCA9IChtLmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IgPSBtLmRlZmF1bHQuX2NoZWNrRm9yVXNlckRlZmluZWRGdW5jdGlvbnMgPSBtLmRlZmF1bHQuX2Zlc0Vycm9yTW9uaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgfSwgdSA9IG51bGwsIFwiaHR0cHM6Ly9naXRodWIuY29tL3Byb2Nlc3NpbmcvcDUuanMvd2lraS9wNS5qcy1vdmVydmlldyN3aHktY2FudC1pLWFzc2lnbi12YXJpYWJsZXMtdXNpbmctcDUtZnVuY3Rpb25zLWFuZC12YXJpYWJsZXMtYmVmb3JlLXNldHVwXCIpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHIobykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuIGlbMF0gIT09IFwiX1wiICYmICEoaSBpbiBzKSAmJiAoc1tpXSA9ICEwKTtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgdmFyIGwgPSB0eXBlb2Ygb1tpXSA9PSBcImZ1bmN0aW9uXCIgPyBcImZ1bmN0aW9uXCIgOiBpID09PSBpLnRvVXBwZXJDYXNlKCkgPyBcImNvbnN0YW50XCIgOiBcInZhcmlhYmxlXCI7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBpLCB0eXBlOiBsIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSB7fTtcbiAgICAgICAgKHUgPSBbXS5jb25jYXQocihtLmRlZmF1bHQucHJvdG90eXBlKSwgcih0KFwiLi4vY29uc3RhbnRzXCIpKSkpLnNvcnQoZnVuY3Rpb24obywgaSkge1xuICAgICAgICAgIHJldHVybiBpLm5hbWUubGVuZ3RoIC0gby5uYW1lLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmID0gKG0uZGVmYXVsdC5wcm90b3R5cGUuX2hlbHBGb3JNaXN1c2VkQXRUb3BMZXZlbENvZGUgPSB5LCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIgJiYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgeSwgITEpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgeSwgITEpO1xuICAgICAgfSkpLCBtLmRlZmF1bHQpO1xuICAgICAgQy5kZWZhdWx0ID0gZjtcbiAgICB9LCB7IFwiLi4vY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9pbnRlcm5hdGlvbmFsaXphdGlvblwiOiAyNzgsIFwiLi4vbWFpblwiOiAyODAsIFwiLi9icm93c2VyX2Vycm9yc1wiOiB2b2lkIDAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiOiAxNTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCI6IDE2MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIjogMTYyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWVcIjogMTY5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCI6IDE3MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiOiAxODEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzXCI6IDE4NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIjogMTg2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yXCI6IDE5MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCI6IDE5OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIjogMjAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGhcIjogMjA0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI3MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtID0gKG0gPSB0KFwiLi4vbWFpblwiKSkgJiYgbS5fX2VzTW9kdWxlID8gbSA6IHsgZGVmYXVsdDogbSB9O1xuICAgICAgdChcIi4uL2ludGVybmF0aW9uYWxpemF0aW9uXCIpLCBtLmRlZmF1bHQuX2ZyaWVuZGx5RmlsZUxvYWRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgfSwgdCA9IG0uZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vaW50ZXJuYXRpb25hbGl6YXRpb25cIjogMjc4LCBcIi4uL21haW5cIjogMjgwIH1dLCAyNzM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgICAgICAgfSkocyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHMpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBtKG8pO1xuICAgICAgICB9IDogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBvICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0obyk7XG4gICAgICAgIH0pKHMpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSBmKHQoXCIuLi9tYWluXCIpKTtcbiAgICAgIHQoXCIuLi9pbnRlcm5hdGlvbmFsaXphdGlvblwiKSwgZyh0KFwiLi4vY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKHMpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCB5KHMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBzIH07XG4gICAgICAgIHZhciBvID0gaCgpO1xuICAgICAgICBpZiAobyAmJiBvLmhhcyhzKSlcbiAgICAgICAgICByZXR1cm4gby5nZXQocyk7XG4gICAgICAgIHZhciBpLCBsLCBuID0ge30sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChpIGluIHMpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIGkpICYmICgobCA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsIGkpIDogbnVsbCkgJiYgKGwuZ2V0IHx8IGwuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBpLCBsKSA6IG5baV0gPSBzW2ldKTtcbiAgICAgICAgcmV0dXJuIG4uZGVmYXVsdCA9IHMsIG8gJiYgby5zZXQocywgbiksIG47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKHMpIHtcbiAgICAgICAgcmV0dXJuIHMgJiYgcy5fX2VzTW9kdWxlID8gcyA6IHsgZGVmYXVsdDogcyB9O1xuICAgICAgfVxuICAgICAgdS5kZWZhdWx0Ll9mZXNDb2RlUmVhZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdmFyIHIgPSB1LmRlZmF1bHQ7XG4gICAgICBDLmRlZmF1bHQgPSByO1xuICAgIH0sIHsgXCIuLi9jb25zdGFudHNcIjogMjY5LCBcIi4uL2ludGVybmF0aW9uYWxpemF0aW9uXCI6IDI3OCwgXCIuLi9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCI6IDE1NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIjogMTYwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIjogMTYyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiOiAxNjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCI6IDE4NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3RvclwiOiAxOTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiOiAxOTgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiOiAyMDMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCI6IDIwNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI3NDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIG0oKSB7XG4gICAgICAgIHZhciB5ID0gLyhefEApXFxTKzpcXGQrLywgdSA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL20sIGggPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG4gICAgICAgIHJldHVybiB7IHBhcnNlOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcuc3RhY2t0cmFjZSAhPT0gdm9pZCAwIHx8IGdbXCJvcGVyYSNzb3VyY2Vsb2NcIl0gIT09IHZvaWQgMCA/IHRoaXMucGFyc2VPcGVyYShnKSA6IGcuc3RhY2sgJiYgZy5zdGFjay5tYXRjaCh1KSA/IHRoaXMucGFyc2VWOE9ySUUoZykgOiBnLnN0YWNrID8gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZykgOiB2b2lkIDA7XG4gICAgICAgIH0sIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24oZykge1xuICAgICAgICAgIHJldHVybiBnLmluZGV4T2YoXCI6XCIpID09PSAtMSA/IFtnXSA6IFsoZyA9IC8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMoZy5yZXBsYWNlKC9bKCldL2csIFwiXCIpKSlbMV0sIGdbMl0gfHwgdm9pZCAwLCBnWzNdIHx8IHZvaWQgMF07XG4gICAgICAgIH0sIHBhcnNlVjhPcklFOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcuc3RhY2suc3BsaXQoYFxuYCkuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWYubWF0Y2godSk7XG4gICAgICAgICAgfSwgdGhpcykubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHZhciByID0gKGYgPSAtMSA8IGYuaW5kZXhPZihcIihldmFsIFwiKSA/IGYucmVwbGFjZSgvZXZhbCBjb2RlL2csIFwiZXZhbFwiKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCBcIlwiKSA6IGYpLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csIFwiKFwiKSwgcyA9IHIubWF0Y2goLyAoXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJCkvKSwgciA9IChyID0gcyA/IHIucmVwbGFjZShzWzBdLCBcIlwiKSA6IHIpLnNwbGl0KC9cXHMrLykuc2xpY2UoMSksIHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihzID8gc1sxXSA6IHIucG9wKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnVuY3Rpb25OYW1lOiByLmpvaW4oXCIgXCIpIHx8IHZvaWQgMCwgZmlsZU5hbWU6IC0xIDwgW1wiZXZhbFwiLCBcIjxhbm9ueW1vdXM+XCJdLmluZGV4T2Yoc1swXSkgPyB2b2lkIDAgOiBzWzBdLCBsaW5lTnVtYmVyOiBzWzFdLCBjb2x1bW5OdW1iZXI6IHNbMl0sIHNvdXJjZTogZiB9O1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICByZXR1cm4gZy5zdGFjay5zcGxpdChgXG5gKS5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuICFmLm1hdGNoKGgpO1xuICAgICAgICAgIH0sIHRoaXMpLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICB2YXIgciwgcztcbiAgICAgICAgICAgIHJldHVybiAoZiA9IC0xIDwgZi5pbmRleE9mKFwiID4gZXZhbFwiKSA/IGYucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csIFwiOiQxXCIpIDogZikuaW5kZXhPZihcIkBcIikgPT09IC0xICYmIGYuaW5kZXhPZihcIjpcIikgPT09IC0xID8geyBmdW5jdGlvbk5hbWU6IGYgfSA6IHsgZnVuY3Rpb25OYW1lOiAocyA9IGYubWF0Y2gociA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLykpICYmIHNbMV0gPyBzWzFdIDogdm9pZCAwLCBmaWxlTmFtZTogKHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihmLnJlcGxhY2UociwgXCJcIikpKVswXSwgbGluZU51bWJlcjogc1sxXSwgY29sdW1uTnVtYmVyOiBzWzJdLCBzb3VyY2U6IGYgfTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgcGFyc2VPcGVyYTogZnVuY3Rpb24oZykge1xuICAgICAgICAgIHJldHVybiAhZy5zdGFja3RyYWNlIHx8IC0xIDwgZy5tZXNzYWdlLmluZGV4T2YoYFxuYCkgJiYgZy5tZXNzYWdlLnNwbGl0KGBcbmApLmxlbmd0aCA+IGcuc3RhY2t0cmFjZS5zcGxpdChgXG5gKS5sZW5ndGggPyB0aGlzLnBhcnNlT3BlcmE5KGcpIDogZy5zdGFjayA/IHRoaXMucGFyc2VPcGVyYTExKGcpIDogdGhpcy5wYXJzZU9wZXJhMTAoZyk7XG4gICAgICAgIH0sIHBhcnNlT3BlcmE5OiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgZm9yICh2YXIgZiA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2ksIHIgPSBnLm1lc3NhZ2Uuc3BsaXQoYFxuYCksIHMgPSBbXSwgbyA9IDIsIGkgPSByLmxlbmd0aDsgbyA8IGk7IG8gKz0gMikge1xuICAgICAgICAgICAgdmFyIGwgPSBmLmV4ZWMocltvXSk7XG4gICAgICAgICAgICBsICYmIHMucHVzaCh7IGZpbGVOYW1lOiBsWzJdLCBsaW5lTnVtYmVyOiBsWzFdLCBzb3VyY2U6IHJbb10gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBwYXJzZU9wZXJhMTA6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICBmb3IgKHZhciBmID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pLCByID0gZy5zdGFja3RyYWNlLnNwbGl0KGBcbmApLCBzID0gW10sIG8gPSAwLCBpID0gci5sZW5ndGg7IG8gPCBpOyBvICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBsID0gZi5leGVjKHJbb10pO1xuICAgICAgICAgICAgbCAmJiBzLnB1c2goeyBmdW5jdGlvbk5hbWU6IGxbM10gfHwgdm9pZCAwLCBmaWxlTmFtZTogbFsyXSwgbGluZU51bWJlcjogbFsxXSwgc291cmNlOiByW29dIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgcGFyc2VPcGVyYTExOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcuc3RhY2suc3BsaXQoYFxuYCkuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWYubWF0Y2goeSkgJiYgIWYubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICAgICAgfSwgdGhpcykubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHZhciByLCBvID0gZi5zcGxpdChcIkBcIiksIHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihvLnBvcCgpKSwgbyA9IG8uc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnVuY3Rpb25OYW1lOiBvLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCBcIiQyXCIpLnJlcGxhY2UoL1xcKFteKV0qXFwpL2csIFwiXCIpIHx8IHZvaWQgMCwgYXJnczogKHIgPSBvLm1hdGNoKC9cXCgoW14pXSopXFwpLykgPyBvLnJlcGxhY2UoL15bXihdK1xcKChbXildKilcXCkkLywgXCIkMVwiKSA6IHIpID09PSB2b2lkIDAgfHwgciA9PT0gXCJbYXJndW1lbnRzIG5vdCBhdmFpbGFibGVdXCIgPyB2b2lkIDAgOiByLnNwbGl0KFwiLFwiKSwgZmlsZU5hbWU6IHNbMF0sIGxpbmVOdW1iZXI6IHNbMV0sIGNvbHVtbk51bWJlcjogc1syXSwgc291cmNlOiBmIH07XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gfTtcbiAgICAgIH1cbiAgICAgIHQuZGVmYXVsdC5fZ2V0RXJyb3JTdGFja1BhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IG0oKTtcbiAgICAgIH0sIHQgPSB0LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCI6IDE5OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIjogMjAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzIH1dLCAyNzU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGcpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgZjtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBmLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZjtcbiAgICAgICAgfSkoZyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgeSA9ICh5ID0gdChcIi4uL21haW5cIikpICYmIHkuX19lc01vZHVsZSA/IHkgOiB7IGRlZmF1bHQ6IHkgfTtcbiAgICAgIChmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmICghKGcgJiYgZy5fX2VzTW9kdWxlKSAmJiAhKGcgPT09IG51bGwgfHwgaChnKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZyAhPSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFyIGYgPSB1KCk7XG4gICAgICAgICAgaWYgKGYgJiYgZi5oYXMoZykpXG4gICAgICAgICAgICByZXR1cm4gZi5nZXQoZyk7XG4gICAgICAgICAgdmFyIHIsIHMgPSB7fSwgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICAgIGZvciAociBpbiBnKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnLCByKSAmJiAoKGkgPSBvID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnLCByKSA6IG51bGwpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgaSkgOiBzW3JdID0gZ1tyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMuZGVmYXVsdCA9IGcsIGYgJiYgZi5zZXQoZywgcyk7XG4gICAgICAgIH1cbiAgICAgIH0pKHQoXCIuLi9jb25zdGFudHNcIikpLCB0KFwiLi4vaW50ZXJuYXRpb25hbGl6YXRpb25cIik7XG4gICAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgICB2YXIgZztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAoZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIH0sIGcpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaChnKSB7XG4gICAgICAgIHJldHVybiAoaCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gbShmKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBmLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKGYpO1xuICAgICAgICB9KShnKTtcbiAgICAgIH1cbiAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzID0geS5kZWZhdWx0Ll9jbGVhclZhbGlkYXRlUGFyYW1zQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIH0sIHQgPSB5LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uLy4uLy4uL2RvY3MvcGFyYW1ldGVyRGF0YS5qc29uXCI6IHZvaWQgMCwgXCIuLi9jb25zdGFudHNcIjogMjY5LCBcIi4uL2ludGVybmF0aW9uYWxpemF0aW9uXCI6IDI3OCwgXCIuLi9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCI6IDE1MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIjogMTYwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCI6IDE2MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCI6IDE2NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubGFzdC1pbmRleC1vZlwiOiAxNjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiOiAxNzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiOiAxNzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiOiAxNzgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiOiAxODUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCI6IDE4NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0XCI6IDE4OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCI6IDE5NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCI6IDE5NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI3NjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oZykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBmO1xuICAgICAgICB9IDogZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGYuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBmICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBmO1xuICAgICAgICB9KShnKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoZykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuIG0oZik7XG4gICAgICAgIH0gOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuIGYgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgZi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGYgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShmKTtcbiAgICAgICAgfSkoZyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmIChnICYmIGcuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgaWYgKGcgPT09IG51bGwgfHwgeShnKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogZyB9O1xuICAgICAgICB2YXIgZiA9IGgoKTtcbiAgICAgICAgaWYgKGYgJiYgZi5oYXMoZykpXG4gICAgICAgICAgcmV0dXJuIGYuZ2V0KGcpO1xuICAgICAgICB2YXIgciwgcyA9IHt9LCBvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAociBpbiBnKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGcsIHIpICYmICgoaSA9IG8gPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGcsIHIpIDogbnVsbCkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCByLCBpKSA6IHNbcl0gPSBnW3JdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcy5kZWZhdWx0ID0gZywgZiAmJiBmLnNldChnLCBzKSwgcztcbiAgICAgIH0odChcIi4vY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHZhciBnO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChnID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgfSwgZyk7XG4gICAgICB9XG4gICAgICBDLmRlZmF1bHQgPSB7IG1vZGVBZGp1c3Q6IGZ1bmN0aW9uKGcsIGYsIHIsIHMsIG8pIHtcbiAgICAgICAgcmV0dXJuIG8gPT09IHUuQ09STkVSID8geyB4OiBnLCB5OiBmLCB3OiByLCBoOiBzIH0gOiBvID09PSB1LkNPUk5FUlMgPyB7IHg6IGcsIHk6IGYsIHc6IHIgLSBnLCBoOiBzIC0gZiB9IDogbyA9PT0gdS5SQURJVVMgPyB7IHg6IGcgLSByLCB5OiBmIC0gcywgdzogMiAqIHIsIGg6IDIgKiBzIH0gOiBvID09PSB1LkNFTlRFUiA/IHsgeDogZyAtIDAuNSAqIHIsIHk6IGYgLSAwLjUgKiBzLCB3OiByLCBoOiBzIH0gOiB2b2lkIDA7XG4gICAgICB9IH07XG4gICAgfSwgeyBcIi4vY29uc3RhbnRzXCI6IDI2OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI3NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKTtcbiAgICAgIHZhciBtID0gKHkgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB5Ll9fZXNNb2R1bGUgPyB5IDogeyBkZWZhdWx0OiB5IH07XG4gICAgICB0KFwiLi9pbnRlcm5hdGlvbmFsaXphdGlvblwiKTtcbiAgICAgIHZhciB5ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoZnVuY3Rpb24odSwgaCkge1xuICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgPyB1KCkgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdSwgITEpO1xuICAgICAgfSksIHldKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuX3NldHVwRG9uZSAhPT0gdm9pZCAwID8gY29uc29sZS53YXJuKFwicDUuanMgc2VlbXMgdG8gaGF2ZSBiZWVuIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzLiBQbGVhc2UgcmVtb3ZlIHRoZSBkdXBsaWNhdGUgaW1wb3J0XCIpIDogd2luZG93Lm1vY2hhIHx8ICh3aW5kb3cuc2V0dXAgJiYgdHlwZW9mIHdpbmRvdy5zZXR1cCA9PSBcImZ1bmN0aW9uXCIgfHwgd2luZG93LmRyYXcgJiYgdHlwZW9mIHdpbmRvdy5kcmF3ID09IFwiZnVuY3Rpb25cIikgJiYgIW0uZGVmYXVsdC5pbnN0YW5jZSAmJiBuZXcgbS5kZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuL2ludGVybmF0aW9uYWxpemF0aW9uXCI6IDI3OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiOiAxODgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyNzg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5zZXRUcmFuc2xhdG9yTGFuZ3VhZ2UgPSBDLmN1cnJlbnRUcmFuc2xhdG9yTGFuZ3VhZ2UgPSBDLmF2YWlsYWJsZVRyYW5zbGF0b3JMYW5ndWFnZXMgPSBDLmluaXRpYWxpemUgPSBDLnRyYW5zbGF0b3IgPSB2b2lkIDA7XG4gICAgICB2YXIgbSwgeSwgdSA9IGcodChcImkxOG5leHRcIikpLCBoID0gZyh0KFwiaTE4bmV4dC1icm93c2VyLWxhbmd1YWdlZGV0ZWN0b3JcIikpO1xuICAgICAgZnVuY3Rpb24gZyhzKSB7XG4gICAgICAgIHJldHVybiBzICYmIHMuX19lc01vZHVsZSA/IHMgOiB7IGRlZmF1bHQ6IHMgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYocywgbykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbCA9IG9baV07XG4gICAgICAgICAgbC5lbnVtZXJhYmxlID0gbC5lbnVtZXJhYmxlIHx8ICExLCBsLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbCAmJiAobC53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIGwua2V5LCBsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gcyhsLCBuKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLmluaXQobCwgbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG8sIGk7XG4gICAgICAgIHJldHVybiBvID0gcywgKGkgPSBbeyBrZXk6IFwiZmV0Y2hXaXRoVGltZW91dFwiLCB2YWx1ZTogZnVuY3Rpb24obCwgbikge1xuICAgICAgICAgIHZhciBhID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAyZTM7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZmV0Y2gobCwgbiksIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGMsIHApIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgIH0sIGEpO1xuICAgICAgICAgIH0pXSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaW5pdFwiLCB2YWx1ZTogZnVuY3Rpb24obCkge1xuICAgICAgICAgIHZhciBuID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgICB0aGlzLnNlcnZpY2VzID0gbCwgdGhpcy5vcHRpb25zID0gbjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZWFkXCIsIHZhbHVlOiBmdW5jdGlvbihsLCBuLCBhKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMubG9hZFBhdGg7XG4gICAgICAgICAgbCA9PT0gdGhpcy5vcHRpb25zLmZhbGxiYWNrID8gYShudWxsLCBtW2xdW25dKSA6IHkuaW5jbHVkZXMobCkgPyAoYyA9IHRoaXMuc2VydmljZXMuaW50ZXJwb2xhdG9yLmludGVycG9sYXRlKGMsIHsgbG5nOiBsLCBuczogbiB9KSwgdGhpcy5sb2FkVXJsKGMsIGEpKSA6IGEoXCJOb3QgZm91bmRcIiwgITEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxvYWRVcmxcIiwgdmFsdWU6IGZ1bmN0aW9uKGwsIG4pIHtcbiAgICAgICAgICB0aGlzLmZldGNoV2l0aFRpbWVvdXQobCkudGhlbihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICBpZiAoYS5vaylcbiAgICAgICAgICAgICAgcmV0dXJuIGEuanNvbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIGxvYWRpbmcgXCIuY29uY2F0KGwpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCBsb2FkaW5nIFwiLmNvbmNhdChsKSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gbihudWxsLCBhKTtcbiAgICAgICAgICB9KS5jYXRjaChuKTtcbiAgICAgICAgfSB9XSkgJiYgZihvLnByb3RvdHlwZSwgaSksIHM7XG4gICAgICB9KCk7XG4gICAgICByLnR5cGUgPSBcImJhY2tlbmRcIiwgQy50cmFuc2xhdG9yID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwicDUuanMgdHJhbnNsYXRvciBjYWxsZWQgYmVmb3JlIHRyYW5zbGF0aW9ucyB3ZXJlIGxvYWRlZFwiKSwgdS5kZWZhdWx0LnQocywgbyk7XG4gICAgICB9LCBDLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC51c2UoaC5kZWZhdWx0KS51c2UocikuaW5pdCh7IGZhbGxiYWNrTG5nOiBcImVuXCIsIG5lc3RpbmdQcmVmaXg6IFwiJHRyKFwiLCBuZXN0aW5nU3VmZml4OiBcIilcIiwgZGVmYXVsdE5TOiBcInRyYW5zbGF0aW9uXCIsIHJldHVybkVtcHR5U3RyaW5nOiAhMSwgaW50ZXJwb2xhdGlvbjogeyBlc2NhcGVWYWx1ZTogITEgfSwgZGV0ZWN0aW9uOiB7IGNoZWNrV2hpdGVsaXN0OiAhMSwgb3JkZXI6IFtcInF1ZXJ5c3RyaW5nXCIsIFwibmF2aWdhdG9yXCIsIFwiaHRtbFRhZ1wiLCBcInBhdGhcIiwgXCJzdWJkb21haW5cIl0sIGNhY2hlczogW10gfSwgYmFja2VuZDogeyBmYWxsYmFjazogXCJlblwiLCBsb2FkUGF0aDogXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL3A1L3RyYW5zbGF0aW9ucy97e2xuZ319L3t7bnN9fS5qc29uXCIgfSwgcGFydGlhbEJ1bmRsZWRMYW5ndWFnZXM6ICEwLCByZXNvdXJjZXM6IG0gfSkudGhlbihmdW5jdGlvbihzKSB7XG4gICAgICAgICAgQy50cmFuc2xhdG9yID0gcztcbiAgICAgICAgfSwgZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmRlYnVnKFwiVHJhbnNsYXRpb25zIGZhaWxlZCB0byBsb2FkIChcIi5jb25jYXQocywgXCIpXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBDLmF2YWlsYWJsZVRyYW5zbGF0b3JMYW5ndWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5sYW5ndWFnZXM7XG4gICAgICB9LCBDLmN1cnJlbnRUcmFuc2xhdG9yTGFuZ3VhZ2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB1LmRlZmF1bHQubGFuZ3VhZ2U7XG4gICAgICB9LCBDLnNldFRyYW5zbGF0b3JMYW5ndWFnZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5jaGFuZ2VMYW5ndWFnZShzIHx8IHZvaWQgMCwgZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmRlYnVnKFwiVHJhbnNsYXRpb25zIGZhaWxlZCB0byBsb2FkIChcIi5jb25jYXQobywgXCIpXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIHsgXCIuLi8uLi90cmFuc2xhdGlvbnNcIjogdm9pZCAwLCBcIi4uLy4uL3RyYW5zbGF0aW9ucy9kZXZcIjogdm9pZCAwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiOiAxNjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIjogMTg2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiOiAxODgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCI6IDE5NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMsIGkxOG5leHQ6IDMsIFwiaTE4bmV4dC1icm93c2VyLWxhbmd1YWdlZGV0ZWN0b3JcIjogMyB9XSwgMjc5OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwLCB0ID0gKHQgPSB0KFwiLi9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH0sIHQuZGVmYXVsdC5wcm90b3R5cGUucHVzaFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInB1c2hTdHlsZSgpIG5vdCB1c2VkLCBzZWUgcHVzaCgpXCIpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5wb3BTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3BTdHlsZSgpIG5vdCB1c2VkLCBzZWUgcG9wKClcIik7XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLnBvcE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3BNYXRyaXgoKSBub3QgdXNlZCwgc2VlIHBvcCgpXCIpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5wdXNoTWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInB1c2hNYXRyaXgoKSBub3QgdXNlZCwgc2VlIHB1c2goKVwiKTtcbiAgICAgIH0sIHQgPSB0LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4vbWFpblwiOiAyODAgfV0sIDI4MDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvO1xuICAgICAgICB9IDogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBvICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICAgICAgICB9KShzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG0obyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShvKTtcbiAgICAgICAgfSkocyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQoXCIuL3NoaW1cIik7XG4gICAgICB2YXIgdSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCB5KHMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBzIH07XG4gICAgICAgIHZhciBvID0gaCgpO1xuICAgICAgICBpZiAobyAmJiBvLmhhcyhzKSlcbiAgICAgICAgICByZXR1cm4gby5nZXQocyk7XG4gICAgICAgIHZhciBpLCBsID0ge30sIG4gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChpIGluIHMpIHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgaSkgJiYgKChhID0gbiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocywgaSkgOiBudWxsKSAmJiAoYS5nZXQgfHwgYS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGksIGEpIDogbFtpXSA9IHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsLmRlZmF1bHQgPSBzLCBvICYmIG8uc2V0KHMsIGwpLCBsO1xuICAgICAgfSh0KFwiLi9jb25zdGFudHNcIikpO1xuICAgICAgZnVuY3Rpb24gaCgpIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGcocywgbykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbCA9IG9baV07XG4gICAgICAgICAgbC5lbnVtZXJhYmxlID0gbC5lbnVtZXJhYmxlIHx8ICExLCBsLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbCAmJiAobC53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIGwua2V5LCBsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGYsIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gcyhsLCBjKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5fc2V0dXBEb25lID0gITEsIHRoaXMuX3ByZWxvYWREb25lID0gITEsIHRoaXMuX3BpeGVsRGVuc2l0eSA9IE1hdGguY2VpbCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMSwgdGhpcy5fbWF4QWxsb3dlZFBpeGVsRGltZW5zaW9ucyA9IDAsIHRoaXMuX3VzZXJOb2RlID0gYywgdGhpcy5fY3VyRWxlbWVudCA9IG51bGwsIHRoaXMuX2VsZW1lbnRzID0gW10sIHRoaXMuX2dsQXR0cmlidXRlcyA9IG51bGwsIHRoaXMuX3JlcXVlc3RBbmltSWQgPSAwLCB0aGlzLl9wcmVsb2FkQ291bnQgPSAwLCB0aGlzLl9pc0dsb2JhbCA9ICExLCB0aGlzLl9sb29wID0gITAsIHRoaXMuX3N0YXJ0TGlzdGVuZXIgPSBudWxsLCB0aGlzLl9pbml0aWFsaXplSW5zdGFuY2VWYXJpYWJsZXMoKSwgdGhpcy5fZGVmYXVsdENhbnZhc1NpemUgPSB7IHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH0sIHRoaXMuX2V2ZW50cyA9IHsgbW91c2Vtb3ZlOiBudWxsLCBtb3VzZWRvd246IG51bGwsIG1vdXNldXA6IG51bGwsIGRyYWdlbmQ6IG51bGwsIGRyYWdvdmVyOiBudWxsLCBjbGljazogbnVsbCwgZGJsY2xpY2s6IG51bGwsIG1vdXNlb3ZlcjogbnVsbCwgbW91c2VvdXQ6IG51bGwsIGtleWRvd246IG51bGwsIGtleXVwOiBudWxsLCBrZXlwcmVzczogbnVsbCwgdG91Y2hzdGFydDogbnVsbCwgdG91Y2htb3ZlOiBudWxsLCB0b3VjaGVuZDogbnVsbCwgcmVzaXplOiBudWxsLCBibHVyOiBudWxsIH0sIHRoaXMuX21pbGxpc1N0YXJ0ID0gLTEsIHRoaXMuX3JlY29yZGluZyA9ICExLCB0aGlzLnRvdWNoc3RhcnQgPSAhMSwgdGhpcy50b3VjaGVuZCA9ICExLCB0aGlzLl9sY2dfcmFuZG9tX3N0YXRlID0gbnVsbCwgdGhpcy5fZ2F1c3NpYW5fcHJldmlvdXMgPSAhMSwgdGhpcy5fZXZlbnRzLndoZWVsID0gbnVsbCwgdGhpcy5fbG9hZGluZ1NjcmVlbklkID0gXCJwNV9sb2FkaW5nXCIsIHRoaXMuX3JlZ2lzdGVyZWRNZXRob2RzID0ge307XG4gICAgICAgICAgdmFyIGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzLnByb3RvdHlwZS5fcmVnaXN0ZXJlZE1ldGhvZHMpLCBwID0gITAsIGogPSAhMSwgVCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgXywgUyA9IGNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKHAgPSAoXyA9IFMubmV4dCgpKS5kb25lKTsgcCA9ICEwKSB7XG4gICAgICAgICAgICAgIHZhciBFID0gXy52YWx1ZTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZE1ldGhvZHNbRV0gPSBzLnByb3RvdHlwZS5fcmVnaXN0ZXJlZE1ldGhvZHNbRV0uc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChHKSB7XG4gICAgICAgICAgICBqID0gITAsIFQgPSBHO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwIHx8IFMucmV0dXJuID09IG51bGwgfHwgUy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChqKVxuICAgICAgICAgICAgICAgIHRocm93IFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbmRvdy5EZXZpY2VPcmllbnRhdGlvbkV2ZW50ICYmICh0aGlzLl9ldmVudHMuZGV2aWNlb3JpZW50YXRpb24gPSBudWxsKSwgd2luZG93LkRldmljZU1vdGlvbkV2ZW50ICYmICF3aW5kb3cuX2lzTm9kZVdlYmtpdCAmJiAodGhpcy5fZXZlbnRzLmRldmljZW1vdGlvbiA9IG51bGwpLCBzLnByb3RvdHlwZS5jYWxsUmVnaXN0ZXJlZEhvb2tzRm9yID0gZnVuY3Rpb24oRykge1xuICAgICAgICAgICAgdmFyIFUgPSB0aGlzIHx8IHMucHJvdG90eXBlLCBXID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzO1xuICAgICAgICAgICAgaWYgKFUuX3JlZ2lzdGVyZWRNZXRob2RzLmhhc093blByb3BlcnR5KEcpKSB7XG4gICAgICAgICAgICAgIHZhciBVID0gVS5fcmVnaXN0ZXJlZE1ldGhvZHNbR10sIFggPSAhMCwgRyA9ICExLCBuZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiLCBPID0gVVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoWCA9IChiID0gTy5uZXh0KCkpLmRvbmUpOyBYID0gITApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBEID0gYi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBEID09IFwiZnVuY3Rpb25cIiAmJiBELmNhbGwoVyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChKKSB7XG4gICAgICAgICAgICAgICAgRyA9ICEwLCBuZSA9IEo7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIFggfHwgTy5yZXR1cm4gPT0gbnVsbCB8fCBPLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoRylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5fc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGEuX3VzZXJOb2RlICYmIHR5cGVvZiBhLl91c2VyTm9kZSA9PSBcInN0cmluZ1wiICYmIChhLl91c2VyTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEuX3VzZXJOb2RlKSk7XG4gICAgICAgICAgICB2YXIgRyA9IGEuX2lzR2xvYmFsID8gd2luZG93IDogYTtcbiAgICAgICAgICAgIGlmIChHLnByZWxvYWQpIHtcbiAgICAgICAgICAgICAgYS5jYWxsUmVnaXN0ZXJlZEhvb2tzRm9yKFwiYmVmb3JlUHJlbG9hZFwiKTtcbiAgICAgICAgICAgICAgdmFyIFUsIFcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhLl9sb2FkaW5nU2NyZWVuSWQpLCBYID0gKFcgfHwgKChXID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuaW5uZXJIVE1MID0gXCJMb2FkaW5nLi4uXCIsIFcuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIFcuaWQgPSBhLl9sb2FkaW5nU2NyZWVuSWQsIChhLl91c2VyTm9kZSB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChXKSksIGEuX3ByZWxvYWRNZXRob2RzKTtcbiAgICAgICAgICAgICAgZm9yIChVIGluIFgpIHtcbiAgICAgICAgICAgICAgICBYW1VdID0gWFtVXSB8fCBzO1xuICAgICAgICAgICAgICAgIHZhciBuZSA9IFhbVV07XG4gICAgICAgICAgICAgICAgbmUgIT09IHMucHJvdG90eXBlICYmIG5lICE9PSBzIHx8IChhLl9pc0dsb2JhbCAmJiAod2luZG93W1VdID0gYS5fd3JhcFByZWxvYWQoYSwgVSkpLCBuZSA9IGEpLCBhLl9yZWdpc3RlcmVkUHJlbG9hZE1ldGhvZHNbVV0gPSBuZVtVXSwgbmVbVV0gPSBhLl93cmFwUHJlbG9hZChuZSwgVSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgRy5wcmVsb2FkKCksIGEuX3J1bklmUHJlbG9hZHNBcmVEb25lKCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgYS5fc2V0dXAoKSwgYS5fcmVjb3JkaW5nIHx8IGEuX2RyYXcoKTtcbiAgICAgICAgICB9LCB0aGlzLl9ydW5JZlByZWxvYWRzQXJlRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIEcsIFUgPSB0aGlzLl9pc0dsb2JhbCA/IHdpbmRvdyA6IHRoaXM7XG4gICAgICAgICAgICBVLl9wcmVsb2FkQ291bnQgPT09IDAgJiYgKChHID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVS5fbG9hZGluZ1NjcmVlbklkKSkgJiYgRy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEcpLCB0aGlzLmNhbGxSZWdpc3RlcmVkSG9va3NGb3IoXCJhZnRlclByZWxvYWRcIiksIHRoaXMuX3NldHVwRG9uZSB8fCAodGhpcy5fbGFzdFRhcmdldEZyYW1lVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSwgdGhpcy5fbGFzdFJlYWxGcmFtZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIFUuX3NldHVwKCksIHRoaXMuX3JlY29yZGluZyB8fCBVLl9kcmF3KCkpKTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWNyZW1lbnRQcmVsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgRyA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgICAgIEcuX3ByZWxvYWREb25lIHx8IHR5cGVvZiBHLnByZWxvYWQgIT0gXCJmdW5jdGlvblwiIHx8IChHLl9zZXRQcm9wZXJ0eShcIl9wcmVsb2FkQ291bnRcIiwgRy5fcHJlbG9hZENvdW50IC0gMSksIEcuX3J1bklmUHJlbG9hZHNBcmVEb25lKCkpO1xuICAgICAgICAgIH0sIHRoaXMuX3dyYXBQcmVsb2FkID0gZnVuY3Rpb24oRywgVSkge1xuICAgICAgICAgICAgdmFyIFcgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBXLl9pbmNyZW1lbnRQcmVsb2FkKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIFggPSBhcmd1bWVudHMubGVuZ3RoLCBuZSA9IG5ldyBBcnJheShYKSwgYiA9IDA7IGIgPCBYOyBiKyspXG4gICAgICAgICAgICAgICAgbmVbYl0gPSBhcmd1bWVudHNbYl07XG4gICAgICAgICAgICAgIHJldHVybiBXLl9yZWdpc3RlcmVkUHJlbG9hZE1ldGhvZHNbVV0uYXBwbHkoRywgbmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCB0aGlzLl9pbmNyZW1lbnRQcmVsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgRyA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgICAgIEcuX3ByZWxvYWREb25lIHx8IEcuX3NldFByb3BlcnR5KFwiX3ByZWxvYWRDb3VudFwiLCBHLl9wcmVsb2FkQ291bnQgKyAxKTtcbiAgICAgICAgICB9LCB0aGlzLl9zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYS5jYWxsUmVnaXN0ZXJlZEhvb2tzRm9yKFwiYmVmb3JlU2V0dXBcIiksIGEuY3JlYXRlQ2FudmFzKGEuX2RlZmF1bHRDYW52YXNTaXplLndpZHRoLCBhLl9kZWZhdWx0Q2FudmFzU2l6ZS5oZWlnaHQsIFwicDJkXCIpO1xuICAgICAgICAgICAgdmFyIEcgPSBhLl9pc0dsb2JhbCA/IHdpbmRvdyA6IGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEcucHJlbG9hZCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgIGZvciAodmFyIFUgaW4gYS5fcHJlbG9hZE1ldGhvZHMpXG4gICAgICAgICAgICAgICAgR1tVXSA9IGEuX3ByZWxvYWRNZXRob2RzW1VdW1VdLCBHW1VdICYmIGEgJiYgKEdbVV0gPSBHW1VdLmJpbmQoYSkpO1xuICAgICAgICAgICAgYS5fbWlsbGlzU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIEcuX3ByZWxvYWREb25lID0gITAsIHR5cGVvZiBHLnNldHVwID09IFwiZnVuY3Rpb25cIiAmJiBHLnNldHVwKCk7XG4gICAgICAgICAgICB2YXIgVyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FudmFzXCIpLCBYID0gITAsIG5lID0gITEsIGIgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBPLCBEID0gV1tTeW1ib2wuaXRlcmF0b3JdKCk7ICEoWCA9IChPID0gRC5uZXh0KCkpLmRvbmUpOyBYID0gITApIHtcbiAgICAgICAgICAgICAgICB2YXIgQiA9IE8udmFsdWU7XG4gICAgICAgICAgICAgICAgQi5kYXRhc2V0LmhpZGRlbiA9PT0gXCJ0cnVlXCIgJiYgKEIuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCIsIGRlbGV0ZSBCLmRhdGFzZXQuaGlkZGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoWSkge1xuICAgICAgICAgICAgICBuZSA9ICEwLCBiID0gWTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgWCB8fCBELnJldHVybiA9PSBudWxsIHx8IEQucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgYjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS5fbGFzdFRhcmdldEZyYW1lVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSwgYS5fbGFzdFJlYWxGcmFtZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIGEuX3NldHVwRG9uZSA9ICEwLCAoYS5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZCB8fCBhLl9hY2Nlc3NpYmxlT3V0cHV0cy50ZXh0KSAmJiBhLl91cGRhdGVBY2NzT3V0cHV0KCksIGEuY2FsbFJlZ2lzdGVyZWRIb29rc0ZvcihcImFmdGVyU2V0dXBcIik7XG4gICAgICAgICAgfSwgdGhpcy5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIEcgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIFUgPSBHIC0gYS5fbGFzdFRhcmdldEZyYW1lVGltZSwgVyA9IDFlMyAvIGEuX3RhcmdldEZyYW1lUmF0ZTtcbiAgICAgICAgICAgICghYS5fbG9vcCB8fCBXIC0gNSA8PSBVKSAmJiAoYS5kZWx0YVRpbWUgPSBHIC0gYS5fbGFzdFJlYWxGcmFtZVRpbWUsIGEuX3NldFByb3BlcnR5KFwiZGVsdGFUaW1lXCIsIGEuZGVsdGFUaW1lKSwgYS5fZnJhbWVSYXRlID0gMWUzIC8gYS5kZWx0YVRpbWUsIGEucmVkcmF3KCksIGEuX2xhc3RUYXJnZXRGcmFtZVRpbWUgPSBNYXRoLm1heChhLl9sYXN0VGFyZ2V0RnJhbWVUaW1lICsgVywgRyksIGEuX2xhc3RSZWFsRnJhbWVUaW1lID0gRywgYS5fdXBkYXRlTW91c2VDb29yZHMgIT09IHZvaWQgMCAmJiAoYS5fdXBkYXRlTW91c2VDb29yZHMoKSwgYS5fc2V0UHJvcGVydHkoXCJtb3ZlZFhcIiwgMCksIGEuX3NldFByb3BlcnR5KFwibW92ZWRZXCIsIDApKSksIGEuX2xvb3AgJiYgKGEuX3JlcXVlc3RBbmltSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEuX2RyYXcpKTtcbiAgICAgICAgICB9LCB0aGlzLl9zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKEcsIFUpIHtcbiAgICAgICAgICAgIGFbR10gPSBVLCBhLl9pc0dsb2JhbCAmJiAod2luZG93W0ddID0gVSk7XG4gICAgICAgICAgfSwgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGEuX3N0YXJ0TGlzdGVuZXIgJiYgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGEuX3N0YXJ0TGlzdGVuZXIsICExKTtcbiAgICAgICAgICAgIHZhciBHID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYS5fbG9hZGluZ1NjcmVlbklkKTtcbiAgICAgICAgICAgIGlmIChHICYmIChHLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoRyksIGEuX2luY3JlbWVudFByZWxvYWQoKSksIGEuX2N1ckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgVSBpbiBhLl9sb29wID0gITEsIGEuX3JlcXVlc3RBbmltSWQgJiYgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGEuX3JlcXVlc3RBbmltSWQpLCBhLl9ldmVudHMpXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoVSwgYS5fZXZlbnRzW1VdKTtcbiAgICAgICAgICAgICAgdmFyIFcgPSAhMCwgRyA9ICExLCBYID0gdm9pZCAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5lLCBiID0gYS5fZWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKFcgPSAobmUgPSBiLm5leHQoKSkuZG9uZSk7IFcgPSAhMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIE8sIEQgPSBuZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGZvciAoTyBpbiBELmVsdCAmJiBELmVsdC5wYXJlbnROb2RlICYmIEQuZWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoRC5lbHQpLCBELl9ldmVudHMpXG4gICAgICAgICAgICAgICAgICAgIEQuZWx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoTywgRC5fZXZlbnRzW09dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGNlKSB7XG4gICAgICAgICAgICAgICAgRyA9ICEwLCBYID0gY2U7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIFcgfHwgYi5yZXR1cm4gPT0gbnVsbCB8fCBiLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoRylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIEIgPSBhO1xuICAgICAgICAgICAgICBhLl9yZWdpc3RlcmVkTWV0aG9kcy5yZW1vdmUuZm9yRWFjaChmdW5jdGlvbihjZSkge1xuICAgICAgICAgICAgICAgIGNlICE9PSB2b2lkIDAgJiYgY2UuY2FsbChCKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS5faXNHbG9iYWwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgWSBpbiBzLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tZXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd1tZXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIEogaW4gYSlcbiAgICAgICAgICAgICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShKKSlcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbSl07XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93W0pdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzLl9yZWdpc3RlcmVkTWV0aG9kcy5pbml0LmZvckVhY2goZnVuY3Rpb24oRykge1xuICAgICAgICAgICAgRyAhPT0gdm9pZCAwICYmIEcuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5fc2V0dXBQcm9taXNlUHJlbG9hZHMoKTtcbiAgICAgICAgICB2YXIgQSwgeCwgUCA9IHRoaXMuX2NyZWF0ZUZyaWVuZGx5R2xvYmFsRnVuY3Rpb25CaW5kZXIoKTtcbiAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgIGwodGhpcyksIHMuX2NoZWNrRm9yVXNlckRlZmluZWRGdW5jdGlvbnModGhpcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBNIGluIHRoaXMuX2lzR2xvYmFsID0gITAsIHMuaW5zdGFuY2UgPSB0aGlzLCBzLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgdHlwZW9mIHMucHJvdG90eXBlW01dID09IFwiZnVuY3Rpb25cIiA/IChBID0gTS5zdWJzdHJpbmcoMiksIHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShBKSB8fCAoTWF0aC5oYXNPd25Qcm9wZXJ0eShNKSAmJiBNYXRoW01dID09PSBzLnByb3RvdHlwZVtNXSA/IFAoTSwgcy5wcm90b3R5cGVbTV0pIDogUChNLCBzLnByb3RvdHlwZVtNXS5iaW5kKHRoaXMpKSkpIDogUChNLCBzLnByb3RvdHlwZVtNXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBSIGluIHRoaXMpXG4gICAgICAgICAgICAgIHRoaXMuaGFzT3duUHJvcGVydHkoUikgJiYgUChSLCB0aGlzW1JdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh4IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdmFyIEwgPSB0aGlzW1wiX29uXCIuY29uY2F0KHgpXTtcbiAgICAgICAgICAgIEwgJiYgKEwgPSBMLmJpbmQodGhpcyksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHgsIEwsIHsgcGFzc2l2ZTogITEgfSksIHRoaXMuX2V2ZW50c1t4XSA9IEwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgICAgICAgYS5fc2V0UHJvcGVydHkoXCJmb2N1c2VkXCIsICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVigpIHtcbiAgICAgICAgICAgIGEuX3NldFByb3BlcnR5KFwiZm9jdXNlZFwiLCAhMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgRiksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBWKSwgdGhpcy5yZWdpc3Rlck1ldGhvZChcInJlbW92ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgRiksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBWKTtcbiAgICAgICAgICB9KSwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiID8gdGhpcy5fc3RhcnQoKSA6ICh0aGlzLl9zdGFydExpc3RlbmVyID0gdGhpcy5fc3RhcnQuYmluZCh0aGlzKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX3N0YXJ0TGlzdGVuZXIsICExKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG8sIGk7XG4gICAgICAgIHJldHVybiBvID0gcywgKGkgPSBbeyBrZXk6IFwiX2luaXRpYWxpemVJbnN0YW5jZVZhcmlhYmxlc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMgPSB7IHRleHQ6ICExLCBncmlkOiAhMSwgdGV4dExhYmVsOiAhMSwgZ3JpZExhYmVsOiAhMSB9LCB0aGlzLl9zdHlsZXMgPSBbXSwgdGhpcy5fYmV6aWVyRGV0YWlsID0gMjAsIHRoaXMuX2N1cnZlRGV0YWlsID0gMjAsIHRoaXMuX2NvbG9yTW9kZSA9IHUuUkdCLCB0aGlzLl9jb2xvck1heGVzID0geyByZ2I6IFsyNTUsIDI1NSwgMjU1LCAyNTVdLCBoc2I6IFszNjAsIDEwMCwgMTAwLCAxXSwgaHNsOiBbMzYwLCAxMDAsIDEwMCwgMV0gfSwgdGhpcy5fZG93bktleXMgPSB7fTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZWdpc3RlclByZWxvYWRNZXRob2RcIiwgdmFsdWU6IGZ1bmN0aW9uKGwsIG4pIHtcbiAgICAgICAgICBzLnByb3RvdHlwZS5fcHJlbG9hZE1ldGhvZHMuaGFzT3duUHJvcGVydHkobCkgfHwgKHMucHJvdG90eXBlLl9wcmVsb2FkTWV0aG9kc1tsXSA9IG4pO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlZ2lzdGVyTWV0aG9kXCIsIHZhbHVlOiBmdW5jdGlvbihsLCBuKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzIHx8IHMucHJvdG90eXBlO1xuICAgICAgICAgIGEuX3JlZ2lzdGVyZWRNZXRob2RzLmhhc093blByb3BlcnR5KGwpIHx8IChhLl9yZWdpc3RlcmVkTWV0aG9kc1tsXSA9IFtdKSwgYS5fcmVnaXN0ZXJlZE1ldGhvZHNbbF0ucHVzaChuKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ1bnJlZ2lzdGVyTWV0aG9kXCIsIHZhbHVlOiBmdW5jdGlvbihsLCBuKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzIHx8IHMucHJvdG90eXBlO1xuICAgICAgICAgIGlmIChhLl9yZWdpc3RlcmVkTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShsKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IGEuX3JlZ2lzdGVyZWRNZXRob2RzW2xdLCBwID0gW10sIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgY1tqXSA9PT0gbiAmJiBwLnB1c2goaik7XG4gICAgICAgICAgICBmb3IgKHZhciBUID0gcC5sZW5ndGggLSAxOyAwIDw9IFQ7IFQtLSlcbiAgICAgICAgICAgICAgYy5zcGxpY2UocFtUXSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcIl9jcmVhdGVGcmllbmRseUdsb2JhbEZ1bmN0aW9uQmluZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbCA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge30sIG4gPSBsLmdsb2JhbE9iamVjdCB8fCB3aW5kb3c7XG4gICAgICAgICAgcmV0dXJuIGwubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgICAgIHMuZGlzYWJsZUZyaWVuZGx5RXJyb3JzLCBuW2FdID0gYztcbiAgICAgICAgICB9O1xuICAgICAgICB9IH1dKSAmJiBnKG8ucHJvdG90eXBlLCBpKSwgcztcbiAgICAgIH0oKTtcbiAgICAgIGZvciAoZiBpbiByLmluc3RhbmNlID0gbnVsbCwgci5kaXNhYmxlRnJpZW5kbHlFcnJvcnMgPSAhMSwgdSlcbiAgICAgICAgci5wcm90b3R5cGVbZl0gPSB1W2ZdO1xuICAgICAgci5WRVJTSU9OID0gdS5WRVJTSU9OLCByLnByb3RvdHlwZS5fcHJlbG9hZE1ldGhvZHMgPSB7IGxvYWRKU09OOiByLnByb3RvdHlwZSwgbG9hZEltYWdlOiByLnByb3RvdHlwZSwgbG9hZFN0cmluZ3M6IHIucHJvdG90eXBlLCBsb2FkWE1MOiByLnByb3RvdHlwZSwgbG9hZEJ5dGVzOiByLnByb3RvdHlwZSwgbG9hZFRhYmxlOiByLnByb3RvdHlwZSwgbG9hZEZvbnQ6IHIucHJvdG90eXBlLCBsb2FkTW9kZWw6IHIucHJvdG90eXBlLCBsb2FkU2hhZGVyOiByLnByb3RvdHlwZSB9LCByLnByb3RvdHlwZS5fcmVnaXN0ZXJlZE1ldGhvZHMgPSB7IGluaXQ6IFtdLCBwcmU6IFtdLCBwb3N0OiBbXSwgcmVtb3ZlOiBbXSB9LCByLnByb3RvdHlwZS5fcmVnaXN0ZXJlZFByZWxvYWRNZXRob2RzID0ge30sIEMuZGVmYXVsdCA9IHI7XG4gICAgfSwgeyBcIi4vY29uc3RhbnRzXCI6IDI2OSwgXCIuL3NoaW1cIjogMjkxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiOiAxNjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIjogMTY4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIjogMTcwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXNcIjogMTg0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI4MTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtID0gKHQgPSB0KFwiLi9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH07XG4gICAgICBmdW5jdGlvbiB5KHUsIGgpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBoLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgdmFyIGYgPSBoW2ddO1xuICAgICAgICAgIGYuZW51bWVyYWJsZSA9IGYuZW51bWVyYWJsZSB8fCAhMSwgZi5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGYgJiYgKGYud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBmLmtleSwgZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0uZGVmYXVsdC5FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHUociwgcykge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB1KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5lbHQgPSByLCB0aGlzLl9wSW5zdCA9IHRoaXMuX3BpeGVsc1N0YXRlID0gcywgdGhpcy5fZXZlbnRzID0ge30sIHRoaXMud2lkdGggPSB0aGlzLmVsdC5vZmZzZXRXaWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLmVsdC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGgsIGcsIGY7XG4gICAgICAgIHJldHVybiBoID0gdSwgZiA9IFt7IGtleTogXCJfYWRqdXN0TGlzdGVuZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKHIsIHMsIG8pIHtcbiAgICAgICAgICByZXR1cm4gcyA9PT0gITEgPyBtLmRlZmF1bHQuRWxlbWVudC5fZGV0YWNoTGlzdGVuZXIociwgbykgOiBtLmRlZmF1bHQuRWxlbWVudC5fYXR0YWNoTGlzdGVuZXIociwgcywgbyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2F0dGFjaExpc3RlbmVyXCIsIHZhbHVlOiBmdW5jdGlvbihyLCBzLCBvKSB7XG4gICAgICAgICAgby5fZXZlbnRzW3JdICYmIG0uZGVmYXVsdC5FbGVtZW50Ll9kZXRhY2hMaXN0ZW5lcihyLCBvKSwgcyA9IHMuYmluZChvKSwgby5lbHQuYWRkRXZlbnRMaXN0ZW5lcihyLCBzLCAhMSksIG8uX2V2ZW50c1tyXSA9IHM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2RldGFjaExpc3RlbmVyXCIsIHZhbHVlOiBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgICAgdmFyIG8gPSBzLl9ldmVudHNbcl07XG4gICAgICAgICAgcy5lbHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLCBvLCAhMSksIHMuX2V2ZW50c1tyXSA9IG51bGw7XG4gICAgICAgIH0gfV0sIChnID0gW3sga2V5OiBcInBhcmVudFwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiByID09PSB2b2lkIDAgPyB0aGlzLmVsdC5wYXJlbnROb2RlIDogKHR5cGVvZiByID09IFwic3RyaW5nXCIgPyAoclswXSA9PT0gXCIjXCIgJiYgKHIgPSByLnN1YnN0cmluZygxKSksIHIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKSkgOiByIGluc3RhbmNlb2YgbS5kZWZhdWx0LkVsZW1lbnQgJiYgKHIgPSByLmVsdCksIHIuYXBwZW5kQ2hpbGQodGhpcy5lbHQpLCB0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpZFwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiByID09PSB2b2lkIDAgPyB0aGlzLmVsdC5pZCA6ICh0aGlzLmVsdC5pZCA9IHIsIHRoaXMud2lkdGggPSB0aGlzLmVsdC5vZmZzZXRXaWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLmVsdC5vZmZzZXRIZWlnaHQsIHRoaXMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNsYXNzXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IHRoaXMuZWx0LmNsYXNzTmFtZSA6ICh0aGlzLmVsdC5jbGFzc05hbWUgPSByLCB0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtb3VzZVByZXNzZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LkVsZW1lbnQuX2FkanVzdExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJtb3VzZUlzUHJlc3NlZFwiLCAhMCksIHRoaXMuX3BJbnN0Ll9zZXRNb3VzZUJ1dHRvbihzKSwgci5jYWxsKHRoaXMsIHMpO1xuICAgICAgICAgIH0sIHRoaXMpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRvdWJsZUNsaWNrZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LkVsZW1lbnQuX2FkanVzdExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibW91c2VXaGVlbFwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJ3aGVlbFwiLCByLCB0aGlzKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJtb3VzZVJlbGVhc2VkXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5FbGVtZW50Ll9hZGp1c3RMaXN0ZW5lcihcIm1vdXNldXBcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibW91c2VDbGlja2VkXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5FbGVtZW50Ll9hZGp1c3RMaXN0ZW5lcihcImNsaWNrXCIsIHIsIHRoaXMpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1vdXNlTW92ZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LkVsZW1lbnQuX2FkanVzdExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHIsIHRoaXMpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1vdXNlT3ZlclwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibW91c2VPdXRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LkVsZW1lbnQuX2FkanVzdExpc3RlbmVyKFwibW91c2VvdXRcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidG91Y2hTdGFydGVkXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5FbGVtZW50Ll9hZGp1c3RMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidG91Y2hNb3ZlZFwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgciwgdGhpcyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidG91Y2hFbmRlZFwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCByLCB0aGlzKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJkcmFnT3ZlclwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCByLCB0aGlzKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJkcmFnTGVhdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LkVsZW1lbnQuX2FkanVzdExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIHIsIHRoaXMpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9zZXRQcm9wZXJ0eVwiLCB2YWx1ZTogZnVuY3Rpb24ociwgcykge1xuICAgICAgICAgIHRoaXNbcl0gPSBzO1xuICAgICAgICB9IH1dKSAmJiB5KGgucHJvdG90eXBlLCBnKSwgZiAmJiB5KGgsIGYpLCB1O1xuICAgICAgfSgpLCB0ID0gbS5kZWZhdWx0LkVsZW1lbnQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4vbWFpblwiOiAyODAgfV0sIDI4MjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oYSkge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjO1xuICAgICAgICB9IDogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBjICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBjO1xuICAgICAgICB9KShhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoYSkge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIG0oYyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgYy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShjKTtcbiAgICAgICAgfSkoYSk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKG4gPSB0KFwiLi9tYWluXCIpKSAmJiBuLl9fZXNNb2R1bGUgPyBuIDogeyBkZWZhdWx0OiBuIH0sIGggPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmIChhICYmIGEuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgeShhKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogYSB9O1xuICAgICAgICB2YXIgYyA9IGcoKTtcbiAgICAgICAgaWYgKGMgJiYgYy5oYXMoYSkpXG4gICAgICAgICAgcmV0dXJuIGMuZ2V0KGEpO1xuICAgICAgICB2YXIgcCwgaiA9IHt9LCBUID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAocCBpbiBhKSB7XG4gICAgICAgICAgdmFyIF87XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIHApICYmICgoXyA9IFQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIHApIDogbnVsbCkgJiYgKF8uZ2V0IHx8IF8uc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqLCBwLCBfKSA6IGpbcF0gPSBhW3BdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gai5kZWZhdWx0ID0gYSwgYyAmJiBjLnNldChhLCBqKSwgajtcbiAgICAgIH0odChcIi4vY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChhID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSwgYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKGEsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIGogPSBjW3BdO1xuICAgICAgICAgIGouZW51bWVyYWJsZSA9IGouZW51bWVyYWJsZSB8fCAhMSwgai5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGogJiYgKGoud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBqLmtleSwgaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIoYSwgYykge1xuICAgICAgICByZXR1cm4gKHIgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24ocCwgaikge1xuICAgICAgICAgIHJldHVybiBwLl9fcHJvdG9fXyA9IGosIHA7XG4gICAgICAgIH0pKGEsIGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYywgcCA9IGwoYSk7XG4gICAgICAgICAgcmV0dXJuIG8odGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPCBcInVcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCAmJiAhUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgfSkpLCAxO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oKSA/IChjID0gbCh0aGlzKS5jb25zdHJ1Y3RvciwgUmVmbGVjdC5jb25zdHJ1Y3QocCwgYXJndW1lbnRzLCBjKSkgOiBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbyhhLCBjKSB7XG4gICAgICAgIHJldHVybiAhYyB8fCB5KGMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiA/IGkoYSkgOiBjO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShhKSB7XG4gICAgICAgIGlmIChhID09PSB2b2lkIDApXG4gICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwoYSkge1xuICAgICAgICByZXR1cm4gKGwgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIGMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjKTtcbiAgICAgICAgfSkoYSk7XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQuR3JhcGhpY3MgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciBjID0gajtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9IFwiZnVuY3Rpb25cIiAmJiBhICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGEgJiYgYS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGMsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBhICYmIHIoYywgYSk7XG4gICAgICAgIHZhciBwID0gcyhqKTtcbiAgICAgICAgZnVuY3Rpb24gaihULCBfLCBSLCBFLCBBKSB7XG4gICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGopKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICBNID0gQSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCAoeCA9IHAuY2FsbCh0aGlzLCBNLCBFKSkuY2FudmFzID0gTTtcbiAgICAgICAgICB2YXIgUCwgTSA9IFIgfHwgaC5QMkQsIFIgPSBFLl91c2VyTm9kZSB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgIGZvciAoUCBpbiBBIHx8IFIuYXBwZW5kQ2hpbGQoeC5jYW52YXMpLCB1LmRlZmF1bHQucHJvdG90eXBlKVxuICAgICAgICAgICAgeFtQXSB8fCAodHlwZW9mIHUuZGVmYXVsdC5wcm90b3R5cGVbUF0gPT0gXCJmdW5jdGlvblwiID8geFtQXSA9IHUuZGVmYXVsdC5wcm90b3R5cGVbUF0uYmluZChpKHgpKSA6IHhbUF0gPSB1LmRlZmF1bHQucHJvdG90eXBlW1BdKTtcbiAgICAgICAgICByZXR1cm4gdS5kZWZhdWx0LnByb3RvdHlwZS5faW5pdGlhbGl6ZUluc3RhbmNlVmFyaWFibGVzLmFwcGx5KGkoeCkpLCB4LndpZHRoID0gVCwgeC5oZWlnaHQgPSBfLCB4Ll9waXhlbERlbnNpdHkgPSBFLl9waXhlbERlbnNpdHksIE0gPT09IGguV0VCR0wgPyAoeC5fcmVuZGVyZXIgPSBuZXcgdS5kZWZhdWx0LlJlbmRlcmVyR0woeC5jYW52YXMsIGkoeCksICExKSwgVCA9IChBID0geC5fcmVuZGVyZXIuX2FkanVzdERpbWVuc2lvbnMoVCwgXykpLmFkanVzdGVkV2lkdGgsIF8gPSBBLmFkanVzdGVkSGVpZ2h0KSA6IHguX3JlbmRlcmVyID0gbmV3IHUuZGVmYXVsdC5SZW5kZXJlcjJEKHguY2FudmFzLCBpKHgpLCAhMSksIEUuX2VsZW1lbnRzLnB1c2goaSh4KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpKHgpLCBcImRlbHRhVGltZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcEluc3QuZGVsdGFUaW1lO1xuICAgICAgICAgIH0gfSksIHguX3JlbmRlcmVyLnJlc2l6ZShULCBfKSwgeC5fcmVuZGVyZXIuX2FwcGx5RGVmYXVsdHMoKSwgbyh4LCBpKHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYyA9IGosIChhID0gW3sga2V5OiBcInJlc2V0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZXNldE1hdHJpeCgpLCB0aGlzLl9yZW5kZXJlci5pc1AzRCAmJiB0aGlzLl9yZW5kZXJlci5fdXBkYXRlKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVsdC5wYXJlbnROb2RlICYmIHRoaXMuZWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbHQpO1xuICAgICAgICAgIHZhciBULCBfID0gdGhpcy5fcEluc3QuX2VsZW1lbnRzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgZm9yIChUIGluIF8gIT09IC0xICYmIHRoaXMuX3BJbnN0Ll9lbGVtZW50cy5zcGxpY2UoXywgMSksIHRoaXMuX2V2ZW50cylcbiAgICAgICAgICAgIHRoaXMuZWx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVCwgdGhpcy5fZXZlbnRzW1RdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjcmVhdGVGcmFtZWJ1ZmZlclwiLCB2YWx1ZTogZnVuY3Rpb24oVCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdS5kZWZhdWx0LkZyYW1lYnVmZmVyKHRoaXMsIFQpO1xuICAgICAgICB9IH1dKSAmJiBmKGMucHJvdG90eXBlLCBhKSwgajtcbiAgICAgIH0odS5kZWZhdWx0LkVsZW1lbnQpO1xuICAgICAgdmFyIG4gPSB1LmRlZmF1bHQuR3JhcGhpY3M7XG4gICAgICBDLmRlZmF1bHQgPSBuO1xuICAgIH0sIHsgXCIuL2NvbnN0YW50c1wiOiAyNjksIFwiLi9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIjogMTYzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiOiAxNzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiOiAxODUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiOiAxODksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyODM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGEpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgYztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBjLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgYyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgYztcbiAgICAgICAgfSkoYSk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgeSA9IChsID0gdChcIi4vbWFpblwiKSkgJiYgbC5fX2VzTW9kdWxlID8gbCA6IHsgZGVmYXVsdDogbCB9LCB1ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBpZiAoYSAmJiBhLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGlmIChhID09PSBudWxsIHx8IGcoYSkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGEgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IGEgfTtcbiAgICAgICAgdmFyIGMgPSBoKCk7XG4gICAgICAgIGlmIChjICYmIGMuaGFzKGEpKVxuICAgICAgICAgIHJldHVybiBjLmdldChhKTtcbiAgICAgICAgdmFyIHAsIGogPSB7fSwgVCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKHAgaW4gYSkge1xuICAgICAgICAgIHZhciBfO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSAmJiAoKF8gPSBUID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBwKSA6IG51bGwpICYmIChfLmdldCB8fCBfLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaiwgcCwgXykgOiBqW3BdID0gYVtwXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGouZGVmYXVsdCA9IGEsIGMgJiYgYy5zZXQoYSwgaiksIGo7XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAoYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0sIGEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZyhhKSB7XG4gICAgICAgIHJldHVybiAoZyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gbShjKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBjLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgYyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKGMpO1xuICAgICAgICB9KShhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYoYSwgYykge1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICB2YXIgaiA9IGNbcF07XG4gICAgICAgICAgai5lbnVtZXJhYmxlID0gai5lbnVtZXJhYmxlIHx8ICExLCBqLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gaiAmJiAoai53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGoua2V5LCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihhLCBjKSB7XG4gICAgICAgIHJldHVybiAociA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihwLCBqKSB7XG4gICAgICAgICAgcmV0dXJuIHAuX19wcm90b19fID0gaiwgcDtcbiAgICAgICAgfSkoYSwgYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjLCBwLCBqID0gaShhKTtcbiAgICAgICAgICByZXR1cm4gYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0IDwgXCJ1XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QgJiYgIVJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIH0pKSwgMTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KCkgPyAoYyA9IGkodGhpcykuY29uc3RydWN0b3IsIFJlZmxlY3QuY29uc3RydWN0KGosIGFyZ3VtZW50cywgYykpIDogai5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBqID0gdGhpcywgIShwID0gYykgfHwgZyhwKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcCAhPSBcImZ1bmN0aW9uXCIgPyBvKGopIDogcDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8oYSkge1xuICAgICAgICBpZiAoYSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpKGEpIHtcbiAgICAgICAgcmV0dXJuIChpID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYyk7XG4gICAgICAgIH0pKGEpO1xuICAgICAgfVxuICAgICAgdmFyIGwgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciBjID0gajtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9IFwiZnVuY3Rpb25cIiAmJiBhICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGEgJiYgYS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGMsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBhICYmIHIoYywgYSk7XG4gICAgICAgIHZhciBwID0gcyhqKTtcbiAgICAgICAgZnVuY3Rpb24gaihULCBfLCBTKSB7XG4gICAgICAgICAgdmFyIEU7XG4gICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBqKVxuICAgICAgICAgICAgcmV0dXJuIChFID0gcC5jYWxsKHRoaXMsIFQsIF8pKS5jYW52YXMgPSBULCBFLl9waXhlbHNTdGF0ZSA9IF8sIFMgPyAoRS5faXNNYWluQ2FudmFzID0gITAsIEUuX3BJbnN0Ll9zZXRQcm9wZXJ0eShcIl9jdXJFbGVtZW50XCIsIG8oRSkpLCBFLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJjYW52YXNcIiwgRS5jYW52YXMpLCBFLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJ3aWR0aFwiLCBFLndpZHRoKSwgRS5fcEluc3QuX3NldFByb3BlcnR5KFwiaGVpZ2h0XCIsIEUuaGVpZ2h0KSkgOiAoRS5jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBFLl9zdHlsZXMgPSBbXSksIEUuX2NsaXBwaW5nID0gITEsIEUuX2NsaXBJbnZlcnQgPSAhMSwgRS5fdGV4dFNpemUgPSAxMiwgRS5fdGV4dExlYWRpbmcgPSAxNSwgRS5fdGV4dEZvbnQgPSBcInNhbnMtc2VyaWZcIiwgRS5fdGV4dFN0eWxlID0gdS5OT1JNQUwsIEUuX3RleHRBc2NlbnQgPSBudWxsLCBFLl90ZXh0RGVzY2VudCA9IG51bGwsIEUuX3RleHRBbGlnbiA9IHUuTEVGVCwgRS5fdGV4dEJhc2VsaW5lID0gdS5CQVNFTElORSwgRS5fdGV4dFdyYXAgPSB1LldPUkQsIEUuX3JlY3RNb2RlID0gdS5DT1JORVIsIEUuX2VsbGlwc2VNb2RlID0gdS5DRU5URVIsIEUuX2N1cnZlVGlnaHRuZXNzID0gMCwgRS5faW1hZ2VNb2RlID0gdS5DT1JORVIsIEUuX3RpbnQgPSBudWxsLCBFLl9kb1N0cm9rZSA9ICEwLCBFLl9kb0ZpbGwgPSAhMCwgRS5fc3Ryb2tlU2V0ID0gITEsIEUuX2ZpbGxTZXQgPSAhMSwgRS5fbGVhZGluZ1NldCA9ICExLCBFLl9wdXNoUG9wRGVwdGggPSAwLCBFO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMgPSBqLCAoYSA9IFt7IGtleTogXCJwdXNoXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFBvcERlcHRoKyssIHsgcHJvcGVydGllczogeyBfZG9TdHJva2U6IHRoaXMuX2RvU3Ryb2tlLCBfc3Ryb2tlU2V0OiB0aGlzLl9zdHJva2VTZXQsIF9kb0ZpbGw6IHRoaXMuX2RvRmlsbCwgX2ZpbGxTZXQ6IHRoaXMuX2ZpbGxTZXQsIF90aW50OiB0aGlzLl90aW50LCBfaW1hZ2VNb2RlOiB0aGlzLl9pbWFnZU1vZGUsIF9yZWN0TW9kZTogdGhpcy5fcmVjdE1vZGUsIF9lbGxpcHNlTW9kZTogdGhpcy5fZWxsaXBzZU1vZGUsIF90ZXh0Rm9udDogdGhpcy5fdGV4dEZvbnQsIF90ZXh0TGVhZGluZzogdGhpcy5fdGV4dExlYWRpbmcsIF9sZWFkaW5nU2V0OiB0aGlzLl9sZWFkaW5nU2V0LCBfdGV4dFNpemU6IHRoaXMuX3RleHRTaXplLCBfdGV4dEFsaWduOiB0aGlzLl90ZXh0QWxpZ24sIF90ZXh0QmFzZWxpbmU6IHRoaXMuX3RleHRCYXNlbGluZSwgX3RleHRTdHlsZTogdGhpcy5fdGV4dFN0eWxlLCBfdGV4dFdyYXA6IHRoaXMuX3RleHRXcmFwIH0gfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwb3BcIiwgdmFsdWU6IGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICB0aGlzLl9wdXNoUG9wRGVwdGgtLSwgVC5wcm9wZXJ0aWVzICYmIE9iamVjdC5hc3NpZ24odGhpcywgVC5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJiZWdpbkNsaXBcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBUID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICBpZiAodGhpcy5fY2xpcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB0cnlpbmcgdG8gY2xpcCB3aGlsZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgY2xpcHBpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGVuZENsaXAoKT9cIik7XG4gICAgICAgICAgdGhpcy5fY2xpcHBpbmcgPSAhMCwgdGhpcy5fY2xpcEludmVydCA9IFQuaW52ZXJ0O1xuICAgICAgICB9IH0sIHsga2V5OiBcImVuZENsaXBcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fY2xpcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBjYWxsZWQgZW5kQ2xpcCgpIHdpdGhvdXQgYmVnaW5DbGlwKCkuIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgYmVnaW5DbGlwKCkgZmlyc3Q/XCIpO1xuICAgICAgICAgIHRoaXMuX2NsaXBwaW5nID0gITE7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVzaXplXCIsIHZhbHVlOiBmdW5jdGlvbihULCBfKSB7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IFQsIHRoaXMuaGVpZ2h0ID0gXywgdGhpcy5lbHQud2lkdGggPSBUICogdGhpcy5fcEluc3QuX3BpeGVsRGVuc2l0eSwgdGhpcy5lbHQuaGVpZ2h0ID0gXyAqIHRoaXMuX3BJbnN0Ll9waXhlbERlbnNpdHksIHRoaXMuZWx0LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoVCwgXCJweFwiKSwgdGhpcy5lbHQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoXywgXCJweFwiKSwgdGhpcy5faXNNYWluQ2FudmFzICYmICh0aGlzLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKSwgdGhpcy5fcEluc3QuX3NldFByb3BlcnR5KFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0KSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbihULCBfLCBTLCBFKSB7XG4gICAgICAgICAgdmFyIEEgPSB0aGlzLl9waXhlbHNTdGF0ZSwgeCA9IEEuX3BpeGVsRGVuc2l0eSwgUCA9IHRoaXMuY2FudmFzO1xuICAgICAgICAgIGlmIChUID09PSB2b2lkIDAgJiYgXyA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgVCA9IF8gPSAwLCBTID0gQS53aWR0aCwgRSA9IEEuaGVpZ2h0O1xuICAgICAgICAgIGVsc2UgaWYgKFQgKj0geCwgXyAqPSB4LCBTID09PSB2b2lkIDAgJiYgRSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIFQgPCAwIHx8IF8gPCAwIHx8IFQgPj0gUC53aWR0aCB8fCBfID49IFAuaGVpZ2h0ID8gWzAsIDAsIDAsIDBdIDogdGhpcy5fZ2V0UGl4ZWwoVCwgXyk7XG4gICAgICAgICAgcmV0dXJuIEEgPSBuZXcgeS5kZWZhdWx0LkltYWdlKFMgKiB4LCBFICogeCksIEEucGl4ZWxEZW5zaXR5KHgpLCBBLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKFAsIFQsIF8sIFMgKiB4LCBFICogeCwgMCwgMCwgUyAqIHgsIEUgKiB4KSwgQTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0ZXh0TGVhZGluZ1wiLCB2YWx1ZTogZnVuY3Rpb24oVCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgVCA9PSBcIm51bWJlclwiID8gKHRoaXMuX3NldFByb3BlcnR5KFwiX2xlYWRpbmdTZXRcIiwgITApLCB0aGlzLl9zZXRQcm9wZXJ0eShcIl90ZXh0TGVhZGluZ1wiLCBUKSwgdGhpcy5fcEluc3QpIDogdGhpcy5fdGV4dExlYWRpbmc7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidGV4dFN0eWxlXCIsIHZhbHVlOiBmdW5jdGlvbihUKSB7XG4gICAgICAgICAgcmV0dXJuIFQgPyAoVCAhPT0gdS5OT1JNQUwgJiYgVCAhPT0gdS5JVEFMSUMgJiYgVCAhPT0gdS5CT0xEICYmIFQgIT09IHUuQk9MRElUQUxJQyB8fCB0aGlzLl9zZXRQcm9wZXJ0eShcIl90ZXh0U3R5bGVcIiwgVCksIHRoaXMuX2FwcGx5VGV4dFByb3BlcnRpZXMoKSkgOiB0aGlzLl90ZXh0U3R5bGU7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidGV4dEFzY2VudFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRBc2NlbnQgPT09IG51bGwgJiYgdGhpcy5fdXBkYXRlVGV4dE1ldHJpY3MoKSwgdGhpcy5fdGV4dEFzY2VudDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0ZXh0RGVzY2VudFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHREZXNjZW50ID09PSBudWxsICYmIHRoaXMuX3VwZGF0ZVRleHRNZXRyaWNzKCksIHRoaXMuX3RleHREZXNjZW50O1xuICAgICAgICB9IH0sIHsga2V5OiBcInRleHRBbGlnblwiLCB2YWx1ZTogZnVuY3Rpb24oVCwgXykge1xuICAgICAgICAgIHJldHVybiBUICE9PSB2b2lkIDAgPyAodGhpcy5fc2V0UHJvcGVydHkoXCJfdGV4dEFsaWduXCIsIFQpLCBfICE9PSB2b2lkIDAgJiYgdGhpcy5fc2V0UHJvcGVydHkoXCJfdGV4dEJhc2VsaW5lXCIsIF8pLCB0aGlzLl9hcHBseVRleHRQcm9wZXJ0aWVzKCkpIDogeyBob3Jpem9udGFsOiB0aGlzLl90ZXh0QWxpZ24sIHZlcnRpY2FsOiB0aGlzLl90ZXh0QmFzZWxpbmUgfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0ZXh0V3JhcFwiLCB2YWx1ZTogZnVuY3Rpb24oVCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRQcm9wZXJ0eShcIl90ZXh0V3JhcFwiLCBUKSwgdGhpcy5fdGV4dFdyYXA7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidGV4dFwiLCB2YWx1ZTogZnVuY3Rpb24oVCwgXywgUywgRSwgQSkge1xuICAgICAgICAgIHZhciB4LCBQLCBNLCBSLCBMID0gdGhpcy5fcEluc3QsIEYgPSB0aGlzLl90ZXh0V3JhcCwgViA9IE51bWJlci5NQVhfVkFMVUUsIEcgPSBTO1xuICAgICAgICAgIGlmICgodGhpcy5fZG9GaWxsIHx8IHRoaXMuX2RvU3Ryb2tlKSAmJiBUICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh4ID0gKFQgPSAoVCA9IHR5cGVvZiBUICE9IFwic3RyaW5nXCIgPyBULnRvU3RyaW5nKCkgOiBUKS5yZXBsYWNlKC8oXFx0KS9nLCBcIiAgXCIpKS5zcGxpdChgXG5gKSwgRSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcmVjdE1vZGUgPT09IHUuQ0VOVEVSICYmIChfIC09IEUgLyAyKSwgdGhpcy5fdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1LkNFTlRFUjpcbiAgICAgICAgICAgICAgICAgIF8gKz0gRSAvIDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHUuUklHSFQ6XG4gICAgICAgICAgICAgICAgICBfICs9IEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKEEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3RNb2RlID09PSB1LkNFTlRFUiAmJiAoUyAtPSBBIC8gMiwgRyAtPSBBIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSBTLCBVID0gTC50ZXh0QXNjZW50KCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl90ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgdS5CT1RUT006XG4gICAgICAgICAgICAgICAgICAgIFIgPSBTICsgQSwgUyA9IE1hdGgubWF4KFIsIFMpLCBHICs9IFU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSB1LkNFTlRFUjpcbiAgICAgICAgICAgICAgICAgICAgUiA9IFMgKyBBIC8gMiwgUyA9IE1hdGgubWF4KFIsIFMpLCBHICs9IFUgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBWID0gUyArIEEgLSBVLCB0aGlzLl90ZXh0QmFzZWxpbmUgPT09IHUuQ0VOVEVSICYmIChWID0gVCArIEEgLSBVIC8gMik7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSAhPT0gdS5CT1RUT00gJiYgdGhpcy5fdGV4dEJhc2VsaW5lICE9PSB1LkNFTlRFUiB8fCAoRyA9IFMgLSAoVCA9IEwudGV4dFNpemUoKSAqIHRoaXMuX3RleHRMZWFkaW5nKSAvIDIsIFYgPSBTICsgVCAvIDIpO1xuICAgICAgICAgICAgICBpZiAoRiA9PT0gdS5XT1JEKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgVyA9IFtdLCBYID0gMDsgWCA8IHgubGVuZ3RoOyBYKyspIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5lID0gXCJcIiwgYiA9IHhbWF0uc3BsaXQoXCIgXCIpLCBPID0gMDsgTyA8IGIubGVuZ3RoOyBPKyspXG4gICAgICAgICAgICAgICAgICAgIFAgPSBcIlwiLmNvbmNhdChuZSArIGJbT10pICsgXCIgXCIsIG5lID0gRSA8IChNID0gdGhpcy50ZXh0V2lkdGgoUCkpICYmIDAgPCBuZS5sZW5ndGggPyAoVy5wdXNoKG5lKSwgXCJcIi5jb25jYXQoYltPXSkgKyBcIiBcIikgOiBQO1xuICAgICAgICAgICAgICAgICAgVy5wdXNoKG5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIEQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9PT0gdS5DRU5URVIgPyBEID0gKFcubGVuZ3RoIC0gMSkgKiBMLnRleHRMZWFkaW5nKCkgLyAyIDogdGhpcy5fdGV4dEJhc2VsaW5lID09PSB1LkJPVFRPTSAmJiAoRCA9IChXLmxlbmd0aCAtIDEpICogTC50ZXh0TGVhZGluZygpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBCID0gMDsgQiA8IHgubGVuZ3RoOyBCKyspIHtcbiAgICAgICAgICAgICAgICAgIG5lID0gXCJcIiwgYiA9IHhbQl0uc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgWSA9IDA7IFkgPCBiLmxlbmd0aDsgWSsrKVxuICAgICAgICAgICAgICAgICAgICBQID0gXCJcIi5jb25jYXQobmUgKyBiW1ldKSArIFwiIFwiLCBFIDwgKE0gPSB0aGlzLnRleHRXaWR0aChQKSkgJiYgMCA8IG5lLmxlbmd0aCA/ICh0aGlzLl9yZW5kZXJUZXh0KEwsIG5lLnRyaW0oKSwgXywgUyAtIEQsIFYsIEcpLCBuZSA9IFwiXCIuY29uY2F0KGJbWV0pICsgXCIgXCIsIFMgKz0gTC50ZXh0TGVhZGluZygpKSA6IG5lID0gUDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHQoTCwgbmUudHJpbSgpLCBfLCBTIC0gRCwgViwgRyksIFMgKz0gTC50ZXh0TGVhZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBKID0gW10sIHRlID0gMDsgdGUgPCB4Lmxlbmd0aDsgdGUrKylcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNlID0geFt0ZV0uc3BsaXQobmUgPSBcIlwiKSwgcmUgPSAwOyByZSA8IGNlLmxlbmd0aDsgcmUrKylcbiAgICAgICAgICAgICAgICAgICAgUCA9IFwiXCIuY29uY2F0KG5lICsgY2VbcmVdKSwgKE0gPSB0aGlzLnRleHRXaWR0aChQKSkgPD0gRSA/IG5lICs9IGNlW3JlXSA6IEUgPCBNICYmIDAgPCBuZS5sZW5ndGggJiYgKEoucHVzaChuZSksIG5lID0gXCJcIi5jb25jYXQoY2VbcmVdKSk7XG4gICAgICAgICAgICAgICAgSi5wdXNoKG5lKTtcbiAgICAgICAgICAgICAgICB2YXIgdWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9PT0gdS5DRU5URVIgPyB1ZSA9IChKLmxlbmd0aCAtIDEpICogTC50ZXh0TGVhZGluZygpIC8gMiA6IHRoaXMuX3RleHRCYXNlbGluZSA9PT0gdS5CT1RUT00gJiYgKHVlID0gKEoubGVuZ3RoIC0gMSkgKiBMLnRleHRMZWFkaW5nKCkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxlID0gMDsgbGUgPCB4Lmxlbmd0aDsgbGUrKykge1xuICAgICAgICAgICAgICAgICAgY2UgPSB4W2xlXS5zcGxpdChuZSA9IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgSyA9IDA7IEsgPCBjZS5sZW5ndGg7IEsrKylcbiAgICAgICAgICAgICAgICAgICAgUCA9IFwiXCIuY29uY2F0KG5lICsgY2VbS10pLCAoTSA9IHRoaXMudGV4dFdpZHRoKFApKSA8PSBFID8gbmUgKz0gY2VbS10gOiBFIDwgTSAmJiAwIDwgbmUubGVuZ3RoICYmICh0aGlzLl9yZW5kZXJUZXh0KEwsIG5lLnRyaW0oKSwgXywgUyAtIHVlLCBWLCBHKSwgUyArPSBMLnRleHRMZWFkaW5nKCksIG5lID0gXCJcIi5jb25jYXQoY2VbS10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dChMLCBuZS50cmltKCksIF8sIFMgLSB1ZSwgViwgRyksIFMgKz0gTC50ZXh0TGVhZGluZygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYWUgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPT09IHUuQ0VOVEVSID8gYWUgPSAoeC5sZW5ndGggLSAxKSAqIEwudGV4dExlYWRpbmcoKSAvIDIgOiB0aGlzLl90ZXh0QmFzZWxpbmUgPT09IHUuQk9UVE9NICYmIChhZSA9ICh4Lmxlbmd0aCAtIDEpICogTC50ZXh0TGVhZGluZygpKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaGUgPSAwOyBoZSA8IHgubGVuZ3RoOyBoZSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHQoTCwgeFtoZV0sIF8sIFMgLSBhZSwgViwgRyAtIGFlKSwgUyArPSBMLnRleHRMZWFkaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2FwcGx5RGVmYXVsdHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9pc09wZW5UeXBlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgVCA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogdGhpcy5fdGV4dEZvbnQ7XG4gICAgICAgICAgcmV0dXJuIGcoVCkgPT09IFwib2JqZWN0XCIgJiYgVC5mb250ICYmIFQuZm9udC5zdXBwb3J0ZWQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3VwZGF0ZVRleHRNZXRyaWNzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgVCwgXywgUywgRSwgQSwgeDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuVHlwZSgpID8gKHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHRBc2NlbnRcIiwgdGhpcy5fdGV4dEZvbnQuX3RleHRBc2NlbnQoKSksIHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHREZXNjZW50XCIsIHRoaXMuX3RleHRGb250Ll90ZXh0RGVzY2VudCgpKSkgOiAoKFQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSkuc3R5bGUuZm9udEZhbWlseSA9IHRoaXMuX3RleHRGb250LCBULnN0eWxlLmZvbnRTaXplID0gXCJcIi5jb25jYXQodGhpcy5fdGV4dFNpemUsIFwicHhcIiksIFQuaW5uZXJIVE1MID0gXCJBQkNqZ3F8XCIsICh4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIsIHguc3R5bGUud2lkdGggPSBcIjFweFwiLCB4LnN0eWxlLmhlaWdodCA9IFwiMHB4XCIsIEUgPSAoKF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hcHBlbmRDaGlsZChUKSwgXy5hcHBlbmRDaGlsZCh4KSwgXy5zdHlsZS5oZWlnaHQgPSBcIjBweFwiLCBfLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfKSwgeC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJiYXNlbGluZVwiLCBuKHgpKSwgQSA9IG4oVCksIFMgPSBFWzFdIC0gQVsxXSwgRSA9ICh4LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcImJvdHRvbVwiLCBuKHgpKSwgQSA9IG4oVCksIHggPSBFWzFdIC0gQVsxXSAtIFMsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoXyksIHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHRBc2NlbnRcIiwgUyksIHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHREZXNjZW50XCIsIHgpKSwgdGhpcztcbiAgICAgICAgfSB9XSkgJiYgZihjLnByb3RvdHlwZSwgYSksIGo7XG4gICAgICB9KHkuZGVmYXVsdC5FbGVtZW50KTtcbiAgICAgIGZ1bmN0aW9uIG4oYSkge1xuICAgICAgICB2YXIgYyA9IDAsIHAgPSAwO1xuICAgICAgICBpZiAoYS5vZmZzZXRQYXJlbnQpXG4gICAgICAgICAgZm9yICg7IGMgKz0gYS5vZmZzZXRMZWZ0LCBwICs9IGEub2Zmc2V0VG9wLCBhID0gYS5vZmZzZXRQYXJlbnQ7IClcbiAgICAgICAgICAgIDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGMgKz0gYS5vZmZzZXRMZWZ0LCBwICs9IGEub2Zmc2V0VG9wO1xuICAgICAgICByZXR1cm4gW2MsIHBdO1xuICAgICAgfVxuICAgICAgbC5wcm90b3R5cGUudGV4dFNpemUgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PSBcIm51bWJlclwiID8gKHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHRTaXplXCIsIGEpLCB0aGlzLl9sZWFkaW5nU2V0IHx8IHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHRMZWFkaW5nXCIsIGEgKiB1Ll9ERUZBVUxUX0xFQURNVUxUKSwgdGhpcy5fYXBwbHlUZXh0UHJvcGVydGllcygpKSA6IHRoaXMuX3RleHRTaXplO1xuICAgICAgfSwgeS5kZWZhdWx0LlJlbmRlcmVyID0gbCwgdCA9IHkuZGVmYXVsdC5SZW5kZXJlciwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9jb25zdGFudHNcIjogMjY5LCBcIi4vbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yXCI6IDE3OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiOiAxODEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiOiAxODUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiOiAxODksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCI6IDIwMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIjogMjA2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyODQ6IFtmdW5jdGlvbihhLCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgcDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBwLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgcDtcbiAgICAgICAgfSkoYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KGMpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBtKHApO1xuICAgICAgICB9IDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHAuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBwICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0ocCk7XG4gICAgICAgIH0pKGMpO1xuICAgICAgfVxuICAgICAgYShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCBhKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWRcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIGEoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgYShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChuID0gYShcIi4vbWFpblwiKSkgJiYgbi5fX2VzTW9kdWxlID8gbiA6IHsgZGVmYXVsdDogbiB9LCBoID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYyAmJiBjLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIGlmIChjID09PSBudWxsIHx8IHkoYykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IGMgfTtcbiAgICAgICAgdmFyIHAgPSBnKCk7XG4gICAgICAgIGlmIChwICYmIHAuaGFzKGMpKVxuICAgICAgICAgIHJldHVybiBwLmdldChjKTtcbiAgICAgICAgdmFyIGosIFQgPSB7fSwgXyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGogaW4gYykge1xuICAgICAgICAgIHZhciBTO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLCBqKSAmJiAoKFMgPSBfID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjLCBqKSA6IG51bGwpICYmIChTLmdldCB8fCBTLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoVCwgaiwgUykgOiBUW2pdID0gY1tqXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFQuZGVmYXVsdCA9IGMsIHAgJiYgcC5zZXQoYywgVCksIFQ7XG4gICAgICB9KGEoXCIuL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAoYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0sIGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihjLCBwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBUID0gcFtqXTtcbiAgICAgICAgICBULmVudW1lcmFibGUgPSBULmVudW1lcmFibGUgfHwgITEsIFQuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBUICYmIChULndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgVC5rZXksIFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKGMsIHAsIGopIHtcbiAgICAgICAgcmV0dXJuIChyID0gdHlwZW9mIFJlZmxlY3QgPCBcInVcIiAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0IDogZnVuY3Rpb24oRSwgXywgUykge1xuICAgICAgICAgIHZhciBFID0gZnVuY3Rpb24oQSwgeCkge1xuICAgICAgICAgICAgZm9yICg7ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSwgeCkgJiYgKEEgPSBpKEEpKSAhPT0gbnVsbDsgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgICB9KEUsIF8pO1xuICAgICAgICAgIGlmIChFKVxuICAgICAgICAgICAgcmV0dXJuIChFID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFLCBfKSkuZ2V0ID8gRS5nZXQuY2FsbChTKSA6IEUudmFsdWU7XG4gICAgICAgIH0pKGMsIHAsIGogfHwgYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKGMsIHApIHtcbiAgICAgICAgcmV0dXJuIChzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKGosIFQpIHtcbiAgICAgICAgICByZXR1cm4gai5fX3Byb3RvX18gPSBULCBqO1xuICAgICAgICB9KShjLCBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8oYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAsIGogPSBpKGMpLCBqID0gKHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KSksIDE7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSgpID8gKHAgPSBpKHRoaXMpLmNvbnN0cnVjdG9yLCBSZWZsZWN0LmNvbnN0cnVjdChqLCBhcmd1bWVudHMsIHApKSA6IGouYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFwIHx8IHkocCkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHAgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaiAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICByZXR1cm4gajtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpKGMpIHtcbiAgICAgICAgcmV0dXJuIChpID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCk7XG4gICAgICAgIH0pKGMpO1xuICAgICAgfVxuICAgICAgYShcIi4vcDUuUmVuZGVyZXJcIik7XG4gICAgICB2YXIgbCA9IFwicmdiYSgwLDAsMCwwKVwiLCBuID0gZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgcCA9IFQ7XG4gICAgICAgIGlmICh0eXBlb2YgYyAhPSBcImZ1bmN0aW9uXCIgJiYgYyAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjICYmIGMucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBwLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgYyAmJiBzKHAsIGMpO1xuICAgICAgICB2YXIgaiA9IG8oVCk7XG4gICAgICAgIGZ1bmN0aW9uIFQoXywgUywgRSkge1xuICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVClcbiAgICAgICAgICAgIHJldHVybiAoXyA9IGouY2FsbCh0aGlzLCBfLCBTLCBFKSkuZHJhd2luZ0NvbnRleHQgPSBfLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIF8uX3BJbnN0Ll9zZXRQcm9wZXJ0eShcImRyYXdpbmdDb250ZXh0XCIsIF8uZHJhd2luZ0NvbnRleHQpLCBfO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAgPSBULCAoYyA9IFt7IGtleTogXCJnZXRGaWx0ZXJHcmFwaGljc0xheWVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgXztcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJHcmFwaGljc0xheWVyIHx8IChfID0gKHRoaXMuX3BJbnN0IGluc3RhbmNlb2YgdS5kZWZhdWx0LkdyYXBoaWNzID8gdGhpcy5fcEluc3QgOiB0aGlzKS5fcEluc3QsIHRoaXMuZmlsdGVyR3JhcGhpY3NMYXllciA9IG5ldyB1LmRlZmF1bHQuR3JhcGhpY3ModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGguV0VCR0wsIF8pKSwgdGhpcy5maWx0ZXJHcmFwaGljc0xheWVyLndpZHRoID09PSB0aGlzLndpZHRoICYmIHRoaXMuZmlsdGVyR3JhcGhpY3NMYXllci5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0IHx8IHRoaXMuZmlsdGVyR3JhcGhpY3NMYXllci5yZXNpemVDYW52YXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmZpbHRlckdyYXBoaWNzTGF5ZXIucGl4ZWxEZW5zaXR5KCkgIT09IHRoaXMuX3BJbnN0LnBpeGVsRGVuc2l0eSgpICYmIHRoaXMuZmlsdGVyR3JhcGhpY3NMYXllci5waXhlbERlbnNpdHkodGhpcy5fcEluc3QucGl4ZWxEZW5zaXR5KCkpLCB0aGlzLmZpbHRlckdyYXBoaWNzTGF5ZXI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2FwcGx5RGVmYXVsdHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlZEZpbGxTdHlsZSA9IHRoaXMuX2NhY2hlZFN0cm9rZVN0eWxlID0gdm9pZCAwLCB0aGlzLl9jYWNoZWRCbGVuZE1vZGUgPSBoLkJMRU5ELCB0aGlzLl9zZXRGaWxsKGguX0RFRkFVTFRfRklMTCksIHRoaXMuX3NldFN0cm9rZShoLl9ERUZBVUxUX1NUUk9LRSksIHRoaXMuZHJhd2luZ0NvbnRleHQubGluZUNhcCA9IGguUk9VTkQsIHRoaXMuZHJhd2luZ0NvbnRleHQuZm9udCA9IFwibm9ybWFsIDEycHggc2Fucy1zZXJpZlwiO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlc2l6ZVwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUykge1xuICAgICAgICAgIHIoaShULnByb3RvdHlwZSksIFwicmVzaXplXCIsIHRoaXMpLmNhbGwodGhpcywgXywgUyksIHRoaXMuZHJhd2luZ0NvbnRleHQuc2NhbGUodGhpcy5fcEluc3QuX3BpeGVsRGVuc2l0eSwgdGhpcy5fcEluc3QuX3BpeGVsRGVuc2l0eSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYmFja2dyb3VuZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF8sIFM7XG4gICAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dC5zYXZlKCksIHRoaXMucmVzZXRNYXRyaXgoKSwgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgaW5zdGFuY2VvZiB1LmRlZmF1bHQuSW1hZ2UgPyAwIDw9IChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pID8gKF8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIHRoaXMuZHJhd2luZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSAvIDI1NSwgdGhpcy5fcEluc3QuaW1hZ2UoXywgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpKSA6IHRoaXMuX3BJbnN0LmltYWdlKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIDogKF8gPSB0aGlzLl9nZXRGaWxsKCksIFMgPSAoUyA9IHRoaXMuX3BJbnN0KS5jb2xvci5hcHBseShTLCBhcmd1bWVudHMpLCB0aGlzLl9wSW5zdC5fYWRkQWNjc091dHB1dCgpICYmIHRoaXMuX3BJbnN0Ll9hY2NzQmFja2dyb3VuZChTLmxldmVscyksIFMgPSBTLnRvU3RyaW5nKCksIHRoaXMuX3NldEZpbGwoUyksIHRoaXMuX2lzRXJhc2luZyAmJiB0aGlzLmJsZW5kTW9kZSh0aGlzLl9jYWNoZWRCbGVuZE1vZGUpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgdGhpcy5fc2V0RmlsbChfKSwgdGhpcy5faXNFcmFzaW5nICYmIHRoaXMuX3BJbnN0LmVyYXNlKCkpLCB0aGlzLmRyYXdpbmdDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjbGVhclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dC5zYXZlKCksIHRoaXMucmVzZXRNYXRyaXgoKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmRyYXdpbmdDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJmaWxsXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgXyA9IChfID0gdGhpcy5fcEluc3QpLmNvbG9yLmFwcGx5KF8sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5fc2V0RmlsbChfLnRvU3RyaW5nKCkpLCB0aGlzLl9wSW5zdC5fYWRkQWNjc091dHB1dCgpICYmIHRoaXMuX3BJbnN0Ll9hY2NzQ2FudmFzQ29sb3JzKFwiZmlsbFwiLCBfLmxldmVscyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic3Ryb2tlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgXyA9IChfID0gdGhpcy5fcEluc3QpLmNvbG9yLmFwcGx5KF8sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5fc2V0U3Ryb2tlKF8udG9TdHJpbmcoKSksIHRoaXMuX3BJbnN0Ll9hZGRBY2NzT3V0cHV0KCkgJiYgdGhpcy5fcEluc3QuX2FjY3NDYW52YXNDb2xvcnMoXCJzdHJva2VcIiwgXy5sZXZlbHMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImVyYXNlXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTKSB7XG4gICAgICAgICAgdGhpcy5faXNFcmFzaW5nIHx8ICh0aGlzLl9jYWNoZWRGaWxsU3R5bGUgPSB0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGxTdHlsZSwgXyA9IHRoaXMuX3BJbnN0LmNvbG9yKDI1NSwgXykudG9TdHJpbmcoKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5maWxsU3R5bGUgPSBfLCB0aGlzLl9jYWNoZWRTdHJva2VTdHlsZSA9IHRoaXMuZHJhd2luZ0NvbnRleHQuc3Ryb2tlU3R5bGUsIF8gPSB0aGlzLl9wSW5zdC5jb2xvcigyNTUsIFMpLnRvU3RyaW5nKCksIHRoaXMuZHJhd2luZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBfLCBTID0gdGhpcy5fY2FjaGVkQmxlbmRNb2RlLCB0aGlzLmJsZW5kTW9kZShoLlJFTU9WRSksIHRoaXMuX2NhY2hlZEJsZW5kTW9kZSA9IFMsIHRoaXMuX2lzRXJhc2luZyA9ICEwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJub0VyYXNlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9pc0VyYXNpbmcgJiYgKHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fY2FjaGVkRmlsbFN0eWxlLCB0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGUsIHRoaXMuYmxlbmRNb2RlKHRoaXMuX2NhY2hlZEJsZW5kTW9kZSksIHRoaXMuX2lzRXJhc2luZyA9ICExKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJiZWdpbkNsaXBcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSwgXyA9IChyKGkoVC5wcm90b3R5cGUpLCBcImJlZ2luQ2xpcFwiLCB0aGlzKS5jYWxsKHRoaXMsIF8pLCB0aGlzLl9jYWNoZWRGaWxsU3R5bGUgPSB0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGxTdHlsZSwgdGhpcy5fcEluc3QuY29sb3IoMjU1LCAwKS50b1N0cmluZygpKSwgXyA9ICh0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGxTdHlsZSA9IF8sIHRoaXMuX2NhY2hlZFN0cm9rZVN0eWxlID0gdGhpcy5kcmF3aW5nQ29udGV4dC5zdHJva2VTdHlsZSwgdGhpcy5fcEluc3QuY29sb3IoMjU1LCAwKS50b1N0cmluZygpKSwgXyA9ICh0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gXywgdGhpcy5fY2FjaGVkQmxlbmRNb2RlKTtcbiAgICAgICAgICB0aGlzLmJsZW5kTW9kZShoLkJMRU5EKSwgdGhpcy5fY2FjaGVkQmxlbmRNb2RlID0gXywgdGhpcy5kcmF3aW5nQ29udGV4dC5iZWdpblBhdGgoKSwgdGhpcy5fY2xpcEludmVydCAmJiAodGhpcy5kcmF3aW5nQ29udGV4dC5tb3ZlVG8oLTIgKiB0aGlzLndpZHRoLCAtMiAqIHRoaXMuaGVpZ2h0KSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oLTIgKiB0aGlzLndpZHRoLCAyICogdGhpcy5oZWlnaHQpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbygyICogdGhpcy53aWR0aCwgMiAqIHRoaXMuaGVpZ2h0KSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oMiAqIHRoaXMud2lkdGgsIC0yICogdGhpcy5oZWlnaHQpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmNsb3NlUGF0aCgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlbmRDbGlwXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9kb0ZpbGxTdHJva2VDbG9zZSgpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmNsaXAoKSwgcihpKFQucHJvdG90eXBlKSwgXCJlbmRDbGlwXCIsIHRoaXMpLmNhbGwodGhpcyksIHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fY2FjaGVkRmlsbFN0eWxlLCB0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGUsIHRoaXMuYmxlbmRNb2RlKHRoaXMuX2NhY2hlZEJsZW5kTW9kZSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaW1hZ2VcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMsIEUsIEEsIHgsIFAsIE0sIFIsIEwpIHtcbiAgICAgICAgICBfLmdpZlByb3BlcnRpZXMgJiYgXy5fYW5pbWF0ZUdpZih0aGlzLl9wSW5zdCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHUuZGVmYXVsdC5NZWRpYUVsZW1lbnQgJiYgXyBpbnN0YW5jZW9mIHUuZGVmYXVsdC5NZWRpYUVsZW1lbnQgJiYgXy5fZW5zdXJlQ2FudmFzKCk7XG4gICAgICAgICAgICB2YXIgRiA9IChGID0gdGhpcy5fdGludCAmJiBfLmNhbnZhcyA/IHRoaXMuX2dldFRpbnRlZEltYWdlQ2FudmFzKF8pIDogRikgfHwgXy5jYW52YXMgfHwgXy5lbHQsIFYgPSAxO1xuICAgICAgICAgICAgXy53aWR0aCAmJiAwIDwgXy53aWR0aCAmJiAoViA9IEYud2lkdGggLyBfLndpZHRoKSwgdGhpcy5faXNFcmFzaW5nICYmIHRoaXMuYmxlbmRNb2RlKHRoaXMuX2NhY2hlZEJsZW5kTW9kZSksIHRoaXMuZHJhd2luZ0NvbnRleHQuZHJhd0ltYWdlKEYsIFYgKiBTLCBWICogRSwgViAqIEEsIFYgKiB4LCBQLCBNLCBSLCBMKSwgdGhpcy5faXNFcmFzaW5nICYmIHRoaXMuX3BJbnN0LmVyYXNlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoRykge1xuICAgICAgICAgICAgaWYgKEcubmFtZSAhPT0gXCJOU19FUlJPUl9OT1RfQVZBSUxBQkxFXCIpXG4gICAgICAgICAgICAgIHRocm93IEc7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRUaW50ZWRJbWFnZUNhbnZhc1wiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIGlmICghXy5jYW52YXMpXG4gICAgICAgICAgICByZXR1cm4gXztcbiAgICAgICAgICBfLnRpbnRDYW52YXMgfHwgKF8udGludENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpLCBfLnRpbnRDYW52YXMud2lkdGggIT09IF8uY2FudmFzLndpZHRoICYmIChfLnRpbnRDYW52YXMud2lkdGggPSBfLmNhbnZhcy53aWR0aCksIF8udGludENhbnZhcy5oZWlnaHQgIT09IF8uY2FudmFzLmhlaWdodCAmJiAoXy50aW50Q2FudmFzLmhlaWdodCA9IF8uY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgdmFyIFMgPSBfLnRpbnRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIHJldHVybiBTLnNhdmUoKSwgUy5jbGVhclJlY3QoMCwgMCwgXy5jYW52YXMud2lkdGgsIF8uY2FudmFzLmhlaWdodCksICh0aGlzLl90aW50WzBdIDwgMjU1IHx8IHRoaXMuX3RpbnRbMV0gPCAyNTUgfHwgdGhpcy5fdGludFsyXSA8IDI1NSkgJiYgKFMuZHJhd0ltYWdlKF8uY2FudmFzLCAwLCAwKSwgUy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImx1bWlub3NpdHlcIiwgUy5kcmF3SW1hZ2UoXy5jYW52YXMsIDAsIDApLCBTLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiY29sb3JcIiwgUy5kcmF3SW1hZ2UoXy5jYW52YXMsIDAsIDApLCBTLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwibXVsdGlwbHlcIiwgUy5maWxsU3R5bGUgPSBcInJnYihcIi5jb25jYXQodGhpcy5fdGludC5zbGljZSgwLCAzKS5qb2luKFwiLCBcIiksIFwiKVwiKSwgUy5maWxsUmVjdCgwLCAwLCBfLmNhbnZhcy53aWR0aCwgXy5jYW52YXMuaGVpZ2h0KSwgUy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCIpLCBTLmdsb2JhbEFscGhhID0gdGhpcy5fdGludFszXSAvIDI1NSwgUy5kcmF3SW1hZ2UoXy5jYW52YXMsIDAsIDApLCBTLnJlc3RvcmUoKSwgXy50aW50Q2FudmFzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImJsZW5kTW9kZVwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIGlmIChfID09PSBoLlNVQlRSQUNUKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYmxlbmRNb2RlKFNVQlRSQUNUKSBvbmx5IHdvcmtzIGluIFdFQkdMIG1vZGUuXCIpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKF8gIT09IGguQkxFTkQgJiYgXyAhPT0gaC5SRU1PVkUgJiYgXyAhPT0gaC5EQVJLRVNUICYmIF8gIT09IGguTElHSFRFU1QgJiYgXyAhPT0gaC5ESUZGRVJFTkNFICYmIF8gIT09IGguTVVMVElQTFkgJiYgXyAhPT0gaC5FWENMVVNJT04gJiYgXyAhPT0gaC5TQ1JFRU4gJiYgXyAhPT0gaC5SRVBMQUNFICYmIF8gIT09IGguT1ZFUkxBWSAmJiBfICE9PSBoLkhBUkRfTElHSFQgJiYgXyAhPT0gaC5TT0ZUX0xJR0hUICYmIF8gIT09IGguRE9ER0UgJiYgXyAhPT0gaC5CVVJOICYmIF8gIT09IGguQUREKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlIFwiLmNvbmNhdChfLCBcIiBub3QgcmVjb2duaXplZC5cIikpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQmxlbmRNb2RlID0gXywgdGhpcy5kcmF3aW5nQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB7IGtleTogXCJibGVuZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IHRoaXMuZHJhd2luZ0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLCBTID0gYXJndW1lbnRzLmxlbmd0aCwgRSA9IG5ldyBBcnJheShTKSwgQSA9IDA7IEEgPCBTOyBBKyspXG4gICAgICAgICAgICBFW0FdID0gYXJndW1lbnRzW0FdO1xuICAgICAgICAgIHZhciB4ID0gRVtFLmxlbmd0aCAtIDFdLCBQID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoRSwgMCwgRS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHgsIHUuZGVmYXVsdC5wcm90b3R5cGUuY29weS5hcHBseSh0aGlzLCBQKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRQaXhlbFwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUykge1xuICAgICAgICAgIHJldHVybiBfID0gdGhpcy5kcmF3aW5nQ29udGV4dC5nZXRJbWFnZURhdGEoXywgUywgMSwgMSkuZGF0YSwgW19bMF0sIF9bMV0sIF9bMl0sIF9bM11dO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxvYWRQaXhlbHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfID0gdGhpcy5fcGl4ZWxzU3RhdGUsIFMgPSBfLl9waXhlbERlbnNpdHksIEUgPSB0aGlzLndpZHRoICogUywgUyA9IHRoaXMuaGVpZ2h0ICogUywgRSA9IHRoaXMuZHJhd2luZ0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIEUsIFMpO1xuICAgICAgICAgIF8uX3NldFByb3BlcnR5KFwiaW1hZ2VEYXRhXCIsIEUpLCBfLl9zZXRQcm9wZXJ0eShcInBpeGVsc1wiLCBFLmRhdGEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUywgRSkge1xuICAgICAgICAgIF8gPSBNYXRoLmZsb29yKF8pLCBTID0gTWF0aC5mbG9vcihTKTtcbiAgICAgICAgICB2YXIgQSA9IHRoaXMuX3BpeGVsc1N0YXRlO1xuICAgICAgICAgIGlmIChFIGluc3RhbmNlb2YgdS5kZWZhdWx0LkltYWdlKVxuICAgICAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dC5zYXZlKCksIHRoaXMuZHJhd2luZ0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApLCB0aGlzLmRyYXdpbmdDb250ZXh0LnNjYWxlKEEuX3BpeGVsRGVuc2l0eSwgQS5fcGl4ZWxEZW5zaXR5KSwgdGhpcy5kcmF3aW5nQ29udGV4dC5jbGVhclJlY3QoXywgUywgRS53aWR0aCwgRS5oZWlnaHQpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmRyYXdJbWFnZShFLmNhbnZhcywgXywgUyksIHRoaXMuZHJhd2luZ0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSAwLCBQID0gMCwgTSA9IDAsIFIgPSAwLCBMID0gNCAqIChTICogQS5fcGl4ZWxEZW5zaXR5ICogKHRoaXMud2lkdGggKiBBLl9waXhlbERlbnNpdHkpICsgXyAqIEEuX3BpeGVsRGVuc2l0eSk7XG4gICAgICAgICAgICBpZiAoQS5pbWFnZURhdGEgfHwgQS5sb2FkUGl4ZWxzKCksIHR5cGVvZiBFID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIEwgPCBBLnBpeGVscy5sZW5ndGggJiYgKE0gPSBQID0geCA9IEUsIFIgPSAyNTUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShFKSkge1xuICAgICAgICAgICAgICBpZiAoRS5sZW5ndGggPCA0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBpeGVsIGFycmF5IG11c3QgYmUgb2YgdGhlIGZvcm0gW1IsIEcsIEIsIEFdXCIpO1xuICAgICAgICAgICAgICBMIDwgQS5waXhlbHMubGVuZ3RoICYmICh4ID0gRVswXSwgUCA9IEVbMV0sIE0gPSBFWzJdLCBSID0gRVszXSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgRSBpbnN0YW5jZW9mIHUuZGVmYXVsdC5Db2xvciAmJiBMIDwgQS5waXhlbHMubGVuZ3RoICYmICh4ID0gRS5sZXZlbHNbMF0sIFAgPSBFLmxldmVsc1sxXSwgTSA9IEUubGV2ZWxzWzJdLCBSID0gRS5sZXZlbHNbM10pO1xuICAgICAgICAgICAgZm9yICh2YXIgRiA9IDA7IEYgPCBBLl9waXhlbERlbnNpdHk7IEYrKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgViA9IDA7IFYgPCBBLl9waXhlbERlbnNpdHk7IFYrKylcbiAgICAgICAgICAgICAgICBMID0gNCAqICgoUyAqIEEuX3BpeGVsRGVuc2l0eSArIFYpICogdGhpcy53aWR0aCAqIEEuX3BpeGVsRGVuc2l0eSArIChfICogQS5fcGl4ZWxEZW5zaXR5ICsgRikpLCBBLnBpeGVsc1tMXSA9IHgsIEEucGl4ZWxzW0wgKyAxXSA9IFAsIEEucGl4ZWxzW0wgKyAyXSA9IE0sIEEucGl4ZWxzW0wgKyAzXSA9IFI7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcInVwZGF0ZVBpeGVsc1wiLCB2YWx1ZTogZnVuY3Rpb24oXywgUywgRSwgQSkge1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5fcGl4ZWxzU3RhdGUsIFAgPSB4Ll9waXhlbERlbnNpdHk7XG4gICAgICAgICAgXyA9PT0gdm9pZCAwICYmIFMgPT09IHZvaWQgMCAmJiBFID09PSB2b2lkIDAgJiYgQSA9PT0gdm9pZCAwICYmIChTID0gXyA9IDAsIEUgPSB0aGlzLndpZHRoLCBBID0gdGhpcy5oZWlnaHQpLCBfICo9IFAsIFMgKj0gUCwgRSAqPSBQLCBBICo9IFAsIHRoaXMuZ2lmUHJvcGVydGllcyAmJiAodGhpcy5naWZQcm9wZXJ0aWVzLmZyYW1lc1t0aGlzLmdpZlByb3BlcnRpZXMuZGlzcGxheUluZGV4XS5pbWFnZSA9IHguaW1hZ2VEYXRhKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5wdXRJbWFnZURhdGEoeC5pbWFnZURhdGEsIF8sIFMsIDAsIDAsIEUsIEEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hY3V0ZUFyY1RvQmV6aWVyXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTKSB7XG4gICAgICAgICAgdmFyIFAgPSBTIC8gMiwgRSA9IE1hdGguY29zKFApLCBSID0gTWF0aC5zaW4oUCksIEEgPSAxIC8gTWF0aC50YW4oUCksIFAgPSBfICsgUCwgeCA9IE1hdGguY29zKFApLCBQID0gTWF0aC5zaW4oUCksIE0gPSAoNCAtIEUpIC8gMywgUiA9IFIgKyAoRSAtIE0pICogQTtcbiAgICAgICAgICByZXR1cm4geyBheDogTWF0aC5jb3MoXykudG9GaXhlZCg3KSwgYXk6IE1hdGguc2luKF8pLnRvRml4ZWQoNyksIGJ4OiAoTSAqIHggKyBSICogUCkudG9GaXhlZCg3KSwgYnk6IChNICogUCAtIFIgKiB4KS50b0ZpeGVkKDcpLCBjeDogKE0gKiB4IC0gUiAqIFApLnRvRml4ZWQoNyksIGN5OiAoTSAqIFAgKyBSICogeCkudG9GaXhlZCg3KSwgZHg6IE1hdGguY29zKF8gKyBTKS50b0ZpeGVkKDcpLCBkeTogTWF0aC5zaW4oXyArIFMpLnRvRml4ZWQoNykgfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJhcmNcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMsIEUsIEEsIHgsIFAsIE0pIHtcbiAgICAgICAgICB2YXIgUiwgTCA9IHRoaXMuZHJhd2luZ0NvbnRleHQsIEYgPSBFIC8gMiwgViA9IEEgLyAyLCBHID0gW107XG4gICAgICAgICAgZm9yIChfICs9IEYsIFMgKz0gVjsgMWUtNSA8PSBQIC0geDsgKVxuICAgICAgICAgICAgUiA9IE1hdGgubWluKFAgLSB4LCBoLkhBTEZfUEkpLCBHLnB1c2godGhpcy5fYWN1dGVBcmNUb0Jlemllcih4LCBSKSksIHggKz0gUjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZG9GaWxsICYmICh0aGlzLl9jbGlwcGluZyB8fCBMLmJlZ2luUGF0aCgpLCBHLmZvckVhY2goZnVuY3Rpb24oVSwgVykge1xuICAgICAgICAgICAgVyA9PT0gMCAmJiBMLm1vdmVUbyhfICsgVS5heCAqIEYsIFMgKyBVLmF5ICogViksIEwuYmV6aWVyQ3VydmVUbyhfICsgVS5ieCAqIEYsIFMgKyBVLmJ5ICogViwgXyArIFUuY3ggKiBGLCBTICsgVS5jeSAqIFYsIF8gKyBVLmR4ICogRiwgUyArIFUuZHkgKiBWKTtcbiAgICAgICAgICB9KSwgTSAhPT0gaC5QSUUgJiYgTSAhPSBudWxsIHx8IEwubGluZVRvKF8sIFMpLCBMLmNsb3NlUGF0aCgpLCB0aGlzLl9jbGlwcGluZyB8fCBMLmZpbGwoKSksIHRoaXMuX2RvU3Ryb2tlICYmICh0aGlzLl9jbGlwcGluZyB8fCBMLmJlZ2luUGF0aCgpLCBHLmZvckVhY2goZnVuY3Rpb24oVSwgVykge1xuICAgICAgICAgICAgVyA9PT0gMCAmJiBMLm1vdmVUbyhfICsgVS5heCAqIEYsIFMgKyBVLmF5ICogViksIEwuYmV6aWVyQ3VydmVUbyhfICsgVS5ieCAqIEYsIFMgKyBVLmJ5ICogViwgXyArIFUuY3ggKiBGLCBTICsgVS5jeSAqIFYsIF8gKyBVLmR4ICogRiwgUyArIFUuZHkgKiBWKTtcbiAgICAgICAgICB9KSwgTSA9PT0gaC5QSUUgPyAoTC5saW5lVG8oXywgUyksIEwuY2xvc2VQYXRoKCkpIDogTSA9PT0gaC5DSE9SRCAmJiBMLmNsb3NlUGF0aCgpLCB0aGlzLl9jbGlwcGluZyB8fCBMLnN0cm9rZSgpKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJlbGxpcHNlXCIsIHZhbHVlOiBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgdmFyIFMgPSB0aGlzLmRyYXdpbmdDb250ZXh0LCBFID0gdGhpcy5fZG9GaWxsLCBBID0gdGhpcy5fZG9TdHJva2UsIHggPSBwYXJzZUZsb2F0KFJbMF0pLCBQID0gcGFyc2VGbG9hdChSWzFdKSwgTSA9IHBhcnNlRmxvYXQoUlsyXSksIFIgPSBwYXJzZUZsb2F0KFJbM10pO1xuICAgICAgICAgIGlmIChFICYmICFBKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0RmlsbCgpID09PSBsKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2UgaWYgKCFFICYmIEEgJiYgdGhpcy5fZ2V0U3Ryb2tlKCkgPT09IGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB4ICs9IE0gLyAyLCBQICs9IFIgLyAyLCBNIC89IDIsIFIgLz0gMiwgdGhpcy5fY2xpcHBpbmcgfHwgUy5iZWdpblBhdGgoKSwgUy5lbGxpcHNlKHgsIFAsIE0sIFIsIDAsIDAsIDIgKiBNYXRoLlBJKSwgIXRoaXMuX2NsaXBwaW5nICYmIEUgJiYgUy5maWxsKCksICF0aGlzLl9jbGlwcGluZyAmJiBBICYmIFMuc3Ryb2tlKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibGluZVwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUywgRSwgQSkge1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5kcmF3aW5nQ29udGV4dDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZG9TdHJva2UgJiYgdGhpcy5fZ2V0U3Ryb2tlKCkgIT09IGwgJiYgKHRoaXMuX2NsaXBwaW5nIHx8IHguYmVnaW5QYXRoKCksIHgubW92ZVRvKF8sIFMpLCB4LmxpbmVUbyhFLCBBKSwgeC5zdHJva2UoKSksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicG9pbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMpIHtcbiAgICAgICAgICB2YXIgRSwgQSwgeCA9IHRoaXMuZHJhd2luZ0NvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLl9kb1N0cm9rZSB8fCB0aGlzLl9nZXRTdHJva2UoKSA9PT0gbCA/IHRoaXMgOiAoRSA9IHRoaXMuX2dldFN0cm9rZSgpLCBBID0gdGhpcy5fZ2V0RmlsbCgpLCB0aGlzLl9jbGlwcGluZyB8fCB0aGlzLl9zZXRGaWxsKEUpLCB0aGlzLl9jbGlwcGluZyB8fCB4LmJlZ2luUGF0aCgpLCB4LmFyYyhfLCBTLCB4LmxpbmVXaWR0aCAvIDIsIDAsIGguVFdPX1BJLCAhMSksIHZvaWQgKHRoaXMuX2NsaXBwaW5nIHx8ICh4LmZpbGwoKSwgdGhpcy5fc2V0RmlsbChBKSkpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJxdWFkXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTLCBFLCBBLCB4LCBQLCBNLCBSKSB7XG4gICAgICAgICAgdmFyIEwgPSB0aGlzLmRyYXdpbmdDb250ZXh0LCBGID0gdGhpcy5fZG9GaWxsLCBWID0gdGhpcy5fZG9TdHJva2U7XG4gICAgICAgICAgaWYgKEYgJiYgIVYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRGaWxsKCkgPT09IGwpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIUYgJiYgViAmJiB0aGlzLl9nZXRTdHJva2UoKSA9PT0gbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwcGluZyB8fCBMLmJlZ2luUGF0aCgpLCBMLm1vdmVUbyhfLCBTKSwgTC5saW5lVG8oRSwgQSksIEwubGluZVRvKHgsIFApLCBMLmxpbmVUbyhNLCBSKSwgTC5jbG9zZVBhdGgoKSwgIXRoaXMuX2NsaXBwaW5nICYmIEYgJiYgTC5maWxsKCksICF0aGlzLl9jbGlwcGluZyAmJiBWICYmIEwuc3Ryb2tlKCksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVjdFwiLCB2YWx1ZTogZnVuY3Rpb24oVikge1xuICAgICAgICAgIHZhciBTLCBFLCBBID0gVlswXSwgeCA9IFZbMV0sIFAgPSBWWzJdLCBNID0gVlszXSwgUiA9IFZbNF0sIEwgPSBWWzVdLCBGID0gVls2XSwgViA9IFZbN10sIEcgPSB0aGlzLmRyYXdpbmdDb250ZXh0LCBVID0gdGhpcy5fZG9GaWxsLCBXID0gdGhpcy5fZG9TdHJva2U7XG4gICAgICAgICAgaWYgKFUgJiYgIVcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRGaWxsKCkgPT09IGwpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIVUgJiYgVyAmJiB0aGlzLl9nZXRTdHJva2UoKSA9PT0gbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwcGluZyB8fCBHLmJlZ2luUGF0aCgpLCBSID09PSB2b2lkIDAgPyBHLnJlY3QoQSwgeCwgUCwgTSkgOiAoTCA9PT0gdm9pZCAwICYmIChMID0gUiksIEYgPT09IHZvaWQgMCAmJiAoRiA9IEwpLCBWID09PSB2b2lkIDAgJiYgKFYgPSBGKSwgVyA9IChVID0gTWF0aC5hYnMoUCkpIC8gMiwgRSA9IChTID0gTWF0aC5hYnMoTSkpIC8gMiwgUyA8IDIgKiAoUiA9IFUgPCAyICogUiA/IFcgOiBSKSAmJiAoUiA9IEUpLCBTIDwgMiAqIChMID0gVSA8IDIgKiBMID8gVyA6IEwpICYmIChMID0gRSksIFMgPCAyICogKEYgPSBVIDwgMiAqIEYgPyBXIDogRikgJiYgKEYgPSBFKSwgUyA8IDIgKiAoViA9IFUgPCAyICogViA/IFcgOiBWKSAmJiAoViA9IEUpLCB0aGlzLl9jbGlwcGluZyB8fCBHLmJlZ2luUGF0aCgpLCBHLm1vdmVUbyhBICsgUiwgeCksIEcuYXJjVG8oQSArIFAsIHgsIEEgKyBQLCB4ICsgTSwgTCksIEcuYXJjVG8oQSArIFAsIHggKyBNLCBBLCB4ICsgTSwgRiksIEcuYXJjVG8oQSwgeCArIE0sIEEsIHgsIFYpLCBHLmFyY1RvKEEsIHgsIEEgKyBQLCB4LCBSKSwgRy5jbG9zZVBhdGgoKSksICF0aGlzLl9jbGlwcGluZyAmJiB0aGlzLl9kb0ZpbGwgJiYgRy5maWxsKCksICF0aGlzLl9jbGlwcGluZyAmJiB0aGlzLl9kb1N0cm9rZSAmJiBHLnN0cm9rZSgpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInRyaWFuZ2xlXCIsIHZhbHVlOiBmdW5jdGlvbihGKSB7XG4gICAgICAgICAgdmFyIFMgPSB0aGlzLmRyYXdpbmdDb250ZXh0LCBFID0gdGhpcy5fZG9GaWxsLCBBID0gdGhpcy5fZG9TdHJva2UsIHggPSBGWzBdLCBQID0gRlsxXSwgTSA9IEZbMl0sIFIgPSBGWzNdLCBMID0gRls0XSwgRiA9IEZbNV07XG4gICAgICAgICAgaWYgKEUgJiYgIUEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRGaWxsKCkgPT09IGwpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIUUgJiYgQSAmJiB0aGlzLl9nZXRTdHJva2UoKSA9PT0gbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIHRoaXMuX2NsaXBwaW5nIHx8IFMuYmVnaW5QYXRoKCksIFMubW92ZVRvKHgsIFApLCBTLmxpbmVUbyhNLCBSKSwgUy5saW5lVG8oTCwgRiksIFMuY2xvc2VQYXRoKCksICF0aGlzLl9jbGlwcGluZyAmJiBFICYmIFMuZmlsbCgpLCAhdGhpcy5fY2xpcHBpbmcgJiYgQSAmJiBTLnN0cm9rZSgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImVuZFNoYXBlXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTLCBFLCBBLCB4LCBQLCBNKSB7XG4gICAgICAgICAgaWYgKFMubGVuZ3RoICE9PSAwICYmICh0aGlzLl9kb1N0cm9rZSB8fCB0aGlzLl9kb0ZpbGwpKSB7XG4gICAgICAgICAgICB2YXIgUiwgTCwgRiwgViA9IF8gPT09IGguQ0xPU0UsIEcgPSAoViAmJiAhUCAmJiBTLnB1c2goU1swXSksIFMubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChFICYmIE0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKDMgPCBHKSB7XG4gICAgICAgICAgICAgICAgdmFyIFUgPSBbXSwgVyA9IDEgLSB0aGlzLl9jdXJ2ZVRpZ2h0bmVzcztcbiAgICAgICAgICAgICAgICBmb3IgKHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuZHJhd2luZ0NvbnRleHQuYmVnaW5QYXRoKCksIHRoaXMuZHJhd2luZ0NvbnRleHQubW92ZVRvKFNbMV1bMF0sIFNbMV1bMV0pLCBMID0gMTsgTCArIDIgPCBHOyBMKyspXG4gICAgICAgICAgICAgICAgICBSID0gU1tMXSwgVVswXSA9IFtSWzBdLCBSWzFdXSwgVVsxXSA9IFtSWzBdICsgKFcgKiBTW0wgKyAxXVswXSAtIFcgKiBTW0wgLSAxXVswXSkgLyA2LCBSWzFdICsgKFcgKiBTW0wgKyAxXVsxXSAtIFcgKiBTW0wgLSAxXVsxXSkgLyA2XSwgVVsyXSA9IFtTW0wgKyAxXVswXSArIChXICogU1tMXVswXSAtIFcgKiBTW0wgKyAyXVswXSkgLyA2LCBTW0wgKyAxXVsxXSArIChXICogU1tMXVsxXSAtIFcgKiBTW0wgKyAyXVsxXSkgLyA2XSwgVVszXSA9IFtTW0wgKyAxXVswXSwgU1tMICsgMV1bMV1dLCB0aGlzLmRyYXdpbmdDb250ZXh0LmJlemllckN1cnZlVG8oVVsxXVswXSwgVVsxXVsxXSwgVVsyXVswXSwgVVsyXVsxXSwgVVszXVswXSwgVVszXVsxXSk7XG4gICAgICAgICAgICAgICAgViAmJiB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhTW0wgKyAxXVswXSwgU1tMICsgMV1bMV0pLCB0aGlzLl9kb0ZpbGxTdHJva2VDbG9zZShWKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChBICYmIE0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yICh0aGlzLl9jbGlwcGluZyB8fCB0aGlzLmRyYXdpbmdDb250ZXh0LmJlZ2luUGF0aCgpLCBMID0gMDsgTCA8IEc7IEwrKylcbiAgICAgICAgICAgICAgICBTW0xdLmlzVmVydCA/IFNbTF0ubW92ZVRvID8gdGhpcy5kcmF3aW5nQ29udGV4dC5tb3ZlVG8oU1tMXVswXSwgU1tMXVsxXSkgOiB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhTW0xdWzBdLCBTW0xdWzFdKSA6IHRoaXMuZHJhd2luZ0NvbnRleHQuYmV6aWVyQ3VydmVUbyhTW0xdWzBdLCBTW0xdWzFdLCBTW0xdWzJdLCBTW0xdWzNdLCBTW0xdWzRdLCBTW0xdWzVdKTtcbiAgICAgICAgICAgICAgdGhpcy5fZG9GaWxsU3Ryb2tlQ2xvc2UoVik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggJiYgTSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuZHJhd2luZ0NvbnRleHQuYmVnaW5QYXRoKCksIEwgPSAwOyBMIDwgRzsgTCsrKVxuICAgICAgICAgICAgICAgIFNbTF0uaXNWZXJ0ID8gU1tMXS5tb3ZlVG8gPyB0aGlzLmRyYXdpbmdDb250ZXh0Lm1vdmVUbyhTW0xdWzBdLCBTW0xdWzFdKSA6IHRoaXMuZHJhd2luZ0NvbnRleHQubGluZVRvKFNbTF1bMF0sIFNbTF1bMV0pIDogdGhpcy5kcmF3aW5nQ29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKFNbTF1bMF0sIFNbTF1bMV0sIFNbTF1bMl0sIFNbTF1bM10pO1xuICAgICAgICAgICAgICB0aGlzLl9kb0ZpbGxTdHJva2VDbG9zZShWKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTSA9PT0gaC5QT0lOVFMpXG4gICAgICAgICAgICAgIGZvciAoTCA9IDA7IEwgPCBHOyBMKyspXG4gICAgICAgICAgICAgICAgUiA9IFNbTF0sIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3BJbnN0LnN0cm9rZShSWzZdKSwgdGhpcy5fcEluc3QucG9pbnQoUlswXSwgUlsxXSk7XG4gICAgICAgICAgICBlbHNlIGlmIChNID09PSBoLkxJTkVTKVxuICAgICAgICAgICAgICBmb3IgKEwgPSAwOyBMICsgMSA8IEc7IEwgKz0gMilcbiAgICAgICAgICAgICAgICBSID0gU1tMXSwgdGhpcy5fZG9TdHJva2UgJiYgdGhpcy5fcEluc3Quc3Ryb2tlKFNbTCArIDFdWzZdKSwgdGhpcy5fcEluc3QubGluZShSWzBdLCBSWzFdLCBTW0wgKyAxXVswXSwgU1tMICsgMV1bMV0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoTSA9PT0gaC5UUklBTkdMRVMpXG4gICAgICAgICAgICAgIGZvciAoTCA9IDA7IEwgKyAyIDwgRzsgTCArPSAzKVxuICAgICAgICAgICAgICAgIFIgPSBTW0xdLCB0aGlzLl9jbGlwcGluZyB8fCB0aGlzLmRyYXdpbmdDb250ZXh0LmJlZ2luUGF0aCgpLCB0aGlzLmRyYXdpbmdDb250ZXh0Lm1vdmVUbyhSWzBdLCBSWzFdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgMV1bMF0sIFNbTCArIDFdWzFdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgMl1bMF0sIFNbTCArIDJdWzFdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5jbG9zZVBhdGgoKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvRmlsbCAmJiAodGhpcy5fcEluc3QuZmlsbChTW0wgKyAyXVs1XSksIHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbCgpKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmICh0aGlzLl9wSW5zdC5zdHJva2UoU1tMICsgMl1bNl0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE0gPT09IGguVFJJQU5HTEVfU1RSSVApXG4gICAgICAgICAgICAgIGZvciAoTCA9IDA7IEwgKyAxIDwgRzsgTCsrKVxuICAgICAgICAgICAgICAgIFIgPSBTW0xdLCB0aGlzLl9jbGlwcGluZyB8fCB0aGlzLmRyYXdpbmdDb250ZXh0LmJlZ2luUGF0aCgpLCB0aGlzLmRyYXdpbmdDb250ZXh0Lm1vdmVUbyhTW0wgKyAxXVswXSwgU1tMICsgMV1bMV0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhSWzBdLCBSWzFdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3BJbnN0LnN0cm9rZShTW0wgKyAxXVs2XSksICF0aGlzLl9jbGlwcGluZyAmJiB0aGlzLl9kb0ZpbGwgJiYgdGhpcy5fcEluc3QuZmlsbChTW0wgKyAxXVs1XSksIEwgKyAyIDwgRyAmJiAodGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgMl1bMF0sIFNbTCArIDJdWzFdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3BJbnN0LnN0cm9rZShTW0wgKyAyXVs2XSksICF0aGlzLl9jbGlwcGluZyAmJiB0aGlzLl9kb0ZpbGwgJiYgdGhpcy5fcEluc3QuZmlsbChTW0wgKyAyXVs1XSkpLCB0aGlzLl9kb0ZpbGxTdHJva2VDbG9zZShWKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE0gPT09IGguVFJJQU5HTEVfRkFOKSB7XG4gICAgICAgICAgICAgIGlmICgyIDwgRykge1xuICAgICAgICAgICAgICAgIGZvciAodGhpcy5fY2xpcHBpbmcgfHwgdGhpcy5kcmF3aW5nQ29udGV4dC5iZWdpblBhdGgoKSwgTCA9IDI7IEwgPCBHOyBMKyspXG4gICAgICAgICAgICAgICAgICBSID0gU1tMXSwgdGhpcy5kcmF3aW5nQ29udGV4dC5tb3ZlVG8oU1swXVswXSwgU1swXVsxXSksIHRoaXMuZHJhd2luZ0NvbnRleHQubGluZVRvKFNbTCAtIDFdWzBdLCBTW0wgLSAxXVsxXSksIHRoaXMuZHJhd2luZ0NvbnRleHQubGluZVRvKFJbMF0sIFJbMV0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhTWzBdWzBdLCBTWzBdWzFdKSwgTCA8IEcgLSAxICYmICh0aGlzLl9kb0ZpbGwgJiYgUls1XSAhPT0gU1tMICsgMV1bNV0gfHwgdGhpcy5fZG9TdHJva2UgJiYgUls2XSAhPT0gU1tMICsgMV1bNl0pICYmICghdGhpcy5fY2xpcHBpbmcgJiYgdGhpcy5fZG9GaWxsICYmICh0aGlzLl9wSW5zdC5maWxsKFJbNV0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGwoKSwgdGhpcy5fcEluc3QuZmlsbChTW0wgKyAxXVs1XSkpLCAhdGhpcy5fY2xpcHBpbmcgJiYgdGhpcy5fZG9TdHJva2UgJiYgKHRoaXMuX3BJbnN0LnN0cm9rZShSWzZdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5zdHJva2UoKSwgdGhpcy5fcEluc3Quc3Ryb2tlKFNbTCArIDFdWzZdKSksIHRoaXMuZHJhd2luZ0NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuZHJhd2luZ0NvbnRleHQuYmVnaW5QYXRoKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvRmlsbFN0cm9rZUNsb3NlKFYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE0gPT09IGguUVVBRFMpXG4gICAgICAgICAgICAgIGZvciAoTCA9IDA7IEwgKyAzIDwgRzsgTCArPSA0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChSID0gU1tMXSwgdGhpcy5fY2xpcHBpbmcgfHwgdGhpcy5kcmF3aW5nQ29udGV4dC5iZWdpblBhdGgoKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5tb3ZlVG8oUlswXSwgUlsxXSksIEYgPSAxOyBGIDwgNDsgRisrKVxuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgRl1bMF0sIFNbTCArIEZdWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhSWzBdLCBSWzFdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvRmlsbCAmJiB0aGlzLl9wSW5zdC5maWxsKFNbTCArIDNdWzVdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3BJbnN0LnN0cm9rZShTW0wgKyAzXVs2XSksIHRoaXMuX2RvRmlsbFN0cm9rZUNsb3NlKFYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNID09PSBoLlFVQURfU1RSSVApIHtcbiAgICAgICAgICAgICAgaWYgKDMgPCBHKVxuICAgICAgICAgICAgICAgIGZvciAoTCA9IDA7IEwgKyAxIDwgRzsgTCArPSAyKVxuICAgICAgICAgICAgICAgICAgUiA9IFNbTF0sIHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuZHJhd2luZ0NvbnRleHQuYmVnaW5QYXRoKCksIEwgKyAzIDwgRyA/ICh0aGlzLmRyYXdpbmdDb250ZXh0Lm1vdmVUbyhTW0wgKyAyXVswXSwgU1tMICsgMl1bMV0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhSWzBdLCBSWzFdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgMV1bMF0sIFNbTCArIDFdWzFdKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5saW5lVG8oU1tMICsgM11bMF0sIFNbTCArIDNdWzFdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvRmlsbCAmJiB0aGlzLl9wSW5zdC5maWxsKFNbTCArIDNdWzVdKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3BJbnN0LnN0cm9rZShTW0wgKyAzXVs2XSkpIDogKHRoaXMuZHJhd2luZ0NvbnRleHQubW92ZVRvKFJbMF0sIFJbMV0pLCB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhTW0wgKyAxXVswXSwgU1tMICsgMV1bMV0pKSwgdGhpcy5fZG9GaWxsU3Ryb2tlQ2xvc2UoVik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuZHJhd2luZ0NvbnRleHQuYmVnaW5QYXRoKCksIHRoaXMuZHJhd2luZ0NvbnRleHQubW92ZVRvKFNbMF1bMF0sIFNbMF1bMV0pLCBMID0gMTsgTCA8IEc7IEwrKylcbiAgICAgICAgICAgICAgICAoUiA9IFNbTF0pLmlzVmVydCAmJiAoUi5tb3ZlVG8gPyAoViAmJiB0aGlzLmRyYXdpbmdDb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLmRyYXdpbmdDb250ZXh0Lm1vdmVUbyhSWzBdLCBSWzFdKSkgOiB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVUbyhSWzBdLCBSWzFdKSk7XG4gICAgICAgICAgICAgIHRoaXMuX2RvRmlsbFN0cm9rZUNsb3NlKFYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IHggPSBBID0gRSA9ICExLCBWICYmIFMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0cm9rZUNhcFwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIHJldHVybiBfICE9PSBoLlJPVU5EICYmIF8gIT09IGguU1FVQVJFICYmIF8gIT09IGguUFJPSkVDVCB8fCAodGhpcy5kcmF3aW5nQ29udGV4dC5saW5lQ2FwID0gXyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic3Ryb2tlSm9pblwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIHJldHVybiBfICE9PSBoLlJPVU5EICYmIF8gIT09IGguQkVWRUwgJiYgXyAhPT0gaC5NSVRFUiB8fCAodGhpcy5kcmF3aW5nQ29udGV4dC5saW5lSm9pbiA9IF8pLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0cm9rZVdlaWdodFwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdpbmdDb250ZXh0LmxpbmVXaWR0aCA9IF8gPT09IHZvaWQgMCB8fCBfID09PSAwID8gMWUtNCA6IF8sIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEZpbGxcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRGaWxsU3R5bGUgfHwgKHRoaXMuX2NhY2hlZEZpbGxTdHlsZSA9IHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbFN0eWxlKSwgdGhpcy5fY2FjaGVkRmlsbFN0eWxlO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9zZXRGaWxsXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgXyAhPT0gdGhpcy5fY2FjaGVkRmlsbFN0eWxlICYmICh0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGxTdHlsZSA9IF8sIHRoaXMuX2NhY2hlZEZpbGxTdHlsZSA9IF8pO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRTdHJva2VcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRTdHJva2VTdHlsZSB8fCAodGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGUgPSB0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVN0eWxlKSwgdGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGU7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NldFN0cm9rZVwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIF8gIT09IHRoaXMuX2NhY2hlZFN0cm9rZVN0eWxlICYmICh0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gXywgdGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGUgPSBfKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJiZXppZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMsIEUsIEEsIHgsIFAsIE0sIFIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcEluc3QuYmVnaW5TaGFwZSgpLCB0aGlzLl9wSW5zdC52ZXJ0ZXgoXywgUyksIHRoaXMuX3BJbnN0LmJlemllclZlcnRleChFLCBBLCB4LCBQLCBNLCBSKSwgdGhpcy5fcEluc3QuZW5kU2hhcGUoKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJjdXJ2ZVwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUywgRSwgQSwgeCwgUCwgTSwgUikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wSW5zdC5iZWdpblNoYXBlKCksIHRoaXMuX3BJbnN0LmN1cnZlVmVydGV4KF8sIFMpLCB0aGlzLl9wSW5zdC5jdXJ2ZVZlcnRleChFLCBBKSwgdGhpcy5fcEluc3QuY3VydmVWZXJ0ZXgoeCwgUCksIHRoaXMuX3BJbnN0LmN1cnZlVmVydGV4KE0sIFIpLCB0aGlzLl9wSW5zdC5lbmRTaGFwZSgpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9kb0ZpbGxTdHJva2VDbG9zZVwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIF8gJiYgdGhpcy5kcmF3aW5nQ29udGV4dC5jbG9zZVBhdGgoKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvRmlsbCAmJiB0aGlzLmRyYXdpbmdDb250ZXh0LmZpbGwoKSwgIXRoaXMuX2NsaXBwaW5nICYmIHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuZHJhd2luZ0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYXBwbHlNYXRyaXhcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMsIEUsIEEsIHgsIFApIHtcbiAgICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0LnRyYW5zZm9ybShfLCBTLCBFLCBBLCB4LCBQKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZXNldE1hdHJpeFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2luZ0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApLCB0aGlzLmRyYXdpbmdDb250ZXh0LnNjYWxlKHRoaXMuX3BJbnN0Ll9waXhlbERlbnNpdHksIHRoaXMuX3BJbnN0Ll9waXhlbERlbnNpdHkpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJvdGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQucm90YXRlKF8pO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNjYWxlXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2luZ0NvbnRleHQuc2NhbGUoXywgUyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidHJhbnNsYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTKSB7XG4gICAgICAgICAgcmV0dXJuIF8gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yICYmIChTID0gXy55LCBfID0gXy54KSwgdGhpcy5kcmF3aW5nQ29udGV4dC50cmFuc2xhdGUoXywgUyksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3JlbmRlclRleHRcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIFMsIEUsIEEsIHgsIFApIHtcbiAgICAgICAgICBpZiAoIShBIDwgUCB8fCB4IDw9IEEpKVxuICAgICAgICAgICAgcmV0dXJuIF8ucHVzaCgpLCB0aGlzLl9pc09wZW5UeXBlKCkgPyB0aGlzLl90ZXh0Rm9udC5fcmVuZGVyUGF0aChTLCBFLCBBLCB7IHJlbmRlcmVyOiB0aGlzIH0pIDogKHRoaXMuX2RvU3Ryb2tlICYmIHRoaXMuX3N0cm9rZVNldCAmJiB0aGlzLmRyYXdpbmdDb250ZXh0LnN0cm9rZVRleHQoUywgRSwgQSksICF0aGlzLl9jbGlwcGluZyAmJiB0aGlzLl9kb0ZpbGwgJiYgKHRoaXMuX2ZpbGxTZXQgfHwgdGhpcy5fc2V0RmlsbChoLl9ERUZBVUxUX1RFWFRfRklMTCksIHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbFRleHQoUywgRSwgQSkpKSwgXy5wb3AoKSwgXztcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0ZXh0V2lkdGhcIiwgdmFsdWU6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuVHlwZSgpID8gdGhpcy5fdGV4dEZvbnQuX3RleHRXaWR0aChfLCB0aGlzLl90ZXh0U2l6ZSkgOiB0aGlzLmRyYXdpbmdDb250ZXh0Lm1lYXN1cmVUZXh0KF8pLndpZHRoO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hcHBseVRleHRQcm9wZXJ0aWVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgXyA9IHRoaXMuX3BJbnN0LCBTID0gKHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHRBc2NlbnRcIiwgbnVsbCksIHRoaXMuX3NldFByb3BlcnR5KFwiX3RleHREZXNjZW50XCIsIG51bGwpLCBTID0gdGhpcy5fdGV4dEZvbnQsIHRoaXMuX2lzT3BlblR5cGUoKSAmJiAoUyA9IHRoaXMuX3RleHRGb250LmZvbnQuZmFtaWx5TmFtZSwgdGhpcy5fc2V0UHJvcGVydHkoXCJfdGV4dFN0eWxlXCIsIHRoaXMuX3RleHRGb250LmZvbnQuc3R5bGVOYW1lKSksIFMgfHwgXCJzYW5zLXNlcmlmXCIpO1xuICAgICAgICAgIHJldHVybiAvXFxzLy5leGVjKFMpICYmIChTID0gJ1wiJy5jb25jYXQoUywgJ1wiJykpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh0aGlzLl90ZXh0U3R5bGUgfHwgXCJub3JtYWxcIiwgXCIgXCIpLmNvbmNhdCh0aGlzLl90ZXh0U2l6ZSB8fCAxMiwgXCJweCBcIikuY29uY2F0KFMpLCB0aGlzLmRyYXdpbmdDb250ZXh0LnRleHRBbGlnbiA9IHRoaXMuX3RleHRBbGlnbiwgdGhpcy5fdGV4dEJhc2VsaW5lID09PSBoLkNFTlRFUiA/IHRoaXMuZHJhd2luZ0NvbnRleHQudGV4dEJhc2VsaW5lID0gaC5fQ1RYX01JRERMRSA6IHRoaXMuZHJhd2luZ0NvbnRleHQudGV4dEJhc2VsaW5lID0gdGhpcy5fdGV4dEJhc2VsaW5lLCBfO1xuICAgICAgICB9IH0sIHsga2V5OiBcInB1c2hcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdpbmdDb250ZXh0LnNhdmUoKSwgcihpKFQucHJvdG90eXBlKSwgXCJwdXNoXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicG9wXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dC5yZXN0b3JlKCksIHRoaXMuX2NhY2hlZEZpbGxTdHlsZSA9IHRoaXMuZHJhd2luZ0NvbnRleHQuZmlsbFN0eWxlLCB0aGlzLl9jYWNoZWRTdHJva2VTdHlsZSA9IHRoaXMuZHJhd2luZ0NvbnRleHQuc3Ryb2tlU3R5bGUsIHIoaShULnByb3RvdHlwZSksIFwicG9wXCIsIHRoaXMpLmNhbGwodGhpcywgXyk7XG4gICAgICAgIH0gfV0pICYmIGYocC5wcm90b3R5cGUsIGMpLCBUO1xuICAgICAgfSh1LmRlZmF1bHQuUmVuZGVyZXIpLCBhID0gKG4ucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihjLCBwLCBqLCBFLCBfKSB7XG4gICAgICAgIEUgIT09IHZvaWQgMCAmJiB0aGlzLmRyYXdpbmdDb250ZXh0LnRleHRCYXNlbGluZSA9PT0gaC5CQVNFTElORSAmJiAoUyA9ICEwLCB0aGlzLmRyYXdpbmdDb250ZXh0LnRleHRCYXNlbGluZSA9IGguVE9QKTtcbiAgICAgICAgdmFyIFMsIEUgPSB1LmRlZmF1bHQuUmVuZGVyZXIucHJvdG90eXBlLnRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIFMgJiYgKHRoaXMuZHJhd2luZ0NvbnRleHQudGV4dEJhc2VsaW5lID0gaC5CQVNFTElORSksIEU7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXIyRCA9IG4sIHUuZGVmYXVsdC5SZW5kZXJlcjJEKTtcbiAgICAgIEMuZGVmYXVsdCA9IGE7XG4gICAgfSwgeyBcIi4vY29uc3RhbnRzXCI6IDI2OSwgXCIuL21haW5cIjogMjgwLCBcIi4vcDUuUmVuZGVyZXJcIjogMjgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCI6IDE1NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIjogMTYwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIjogMTczLCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWRcIjogMTgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjogMTg1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIjogMTg5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiOiAxOTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI4NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIik7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4vbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5fcHJvbWlzZVByZWxvYWRzID0gW107XG4gICAgICBmdW5jdGlvbiB5KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgdSA9ICEobS5kZWZhdWx0LnByb3RvdHlwZS5yZWdpc3RlclByb21pc2VQcmVsb2FkID0gZnVuY3Rpb24oaCkge1xuICAgICAgICBtLmRlZmF1bHQucHJvdG90eXBlLl9wcm9taXNlUHJlbG9hZHMucHVzaChoKTtcbiAgICAgIH0pO1xuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5fc2V0dXBQcm9taXNlUHJlbG9hZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGggPSAhMCwgZyA9ICExLCBmID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIHIsIHMgPSB0aGlzLl9wcm9taXNlUHJlbG9hZHNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKGggPSAociA9IHMubmV4dCgpKS5kb25lKTsgaCA9ICEwKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHIudmFsdWUsIGkgPSB0aGlzLCBsID0gby5tZXRob2QsIG4gPSBvLmFkZENhbGxiYWNrcywgYSA9IG8ubGVnYWN5UHJlbG9hZFNldHVwLCBjID0gby50YXJnZXQgfHwgdGhpcywgcCA9IGNbbF0uYmluZChjKTtcbiAgICAgICAgICAgIGlmIChjID09PSBtLmRlZmF1bHQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgIGlmICh1KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpID0gbnVsbCwgcCA9IGNbbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjW2xdID0gdGhpcy5fd3JhcFByb21pc2VQcmVsb2FkKGksIHAsIG4pLCBhICYmIChjW2EubWV0aG9kXSA9IHRoaXMuX2xlZ2FjeVByZWxvYWRHZW5lcmF0b3IoaSwgYSwgY1tsXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaikge1xuICAgICAgICAgIGcgPSAhMCwgZiA9IGo7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGggfHwgcy5yZXR1cm4gPT0gbnVsbCB8fCBzLnJldHVybigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZylcbiAgICAgICAgICAgICAgdGhyb3cgZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdSA9ICEwO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fd3JhcFByb21pc2VQcmVsb2FkID0gZnVuY3Rpb24oaCwgZywgZikge1xuICAgICAgICB2YXIgciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIHMgPSB0aGlzLCBvID0gKHRoaXMuX2luY3JlbWVudFByZWxvYWQoKSwgbnVsbCksIGkgPSBudWxsLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheShsKSwgYSA9IDA7IGEgPCBsOyBhKyspXG4gICAgICAgICAgICBuW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IG4ubGVuZ3RoIC0gMTsgMCA8PSBjICYmICFpICYmIHR5cGVvZiBuW2NdID09IFwiZnVuY3Rpb25cIjsgYy0tKVxuICAgICAgICAgICAgICBpID0gbywgbyA9IG4ucG9wKCk7XG4gICAgICAgICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoZy5hcHBseSh0aGlzLCBuKSk7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgcC50aGVuKG8pLCBpICYmIHAuY2F0Y2goaSksIHAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzLl9kZWNyZW1lbnRQcmVsb2FkKCk7XG4gICAgICAgICAgfSksIHA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByID0gaCA/IHIuYmluZChoKSA6IHI7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLl9sZWdhY3lQcmVsb2FkR2VuZXJhdG9yID0gZnVuY3Rpb24oaCwgcywgZikge1xuICAgICAgICB2YXIgciA9IHMuY3JlYXRlQmFzZU9iamVjdCB8fCB5LCBzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2luY3JlbWVudFByZWxvYWQoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgbCA9IG5ldyBBcnJheShpKSwgbiA9IDA7IG4gPCBpOyBuKyspXG4gICAgICAgICAgICBsW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICAgIHZhciBhID0gci5hcHBseSh0aGlzLCBsKTtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBsKS50aGVuKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYSwgYyksIG8uX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgICAgICB9KSwgYTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHMgPSBoID8gcy5iaW5kKGgpIDogcztcbiAgICAgIH07XG4gICAgfSwgeyBcIi4vbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiOiAxODEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCI6IDE4OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI4NjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvO1xuICAgICAgICB9IDogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBvICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICAgICAgICB9KShzKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHkgPSAociA9IHQoXCIuL21haW5cIikpICYmIHIuX19lc01vZHVsZSA/IHIgOiB7IGRlZmF1bHQ6IHIgfSwgdSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBnKHMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBzIH07XG4gICAgICAgIHZhciBvID0gaCgpO1xuICAgICAgICBpZiAobyAmJiBvLmhhcyhzKSlcbiAgICAgICAgICByZXR1cm4gby5nZXQocyk7XG4gICAgICAgIHZhciBpLCBsID0ge30sIG4gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChpIGluIHMpIHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgaSkgJiYgKChhID0gbiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocywgaSkgOiBudWxsKSAmJiAoYS5nZXQgfHwgYS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGksIGEpIDogbFtpXSA9IHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsLmRlZmF1bHQgPSBzLCBvICYmIG8uc2V0KHMsIGwpLCBsO1xuICAgICAgfSh0KFwiLi9jb25zdGFudHNcIikpO1xuICAgICAgZnVuY3Rpb24gaCgpIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGcocykge1xuICAgICAgICByZXR1cm4gKGcgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG0obyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShvKTtcbiAgICAgICAgfSkocyk7XG4gICAgICB9XG4gICAgICB0KFwiLi9wNS5HcmFwaGljc1wiKSwgdChcIi4vcDUuUmVuZGVyZXIyRFwiKSwgdChcIi4uL3dlYmdsL3A1LlJlbmRlcmVyR0xcIik7XG4gICAgICB2YXIgZiA9IFwiZGVmYXVsdENhbnZhczBcIiwgciA9ICh5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKHMsIG8sIGksIGwpIHtcbiAgICAgICAgdmFyIG4sIGEsIGM7XG4gICAgICAgIGlmICh5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUNhbnZhc1wiLCBhcmd1bWVudHMpLCBhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCA/IChpID0gdS5QMkQsIGwgPSBhcmd1bWVudHNbMl0pIDogbiA9IGkgfHwgdS5QMkQsIGwpXG4gICAgICAgICAgKGMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKSkgJiYgYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLCBjID0gbCwgdGhpcy5fZGVmYXVsdEdyYXBoaWNzQ3JlYXRlZCA9ICExO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobiA9PT0gdS5XRUJHTClcbiAgICAgICAgICAgIChjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZikpICYmIChjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksIGEgPSB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICByZXR1cm4gaiAhPT0gYTtcbiAgICAgICAgICAgIH0pKSwgKGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKS5pZCA9IGYsIGMuY2xhc3NMaXN0LmFkZChcInA1Q2FudmFzXCIpO1xuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2RlZmF1bHRHcmFwaGljc0NyZWF0ZWQpXG4gICAgICAgICAgICBjID0gdGhpcy5jYW52YXM7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjID0gbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVmYXVsdENhbnZhc1wiLmNvbmNhdChwKSk7IClcbiAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgZiA9IFwiZGVmYXVsdENhbnZhc1wiLmNvbmNhdChwKSwgYy5pZCA9IGYsIGMuY2xhc3NMaXN0LmFkZChcInA1Q2FudmFzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZXR1cERvbmUgfHwgKGMuZGF0YXNldC5oaWRkZW4gPSAhMCwgYy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiksICh0aGlzLl91c2VyTm9kZSB8fCAoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYWluXCIpLmxlbmd0aCA9PT0gMCAmJiAoaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGkpKSwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYWluXCIpWzBdKSkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4gPT09IHUuV0VCR0wgPyAodGhpcy5fc2V0UHJvcGVydHkoXCJfcmVuZGVyZXJcIiwgbmV3IHkuZGVmYXVsdC5SZW5kZXJlckdMKGMsIHRoaXMsICEwKSksIHRoaXMuX2VsZW1lbnRzLnB1c2godGhpcy5fcmVuZGVyZXIpLCBzID0gKGwgPSB0aGlzLl9yZW5kZXJlci5fYWRqdXN0RGltZW5zaW9ucyhzLCBvKSkuYWRqdXN0ZWRXaWR0aCwgbyA9IGwuYWRqdXN0ZWRIZWlnaHQpIDogdGhpcy5fZGVmYXVsdEdyYXBoaWNzQ3JlYXRlZCB8fCAodGhpcy5fc2V0UHJvcGVydHkoXCJfcmVuZGVyZXJcIiwgbmV3IHkuZGVmYXVsdC5SZW5kZXJlcjJEKGMsIHRoaXMsICEwKSksIHRoaXMuX2RlZmF1bHRHcmFwaGljc0NyZWF0ZWQgPSAhMCwgdGhpcy5fZWxlbWVudHMucHVzaCh0aGlzLl9yZW5kZXJlcikpLCB0aGlzLl9yZW5kZXJlci5yZXNpemUocywgbyksIHRoaXMuX3JlbmRlcmVyLl9hcHBseURlZmF1bHRzKCksIHRoaXMuX3JlbmRlcmVyO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5yZXNpemVDYW52YXMgPSBmdW5jdGlvbihzLCBvLCBpKSB7XG4gICAgICAgIGlmICh5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInJlc2l6ZUNhbnZhc1wiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlcikge1xuICAgICAgICAgIHZhciBsLCBuLCBhLCBjID0ge307XG4gICAgICAgICAgZm9yIChsIGluIHRoaXMuZHJhd2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5kcmF3aW5nQ29udGV4dFtsXTtcbiAgICAgICAgICAgIGcocCkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHAgIT0gXCJmdW5jdGlvblwiICYmIChjW2xdID0gcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYSBpbiB0aGlzLl9yZW5kZXJlciBpbnN0YW5jZW9mIHkuZGVmYXVsdC5SZW5kZXJlckdMICYmIChzID0gKG4gPSB0aGlzLl9yZW5kZXJlci5fYWRqdXN0RGltZW5zaW9ucyhzLCBvKSkuYWRqdXN0ZWRXaWR0aCwgbyA9IG4uYWRqdXN0ZWRIZWlnaHQpLCB0aGlzLndpZHRoID0gcywgdGhpcy5oZWlnaHQgPSBvLCB0aGlzLl9yZW5kZXJlci5yZXNpemUocywgbyksIGMpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0W2FdID0gY1thXTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGkgfHwgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRBY2NzT3V0cHV0KCkgJiYgdGhpcy5fdXBkYXRlQWNjc091dHB1dCgpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5ub0NhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlR3JhcGhpY3MgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBsID0gbmV3IEFycmF5KDIgPCBpID8gaSAtIDIgOiAwKSwgbiA9IDI7IG4gPCBpOyBuKyspXG4gICAgICAgICAgbFtuIC0gMl0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIHJldHVybiBsWzBdIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgKGxbMV0gPSBsWzBdLCBsWzBdID0gdS5QMkQpLCB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUdyYXBoaWNzXCIsIGFyZ3VtZW50cyksIG5ldyB5LmRlZmF1bHQuR3JhcGhpY3MocywgbywgbFswXSwgdGhpcywgbFsxXSk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUZyYW1lYnVmZmVyID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbmV3IHkuZGVmYXVsdC5GcmFtZWJ1ZmZlcih0aGlzLCBzKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJjbGVhckRlcHRoXCIpLCB0aGlzLl9yZW5kZXJlci5jbGVhckRlcHRoKHMpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5ibGVuZE1vZGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYmxlbmRNb2RlXCIsIGFyZ3VtZW50cyksIHMgPT09IHUuTk9STUFMICYmIChjb25zb2xlLndhcm4oXCJOT1JNQUwgaGFzIGJlZW4gZGVwcmVjYXRlZCBmb3IgdXNlIGluIGJsZW5kTW9kZS4gZGVmYXVsdGluZyB0byBCTEVORCBpbnN0ZWFkLlwiKSwgcyA9IHUuQkxFTkQpLCB0aGlzLl9yZW5kZXJlci5ibGVuZE1vZGUocyk7XG4gICAgICB9LCB5LmRlZmF1bHQpO1xuICAgICAgQy5kZWZhdWx0ID0gcjtcbiAgICB9LCB7IFwiLi4vd2ViZ2wvcDUuUmVuZGVyZXJHTFwiOiAzMzcsIFwiLi9jb25zdGFudHNcIjogMjY5LCBcIi4vbWFpblwiOiAyODAsIFwiLi9wNS5HcmFwaGljc1wiOiAyODIsIFwiLi9wNS5SZW5kZXJlcjJEXCI6IDI4NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCI6IDE1NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI4NzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBpO1xuICAgICAgICB9KShvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkobykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIG0oaSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgaS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGkgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShpKTtcbiAgICAgICAgfSkobyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gcih0KFwiLi4vbWFpblwiKSksIGggPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmIChvICYmIG8uX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgaWYgKG8gPT09IG51bGwgfHwgeShvKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogbyB9O1xuICAgICAgICB2YXIgaSA9IGYoKTtcbiAgICAgICAgaWYgKGkgJiYgaS5oYXMobykpXG4gICAgICAgICAgcmV0dXJuIGkuZ2V0KG8pO1xuICAgICAgICB2YXIgbCwgbiA9IHt9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAobCBpbiBvKSB7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGwpICYmICgoYyA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIGwpIDogbnVsbCkgJiYgKGMuZ2V0IHx8IGMuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBsLCBjKSA6IG5bbF0gPSBvW2xdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5kZWZhdWx0ID0gbywgaSAmJiBpLnNldChvLCBuKSwgbjtcbiAgICAgIH0odChcIi4uL2NvbnN0YW50c1wiKSksIGcgPSByKHQoXCIuLi9oZWxwZXJzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIHZhciBvO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChvID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSwgbyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gJiYgby5fX2VzTW9kdWxlID8gbyA6IHsgZGVmYXVsdDogbyB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBuID0gbmV3IEFycmF5KGkubGVuZ3RoKTsgbCA8IGkubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgIG5bbF0gPSBpW2xdO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KG8pIHx8IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaSkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpKTtcbiAgICAgICAgfShvKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIHQoXCIuLi9mcmllbmRseV9lcnJvcnMvZmVzX2NvcmVcIiksIHQoXCIuLi9mcmllbmRseV9lcnJvcnMvZmlsZV9lcnJvcnNcIiksIHQoXCIuLi9mcmllbmRseV9lcnJvcnMvdmFsaWRhdGVfcGFyYW1zXCIpLCB1LmRlZmF1bHQucHJvdG90eXBlLl9ub3JtYWxpemVBcmNBbmdsZXMgPSBmdW5jdGlvbihvLCBpLCBsLCBuLCBhKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICByZXR1cm4gbyAtPSBoLlRXT19QSSAqIE1hdGguZmxvb3IobyAvIGguVFdPX1BJKSwgaSAtPSBoLlRXT19QSSAqIE1hdGguZmxvb3IoaSAvIGguVFdPX1BJKSwgYyA9IE1hdGgubWluKE1hdGguYWJzKG8gLSBpKSwgaC5UV09fUEkgLSBNYXRoLmFicyhvIC0gaSkpLCBhICYmIChvID0gbyA8PSBoLkhBTEZfUEkgPyBNYXRoLmF0YW4obCAvIG4gKiBNYXRoLnRhbihvKSkgOiBvID4gaC5IQUxGX1BJICYmIG8gPD0gMyAqIGguSEFMRl9QSSA/IE1hdGguYXRhbihsIC8gbiAqIE1hdGgudGFuKG8pKSArIGguUEkgOiBNYXRoLmF0YW4obCAvIG4gKiBNYXRoLnRhbihvKSkgKyBoLlRXT19QSSwgaSA9IGkgPD0gaC5IQUxGX1BJID8gTWF0aC5hdGFuKGwgLyBuICogTWF0aC50YW4oaSkpIDogaSA+IGguSEFMRl9QSSAmJiBpIDw9IDMgKiBoLkhBTEZfUEkgPyBNYXRoLmF0YW4obCAvIG4gKiBNYXRoLnRhbihpKSkgKyBoLlBJIDogTWF0aC5hdGFuKGwgLyBuICogTWF0aC50YW4oaSkpICsgaC5UV09fUEkpLCBpIDwgbyAmJiAoaSArPSBoLlRXT19QSSksIHsgc3RhcnQ6IG8sIHN0b3A6IGksIGNvcnJlc3BvbmRUb1NhbWVQb2ludDogYyA8IDFlLTUgfTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24obywgaSwgbCwgbiwgYSwgYywgcCwgaikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJhcmNcIiwgYXJndW1lbnRzKSwgKHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSB8fCB0aGlzLl9yZW5kZXJlci5fZG9GaWxsKSAmJiBhICE9PSBjICYmIChhID0gdGhpcy5fdG9SYWRpYW5zKGEpLCBjID0gdGhpcy5fdG9SYWRpYW5zKGMpLCBsID0gTWF0aC5hYnMobCksIG4gPSBNYXRoLmFicyhuKSwgbyA9IGcuZGVmYXVsdC5tb2RlQWRqdXN0KG8sIGksIGwsIG4sIHRoaXMuX3JlbmRlcmVyLl9lbGxpcHNlTW9kZSksIChpID0gdGhpcy5fbm9ybWFsaXplQXJjQW5nbGVzKGEsIGMsIG8udywgby5oLCAhMCkpLmNvcnJlc3BvbmRUb1NhbWVQb2ludCA/IHRoaXMuX3JlbmRlcmVyLmVsbGlwc2UoW28ueCwgby55LCBvLncsIG8uaCwgal0pIDogKHRoaXMuX3JlbmRlcmVyLmFyYyhvLngsIG8ueSwgby53LCBvLmgsIGkuc3RhcnQsIGkuc3RvcCwgcCwgaiksICh0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy5ncmlkIHx8IHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHQpICYmIHRoaXMuX2FjY3NPdXRwdXQoXCJhcmNcIiwgW28ueCwgby55LCBvLncsIG8uaCwgaS5zdGFydCwgaS5zdG9wLCBwXSkpKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uKG8sIGksIGwsIG4sIGEpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZWxsaXBzZVwiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJFbGxpcHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IG5ldyBBcnJheShvKSwgbCA9IDA7IGwgPCBvOyBsKyspXG4gICAgICAgICAgaVtsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgICAgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjaXJjbGVcIiwgaSk7XG4gICAgICAgIHZhciBuID0gaS5zbGljZSgwLCAyKTtcbiAgICAgICAgcmV0dXJuIG4ucHVzaChpWzJdLCBpWzJdKSwgdGhpcy5fcmVuZGVyRWxsaXBzZS5hcHBseSh0aGlzLCBzKG4pKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuX3JlbmRlckVsbGlwc2UgPSBmdW5jdGlvbihvLCBpLCBsLCBuLCBhKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlIHx8IHRoaXMuX3JlbmRlcmVyLl9kb0ZpbGwpICYmIChsIDwgMCAmJiAobCA9IE1hdGguYWJzKGwpKSwgbiA9PT0gdm9pZCAwID8gbiA9IGwgOiBuIDwgMCAmJiAobiA9IE1hdGguYWJzKG4pKSwgbyA9IGcuZGVmYXVsdC5tb2RlQWRqdXN0KG8sIGksIGwsIG4sIHRoaXMuX3JlbmRlcmVyLl9lbGxpcHNlTW9kZSksIHRoaXMuX3JlbmRlcmVyLmVsbGlwc2UoW28ueCwgby55LCBvLncsIG8uaCwgYV0pLCAodGhpcy5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZCB8fCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy50ZXh0KSAmJiB0aGlzLl9hY2NzT3V0cHV0KFwiZWxsaXBzZVwiLCBbby54LCBvLnksIG8udywgby5oXSkpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIG8sIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBsID0gbmV3IEFycmF5KGkpLCBuID0gMDsgbiA8IGk7IG4rKylcbiAgICAgICAgICBsW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsaW5lXCIsIGwpLCB0aGlzLl9yZW5kZXJlci5fZG9TdHJva2UgJiYgKG8gPSB0aGlzLl9yZW5kZXJlcikubGluZS5hcHBseShvLCBsKSwgKHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLmdyaWQgfHwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMudGV4dCkgJiYgdGhpcy5fYWNjc091dHB1dChcImxpbmVcIiwgbCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIG8sIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBsID0gbmV3IEFycmF5KGkpLCBuID0gMDsgbiA8IGk7IG4rKylcbiAgICAgICAgICBsW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJwb2ludFwiLCBsKSwgdGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlICYmIChsLmxlbmd0aCA9PT0gMSAmJiBsWzBdIGluc3RhbmNlb2YgdS5kZWZhdWx0LlZlY3RvciA/IHRoaXMuX3JlbmRlcmVyLnBvaW50LmNhbGwodGhpcy5fcmVuZGVyZXIsIGxbMF0ueCwgbFswXS55LCBsWzBdLnopIDogKChvID0gdGhpcy5fcmVuZGVyZXIpLnBvaW50LmFwcGx5KG8sIGwpLCAodGhpcy5fYWNjZXNzaWJsZU91dHB1dHMuZ3JpZCB8fCB0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy50ZXh0KSAmJiB0aGlzLl9hY2NzT3V0cHV0KFwicG9pbnRcIiwgbCkpKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucXVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBvLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgbCA9IG5ldyBBcnJheShpKSwgbiA9IDA7IG4gPCBpOyBuKyspXG4gICAgICAgICAgbFtuXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwicXVhZFwiLCBsKSwgKHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSB8fCB0aGlzLl9yZW5kZXJlci5fZG9GaWxsKSAmJiAodGhpcy5fcmVuZGVyZXIuaXNQM0QgJiYgbC5sZW5ndGggPCAxMiA/IHRoaXMuX3JlbmRlcmVyLnF1YWQuY2FsbCh0aGlzLl9yZW5kZXJlciwgbFswXSwgbFsxXSwgMCwgbFsyXSwgbFszXSwgMCwgbFs0XSwgbFs1XSwgMCwgbFs2XSwgbFs3XSwgMCwgbFs4XSwgbFs5XSkgOiAoKG8gPSB0aGlzLl9yZW5kZXJlcikucXVhZC5hcHBseShvLCBsKSwgKHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLmdyaWQgfHwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMudGV4dCkgJiYgdGhpcy5fYWNjc091dHB1dChcInF1YWRyaWxhdGVyYWxcIiwgbCkpKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IG5ldyBBcnJheShvKSwgbCA9IDA7IGwgPCBvOyBsKyspXG4gICAgICAgICAgaVtsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwicmVjdFwiLCBpKSwgdGhpcy5fcmVuZGVyUmVjdC5hcHBseSh0aGlzLCBpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24obywgaSwgbCwgbiwgYSwgYywgcCkge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzcXVhcmVcIiwgYXJndW1lbnRzKSwgdGhpcy5fcmVuZGVyUmVjdC5jYWxsKHRoaXMsIG8sIGksIGwsIGwsIG4sIGEsIGMsIHApO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fcmVuZGVyUmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlIHx8IHRoaXMuX3JlbmRlcmVyLl9kb0ZpbGwpIHtcbiAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIChhcmd1bWVudHNbM10gPSBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGZvciAodmFyIG8gPSBnLmRlZmF1bHQubW9kZUFkanVzdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIHRoaXMuX3JlbmRlcmVyLl9yZWN0TW9kZSksIGkgPSBbby54LCBvLnksIG8udywgby5oXSwgbCA9IDQ7IGwgPCBhcmd1bWVudHMubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICBpW2xdID0gYXJndW1lbnRzW2xdO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlY3QoaSksICh0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy5ncmlkIHx8IHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHQpICYmIHRoaXMuX2FjY3NPdXRwdXQoXCJyZWN0YW5nbGVcIiwgW28ueCwgby55LCBvLncsIG8uaF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IG5ldyBBcnJheShvKSwgbCA9IDA7IGwgPCBvOyBsKyspXG4gICAgICAgICAgaVtsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwidHJpYW5nbGVcIiwgaSksICh0aGlzLl9yZW5kZXJlci5fZG9TdHJva2UgfHwgdGhpcy5fcmVuZGVyZXIuX2RvRmlsbCkgJiYgdGhpcy5fcmVuZGVyZXIudHJpYW5nbGUoaSksICh0aGlzLl9hY2Nlc3NpYmxlT3V0cHV0cy5ncmlkIHx8IHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLnRleHQpICYmIHRoaXMuX2FjY3NPdXRwdXQoXCJ0cmlhbmdsZVwiLCBpKSwgdGhpcztcbiAgICAgIH0sIHQgPSB1LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCI6IDI3MSwgXCIuLi9mcmllbmRseV9lcnJvcnMvZmlsZV9lcnJvcnNcIjogMjcyLCBcIi4uL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIjogMjc1LCBcIi4uL2hlbHBlcnNcIjogMjc2LCBcIi4uL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI4ODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocikge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBzO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBzO1xuICAgICAgICB9KShyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocikge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIG0ocyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShzKTtcbiAgICAgICAgfSkocik7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAoZiA9IHQoXCIuLi9tYWluXCIpKSAmJiBmLl9fZXNNb2R1bGUgPyBmIDogeyBkZWZhdWx0OiBmIH0sIGggPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmIChyICYmIHIuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgaWYgKHIgPT09IG51bGwgfHwgeShyKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogciB9O1xuICAgICAgICB2YXIgcyA9IGcoKTtcbiAgICAgICAgaWYgKHMgJiYgcy5oYXMocikpXG4gICAgICAgICAgcmV0dXJuIHMuZ2V0KHIpO1xuICAgICAgICB2YXIgbywgaSA9IHt9LCBsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAobyBpbiByKSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG8pICYmICgobiA9IGwgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIG8pIDogbnVsbCkgJiYgKG4uZ2V0IHx8IG4uc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCBuKSA6IGlbb10gPSByW29dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5kZWZhdWx0ID0gciwgcyAmJiBzLnNldChyLCBpKSwgaTtcbiAgICAgIH0odChcIi4uL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAociA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIHIpO1xuICAgICAgfVxuICAgICAgdS5kZWZhdWx0LnByb3RvdHlwZS5lbGxpcHNlTW9kZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZWxsaXBzZU1vZGVcIiwgYXJndW1lbnRzKSwgciAhPT0gaC5DT1JORVIgJiYgciAhPT0gaC5DT1JORVJTICYmIHIgIT09IGguUkFESVVTICYmIHIgIT09IGguQ0VOVEVSIHx8ICh0aGlzLl9yZW5kZXJlci5fZWxsaXBzZU1vZGUgPSByKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUubm9TbW9vdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmlzUDNEID8gdGhpcy5zZXRBdHRyaWJ1dGVzKFwiYW50aWFsaWFzXCIsICExKSA6IFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5kcmF3aW5nQ29udGV4dCAmJiAodGhpcy5kcmF3aW5nQ29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSAhMSksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnJlY3RNb2RlID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJyZWN0TW9kZVwiLCBhcmd1bWVudHMpLCByICE9PSBoLkNPUk5FUiAmJiByICE9PSBoLkNPUk5FUlMgJiYgciAhPT0gaC5SQURJVVMgJiYgciAhPT0gaC5DRU5URVIgfHwgKHRoaXMuX3JlbmRlcmVyLl9yZWN0TW9kZSA9IHIpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5zbW9vdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlcyhcImFudGlhbGlhc1wiLCAhMCksIHRoaXMuX3JlbmRlcmVyLmlzUDNEIHx8IFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5kcmF3aW5nQ29udGV4dCAmJiAodGhpcy5kcmF3aW5nQ29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSAhMCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnN0cm9rZUNhcCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic3Ryb2tlQ2FwXCIsIGFyZ3VtZW50cyksIHIgIT09IGguUk9VTkQgJiYgciAhPT0gaC5TUVVBUkUgJiYgciAhPT0gaC5QUk9KRUNUIHx8IHRoaXMuX3JlbmRlcmVyLnN0cm9rZUNhcChyKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuc3Ryb2tlSm9pbiA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic3Ryb2tlSm9pblwiLCBhcmd1bWVudHMpLCByICE9PSBoLlJPVU5EICYmIHIgIT09IGguQkVWRUwgJiYgciAhPT0gaC5NSVRFUiB8fCB0aGlzLl9yZW5kZXJlci5zdHJva2VKb2luKHIpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5zdHJva2VXZWlnaHQgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInN0cm9rZVdlaWdodFwiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5zdHJva2VXZWlnaHQociksIHRoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGYgPSB1LmRlZmF1bHQ7XG4gICAgICBDLmRlZmF1bHQgPSBmO1xuICAgIH0sIHsgXCIuLi9jb25zdGFudHNcIjogMjY5LCBcIi4uL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMjg5OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAoeSA9IHQoXCIuLi9tYWluXCIpKSAmJiB5Ll9fZXNNb2R1bGUgPyB5IDogeyBkZWZhdWx0OiB5IH07XG4gICAgICB0KFwiLi4vZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCIpLCB0KFwiLi4vZnJpZW5kbHlfZXJyb3JzL2ZpbGVfZXJyb3JzXCIpLCB0KFwiLi4vZnJpZW5kbHlfZXJyb3JzL3ZhbGlkYXRlX3BhcmFtc1wiKSwgbS5kZWZhdWx0LnByb3RvdHlwZS5iZXppZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdSwgaCA9IGFyZ3VtZW50cy5sZW5ndGgsIGcgPSBuZXcgQXJyYXkoaCksIGYgPSAwOyBmIDwgaDsgZisrKVxuICAgICAgICAgIGdbZl0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImJlemllclwiLCBnKSwgKHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSB8fCB0aGlzLl9yZW5kZXJlci5fZG9GaWxsKSAmJiAodSA9IHRoaXMuX3JlbmRlcmVyKS5iZXppZXIuYXBwbHkodSwgZyksIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmJlemllckRldGFpbCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYmV6aWVyRGV0YWlsXCIsIGFyZ3VtZW50cyksIHRoaXMuX2JlemllckRldGFpbCA9IHUsIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmJlemllclBvaW50ID0gZnVuY3Rpb24odSwgaCwgZywgZiwgcikge1xuICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImJlemllclBvaW50XCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzID0gMSAtIHI7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhzLCAzKSAqIHUgKyAzICogTWF0aC5wb3cocywgMikgKiByICogaCArIDMgKiBzICogTWF0aC5wb3cociwgMikgKiBnICsgTWF0aC5wb3cociwgMykgKiBmO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5iZXppZXJUYW5nZW50ID0gZnVuY3Rpb24odSwgaCwgZywgZiwgcikge1xuICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImJlemllclRhbmdlbnRcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHMgPSAxIC0gcjtcbiAgICAgICAgcmV0dXJuIDMgKiBmICogTWF0aC5wb3cociwgMikgLSAzICogZyAqIE1hdGgucG93KHIsIDIpICsgNiAqIGcgKiBzICogciAtIDYgKiBoICogcyAqIHIgKyAzICogaCAqIE1hdGgucG93KHMsIDIpIC0gMyAqIHUgKiBNYXRoLnBvdyhzLCAyKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuY3VydmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdSwgaCA9IGFyZ3VtZW50cy5sZW5ndGgsIGcgPSBuZXcgQXJyYXkoaCksIGYgPSAwOyBmIDwgaDsgZisrKVxuICAgICAgICAgIGdbZl0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImN1cnZlXCIsIGcpLCB0aGlzLl9yZW5kZXJlci5fZG9TdHJva2UgJiYgKHUgPSB0aGlzLl9yZW5kZXJlcikuY3VydmUuYXBwbHkodSwgZyksIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmN1cnZlRGV0YWlsID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjdXJ2ZURldGFpbFwiLCBhcmd1bWVudHMpLCB0aGlzLl9jdXJ2ZURldGFpbCA9IHUgPCAzID8gMyA6IHUsIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmN1cnZlVGlnaHRuZXNzID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjdXJ2ZVRpZ2h0bmVzc1wiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5fY3VydmVUaWdodG5lc3MgPSB1LCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5jdXJ2ZVBvaW50ID0gZnVuY3Rpb24odSwgaCwgZywgZiwgcikge1xuICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImN1cnZlUG9pbnRcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9yZW5kZXJlci5fY3VydmVUaWdodG5lc3MsIG8gPSByICogciAqIHIsIGkgPSByICogcjtcbiAgICAgICAgcmV0dXJuIHUgKiAoKHMgLSAxKSAvIDIgKiBvICsgKDEgLSBzKSAqIGkgKyAocyAtIDEpIC8gMiAqIHIpICsgaCAqICgocyArIDMpIC8gMiAqIG8gKyAoLTUgLSBzKSAvIDIgKiBpICsgMSkgKyBnICogKCgtMyAtIHMpIC8gMiAqIG8gKyAocyArIDIpICogaSArICgxIC0gcykgLyAyICogcikgKyBmICogKCgxIC0gcykgLyAyICogbyArIChzIC0gMSkgLyAyICogaSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmN1cnZlVGFuZ2VudCA9IGZ1bmN0aW9uKHUsIGgsIGcsIGYsIGkpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjdXJ2ZVRhbmdlbnRcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9yZW5kZXJlci5fY3VydmVUaWdodG5lc3MsIG8gPSBpICogaSAqIDMsIGkgPSAyICogaTtcbiAgICAgICAgcmV0dXJuIHUgKiAoKHMgLSAxKSAvIDIgKiBvICsgKDEgLSBzKSAqIGkgKyAocyAtIDEpIC8gMikgKyBoICogKChzICsgMykgLyAyICogbyArICgtNSAtIHMpIC8gMiAqIGkpICsgZyAqICgoLTMgLSBzKSAvIDIgKiBvICsgKHMgKyAyKSAqIGkgKyAoMSAtIHMpIC8gMikgKyBmICogKCgxIC0gcykgLyAyICogbyArIChzIC0gMSkgLyAyICogaSk7XG4gICAgICB9O1xuICAgICAgdmFyIHkgPSBtLmRlZmF1bHQ7XG4gICAgICBDLmRlZmF1bHQgPSB5O1xuICAgIH0sIHsgXCIuLi9mcmllbmRseV9lcnJvcnMvZmVzX2NvcmVcIjogMjcxLCBcIi4uL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiOiAyNzIsIFwiLi4vZnJpZW5kbHlfZXJyb3JzL3ZhbGlkYXRlX3BhcmFtc1wiOiAyNzUsIFwiLi4vbWFpblwiOiAyODAgfV0sIDI5MDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocCkge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBqO1xuICAgICAgICB9IDogZnVuY3Rpb24oaikge1xuICAgICAgICAgIHJldHVybiBqICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBqO1xuICAgICAgICB9KShwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocCkge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIG0oaik7XG4gICAgICAgIH0gOiBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIGogJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShqKTtcbiAgICAgICAgfSkocCk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAoYyA9IHQoXCIuLi9tYWluXCIpKSAmJiBjLl9fZXNNb2R1bGUgPyBjIDogeyBkZWZhdWx0OiBjIH0sIGggPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIGlmIChwICYmIHAuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgaWYgKHAgPT09IG51bGwgfHwgeShwKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogcCB9O1xuICAgICAgICB2YXIgaiA9IGcoKTtcbiAgICAgICAgaWYgKGogJiYgai5oYXMocCkpXG4gICAgICAgICAgcmV0dXJuIGouZ2V0KHApO1xuICAgICAgICB2YXIgVCwgXyA9IHt9LCBTID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAoVCBpbiBwKSB7XG4gICAgICAgICAgdmFyIEU7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsIFQpICYmICgoRSA9IFMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIFQpIDogbnVsbCkgJiYgKEUuZ2V0IHx8IEUuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBULCBFKSA6IF9bVF0gPSBwW1RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy5kZWZhdWx0ID0gcCwgaiAmJiBqLnNldChwLCBfKSwgXztcbiAgICAgIH0odChcIi4uL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAocCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIHApO1xuICAgICAgfVxuICAgICAgdmFyIGYgPSBudWxsLCByID0gW10sIHMgPSBbXSwgbyA9ICExLCBpID0gITEsIGwgPSAhMSwgbiA9ICExLCBhID0gITAsIGMgPSAodS5kZWZhdWx0LnByb3RvdHlwZS5iZWdpbkNvbnRvdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmlzUDNEID8gdGhpcy5fcmVuZGVyZXIuYmVnaW5Db250b3VyKCkgOiAocyA9IFtdLCBuID0gITApLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5iZWdpblNoYXBlID0gZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgajtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYmVnaW5TaGFwZVwiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5pc1AzRCA/IChqID0gdGhpcy5fcmVuZGVyZXIpLmJlZ2luU2hhcGUuYXBwbHkoaiwgYXJndW1lbnRzKSA6IChmID0gcCA9PT0gaC5QT0lOVFMgfHwgcCA9PT0gaC5MSU5FUyB8fCBwID09PSBoLlRSSUFOR0xFUyB8fCBwID09PSBoLlRSSUFOR0xFX0ZBTiB8fCBwID09PSBoLlRSSUFOR0xFX1NUUklQIHx8IHAgPT09IGguUVVBRFMgfHwgcCA9PT0gaC5RVUFEX1NUUklQID8gcCA6IG51bGwsIHIgPSBbXSwgcyA9IFtdKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuYmV6aWVyVmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAsIGogPSBhcmd1bWVudHMubGVuZ3RoLCBUID0gbmV3IEFycmF5KGopLCBfID0gMDsgXyA8IGo7IF8rKylcbiAgICAgICAgICBUW19dID0gYXJndW1lbnRzW19dO1xuICAgICAgICBpZiAodS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJiZXppZXJWZXJ0ZXhcIiwgVCksIHRoaXMuX3JlbmRlcmVyLmlzUDNEKVxuICAgICAgICAgIChwID0gdGhpcy5fcmVuZGVyZXIpLmJlemllclZlcnRleC5hcHBseShwLCBUKTtcbiAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDApXG4gICAgICAgICAgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwidmVydGV4KCkgbXVzdCBiZSB1c2VkIG9uY2UgYmVmb3JlIGNhbGxpbmcgYmV6aWVyVmVydGV4KClcIiwgXCJiZXppZXJWZXJ0ZXhcIik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG8gPSAhMDtcbiAgICAgICAgICBmb3IgKHZhciBTID0gW10sIEUgPSAwOyBFIDwgVC5sZW5ndGg7IEUrKylcbiAgICAgICAgICAgIFNbRV0gPSBUW0VdO1xuICAgICAgICAgIFMuaXNWZXJ0ID0gITEsIChuID8gcyA6IHIpLnB1c2goUyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmN1cnZlVmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAsIGogPSBhcmd1bWVudHMubGVuZ3RoLCBUID0gbmV3IEFycmF5KGopLCBfID0gMDsgXyA8IGo7IF8rKylcbiAgICAgICAgICBUW19dID0gYXJndW1lbnRzW19dO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjdXJ2ZVZlcnRleFwiLCBUKSwgdGhpcy5fcmVuZGVyZXIuaXNQM0QgPyAocCA9IHRoaXMuX3JlbmRlcmVyKS5jdXJ2ZVZlcnRleC5hcHBseShwLCBUKSA6IChpID0gITAsIHRoaXMudmVydGV4KFRbMF0sIFRbMV0pKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZW5kQ29udG91ciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmlzUDNEKSB7XG4gICAgICAgICAgdmFyIHAgPSBzWzBdLnNsaWNlKCk7XG4gICAgICAgICAgcC5pc1ZlcnQgPSBzWzBdLmlzVmVydCwgcC5tb3ZlVG8gPSAhMSwgcy5wdXNoKHApLCBhICYmIChyLnB1c2goclswXSksIGEgPSAhMSk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgci5wdXNoKHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5lbmRTaGFwZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGogPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgIGlmICh1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImVuZFNoYXBlXCIsIGFyZ3VtZW50cyksIGogPCAxICYmIChjb25zb2xlLmxvZyhcIvCfjLggcDUuanMgc2F5czogWW91IGNhbiBub3QgaGF2ZSBsZXNzIHRoYW4gb25lIGluc3RhbmNlXCIpLCBqID0gMSksIHRoaXMuX3JlbmRlcmVyLmlzUDNEKVxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVuZFNoYXBlKHAsIGksIG8sIGwsIG4sIGYsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaiAhPT0gMSAmJiBjb25zb2xlLmxvZyhcIvCfjLggcDUuanMgc2F5czogSW5zdGFuY2luZyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIgbW9kZVwiKSwgci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSAmJiAhdGhpcy5fcmVuZGVyZXIuX2RvRmlsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIGogPSBwID09PSBoLkNMT1NFLCBqICYmICFuICYmIHIucHVzaChyWzBdKSwgdGhpcy5fcmVuZGVyZXIuZW5kU2hhcGUocCwgciwgaSwgbywgbCwgbiwgZiksIGEgPSAhKG4gPSBsID0gbyA9IGkgPSAhMSksIGogJiYgci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucXVhZHJhdGljVmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAsIGogPSBhcmd1bWVudHMubGVuZ3RoLCBUID0gbmV3IEFycmF5KGopLCBfID0gMDsgXyA8IGo7IF8rKylcbiAgICAgICAgICBUW19dID0gYXJndW1lbnRzW19dO1xuICAgICAgICBpZiAodS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJxdWFkcmF0aWNWZXJ0ZXhcIiwgVCksIHRoaXMuX3JlbmRlcmVyLmlzUDNEKVxuICAgICAgICAgIChwID0gdGhpcy5fcmVuZGVyZXIpLnF1YWRyYXRpY1ZlcnRleC5hcHBseShwLCBUKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbnRvdXJJbml0ZWQpXG4gICAgICAgICAgICByZXR1cm4gKHAgPSB7fSkueCA9IFRbMF0sIHAueSA9IFRbMV0sIHAueDMgPSBUWzJdLCBwLnkzID0gVFszXSwgcC50eXBlID0gaC5RVUFEUkFUSUMsIHRoaXMuX2NvbnRvdXJWZXJ0aWNlcy5wdXNoKHApLCB0aGlzO1xuICAgICAgICAgIGlmICgwIDwgci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGwgPSAhMDtcbiAgICAgICAgICAgIGZvciAodmFyIFMgPSBbXSwgRSA9IDA7IEUgPCBULmxlbmd0aDsgRSsrKVxuICAgICAgICAgICAgICBTW0VdID0gVFtFXTtcbiAgICAgICAgICAgIFMuaXNWZXJ0ID0gITEsIChuID8gcyA6IHIpLnB1c2goUyk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB1LmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJ2ZXJ0ZXgoKSBtdXN0IGJlIHVzZWQgb25jZSBiZWZvcmUgY2FsbGluZyBxdWFkcmF0aWNWZXJ0ZXgoKVwiLCBcInF1YWRyYXRpY1ZlcnRleFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUudmVydGV4ID0gZnVuY3Rpb24ocCwgaiwgVCwgXywgUykge1xuICAgICAgICB2YXIgRTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmlzUDNEID8gKEUgPSB0aGlzLl9yZW5kZXJlcikudmVydGV4LmFwcGx5KEUsIGFyZ3VtZW50cykgOiAoKEUgPSBbXSkuaXNWZXJ0ID0gITAsIEVbMF0gPSBwLCBFWzFdID0gaiwgRVsyXSA9IDAsIEVbM10gPSAwLCBFWzRdID0gMCwgRVs1XSA9IHRoaXMuX3JlbmRlcmVyLl9nZXRGaWxsKCksIEVbNl0gPSB0aGlzLl9yZW5kZXJlci5fZ2V0U3Ryb2tlKCksIFQgJiYgKEUubW92ZVRvID0gVCksIChuID8gKHMubGVuZ3RoID09PSAwICYmIChFLm1vdmVUbyA9ICEwKSwgcykgOiByKS5wdXNoKEUpKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24ocCwgaiwgVCkge1xuICAgICAgICB2YXIgXztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwibm9ybWFsXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcIm5vcm1hbFwiLCBhcmd1bWVudHMpLCAoXyA9IHRoaXMuX3JlbmRlcmVyKS5ub3JtYWwuYXBwbHkoXywgYXJndW1lbnRzKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdCk7XG4gICAgICBDLmRlZmF1bHQgPSBjO1xuICAgIH0sIHsgXCIuLi9jb25zdGFudHNcIjogMjY5LCBcIi4uL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyOTE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgfSwge31dLCAyOTI6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwLCB0ID0gKHQgPSB0KFwiLi9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH0sIHQuZGVmYXVsdC5wcm90b3R5cGUubm9Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSAhMTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sb29wIHx8ICh0aGlzLl9sb29wID0gITAsIHRoaXMuX3NldHVwRG9uZSAmJiB0aGlzLl9kcmF3KCkpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5pc0xvb3BpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzLnB1c2goeyBwcm9wczogeyBfY29sb3JNb2RlOiB0aGlzLl9jb2xvck1vZGUgfSwgcmVuZGVyZXI6IHRoaXMuX3JlbmRlcmVyLnB1c2goKSB9KTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5fc3R5bGVzLnBvcCgpO1xuICAgICAgICBtID8gKHRoaXMuX3JlbmRlcmVyLnBvcChtLnJlbmRlcmVyKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBtLnByb3BzKSkgOiBjb25zb2xlLndhcm4oXCJwb3AoKSB3YXMgY2FsbGVkIHdpdGhvdXQgbWF0Y2hpbmcgcHVzaCgpXCIpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5Vc2VyRHJhdyAmJiB0aGlzLl9zZXR1cERvbmUpIHtcbiAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KG0pLCB1ID0gKChpc05hTih5KSB8fCB5IDwgMSkgJiYgKHkgPSAxKSwgdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHUuZHJhdyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHUuc2V0dXAgPT09IHZvaWQgMCAmJiB1LnNjYWxlKHUuX3BpeGVsRGVuc2l0eSwgdS5fcGl4ZWxEZW5zaXR5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgeTsgaCsrKSB7XG4gICAgICAgICAgICAgIHUucmVzZXRNYXRyaXgoKSwgKHRoaXMuX2FjY2Vzc2libGVPdXRwdXRzLmdyaWQgfHwgdGhpcy5fYWNjZXNzaWJsZU91dHB1dHMudGV4dCkgJiYgdGhpcy5fdXBkYXRlQWNjc091dHB1dCgpLCB1Ll9yZW5kZXJlci5pc1AzRCAmJiB1Ll9yZW5kZXJlci5fdXBkYXRlKCksIHUuX3NldFByb3BlcnR5KFwiZnJhbWVDb3VudFwiLCB1LmZyYW1lQ291bnQgKyAxKSwgdGhpcy5jYWxsUmVnaXN0ZXJlZEhvb2tzRm9yKFwicHJlXCIpLCB0aGlzLl9pblVzZXJEcmF3ID0gITA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdS5kcmF3KCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5Vc2VyRHJhdyA9ICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuY2FsbFJlZ2lzdGVyZWRIb29rc0ZvcihcInBvc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0ID0gdC5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCI6IDE4MSB9XSwgMjkzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4vbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24geSh1KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGcgPSAwLCBmID0gbmV3IEFycmF5KGgubGVuZ3RoKTsgZyA8IGgubGVuZ3RoOyBnKyspXG4gICAgICAgICAgICAgIGZbZ10gPSBoW2ddO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgfVxuICAgICAgICB9KHUpIHx8IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChoKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaCkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShoKTtcbiAgICAgICAgfSh1KSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIG0uZGVmYXVsdC5wcm90b3R5cGUuYXBwbHlNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHUgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSBpbnN0YW5jZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSB8fCB1ID8gKHUgPSB0aGlzLl9yZW5kZXJlcikuYXBwbHlNYXRyaXguYXBwbHkodSwgeShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pKSA6ICh1ID0gdGhpcy5fcmVuZGVyZXIpLmFwcGx5TWF0cml4LmFwcGx5KHUsIGFyZ3VtZW50cyksIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnJlc2V0TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZXNldE1hdHJpeCgpLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInJvdGF0ZVwiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5yb3RhdGUodGhpcy5fdG9SYWRpYW5zKHUpLCBoKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUucm90YXRlWCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwicm90YXRlWFwiKSwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJyb3RhdGVYXCIsIGFyZ3VtZW50cyksIHRoaXMuX3JlbmRlcmVyLnJvdGF0ZVgodGhpcy5fdG9SYWRpYW5zKHUpKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwicm90YXRlWVwiKSwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJyb3RhdGVZXCIsIGFyZ3VtZW50cyksIHRoaXMuX3JlbmRlcmVyLnJvdGF0ZVkodGhpcy5fdG9SYWRpYW5zKHUpKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUucm90YXRlWiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwicm90YXRlWlwiKSwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJyb3RhdGVaXCIsIGFyZ3VtZW50cyksIHRoaXMuX3JlbmRlcmVyLnJvdGF0ZVoodGhpcy5fdG9SYWRpYW5zKHUpKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICAgIHZhciBmO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzY2FsZVwiLCBhcmd1bWVudHMpLCB1IGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/ICh1ID0gKGYgPSB1KS54LCBoID0gZi55LCBnID0gZi56KSA6IEFycmF5LmlzQXJyYXkodSkgJiYgKHUgPSAoZiA9IHUpWzBdLCBoID0gZlsxXSwgZyA9IGZbMl0gfHwgMSksIGlzTmFOKGgpID8gaCA9IGcgPSB1IDogaXNOYU4oZykgJiYgKGcgPSAxKSwgdGhpcy5fcmVuZGVyZXIuc2NhbGUodSwgaCwgZyksIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnNoZWFyWCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic2hlYXJYXCIsIGFyZ3VtZW50cyksIHUgPSB0aGlzLl90b1JhZGlhbnModSksIHRoaXMuX3JlbmRlcmVyLmFwcGx5TWF0cml4KDEsIDAsIE1hdGgudGFuKHUpLCAxLCAwLCAwKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc2hlYXJZID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzaGVhcllcIiwgYXJndW1lbnRzKSwgdSA9IHRoaXMuX3RvUmFkaWFucyh1KSwgdGhpcy5fcmVuZGVyZXIuYXBwbHlNYXRyaXgoMSwgTWF0aC50YW4odSksIDAsIDEsIDAsIDApLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInRyYW5zbGF0ZVwiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5pc1AzRCA/IHRoaXMuX3JlbmRlcmVyLnRyYW5zbGF0ZSh1LCBoLCBnKSA6IHRoaXMuX3JlbmRlcmVyLnRyYW5zbGF0ZSh1LCBoKSwgdGhpcztcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4vbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCI6IDE4NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIjogMjE4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiOiAyMTksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCI6IDIyMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIjogMjIzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCI6IDIyNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiOiAyMjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiOiAyMjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiOiAyMjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiOiAyMjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIjogMjI5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIjogMjMwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiOiAyMzEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIjogMjMyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCI6IDIzMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIjogMjM0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCI6IDIzNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCI6IDIzNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIjogMjM5LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMjk0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShnKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGY7XG4gICAgICAgIH0gOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuIGYgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgZi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGYgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGY7XG4gICAgICAgIH0pKGcpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKTtcbiAgICAgIHZhciB5ID0gKHQgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH07XG4gICAgICBmdW5jdGlvbiB1KGcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsIHMgPSBuZXcgQXJyYXkoZi5sZW5ndGgpOyByIDwgZi5sZW5ndGg7IHIrKylcbiAgICAgICAgICAgICAgc1tyXSA9IGZbcl07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgIH0oZykgfHwgZnVuY3Rpb24oZikge1xuICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGYpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIilcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGYpO1xuICAgICAgICB9KGcpIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaChnKSB7XG4gICAgICAgIHJldHVybiAoaCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gbShmKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBmLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKGYpO1xuICAgICAgICB9KShnKTtcbiAgICAgIH1cbiAgICAgIHkuZGVmYXVsdC5wcm90b3R5cGUuc3RvcmVJdGVtID0gZnVuY3Rpb24oZywgZikge1xuICAgICAgICB0eXBlb2YgZyAhPSBcInN0cmluZ1wiICYmIGNvbnNvbGUubG9nKFwiVGhlIGFyZ3VtZW50IHRoYXQgeW91IHBhc3NlZCB0byBzdG9yZUl0ZW0oKSAtIFwiLmNvbmNhdChnLCBcIiBpcyBub3QgYSBzdHJpbmcuXCIpKSwgZy5lbmRzV2l0aChcInA1VHlwZUlEXCIpICYmIGNvbnNvbGUubG9nKFwiVGhlIGFyZ3VtZW50IHRoYXQgeW91IHBhc3NlZCB0byBzdG9yZUl0ZW0oKSAtIFwiLmNvbmNhdChnLCBcIiBtdXN0IG5vdCBlbmQgd2l0aCAncDVUeXBlSUQnLlwiKSksIGYgPT09IHZvaWQgMCAmJiBjb25zb2xlLmxvZyhcIllvdSBjYW5ub3Qgc3RvcmUgdW5kZWZpbmVkIHZhcmlhYmxlcyB1c2luZyBzdG9yZUl0ZW0oKS5cIik7XG4gICAgICAgIHZhciByID0gaChmKTtcbiAgICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBmID0gZi50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgZiBpbnN0YW5jZW9mIHkuZGVmYXVsdC5Db2xvciA/IHIgPSBcInA1LkNvbG9yXCIgOiBmIGluc3RhbmNlb2YgeS5kZWZhdWx0LlZlY3RvciAmJiAociA9IFwicDUuVmVjdG9yXCIsIGYgPSBbZi54LCBmLnksIGYuel0pLCBmID0gSlNPTi5zdHJpbmdpZnkoZik7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZywgZiksIGcgPSBcIlwiLmNvbmNhdChnLCBcInA1VHlwZUlEXCIpLCBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnLCByKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIGYgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnKSwgciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiXCIuY29uY2F0KGcsIFwicDVUeXBlSURcIikpO1xuICAgICAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIGRldGVybWluZSB0eXBlIG9mIGl0ZW0gc3RvcmVkIHVuZGVyIFwiLmNvbmNhdChnLCBcImluIGxvY2FsIHN0b3JhZ2UuIERpZCB5b3Ugc2F2ZSB0aGUgaXRlbSB3aXRoIHNvbWV0aGluZyBvdGhlciB0aGFuIHNldEl0ZW0oKT9cIikpO1xuICAgICAgICBlbHNlIGlmIChmICE9PSBudWxsKVxuICAgICAgICAgIHN3aXRjaCAocikge1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICBmID0gcGFyc2VGbG9hdChmKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICBmID0gZiA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBmID0gSlNPTi5wYXJzZShmKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicDUuQ29sb3JcIjpcbiAgICAgICAgICAgICAgZiA9IEpTT04ucGFyc2UoZiksIGYgPSB0aGlzLmNvbG9yLmFwcGx5KHRoaXMsIHUoZi5sZXZlbHMpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicDUuVmVjdG9yXCI6XG4gICAgICAgICAgICAgIGYgPSBKU09OLnBhcnNlKGYpLCBmID0gdGhpcy5jcmVhdGVWZWN0b3IuYXBwbHkodGhpcywgdShmKSk7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY2xlYXJTdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBmLmVuZHNXaXRoKFwicDVUeXBlSURcIikgJiYgZy5yZW1vdmVJdGVtKGYucmVwbGFjZShcInA1VHlwZUlEXCIsIFwiXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHR5cGVvZiBnICE9IFwic3RyaW5nXCIgJiYgY29uc29sZS5sb2coXCJUaGUgYXJndW1lbnQgdGhhdCB5b3UgcGFzc2VkIHRvIHJlbW92ZUl0ZW0oKSAtIFwiLmNvbmNhdChnLCBcIiBpcyBub3QgYSBzdHJpbmcuXCIpKSwgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZyksIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiXCIuY29uY2F0KGcsIFwicDVUeXBlSURcIikpO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIjogMTYwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiOiAxODYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiOiAxOTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoXCI6IDE5NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIjogMjAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDI5NTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obCkge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBuO1xuICAgICAgICB9IDogZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG4uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBuICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBuO1xuICAgICAgICB9KShsKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkobCkge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG0obik7XG4gICAgICAgIH0gOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4gJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG4gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShuKTtcbiAgICAgICAgfSkobCk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24gaChsLCBuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPSBcImZ1bmN0aW9uXCIgJiYgbiAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuICYmIG4ucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBsLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgbiAmJiBnKGwsIG4pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZyhsLCBuKSB7XG4gICAgICAgIHJldHVybiAoZyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIGEuX19wcm90b19fID0gYywgYTtcbiAgICAgICAgfSkobCwgbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKGwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuLCBhID0gcihsKSwgYSA9IChuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPCBcInVcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCAmJiAhUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgfSkpLCAxO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oKSA/IChuID0gcih0aGlzKS5jb25zdHJ1Y3RvciwgUmVmbGVjdC5jb25zdHJ1Y3QoYSwgYXJndW1lbnRzLCBuKSkgOiBhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMpO1xuICAgICAgICAgIGlmICghbiB8fCB5KG4pICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBuICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGEgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihsKSB7XG4gICAgICAgIHJldHVybiAociA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO1xuICAgICAgICB9KShsKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHMobCwgbikge1xuICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgbikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8obCwgbikge1xuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG4ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICB2YXIgYyA9IG5bYV07XG4gICAgICAgICAgYy5lbnVtZXJhYmxlID0gYy5lbnVtZXJhYmxlIHx8ICExLCBjLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gYyAmJiAoYy53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGMua2V5LCBjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShsLCBuLCBhKSB7XG4gICAgICAgIG4gJiYgbyhsLnByb3RvdHlwZSwgbik7XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZVN0cmluZ0RpY3QgPSBmdW5jdGlvbihsLCBuKSB7XG4gICAgICAgIHJldHVybiB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZVN0cmluZ0RpY3RcIiwgYXJndW1lbnRzKSwgbmV3IHUuZGVmYXVsdC5TdHJpbmdEaWN0KGwsIG4pO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVOdW1iZXJEaWN0ID0gZnVuY3Rpb24obCwgbikge1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjcmVhdGVOdW1iZXJEaWN0XCIsIGFyZ3VtZW50cyksIG5ldyB1LmRlZmF1bHQuTnVtYmVyRGljdChsLCBuKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5UeXBlZERpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gbChuLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIHModGhpcywgbCksIG4gaW5zdGFuY2VvZiBPYmplY3QgPyB0aGlzLmRhdGEgPSBuIDogKHRoaXMuZGF0YSA9IHt9LCB0aGlzLmRhdGFbbl0gPSBhKSwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaShsLCBbeyBrZXk6IFwic2l6ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoO1xuICAgICAgICB9IH0sIHsga2V5OiBcImhhc0tleVwiLCB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkobik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShuKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbbl07XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcIi5jb25jYXQobiwgXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBEaWN0aW9uYXJ5XCIpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgICB0aGlzLl92YWxpZGF0ZShhKSA/IHRoaXMuZGF0YVtuXSA9IGEgOiBjb25zb2xlLmxvZyhcIlRob3NlIHZhbHVlcyBkb250IHdvcmsgZm9yIHRoaXMgZGljdGlvbmFyeSB0eXBlLlwiKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfYWRkT2JqXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSBpbiBuKVxuICAgICAgICAgICAgdGhpcy5zZXQoYSwgblthXSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY3JlYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgbiBpbnN0YW5jZW9mIE9iamVjdCAmJiBhID09PSB2b2lkIDAgPyB0aGlzLl9hZGRPYmoobikgOiBuICE9PSB2b2lkIDAgPyB0aGlzLnNldChuLCBhKSA6IGNvbnNvbGUubG9nKFwiSW4gb3JkZXIgdG8gY3JlYXRlIGEgbmV3IERpY3Rpb25hcnkgZW50cnkgeW91IG11c3QgcGFzcyBhbiBvYmplY3Qgb3IgYSBrZXksIHZhbHVlIHBhaXJcIik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlbW92ZVwiLCB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmhhc093blByb3BlcnR5KG4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG4sIFwiIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgRGljdGlvbmFyeVwiKSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtuXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwcmludFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmRhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImtleTpcIi5jb25jYXQobiwgXCIgdmFsdWU6XCIpLmNvbmNhdCh0aGlzLmRhdGFbbl0pKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzYXZlVGFibGVcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYSwgYyA9IFwiXCI7XG4gICAgICAgICAgZm9yIChhIGluIHRoaXMuZGF0YSlcbiAgICAgICAgICAgIGMgKz0gXCJcIi5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdCh0aGlzLmRhdGFbYV0sIGBcbmApO1xuICAgICAgICAgIHZhciBwID0gbmV3IEJsb2IoW2NdLCB7IHR5cGU6IFwidGV4dC9jc3ZcIiB9KTtcbiAgICAgICAgICB1LmRlZmF1bHQucHJvdG90eXBlLmRvd25sb2FkRmlsZShwLCBuIHx8IFwibXljc3ZcIiwgXCJjc3ZcIik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2F2ZUpTT05cIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgICB1LmRlZmF1bHQucHJvdG90eXBlLnNhdmVKU09OKHRoaXMuZGF0YSwgbiwgYSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3ZhbGlkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9IH1dKSwgbDtcbiAgICAgIH0oKSwgdS5kZWZhdWx0LlN0cmluZ0RpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaChuLCB1LmRlZmF1bHQuVHlwZWREaWN0KTtcbiAgICAgICAgdmFyIGwgPSBmKG4pO1xuICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIHModGhpcywgbik7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGgsIGMgPSBuZXcgQXJyYXkoYSksIHAgPSAwOyBwIDwgYTsgcCsrKVxuICAgICAgICAgICAgY1twXSA9IGFyZ3VtZW50c1twXTtcbiAgICAgICAgICByZXR1cm4gbC5jYWxsLmFwcGx5KGwsIFt0aGlzXS5jb25jYXQoYykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpKG4sIFt7IGtleTogXCJfdmFsaWRhdGVcIiwgdmFsdWU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSB9XSksIG47XG4gICAgICB9KCksIHUuZGVmYXVsdC5OdW1iZXJEaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGgobiwgdS5kZWZhdWx0LlR5cGVkRGljdCk7XG4gICAgICAgIHZhciBsID0gZihuKTtcbiAgICAgICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBzKHRoaXMsIG4pO1xuICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoLCBjID0gbmV3IEFycmF5KGEpLCBwID0gMDsgcCA8IGE7IHArKylcbiAgICAgICAgICAgIGNbcF0gPSBhcmd1bWVudHNbcF07XG4gICAgICAgICAgcmV0dXJuIGwuY2FsbC5hcHBseShsLCBbdGhpc10uY29uY2F0KGMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaShuLCBbeyBrZXk6IFwiX3ZhbGlkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09IFwibnVtYmVyXCI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkXCIsIHZhbHVlOiBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLmhhc093blByb3BlcnR5KGEpID8gdGhpcy5kYXRhW2FdICs9IGMgOiBjb25zb2xlLmxvZyhcIlRoZSBrZXkgLSBcIi5jb25jYXQoYSwgXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBkaWN0aW9uYXJ5LlwiKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic3ViXCIsIHZhbHVlOiBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYSwgLWMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm11bHRcIiwgdmFsdWU6IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgICB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoYSkgPyB0aGlzLmRhdGFbYV0gKj0gYyA6IGNvbnNvbGUubG9nKFwiVGhlIGtleSAtIFwiLmNvbmNhdChhLCBcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGRpY3Rpb25hcnkuXCIpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkaXZcIiwgdmFsdWU6IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgICB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoYSkgPyB0aGlzLmRhdGFbYV0gLz0gYyA6IGNvbnNvbGUubG9nKFwiVGhlIGtleSAtIFwiLmNvbmNhdChhLCBcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGRpY3Rpb25hcnkuXCIpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfdmFsdWVUZXN0XCIsIHZhbHVlOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNlYXJjaCBmb3IgYSBtaW5pbXVtIG9yIG1heGltdW0gdmFsdWUgb24gYW4gZW1wdHkgTnVtYmVyRGljdFwiKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kYXRhKS5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW09iamVjdC5rZXlzKHRoaXMuZGF0YSlbMF1dO1xuICAgICAgICAgIHZhciBjLCBwID0gdGhpcy5kYXRhW09iamVjdC5rZXlzKHRoaXMuZGF0YSlbMF1dO1xuICAgICAgICAgIGZvciAoYyBpbiB0aGlzLmRhdGEpXG4gICAgICAgICAgICB0aGlzLmRhdGFbY10gKiBhIDwgcCAqIGEgJiYgKHAgPSB0aGlzLmRhdGFbY10pO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1pblZhbHVlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVUZXN0KDEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1heFZhbHVlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVUZXN0KC0xKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfa2V5VGVzdFwiLCB2YWx1ZTogZnVuY3Rpb24oYSkge1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB1c2UgbWluVmFsdWUgb24gYW4gZW1wdHkgTnVtYmVyRGljdFwiKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kYXRhKS5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKVswXTtcbiAgICAgICAgICBmb3IgKHZhciBjID0gT2JqZWN0LmtleXModGhpcy5kYXRhKVswXSwgcCA9IDE7IHAgPCBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmxlbmd0aDsgcCsrKVxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5kYXRhKVtwXSAqIGEgPCBjICogYSAmJiAoYyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSlbcF0pO1xuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1pbktleVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2tleVRlc3QoMSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWF4S2V5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5VGVzdCgtMSk7XG4gICAgICAgIH0gfV0pLCBuO1xuICAgICAgfSgpLCB0ID0gdS5kZWZhdWx0LlR5cGVkRGljdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCI6IDE1MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiOiAxODUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCI6IDE4NiwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0XCI6IDE4OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAyOTY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgcDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBwLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgcDtcbiAgICAgICAgfSkoYyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi51cmxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLnVybFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHkgPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIHUoYywgcCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgVCA9IHBbal07XG4gICAgICAgICAgVC5lbnVtZXJhYmxlID0gVC5lbnVtZXJhYmxlIHx8ICExLCBULmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gVCAmJiAoVC53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsIFQua2V5LCBUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaChjLCBwLCBqKSB7XG4gICAgICAgIHAgJiYgdShjLnByb3RvdHlwZSwgcCksIGogJiYgdShjLCBqKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGcoYywgcCkge1xuICAgICAgICByZXR1cm4gKGcgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oaiwgVCkge1xuICAgICAgICAgIHJldHVybiBqLl9fcHJvdG9fXyA9IFQsIGo7XG4gICAgICAgIH0pKGMsIHApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihjKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcCwgaiwgVCA9IHMoYyk7XG4gICAgICAgICAgcmV0dXJuIHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KSksIDE7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSgpID8gKHAgPSBzKHRoaXMpLmNvbnN0cnVjdG9yLCBSZWZsZWN0LmNvbnN0cnVjdChULCBhcmd1bWVudHMsIHApKSA6IFQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgVCA9IHRoaXMsICEoaiA9IHApIHx8IGkoaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGogIT0gXCJmdW5jdGlvblwiID8gcihUKSA6IGo7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMClcbiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhjKSB7XG4gICAgICAgIHJldHVybiAocyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHApO1xuICAgICAgICB9KShjKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8oYywgcCkge1xuICAgICAgICBpZiAoIShjIGluc3RhbmNlb2YgcCkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoYykge1xuICAgICAgICByZXR1cm4gKGkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIG0ocCk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHAgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShwKTtcbiAgICAgICAgfSkoYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKGMsIHAsIGopIHtcbiAgICAgICAgcmV0dXJuIChwLl91c2VyTm9kZSB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChjKSwgaiA9IG5ldyAoaiA/IHkuZGVmYXVsdC5NZWRpYUVsZW1lbnQgOiB5LmRlZmF1bHQuRWxlbWVudCkoYywgcCksIHAuX2VsZW1lbnRzLnB1c2goaiksIGo7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuKGMsIEUsIGosIFQpIHtcbiAgICAgICAgdmFyIF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEUpLCBTID0gKHR5cGVvZiAoaiA9IGogfHwgXCJcIikgPT0gXCJzdHJpbmdcIiAmJiAoaiA9IFtqXSksICEwKSwgRSA9ICExLCBBID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIHgsIFAgPSBqW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShTID0gKHggPSBQLm5leHQoKSkuZG9uZSk7IFMgPSAhMCkge1xuICAgICAgICAgICAgdmFyIE0gPSB4LnZhbHVlLCBSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgICAgICAgIFIuc2V0QXR0cmlidXRlKFwic3JjXCIsIE0pLCBfLmFwcGVuZENoaWxkKFIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoRikge1xuICAgICAgICAgIEUgPSAhMCwgQSA9IEY7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFMgfHwgUC5yZXR1cm4gPT0gbnVsbCB8fCBQLnJldHVybigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoRSlcbiAgICAgICAgICAgICAgdGhyb3cgQTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIFQgPT0gXCJmdW5jdGlvblwiICYmIF8uYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgICAgVCgpLCBfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCBGKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBMID0gbChfLCBjLCAhMCk7XG4gICAgICAgIHJldHVybiBMLmxvYWRlZG1ldGFkYXRhID0gITEsIF8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEwud2lkdGggPSBfLnZpZGVvV2lkdGgsIEwuaGVpZ2h0ID0gXy52aWRlb0hlaWdodCwgTC5lbHQud2lkdGggPT09IDAgJiYgKEwuZWx0LndpZHRoID0gXy52aWRlb1dpZHRoKSwgTC5lbHQuaGVpZ2h0ID09PSAwICYmIChMLmVsdC5oZWlnaHQgPSBfLnZpZGVvSGVpZ2h0KSwgTC5wcmVzZXRQbGF5YmFja1JhdGUgJiYgKEwuZWx0LnBsYXliYWNrUmF0ZSA9IEwucHJlc2V0UGxheWJhY2tSYXRlLCBkZWxldGUgTC5wcmVzZXRQbGF5YmFja1JhdGUpLCBMLmxvYWRlZG1ldGFkYXRhID0gITA7XG4gICAgICAgIH0pLCBMO1xuICAgICAgfVxuICAgICAgeS5kZWZhdWx0LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihjLCBwKSB7XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNlbGVjdFwiLCBhcmd1bWVudHMpLCBwID0gdGhpcy5fZ2V0Q29udGFpbmVyKHApLnF1ZXJ5U2VsZWN0b3IoYyksIHAgPyB0aGlzLl93cmFwRWxlbWVudChwKSA6IG51bGw7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKGMsIHApIHtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzZWxlY3RBbGxcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGogPSBbXSwgVCA9IHRoaXMuX2dldENvbnRhaW5lcihwKS5xdWVyeVNlbGVjdG9yQWxsKGMpO1xuICAgICAgICBpZiAoVClcbiAgICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IFQubGVuZ3RoOyBfKyspIHtcbiAgICAgICAgICAgIHZhciBTID0gdGhpcy5fd3JhcEVsZW1lbnQoVFtfXSk7XG4gICAgICAgICAgICBqLnB1c2goUyk7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gajtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuX2dldENvbnRhaW5lciA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAgPSBkb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09IFwic3RyaW5nXCIgPyBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihjKSB8fCBkb2N1bWVudCA6IGMgaW5zdGFuY2VvZiB5LmRlZmF1bHQuRWxlbWVudCA/IHAgPSBjLmVsdCA6IGMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAocCA9IGMpLCBwO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5fd3JhcEVsZW1lbnQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBwLCBqID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBjLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBjLnR5cGUgPT09IFwiY2hlY2tib3hcIiA/ICgocCA9IG5ldyB5LmRlZmF1bHQuRWxlbWVudChjLCB0aGlzKSkuY2hlY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gdGhpcy5lbHQuY2hlY2tlZCA6ICh0aGlzLmVsdC5jaGVja2VkID0gIShhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgIWFyZ3VtZW50c1swXSksIHRoaXMpO1xuICAgICAgICB9LCBwKSA6IGMudGFnTmFtZSA9PT0gXCJWSURFT1wiIHx8IGMudGFnTmFtZSA9PT0gXCJBVURJT1wiID8gbmV3IHkuZGVmYXVsdC5NZWRpYUVsZW1lbnQoYywgdGhpcykgOiBjLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIgPyB0aGlzLmNyZWF0ZVNlbGVjdChuZXcgeS5kZWZhdWx0LkVsZW1lbnQoYywgdGhpcykpIDogMCA8IGoubGVuZ3RoICYmIGouZXZlcnkoZnVuY3Rpb24oVCkge1xuICAgICAgICAgIHJldHVybiBULnRhZ05hbWUgPT09IFwiSU5QVVRcIiB8fCBULnRhZ05hbWUgPT09IFwiTEFCRUxcIjtcbiAgICAgICAgfSkgPyB0aGlzLmNyZWF0ZVJhZGlvKG5ldyB5LmRlZmF1bHQuRWxlbWVudChjLCB0aGlzKSkgOiBuZXcgeS5kZWZhdWx0LkVsZW1lbnQoYywgdGhpcyk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLnJlbW92ZUVsZW1lbnRzID0gZnVuY3Rpb24oYykge1xuICAgICAgICB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInJlbW92ZUVsZW1lbnRzXCIsIGFyZ3VtZW50cyksIHRoaXMuX2VsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuICEocC5lbHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYywgdGhpcyksIHRoaXM7XG4gICAgICB9LCB5LmRlZmF1bHQuRWxlbWVudC5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuRWxlbWVudC5fYWRqdXN0TGlzdGVuZXIoXCJpbnB1dFwiLCBjLCB0aGlzKSwgdGhpcztcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlRGl2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBcIlwiLCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcmV0dXJuIHAuaW5uZXJIVE1MID0gYywgbChwLCB0aGlzKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlUCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogXCJcIiwgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgICAgICByZXR1cm4gcC5pbm5lckhUTUwgPSBjLCBsKHAsIHRoaXMpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVTcGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBcIlwiLCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHJldHVybiBwLmlubmVySFRNTCA9IGMsIGwocCwgdGhpcyk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUltZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUltZ1wiLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgYywgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksIGogPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiAxIDwgai5sZW5ndGggJiYgdHlwZW9mIGpbMV0gPT0gXCJzdHJpbmdcIiAmJiAocC5hbHQgPSBqWzFdKSwgMiA8IGoubGVuZ3RoICYmIHR5cGVvZiBqWzJdID09IFwic3RyaW5nXCIgJiYgKHAuY3Jvc3NPcmlnaW4gPSBqWzJdKSwgcC5zcmMgPSBqWzBdLCBjID0gbChwLCB0aGlzKSwgcC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjLndpZHRoID0gcC5vZmZzZXRXaWR0aCB8fCBwLndpZHRoLCBjLmhlaWdodCA9IHAub2Zmc2V0SGVpZ2h0IHx8IHAuaGVpZ2h0O1xuICAgICAgICAgIHZhciBUID0galtqLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIiAmJiBUKGMpO1xuICAgICAgICB9KSwgYztcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlQSA9IGZ1bmN0aW9uKGMsIHAsIGopIHtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjcmVhdGVBXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBUID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHJldHVybiBULmhyZWYgPSBjLCBULmlubmVySFRNTCA9IHAsIGogJiYgKFQudGFyZ2V0ID0gaiksIGwoVCwgdGhpcyk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZVNsaWRlciA9IGZ1bmN0aW9uKGMsIHAsIGosIFQpIHtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjcmVhdGVTbGlkZXJcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIHJldHVybiBfLnR5cGUgPSBcInJhbmdlXCIsIF8ubWluID0gYywgXy5tYXggPSBwLCBUID09PSAwID8gXy5zdGVwID0gMWUtMTggOiBUICYmIChfLnN0ZXAgPSBUKSwgdHlwZW9mIGogPT0gXCJudW1iZXJcIiAmJiAoXy52YWx1ZSA9IGopLCBsKF8sIHRoaXMpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVCdXR0b24gPSBmdW5jdGlvbihjLCBwKSB7XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlQnV0dG9uXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBqID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgcmV0dXJuIGouaW5uZXJIVE1MID0gYywgcCAmJiAoai52YWx1ZSA9IHApLCBsKGosIHRoaXMpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVDaGVja2JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShjKSwgaiA9IDA7IGogPCBjOyBqKyspXG4gICAgICAgICAgcFtqXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjcmVhdGVDaGVja2JveFwiLCBwKTtcbiAgICAgICAgdmFyIFQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBTID0gKF8udHlwZSA9IFwiY2hlY2tib3hcIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpKSwgRSA9IChTLmFwcGVuZENoaWxkKF8pLCBULmFwcGVuZENoaWxkKFMpLCBsKFQsIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIEUuY2hlY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBBID0gRS5lbHQuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICBpZiAoQSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBBLmNoZWNrZWQ7XG4gICAgICAgICAgICBBLmNoZWNrZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCAhYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgIH0sIHRoaXMudmFsdWUgPSBmdW5jdGlvbihBKSB7XG4gICAgICAgICAgcmV0dXJuIEUudmFsdWUgPSBBLCB0aGlzO1xuICAgICAgICB9LCBwWzBdICYmIChFLnZhbHVlKHBbMF0pLCAoVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKS5pbm5lckhUTUwgPSBwWzBdLCBTLmFwcGVuZENoaWxkKFQpKSwgcFsxXSAmJiAoXy5jaGVja2VkID0gITApLCBFO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVTZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYywgcCA9IGFyZ3VtZW50cy5sZW5ndGgsIGogPSBuZXcgQXJyYXkocCksIFQgPSAwOyBUIDwgcDsgVCsrKVxuICAgICAgICAgIGpbVF0gPSBhcmd1bWVudHNbVF07XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlU2VsZWN0XCIsIGopO1xuICAgICAgICB2YXIgXywgUyA9IGpbMF07XG4gICAgICAgIHJldHVybiBTIGluc3RhbmNlb2YgeS5kZWZhdWx0LkVsZW1lbnQgJiYgUy5lbHQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCA/IHRoaXMuZWx0ID0gKGMgPSBTKS5lbHQgOiBTIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQgPyAoYyA9IGwoUywgdGhpcyksIHRoaXMuZWx0ID0gUykgOiAoXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksIFMgJiYgdHlwZW9mIFMgPT0gXCJib29sZWFuXCIgJiYgXy5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBcInRydWVcIiksIGMgPSBsKF8sIHRoaXMpLCB0aGlzLmVsdCA9IF8pLCBjLm9wdGlvbiA9IGZ1bmN0aW9uKEUsIEEpIHtcbiAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICBpZiAoRSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBQLCBNID0gMDsgTSA8IHRoaXMuZWx0Lmxlbmd0aDsgTSArPSAxKVxuICAgICAgICAgICAgICBpZiAodGhpcy5lbHRbTV0udGV4dENvbnRlbnQgPT09IEUpIHtcbiAgICAgICAgICAgICAgICB4ID0gTTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAhPT0gdm9pZCAwID8gQSA9PT0gITEgPyB0aGlzLmVsdC5yZW1vdmUoeCkgOiB0aGlzLmVsdFt4XS52YWx1ZSA9IEEgOiAoKFAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKS50ZXh0Q29udGVudCA9IEUsIFAudmFsdWUgPSBBID09PSB2b2lkIDAgPyBFIDogQSwgdGhpcy5lbHQuYXBwZW5kQ2hpbGQoUCksIHRoaXMuX3BJbnN0Ll9lbGVtZW50cy5wdXNoKFApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGMuc2VsZWN0ZWQgPSBmdW5jdGlvbihFKSB7XG4gICAgICAgICAgaWYgKEUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgQSA9IDA7IEEgPCB0aGlzLmVsdC5sZW5ndGg7IEEgKz0gMSlcbiAgICAgICAgICAgICAgdGhpcy5lbHRbQV0udmFsdWUudG9TdHJpbmcoKSA9PT0gRS50b1N0cmluZygpICYmICh0aGlzLmVsdC5zZWxlY3RlZEluZGV4ID0gQSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZWx0LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gICAgICAgICAgICB2YXIgeCA9IFtdLCBQID0gITAsIE0gPSAhMSwgUiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIEwsIEYgPSB0aGlzLmVsdC5zZWxlY3RlZE9wdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKFAgPSAoTCA9IEYubmV4dCgpKS5kb25lKTsgUCA9ICEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIFYgPSBMLnZhbHVlO1xuICAgICAgICAgICAgICAgIHgucHVzaChWLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoRykge1xuICAgICAgICAgICAgICBNID0gITAsIFIgPSBHO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBQIHx8IEYucmV0dXJuID09IG51bGwgfHwgRi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoTSlcbiAgICAgICAgICAgICAgICAgIHRocm93IFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5lbHQudmFsdWU7XG4gICAgICAgIH0sIGMuZGlzYWJsZSA9IGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIEUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvciAodmFyIEEgPSAwOyBBIDwgdGhpcy5lbHQubGVuZ3RoOyBBKyspXG4gICAgICAgICAgICAgIHRoaXMuZWx0W0FdLnZhbHVlLnRvU3RyaW5nKCkgPT09IEUgJiYgKHRoaXMuZWx0W0FdLmRpc2FibGVkID0gITAsIHRoaXMuZWx0W0FdLnNlbGVjdGVkID0gITEpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZWx0LmRpc2FibGVkID0gITA7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGMuZW5hYmxlID0gZnVuY3Rpb24oRSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgRSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9yICh2YXIgQSA9IDA7IEEgPCB0aGlzLmVsdC5sZW5ndGg7IEErKylcbiAgICAgICAgICAgICAgdGhpcy5lbHRbQV0udmFsdWUudG9TdHJpbmcoKSA9PT0gRSAmJiAodGhpcy5lbHRbQV0uZGlzYWJsZWQgPSAhMSwgdGhpcy5lbHRbQV0uc2VsZWN0ZWQgPSAhMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsdC5kaXNhYmxlZCA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmVsdC5sZW5ndGg7IHgrKylcbiAgICAgICAgICAgICAgdGhpcy5lbHRbeF0uZGlzYWJsZWQgPSAhMSwgdGhpcy5lbHRbeF0uc2VsZWN0ZWQgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGM7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZVJhZGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGMoRSkge1xuICAgICAgICAgIHJldHVybiBFIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBFLnR5cGUgPT09IFwicmFkaW9cIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwKEUpIHtcbiAgICAgICAgICByZXR1cm4gRSBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGosIFQsIF8sIFMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBTIGluc3RhbmNlb2YgeS5kZWZhdWx0LkVsZW1lbnQgJiYgKFMuZWx0IGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQgfHwgUy5lbHQgaW5zdGFuY2VvZiBIVE1MU3BhbkVsZW1lbnQpID8gKGogPSBTLCB0aGlzLmVsdCA9IFMuZWx0KSA6IFMgaW5zdGFuY2VvZiBIVE1MRGl2RWxlbWVudCB8fCBTIGluc3RhbmNlb2YgSFRNTFNwYW5FbGVtZW50ID8gKGogPSBsKFMsIHRoaXMpLCBUID0gdGhpcy5lbHQgPSBTLCB0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSkgPT0gXCJzdHJpbmdcIiAmJiAoXyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSkpIDogKHR5cGVvZiBTID09IFwic3RyaW5nXCIgJiYgKF8gPSBTKSwgVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGogPSBsKFQsIHRoaXMpLCB0aGlzLmVsdCA9IFQpLCBqLl9uYW1lID0gXyB8fCBcInJhZGlvT3B0aW9uXCIsIGouX2dldE9wdGlvbnNBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZWx0LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24oRSkge1xuICAgICAgICAgICAgcmV0dXJuIGMoRSkgfHwgcChFKSAmJiBjKEUuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihFKSB7XG4gICAgICAgICAgICByZXR1cm4gYyhFKSA/IEUgOiBFLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBqLm9wdGlvbiA9IGZ1bmN0aW9uKEUsIEEpIHtcbiAgICAgICAgICB2YXIgeCwgUCwgTSwgUiA9ICEwLCBMID0gITEsIEYgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIFYsIEcgPSBqLl9nZXRPcHRpb25zQXJyYXkoKVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoUiA9IChWID0gRy5uZXh0KCkpLmRvbmUpOyBSID0gITApIHtcbiAgICAgICAgICAgICAgdmFyIFUgPSBWLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoVS52YWx1ZSA9PT0gRSkge1xuICAgICAgICAgICAgICAgIHggPSBVO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoVykge1xuICAgICAgICAgICAgTCA9ICEwLCBGID0gVztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUiB8fCBHLnJldHVybiA9PSBudWxsIHx8IEcucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoTClcbiAgICAgICAgICAgICAgICB0aHJvdyBGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geCA9PT0gdm9pZCAwICYmICgoeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpLCB4LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIEUpKSwgeC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGouX25hbWUpLCBwKHgucGFyZW50RWxlbWVudCkgPyBQID0geC5wYXJlbnRFbGVtZW50IDogKFAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIikpLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgeCksIFAubGFzdEVsZW1lbnRDaGlsZCBpbnN0YW5jZW9mIEhUTUxTcGFuRWxlbWVudCA/IE0gPSBQLmxhc3RFbGVtZW50Q2hpbGQgOiAoTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLCB4Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIE0pKSwgTS5pbm5lckhUTUwgPSBBID09PSB2b2lkIDAgPyBFIDogQSwgdGhpcy5lbHQuYXBwZW5kQ2hpbGQoUCksIHg7XG4gICAgICAgIH0sIGoucmVtb3ZlID0gZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHZhciBBID0gITAsIHggPSAhMSwgUCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgTSwgUiA9IGouX2dldE9wdGlvbnNBcnJheSgpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShBID0gKE0gPSBSLm5leHQoKSkuZG9uZSk7IEEgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgTCA9IE0udmFsdWU7XG4gICAgICAgICAgICAgIGlmIChMLnZhbHVlID09PSBFKVxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChwKEwucGFyZW50RWxlbWVudCkgPyBMLnBhcmVudEVsZW1lbnQgOiBMKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgICB4ID0gITAsIFAgPSBGO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBBIHx8IFIucmV0dXJuID09IG51bGwgfHwgUi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmICh4KVxuICAgICAgICAgICAgICAgIHRocm93IFA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBqLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIEUgPSBcIlwiLCBBID0gITAsIHggPSAhMSwgUCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgTSwgUiA9IGouX2dldE9wdGlvbnNBcnJheSgpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShBID0gKE0gPSBSLm5leHQoKSkuZG9uZSk7IEEgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgTCA9IE0udmFsdWU7XG4gICAgICAgICAgICAgIGlmIChMLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBFID0gTC52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKEYpIHtcbiAgICAgICAgICAgIHggPSAhMCwgUCA9IEY7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEEgfHwgUi5yZXR1cm4gPT0gbnVsbCB8fCBSLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKHgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgIH0sIGouc2VsZWN0ZWQgPSBmdW5jdGlvbihFKSB7XG4gICAgICAgICAgdmFyIEEgPSBudWxsO1xuICAgICAgICAgIGlmIChFID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciB4ID0gITAsIFAgPSAhMSwgTSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIFIsIEwgPSBqLl9nZXRPcHRpb25zQXJyYXkoKVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoeCA9IChSID0gTC5uZXh0KCkpLmRvbmUpOyB4ID0gITApIHtcbiAgICAgICAgICAgICAgICB2YXIgRiA9IFIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEYuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgQSA9IEY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKFgpIHtcbiAgICAgICAgICAgICAgUCA9ICEwLCBNID0gWDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeCB8fCBMLnJldHVybiA9PSBudWxsIHx8IEwucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKFApXG4gICAgICAgICAgICAgICAgICB0aHJvdyBNO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGouX2dldE9wdGlvbnNBcnJheSgpLmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICBiLmNoZWNrZWQgPSAhMSwgYi5yZW1vdmVBdHRyaWJ1dGUoXCJjaGVja2VkXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgViA9ICEwLCBQID0gITEsIE0gPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBHLCBVID0gai5fZ2V0T3B0aW9uc0FycmF5KClbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKFYgPSAoRyA9IFUubmV4dCgpKS5kb25lKTsgViA9ICEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIFcgPSBHLnZhbHVlO1xuICAgICAgICAgICAgICAgIFcudmFsdWUgPT09IEUgJiYgKFcuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCAhMCksIFcuY2hlY2tlZCA9ICEwLCBBID0gVyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgUCA9ICEwLCBNID0gYjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgViB8fCBVLnJldHVybiA9PSBudWxsIHx8IFUucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKFApXG4gICAgICAgICAgICAgICAgICB0aHJvdyBNO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9LCBqLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgRSA9ICEoMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1swXSwgQSA9ICEwLCB4ID0gITEsIFAgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIE0sIFIgPSBqLl9nZXRPcHRpb25zQXJyYXkoKVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoQSA9IChNID0gUi5uZXh0KCkpLmRvbmUpOyBBID0gITApXG4gICAgICAgICAgICAgIE0udmFsdWUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgRSk7XG4gICAgICAgICAgfSBjYXRjaCAoTCkge1xuICAgICAgICAgICAgeCA9ICEwLCBQID0gTDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgQSB8fCBSLnJldHVybiA9PSBudWxsIHx8IFIucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoeClcbiAgICAgICAgICAgICAgICB0aHJvdyBQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgajtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlQ29sb3JQaWNrZXIgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlQ29sb3JQaWNrZXJcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIHJldHVybiBwLnR5cGUgPSBcImNvbG9yXCIsIGMgPyBjIGluc3RhbmNlb2YgeS5kZWZhdWx0LkNvbG9yID8gcC52YWx1ZSA9IGMudG9TdHJpbmcoXCIjcnJnZ2JiXCIpIDogKHkuZGVmYXVsdC5wcm90b3R5cGUuX2NvbG9yTW9kZSA9IFwicmdiXCIsIHkuZGVmYXVsdC5wcm90b3R5cGUuX2NvbG9yTWF4ZXMgPSB7IHJnYjogWzI1NSwgMjU1LCAyNTUsIDI1NV0sIGhzYjogWzM2MCwgMTAwLCAxMDAsIDFdLCBoc2w6IFszNjAsIDEwMCwgMTAwLCAxXSB9LCBwLnZhbHVlID0geS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvcihjKS50b1N0cmluZyhcIiNycmdnYmJcIikpIDogcC52YWx1ZSA9IFwiIzAwMDAwMFwiLCAocCA9IGwocCwgdGhpcykpLmNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgKGMubW9kZSAmJiAoeS5kZWZhdWx0LnByb3RvdHlwZS5fY29sb3JNb2RlID0gYy5tb2RlKSwgYy5tYXhlcyAmJiAoeS5kZWZhdWx0LnByb3RvdHlwZS5fY29sb3JNYXhlcyA9IGMubWF4ZXMpKSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvcih0aGlzLmVsdC52YWx1ZSk7XG4gICAgICAgIH0sIHA7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUlucHV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBcIlwiLCBwID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBcInRleHRcIiwgaiA9ICh5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUlucHV0XCIsIGFyZ3VtZW50cyksIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSk7XG4gICAgICAgIHJldHVybiBqLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGMpLCBqLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgcCksIGwoaiwgdGhpcyk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUZpbGVJbnB1dCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAsIGogPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCAmJiBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmICh5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUZpbGVJbnB1dFwiLCBhcmd1bWVudHMpLCB3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZUxpc3QgJiYgd2luZG93LkJsb2IpXG4gICAgICAgICAgcmV0dXJuIChwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZmlsZVwiKSwgaiAmJiBwLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsICEwKSwgcC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICAgIHZhciBfID0gITAsIFMgPSAhMSwgRSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIEEsIHggPSBULnRhcmdldC5maWxlc1tTeW1ib2wuaXRlcmF0b3JdKCk7ICEoXyA9IChBID0geC5uZXh0KCkpLmRvbmUpOyBfID0gITApIHtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IEEudmFsdWU7XG4gICAgICAgICAgICAgICAgeS5kZWZhdWx0LkZpbGUuX2xvYWQoUCwgYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKE0pIHtcbiAgICAgICAgICAgICAgUyA9ICEwLCBFID0gTTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgXyB8fCB4LnJldHVybiA9PSBudWxsIHx8IHgucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKFMpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITEpLCBsKHAsIHRoaXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBGaWxlIEFQSXMgYXJlIG5vdCBmdWxseSBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBDYW5ub3QgY3JlYXRlIGVsZW1lbnQuXCIpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVWaWRlbyA9IGZ1bmN0aW9uKGMsIHApIHtcbiAgICAgICAgcmV0dXJuIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlVmlkZW9cIiwgYXJndW1lbnRzKSwgbih0aGlzLCBcInZpZGVvXCIsIGMsIHApO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVBdWRpbyA9IGZ1bmN0aW9uKGMsIHApIHtcbiAgICAgICAgcmV0dXJuIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlQXVkaW9cIiwgYXJndW1lbnRzKSwgbih0aGlzLCBcImF1ZGlvXCIsIGMsIHApO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5WSURFTyA9IFwidmlkZW9cIiwgeS5kZWZhdWx0LnByb3RvdHlwZS5BVURJTyA9IFwiYXVkaW9cIiwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9PT0gdm9pZCAwICYmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID0ge30pLCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9PT0gdm9pZCAwICYmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAgPSBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWE7XG4gICAgICAgIHJldHVybiBwID8gbmV3IFByb21pc2UoZnVuY3Rpb24oaiwgVCkge1xuICAgICAgICAgIHAuY2FsbChuYXZpZ2F0b3IsIGMsIGosIFQpO1xuICAgICAgICB9KSA6IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImdldFVzZXJNZWRpYSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBicm93c2VyXCIpKTtcbiAgICAgIH0pLCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUNhcHR1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoYyksIGogPSAwOyBqIDwgYzsgaisrKVxuICAgICAgICAgIHBbal0gPSBhcmd1bWVudHNbal07XG4gICAgICAgIGlmICh5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUNhcHR1cmVcIiwgcCksICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIHx8ICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSlcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiZ2V0VXNlck1lZGlhIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICAgICAgICBmb3IgKHZhciBULCBfID0gITAsIFMgPSAhMCwgRSA9ICExLCBBID0gMCwgeCA9IHA7IEEgPCB4Lmxlbmd0aDsgQSsrKSB7XG4gICAgICAgICAgdmFyIFAgPSB4W0FdO1xuICAgICAgICAgIFAgPT09IHkuZGVmYXVsdC5wcm90b3R5cGUuVklERU8gPyBTID0gITEgOiBQID09PSB5LmRlZmF1bHQucHJvdG90eXBlLkFVRElPID8gXyA9ICExIDogaShQKSA9PT0gXCJvYmplY3RcIiA/IChQLmZsaXBwZWQgIT09IHZvaWQgMCAmJiAoRSA9IFAuZmxpcHBlZCwgZGVsZXRlIFAuZmxpcHBlZCksIE0gPSBPYmplY3QuYXNzaWduKHt9LCBNLCBQKSkgOiB0eXBlb2YgUCA9PSBcImZ1bmN0aW9uXCIgJiYgKFQgPSBQKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTSA9IE9iamVjdC5hc3NpZ24oe30sIHsgdmlkZW86IF8sIGF1ZGlvOiBTIH0sIE0pLCBSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpLCBMID0gKFIuc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIiksIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKE0pLnRoZW4oZnVuY3Rpb24oRikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBcInNyY09iamVjdFwiIGluIFIgPyBSLnNyY09iamVjdCA9IEYgOiBSLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKEYpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgUi5zcmMgPSBGO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oRikge1xuICAgICAgICAgIEYubmFtZSA9PT0gXCJOb3RGb3VuZEVycm9yXCIgJiYgeS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiTm8gd2ViY2FtIGZvdW5kIG9uIHRoaXMgZGV2aWNlXCIsIFwiY3JlYXRlQ2FwdHVyZVwiKSwgRi5uYW1lID09PSBcIk5vdEFsbG93ZWRFcnJvclwiICYmIHkuZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIkFjY2VzcyB0byB0aGUgY2FtZXJhIHdhcyBkZW5pZWRcIiwgXCJjcmVhdGVDYXB0dXJlXCIpLCBjb25zb2xlLmVycm9yKEYpO1xuICAgICAgICB9KSwgbChSLCB0aGlzLCAhMCkpO1xuICAgICAgICByZXR1cm4gTC5sb2FkZWRtZXRhZGF0YSA9ICExLCBSLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBSLnBsYXkoKSwgUi53aWR0aCA/IChMLndpZHRoID0gUi53aWR0aCwgTC5oZWlnaHQgPSBSLmhlaWdodCwgRSAmJiAoTC5lbHQuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZVgoLTEpXCIpKSA6IChMLndpZHRoID0gTC5lbHQud2lkdGggPSBSLnZpZGVvV2lkdGgsIEwuaGVpZ2h0ID0gTC5lbHQuaGVpZ2h0ID0gUi52aWRlb0hlaWdodCksIEwubG9hZGVkbWV0YWRhdGEgPSAhMCwgVCAmJiBUKFIuc3JjT2JqZWN0KTtcbiAgICAgICAgfSksIEwuZmxpcHBlZCA9IEUsIEw7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihjLCBwKSB7XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUVsZW1lbnRcIiwgYXJndW1lbnRzKSwgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYyksIHAgIT09IHZvaWQgMCAmJiAoYy5pbm5lckhUTUwgPSBwKSwgbChjLCB0aGlzKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LmNsYXNzTmFtZSA/IHRoaXMuaGFzQ2xhc3MoYykgfHwgKHRoaXMuZWx0LmNsYXNzTmFtZSA9IHRoaXMuZWx0LmNsYXNzTmFtZSArIFwiIFwiICsgYykgOiB0aGlzLmVsdC5jbGFzc05hbWUgPSBjLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHQuY2xhc3NMaXN0LnJlbW92ZShjKSwgdGhpcztcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LmNsYXNzTGlzdC5jb250YWlucyhjKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LmNsYXNzTGlzdC5jb250YWlucyhjKSA/IHRoaXMuZWx0LmNsYXNzTGlzdC5yZW1vdmUoYykgOiB0aGlzLmVsdC5jbGFzc0xpc3QuYWRkKGMpLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gdm9pZCAwID8gdGhpcy5lbHQuY2hpbGROb2RlcyA6ICh0eXBlb2YgYyA9PSBcInN0cmluZ1wiID8gKGNbMF0gPT09IFwiI1wiICYmIChjID0gYy5zdWJzdHJpbmcoMSkpLCBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYykpIDogYyBpbnN0YW5jZW9mIHkuZGVmYXVsdC5FbGVtZW50ICYmIChjID0gYy5lbHQpLCBjIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGhpcy5lbHQuYXBwZW5kQ2hpbGQoYyksIHRoaXMpO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmVsdC5zdHlsZS5kaXNwbGF5LCBqID0gdGhpcy5lbHQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIsIFQgPSB0aGlzLnBhcmVudCgpLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiLCBfID0geyB4OiB0aGlzLmVsdC5vZmZzZXRMZWZ0LCB5OiB0aGlzLmVsdC5vZmZzZXRUb3AgfSwgUyA9IChqICYmIHRoaXMuc2hvdygpLCBUICYmIHRoaXMucGFyZW50KCkuc2hvdygpLCB0aGlzLmVsdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLnBvc2l0aW9uKDAsIDApLCBNYXRoLmFicyh0aGlzLnBhcmVudCgpLm9mZnNldFdpZHRoIC0gdGhpcy5lbHQub2Zmc2V0V2lkdGgpKSwgRSA9IE1hdGguYWJzKHRoaXMucGFyZW50KCkub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbHQub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGMgPT09IFwiYm90aFwiIHx8IGMgPT09IHZvaWQgMCA/IHRoaXMucG9zaXRpb24oUyAvIDIgKyB0aGlzLnBhcmVudCgpLm9mZnNldExlZnQsIEUgLyAyICsgdGhpcy5wYXJlbnQoKS5vZmZzZXRUb3ApIDogYyA9PT0gXCJob3Jpem9udGFsXCIgPyB0aGlzLnBvc2l0aW9uKFMgLyAyICsgdGhpcy5wYXJlbnQoKS5vZmZzZXRMZWZ0LCBfLnkpIDogYyA9PT0gXCJ2ZXJ0aWNhbFwiICYmIHRoaXMucG9zaXRpb24oXy54LCBFIC8gMiArIHRoaXMucGFyZW50KCkub2Zmc2V0VG9wKSwgdGhpcy5zdHlsZShcImRpc3BsYXlcIiwgcCksIGogJiYgdGhpcy5oaWRlKCksIFQgJiYgdGhpcy5wYXJlbnQoKS5oaWRlKCksIHRoaXM7XG4gICAgICB9LCB5LmRlZmF1bHQuRWxlbWVudC5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMuZWx0LmlubmVySFRNTCA6IChhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgIWFyZ3VtZW50c1sxXSA/IHRoaXMuZWx0LmlubmVySFRNTCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSA6IHRoaXMuZWx0Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pLCB0aGlzKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHsgeDogdGhpcy5lbHQub2Zmc2V0TGVmdCwgeTogdGhpcy5lbHQub2Zmc2V0VG9wIH0gOiAodGhpcy5lbHQuc3R5bGUucG9zaXRpb24gPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdKSAhPT0gXCJzdGF0aWNcIiAmJiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdKSAhPT0gXCJmaXhlZFwiICYmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0pICE9PSBcInJlbGF0aXZlXCIgJiYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSkgIT09IFwic3RpY2t5XCIgJiYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSkgIT09IFwiaW5pdGlhbFwiICYmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0pICE9PSBcImluaGVyaXRcIiA/IFwiYWJzb2x1dGVcIiA6IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSwgdGhpcy5lbHQuc3R5bGUubGVmdCA9IChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pICsgXCJweFwiLCB0aGlzLmVsdC5zdHlsZS50b3AgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSArIFwicHhcIiwgdGhpcy54ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdLCB0aGlzLnkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0sIHRoaXMpO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLl90cmFuc2xhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbHQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHZhciBjID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LnN0eWxlLnRyYW5zZm9ybSAmJiAoYyA9IChjID0gdGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoL3RyYW5zbGF0ZTNkXFwoLipcXCkvZywgXCJcIikpLnJlcGxhY2UoL3RyYW5zbGF0ZVtYLVpdP1xcKC4qXFwpL2csIFwiXCIpKSwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IHRoaXMuZWx0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgKyBcInB4LCBcIiArIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pICsgXCJweClcIiA6IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmICh0aGlzLmVsdC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZTNkKFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgKyBcInB4LFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSkgKyBcInB4LFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSkgKyBcInB4KVwiLCB0aGlzLmVsdC5wYXJlbnRFbGVtZW50LnN0eWxlLnBlcnNwZWN0aXZlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IFwiMTAwMHB4XCIgOiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdm9pZCAwIDogYXJndW1lbnRzWzNdKSArIFwicHhcIiksIHRoaXMuZWx0LnN0eWxlLnRyYW5zZm9ybSArPSBjLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLl9yb3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtICYmIChjID0gKGMgPSB0aGlzLmVsdC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvcm90YXRlM2RcXCguKlxcKS9nLCBcIlwiKSkucmVwbGFjZSgvcm90YXRlW1gtWl0/XFwoLipcXCkvZywgXCJcIikpLCBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSArIFwiZGVnKVwiIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IHRoaXMuZWx0LnN0eWxlLnRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgKyBcImRlZywgXCIgKyAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSArIFwiZGVnKVwiIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAodGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtID0gXCJyb3RhdGVYKFwiICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgKyBcImRlZylcIiwgdGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtICs9IFwicm90YXRlWShcIiArIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pICsgXCJkZWcpXCIsIHRoaXMuZWx0LnN0eWxlLnRyYW5zZm9ybSArPSBcInJvdGF0ZVooXCIgKyAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdKSArIFwiZGVnKVwiKSwgdGhpcy5lbHQuc3R5bGUudHJhbnNmb3JtICs9IGMsIHRoaXM7XG4gICAgICB9LCB5LmRlZmF1bHQuRWxlbWVudC5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihjLCBwKSB7XG4gICAgICAgIGlmICgocCA9IHAgaW5zdGFuY2VvZiB5LmRlZmF1bHQuQ29sb3IgPyBcInJnYmEoXCIgKyBwLmxldmVsc1swXSArIFwiLFwiICsgcC5sZXZlbHNbMV0gKyBcIixcIiArIHAubGV2ZWxzWzJdICsgXCIsXCIgKyBwLmxldmVsc1szXSAvIDI1NSArIFwiKVwiIDogcCkgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChjLmluZGV4T2YoXCI6XCIpID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsdCkuZ2V0UHJvcGVydHlWYWx1ZShjKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gYy5zcGxpdChcIjtcIiksIFQgPSAwOyBUIDwgai5sZW5ndGg7IFQrKykge1xuICAgICAgICAgICAgdmFyIF8gPSBqW1RdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIF9bMF0gJiYgX1sxXSAmJiAodGhpcy5lbHQuc3R5bGVbX1swXS50cmltKCldID0gX1sxXS50cmltKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5lbHQuc3R5bGVbY10gPSBwLCBjICE9PSBcIndpZHRoXCIgJiYgYyAhPT0gXCJoZWlnaHRcIiAmJiBjICE9PSBcImxlZnRcIiAmJiBjICE9PSBcInRvcFwiIHx8IChwID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbHQpLmdldFByb3BlcnR5VmFsdWUoYykucmVwbGFjZSgvW15cXGQuXS9nLCBcIlwiKSwgdGhpc1tjXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChwLCAxMCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCB5LmRlZmF1bHQuRWxlbWVudC5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYywgcCkge1xuICAgICAgICBpZiAodGhpcy5lbHQuZmlyc3RDaGlsZCA9PSBudWxsIHx8IHRoaXMuZWx0LmZpcnN0Q2hpbGQudHlwZSAhPT0gXCJjaGVja2JveFwiICYmIHRoaXMuZWx0LmZpcnN0Q2hpbGQudHlwZSAhPT0gXCJyYWRpb1wiKVxuICAgICAgICAgIHJldHVybiBwID09PSB2b2lkIDAgPyB0aGlzLmVsdC5nZXRBdHRyaWJ1dGUoYykgOiAodGhpcy5lbHQuc2V0QXR0cmlidXRlKGMsIHApLCB0aGlzKTtcbiAgICAgICAgaWYgKHAgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbHQuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoYyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5lbHQuY2hpbGROb2Rlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICB0aGlzLmVsdC5jaGlsZE5vZGVzW2pdLnNldEF0dHJpYnV0ZShjLCBwKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmICh0aGlzLmVsdC5maXJzdENoaWxkICE9IG51bGwgJiYgKHRoaXMuZWx0LmZpcnN0Q2hpbGQudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMuZWx0LmZpcnN0Q2hpbGQudHlwZSA9PT0gXCJyYWRpb1wiKSlcbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMuZWx0LmNoaWxkTm9kZXMubGVuZ3RoOyBwKyspXG4gICAgICAgICAgICB0aGlzLmVsdC5jaGlsZE5vZGVzW3BdLnJlbW92ZUF0dHJpYnV0ZShjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LnJlbW92ZUF0dHJpYnV0ZShjKSwgdGhpcztcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMCA8IGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5lbHQudmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIHRoaXMpIDogdGhpcy5lbHQudHlwZSA9PT0gXCJyYW5nZVwiID8gcGFyc2VGbG9hdCh0aGlzLmVsdC52YWx1ZSkgOiB0aGlzLmVsdC52YWx1ZTtcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWx0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgdGhpcztcbiAgICAgIH0sIHkuZGVmYXVsdC5FbGVtZW50LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oYywgcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICByZXR1cm4geyB3aWR0aDogdGhpcy5lbHQub2Zmc2V0V2lkdGgsIGhlaWdodDogdGhpcy5lbHQub2Zmc2V0SGVpZ2h0IH07XG4gICAgICAgIHZhciBqID0gYywgVCA9IHAsIF8gPSB5LmRlZmF1bHQucHJvdG90eXBlLkFVVE87XG4gICAgICAgIGlmIChqICE9PSBfIHx8IFQgIT09IF8pIHtcbiAgICAgICAgICBpZiAoaiA9PT0gXyA/IGogPSBwICogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0IDogVCA9PT0gXyAmJiAoVCA9IGMgKiB0aGlzLmhlaWdodCAvIHRoaXMud2lkdGgpLCB0aGlzLmVsdCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgUywgRSA9IHt9LCBBID0gdGhpcy5lbHQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgZm9yIChTIGluIEEpXG4gICAgICAgICAgICAgIEVbU10gPSBBW1NdO1xuICAgICAgICAgICAgZm9yIChTIGluIHRoaXMuZWx0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGogKiB0aGlzLl9wSW5zdC5fcGl4ZWxEZW5zaXR5KSwgdGhpcy5lbHQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFQgKiB0aGlzLl9wSW5zdC5fcGl4ZWxEZW5zaXR5KSwgdGhpcy5lbHQuc3R5bGUud2lkdGggPSBqICsgXCJweFwiLCB0aGlzLmVsdC5zdHlsZS5oZWlnaHQgPSBUICsgXCJweFwiLCB0aGlzLl9wSW5zdC5zY2FsZSh0aGlzLl9wSW5zdC5fcGl4ZWxEZW5zaXR5LCB0aGlzLl9wSW5zdC5fcGl4ZWxEZW5zaXR5KSwgRSlcbiAgICAgICAgICAgICAgdGhpcy5lbHQuZ2V0Q29udGV4dChcIjJkXCIpW1NdID0gRVtTXTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuZWx0LnN0eWxlLndpZHRoID0gaiArIFwicHhcIiwgdGhpcy5lbHQuc3R5bGUuaGVpZ2h0ID0gVCArIFwicHhcIiwgdGhpcy5lbHQud2lkdGggPSBqLCB0aGlzLmVsdC5oZWlnaHQgPSBUO1xuICAgICAgICAgIHRoaXMud2lkdGggPSBqLCB0aGlzLmhlaWdodCA9IFQsIHRoaXMuX3BJbnN0ICYmIHRoaXMuX3BJbnN0Ll9jdXJFbGVtZW50ICYmIHRoaXMuX3BJbnN0Ll9jdXJFbGVtZW50LmVsdCA9PT0gdGhpcy5lbHQgJiYgKHRoaXMuX3BJbnN0Ll9zZXRQcm9wZXJ0eShcIndpZHRoXCIsIGopLCB0aGlzLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgVCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzIGluc3RhbmNlb2YgeS5kZWZhdWx0Lk1lZGlhRWxlbWVudCAmJiAodGhpcy5zdG9wKCksIChwID0gdGhpcy5lbHQuc3JjT2JqZWN0KSAhPT0gbnVsbCAmJiBwLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICAgIGouc3RvcCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBjLCBwID0gdGhpcy5fcEluc3QuX2VsZW1lbnRzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGZvciAoYyBpbiBwICE9PSAtMSAmJiB0aGlzLl9wSW5zdC5fZWxlbWVudHMuc3BsaWNlKHAsIDEpLCB0aGlzLl9ldmVudHMpXG4gICAgICAgICAgdGhpcy5lbHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLCB0aGlzLl9ldmVudHNbY10pO1xuICAgICAgICB0aGlzLmVsdCAmJiB0aGlzLmVsdC5wYXJlbnROb2RlICYmIHRoaXMuZWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbHQpO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbihjLCBwKSB7XG4gICAgICAgIHZhciBqO1xuICAgICAgICByZXR1cm4gd2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iID8gKHRoaXMuX2RyYWdEaXNhYmxlZCB8fCAodGhpcy5fZHJhZ0Rpc2FibGVkID0gITAsIHRoaXMuZWx0LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBqID0gZnVuY3Rpb24oVCkge1xuICAgICAgICAgIFQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSksIHRoaXMuZWx0LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgaikpLCB5LmRlZmF1bHQuRWxlbWVudC5fYXR0YWNoTGlzdGVuZXIoXCJkcm9wXCIsIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICBfLnByZXZlbnREZWZhdWx0KCksIHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIiAmJiBwLmNhbGwodGhpcywgXyk7XG4gICAgICAgICAgdmFyIF8gPSBfLmRhdGFUcmFuc2Zlci5maWxlcywgUyA9ICEwLCBFID0gITEsIEEgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHgsIFAgPSBfW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShTID0gKHggPSBQLm5leHQoKSkuZG9uZSk7IFMgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgTSA9IHgudmFsdWU7XG4gICAgICAgICAgICAgIHkuZGVmYXVsdC5GaWxlLl9sb2FkKE0sIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICAgIEUgPSAhMCwgQSA9IFI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFMgfHwgUC5yZXR1cm4gPT0gbnVsbCB8fCBQLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKEUpXG4gICAgICAgICAgICAgICAgdGhyb3cgQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpKSA6IGNvbnNvbGUubG9nKFwiVGhlIEZpbGUgQVBJcyBhcmUgbm90IGZ1bGx5IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuXCIpLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LkVsZW1lbnQucHJvdG90eXBlLmRyYWdnYWJsZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAsIGogPSBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdywgVCA9IDAsIF8gPSAwLCBTID0gMCwgRSA9IDAsIEEgPSBqID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCIsIHggPSBqID8gXCJ0b3VjaG1vdmVcIiA6IFwibW91c2Vtb3ZlXCI7XG4gICAgICAgIGZ1bmN0aW9uIFAoUikge1xuICAgICAgICAgIHZhciBMO1xuICAgICAgICAgIFIgPSBSIHx8IHdpbmRvdy5ldmVudCwgRSA9IGogPyAoTCA9IFIuY2hhbmdlZFRvdWNoZXMsIFQgPSBTIC0gcGFyc2VJbnQoTFswXS5jbGllbnRYKSwgXyA9IEUgLSBwYXJzZUludChMWzBdLmNsaWVudFkpLCBTID0gcGFyc2VJbnQoTFswXS5jbGllbnRYKSwgcGFyc2VJbnQoTFswXS5jbGllbnRZKSkgOiAoVCA9IFMgLSBwYXJzZUludChSLmNsaWVudFgpLCBfID0gRSAtIHBhcnNlSW50KFIuY2xpZW50WSksIFMgPSBwYXJzZUludChSLmNsaWVudFgpLCBwYXJzZUludChSLmNsaWVudFkpKSwgYy5zdHlsZS5sZWZ0ID0gYy5vZmZzZXRMZWZ0IC0gVCArIFwicHhcIiwgYy5zdHlsZS50b3AgPSBjLm9mZnNldFRvcCAtIF8gKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTSgpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEEsIE0sICExKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih4LCBQLCAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMgPT09IHZvaWQgMCA/IHAgPSBjID0gdGhpcy5lbHQgOiBjICE9PSB0aGlzLmVsdCAmJiBjLmVsdCAhPT0gdGhpcy5lbHQgJiYgKGMgPSBjLmVsdCwgcCA9IHRoaXMuZWx0KSwgcC5hZGRFdmVudExpc3RlbmVyKGogPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgTDtcbiAgICAgICAgICAgIFIgPSBSIHx8IHdpbmRvdy5ldmVudCwgRSA9IGogPyAoTCA9IFIuY2hhbmdlZFRvdWNoZXMsIFMgPSBwYXJzZUludChMWzBdLmNsaWVudFgpLCBwYXJzZUludChMWzBdLmNsaWVudFkpKSA6IChTID0gcGFyc2VJbnQoUi5jbGllbnRYKSwgcGFyc2VJbnQoUi5jbGllbnRZKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKEEsIE0sICExKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih4LCBQLCAhMSksICExO1xuICAgICAgICB9LCAhMSksIHAuc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCIsIHRoaXM7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gYShjLCBwLCBqLCBUKSB7XG4gICAgICAgIG8odGhpcywgYSksIHRoaXMuY2FsbGJhY2sgPSBjLCB0aGlzLnRpbWUgPSBwLCB0aGlzLmlkID0gaiwgdGhpcy52YWwgPSBUO1xuICAgICAgfVxuICAgICAgdCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAgPSBUO1xuICAgICAgICBpZiAodHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiICYmIGMgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyAmJiBjLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogcCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIGMgJiYgZyhwLCBjKTtcbiAgICAgICAgdmFyIGogPSBmKFQpO1xuICAgICAgICBmdW5jdGlvbiBUKF8sIFMpIHtcbiAgICAgICAgICBvKHRoaXMsIFQpO1xuICAgICAgICAgIHZhciBFID0gcihTID0gai5jYWxsKHRoaXMsIF8sIFMpKTtcbiAgICAgICAgICByZXR1cm4gUy5lbHQuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiLCBTLl9wcmV2VGltZSA9IDAsIFMuX2N1ZUlEQ291bnRlciA9IDAsIFMuX2N1ZXMgPSBbXSwgUy5waXhlbHMgPSBbXSwgUy5fcGl4ZWxzU3RhdGUgPSByKFMpLCBTLl9waXhlbERlbnNpdHkgPSAxLCBTLl9tb2RpZmllZCA9ICExLCBTLl9mcmFtZU9uQ2FudmFzID0gLTEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFLCBcInNyY1wiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgQSA9IEUuZWx0LmNoaWxkcmVuWzBdLnNyYywgeCA9IEUuZWx0LnNyYyA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYgPyBcIlwiIDogRS5lbHQuc3JjO1xuICAgICAgICAgICAgcmV0dXJuIEEgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmID8geCA6IEE7XG4gICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbihBKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEUuZWx0LmNoaWxkcmVuLmxlbmd0aDsgeCsrKVxuICAgICAgICAgICAgICBFLmVsdC5yZW1vdmVDaGlsZChFLmVsdC5jaGlsZHJlblt4XSk7XG4gICAgICAgICAgICB2YXIgUCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG4gICAgICAgICAgICBQLnNyYyA9IEEsIF8uYXBwZW5kQ2hpbGQoUCksIEUuZWx0LnNyYyA9IEEsIEUubW9kaWZpZWQgPSAhMDtcbiAgICAgICAgICB9IH0pLCBFLl9vbmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfSwgRS5lbHQub25lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgRS5fb25lbmRlZChFKTtcbiAgICAgICAgICB9LCBTO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKFQsIFt7IGtleTogXCJwbGF5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgXztcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbHQuY3VycmVudFRpbWUgPT09IHRoaXMuZWx0LmR1cmF0aW9uICYmICh0aGlzLmVsdC5jdXJyZW50VGltZSA9IDApLCAxIDwgdGhpcy5lbHQucmVhZHlTdGF0ZSB8fCB0aGlzLmVsdC5sb2FkKCksIChfID0gdGhpcy5lbHQucGxheSgpKSAmJiBfLmNhdGNoICYmIF8uY2F0Y2goZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgUy5uYW1lID09PSBcIk5vdEFsbG93ZWRFcnJvclwiID8gY29uc29sZS5lcnJvcihTKSA6IGNvbnNvbGUuZXJyb3IoXCJNZWRpYSBwbGF5IG1ldGhvZCBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGVycm9yXCIsIFMpO1xuICAgICAgICAgIH0pLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0b3BcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsdC5wYXVzZSgpLCB0aGlzLmVsdC5jdXJyZW50VGltZSA9IDAsIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicGF1c2VcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsdC5wYXVzZSgpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxvb3BcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsdC5zZXRBdHRyaWJ1dGUoXCJsb29wXCIsICEwKSwgdGhpcy5wbGF5KCksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibm9Mb29wXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbHQucmVtb3ZlQXR0cmlidXRlKFwibG9vcFwiKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfc2V0dXBBdXRvcGxheUZhaWxEZXRlY3Rpb25cIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICB0aGlzLmVsdC5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoXyk7XG4gICAgICAgICAgfSwgeyBwYXNzaXZlOiAhMCwgb25jZTogITAgfSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYXV0b3BsYXlcIiwgdmFsdWU6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICB2YXIgUyA9IHRoaXMsIEUgPSB0aGlzLmVsdC5nZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbHQuc2V0QXR0cmlidXRlKFwiYXV0b3BsYXlcIiwgXyksIF8gJiYgIUUgJiYgKF8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBTLl9zZXR1cEF1dG9wbGF5RmFpbERldGVjdGlvbigpO1xuICAgICAgICAgIH0sIHRoaXMuZWx0LnJlYWR5U3RhdGUgPT09IDQgPyBfKCkgOiB0aGlzLmVsdC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBfLCB7IHBhc3NpdmU6ICEwLCBvbmNlOiAhMCB9KSksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidm9sdW1lXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgaWYgKF8gPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsdC52b2x1bWU7XG4gICAgICAgICAgdGhpcy5lbHQudm9sdW1lID0gXztcbiAgICAgICAgfSB9LCB7IGtleTogXCJzcGVlZFwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIGlmIChfID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVzZXRQbGF5YmFja1JhdGUgfHwgdGhpcy5lbHQucGxheWJhY2tSYXRlO1xuICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPyB0aGlzLmVsdC5wbGF5YmFja1JhdGUgPSBfIDogdGhpcy5wcmVzZXRQbGF5YmFja1JhdGUgPSBfO1xuICAgICAgICB9IH0sIHsga2V5OiBcInRpbWVcIiwgdmFsdWU6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICByZXR1cm4gXyA9PT0gdm9pZCAwID8gdGhpcy5lbHQuY3VycmVudFRpbWUgOiAodGhpcy5lbHQuY3VycmVudFRpbWUgPSBfLCB0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkdXJhdGlvblwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWx0LmR1cmF0aW9uO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9lbnN1cmVDYW52YXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2FudmFzIHx8ICh0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHRoaXMuZHJhd2luZ0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHRoaXMuc2V0TW9kaWZpZWQoITApKTtcbiAgICAgICAgICB2YXIgXyA9IHRoaXMuX2ZyYW1lT25DYW52YXMgIT09IHRoaXMuX3BJbnN0LmZyYW1lQ291bnQ7XG4gICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBfICYmICh0aGlzLmNhbnZhcy53aWR0aCAhPT0gdGhpcy5lbHQud2lkdGggJiYgKHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5lbHQud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuZWx0LmhlaWdodCwgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCksIHRoaXMuZHJhd2luZ0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpLCB0aGlzLmZsaXBwZWQgPT09ICEwICYmICh0aGlzLmRyYXdpbmdDb250ZXh0LnNhdmUoKSwgdGhpcy5kcmF3aW5nQ29udGV4dC5zY2FsZSgtMSwgMSksIHRoaXMuZHJhd2luZ0NvbnRleHQudHJhbnNsYXRlKC10aGlzLmNhbnZhcy53aWR0aCwgMCkpLCB0aGlzLmRyYXdpbmdDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmVsdCwgMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCksIHRoaXMuZmxpcHBlZCA9PT0gITAgJiYgdGhpcy5kcmF3aW5nQ29udGV4dC5yZXN0b3JlKCksIHRoaXMuc2V0TW9kaWZpZWQoITApLCB0aGlzLl9mcmFtZU9uQ2FudmFzID0gdGhpcy5fcEluc3QuZnJhbWVDb3VudCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibG9hZFBpeGVsc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fZW5zdXJlQ2FudmFzKCk7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IGFyZ3VtZW50cy5sZW5ndGgsIFMgPSBuZXcgQXJyYXkoXyksIEUgPSAwOyBFIDwgXzsgRSsrKVxuICAgICAgICAgICAgU1tFXSA9IGFyZ3VtZW50c1tFXTtcbiAgICAgICAgICByZXR1cm4geS5kZWZhdWx0LlJlbmRlcmVyMkQucHJvdG90eXBlLmxvYWRQaXhlbHMuYXBwbHkodGhpcywgUyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXBkYXRlUGl4ZWxzXCIsIHZhbHVlOiBmdW5jdGlvbihfLCBTLCBFLCBBKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgKHRoaXMuX2Vuc3VyZUNhbnZhcygpLCB5LmRlZmF1bHQuUmVuZGVyZXIyRC5wcm90b3R5cGUudXBkYXRlUGl4ZWxzLmNhbGwodGhpcywgXywgUywgRSwgQSkpLCB0aGlzLnNldE1vZGlmaWVkKCEwKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2Vuc3VyZUNhbnZhcygpO1xuICAgICAgICAgIGZvciAodmFyIF8gPSBhcmd1bWVudHMubGVuZ3RoLCBTID0gbmV3IEFycmF5KF8pLCBFID0gMDsgRSA8IF87IEUrKylcbiAgICAgICAgICAgIFNbRV0gPSBhcmd1bWVudHNbRV07XG4gICAgICAgICAgcmV0dXJuIHkuZGVmYXVsdC5SZW5kZXJlcjJELnByb3RvdHlwZS5nZXQuYXBwbHkodGhpcywgUyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldFBpeGVsXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQaXhlbHMoKTtcbiAgICAgICAgICBmb3IgKHZhciBfID0gYXJndW1lbnRzLmxlbmd0aCwgUyA9IG5ldyBBcnJheShfKSwgRSA9IDA7IEUgPCBfOyBFKyspXG4gICAgICAgICAgICBTW0VdID0gYXJndW1lbnRzW0VdO1xuICAgICAgICAgIHJldHVybiB5LmRlZmF1bHQuUmVuZGVyZXIyRC5wcm90b3R5cGUuX2dldFBpeGVsLmFwcGx5KHRoaXMsIFMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFwiLCB2YWx1ZTogZnVuY3Rpb24oXywgUywgRSkge1xuICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgKHRoaXMuX2Vuc3VyZUNhbnZhcygpLCB5LmRlZmF1bHQuUmVuZGVyZXIyRC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgXywgUywgRSksIHRoaXMuc2V0TW9kaWZpZWQoITApKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjb3B5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVDYW52YXMoKTtcbiAgICAgICAgICBmb3IgKHZhciBfID0gYXJndW1lbnRzLmxlbmd0aCwgUyA9IG5ldyBBcnJheShfKSwgRSA9IDA7IEUgPCBfOyBFKyspXG4gICAgICAgICAgICBTW0VdID0gYXJndW1lbnRzW0VdO1xuICAgICAgICAgIHkuZGVmYXVsdC5wcm90b3R5cGUuY29weS5hcHBseSh0aGlzLCBTKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtYXNrXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQaXhlbHMoKSwgdGhpcy5zZXRNb2RpZmllZCghMCk7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IGFyZ3VtZW50cy5sZW5ndGgsIFMgPSBuZXcgQXJyYXkoXyksIEUgPSAwOyBFIDwgXzsgRSsrKVxuICAgICAgICAgICAgU1tFXSA9IGFyZ3VtZW50c1tFXTtcbiAgICAgICAgICB5LmRlZmF1bHQuSW1hZ2UucHJvdG90eXBlLm1hc2suYXBwbHkodGhpcywgUyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaXNNb2RpZmllZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21vZGlmaWVkO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldE1vZGlmaWVkXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgdGhpcy5fbW9kaWZpZWQgPSBfO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm9uZW5kZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25lbmRlZCA9IF8sIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY29ubmVjdFwiLCB2YWx1ZTogZnVuY3Rpb24oXykge1xuICAgICAgICAgIHZhciBTLCBFO1xuICAgICAgICAgIGlmICh0eXBlb2YgeS5kZWZhdWx0LnByb3RvdHlwZS5nZXRBdWRpb0NvbnRleHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgUyA9IHkuZGVmYXVsdC5wcm90b3R5cGUuZ2V0QXVkaW9Db250ZXh0KCksIEUgPSB5LmRlZmF1bHQuc291bmRPdXQuaW5wdXQ7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRSA9IChTID0gXy5jb250ZXh0KS5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB0aHJvdyBcImNvbm5lY3QoKSBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGggV2ViIEF1ZGlvIEFQSSBvciBwNS5zb3VuZC5qc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXVkaW9Tb3VyY2VOb2RlIHx8ICh0aGlzLmF1ZGlvU291cmNlTm9kZSA9IFMuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKHRoaXMuZWx0KSwgdGhpcy5hdWRpb1NvdXJjZU5vZGUuY29ubmVjdChFKSksIF8gPyBfLmlucHV0ID8gdGhpcy5hdWRpb1NvdXJjZU5vZGUuY29ubmVjdChfLmlucHV0KSA6IHRoaXMuYXVkaW9Tb3VyY2VOb2RlLmNvbm5lY3QoXykgOiB0aGlzLmF1ZGlvU291cmNlTm9kZS5jb25uZWN0KEUpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRpc2Nvbm5lY3RcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5hdWRpb1NvdXJjZU5vZGUpXG4gICAgICAgICAgICB0aHJvdyBcIm5vdGhpbmcgdG8gZGlzY29ubmVjdFwiO1xuICAgICAgICAgIHRoaXMuYXVkaW9Tb3VyY2VOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzaG93Q29udHJvbHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZWx0LnN0eWxlW1widGV4dC1hbGlnblwiXSA9IFwiaW5oZXJpdFwiLCB0aGlzLmVsdC5jb250cm9scyA9ICEwO1xuICAgICAgICB9IH0sIHsga2V5OiBcImhpZGVDb250cm9sc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5lbHQuY29udHJvbHMgPSAhMTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJhZGRDdWVcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIHgsIEUpIHtcbiAgICAgICAgICB2YXIgQSA9IHRoaXMuX2N1ZUlEQ291bnRlcisrLCB4ID0gbmV3IGEoeCwgXywgQSwgRSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2N1ZXMucHVzaCh4KSwgdGhpcy5lbHQub250aW1ldXBkYXRlIHx8ICh0aGlzLmVsdC5vbnRpbWV1cGRhdGUgPSB0aGlzLl9vblRpbWVVcGRhdGUuYmluZCh0aGlzKSksIEE7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlQ3VlXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgZm9yICh2YXIgUyA9IDA7IFMgPCB0aGlzLl9jdWVzLmxlbmd0aDsgUysrKVxuICAgICAgICAgICAgdGhpcy5fY3Vlc1tTXS5pZCA9PT0gXyAmJiAoY29uc29sZS5sb2coXyksIHRoaXMuX2N1ZXMuc3BsaWNlKFMsIDEpKTtcbiAgICAgICAgICB0aGlzLl9jdWVzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5lbHQub250aW1ldXBkYXRlID0gbnVsbCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJDdWVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9jdWVzID0gW10sIHRoaXMuZWx0Lm9udGltZXVwZGF0ZSA9IG51bGw7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX29uVGltZVVwZGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IHRoaXMudGltZSgpLCBTID0gMDsgUyA8IHRoaXMuX2N1ZXMubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgICAgIHZhciBFID0gdGhpcy5fY3Vlc1tTXS50aW1lLCBBID0gdGhpcy5fY3Vlc1tTXS52YWw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2VGltZSA8IEUgJiYgRSA8PSBfICYmIHRoaXMuX2N1ZXNbU10uY2FsbGJhY2soQSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gXztcbiAgICAgICAgfSB9XSksIFQ7XG4gICAgICB9KHkuZGVmYXVsdC5FbGVtZW50KSwgeS5kZWZhdWx0Lk1lZGlhRWxlbWVudCA9IHQsIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gYyhwLCBqKSB7XG4gICAgICAgICAgbyh0aGlzLCBjKSwgdGhpcy5maWxlID0gcCwgdGhpcy5fcEluc3QgPSBqLCBqID0gcC50eXBlLnNwbGl0KFwiL1wiKSwgdGhpcy50eXBlID0galswXSwgdGhpcy5zdWJ0eXBlID0galsxXSwgdGhpcy5uYW1lID0gcC5uYW1lLCB0aGlzLnNpemUgPSBwLnNpemUsIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaChjLCBudWxsLCBbeyBrZXk6IFwiX2NyZWF0ZUxvYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24ocCwgaikge1xuICAgICAgICAgIHZhciBUID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZXR1cm4gVC5vbmxvYWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICB2YXIgUywgRSA9IG5ldyB5LmRlZmF1bHQuRmlsZShwKTtcbiAgICAgICAgICAgIEUuZmlsZS50eXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIiA/IEUuZGF0YSA9IEpTT04ucGFyc2UoXy50YXJnZXQucmVzdWx0KSA6IEUuZmlsZS50eXBlID09PSBcInRleHQveG1sXCIgPyAoUyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoXy50YXJnZXQucmVzdWx0LCBcInRleHQveG1sXCIpLCBFLmRhdGEgPSBuZXcgeS5kZWZhdWx0LlhNTChTLmRvY3VtZW50RWxlbWVudCkpIDogRS5kYXRhID0gXy50YXJnZXQucmVzdWx0LCBqKEUpO1xuICAgICAgICAgIH0sIFQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2xvYWRcIiwgdmFsdWU6IGZ1bmN0aW9uKHAsIGopIHtcbiAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAvXnRleHRcXC8vLnRlc3QocC50eXBlKSB8fCBwLnR5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiID8geS5kZWZhdWx0LkZpbGUuX2NyZWF0ZUxvYWRlcihwLCBqKS5yZWFkQXNUZXh0KHApIDogL14odmlkZW98YXVkaW8pXFwvLy50ZXN0KHAudHlwZSkgPyAoKFQgPSBuZXcgeS5kZWZhdWx0LkZpbGUocCkpLmRhdGEgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHApLCBqKFQpKSA6IHkuZGVmYXVsdC5GaWxlLl9jcmVhdGVMb2FkZXIocCwgaikucmVhZEFzRGF0YVVSTChwKTtcbiAgICAgICAgfSB9XSksIGM7XG4gICAgICB9KCksIHkuZGVmYXVsdC5GaWxlID0gdCwgdCA9IHkuZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnlcIjogMTU0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiOiAxNjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCI6IDE2NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIjogMTY4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIjogMTcwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCI6IDE3MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiOiAxODEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mXCI6IDE4NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2VcIjogMTg4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiOiAxODksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCI6IDIwMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIjogMjA2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi51cmxcIjogMjQ1IH1dLCAyOTc6IFtmdW5jdGlvbihpLCBILCBDKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IChpID0gaShcIi4uL2NvcmUvbWFpblwiKSkgJiYgaS5fX2VzTW9kdWxlID8gaSA6IHsgZGVmYXVsdDogaSB9O1xuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5kZXZpY2VPcmllbnRhdGlvbiA9IDEgPCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCA/IFwibGFuZHNjYXBlXCIgOiBcInBvcnRyYWl0XCIsIG0uZGVmYXVsdC5wcm90b3R5cGUuYWNjZWxlcmF0aW9uWCA9IDAsIG0uZGVmYXVsdC5wcm90b3R5cGUuYWNjZWxlcmF0aW9uWSA9IDAsIG0uZGVmYXVsdC5wcm90b3R5cGUuYWNjZWxlcmF0aW9uWiA9IDAsIG0uZGVmYXVsdC5wcm90b3R5cGUucEFjY2VsZXJhdGlvblggPSAwLCBtLmRlZmF1bHQucHJvdG90eXBlLnBBY2NlbGVyYXRpb25ZID0gMCwgbS5kZWZhdWx0LnByb3RvdHlwZS5wQWNjZWxlcmF0aW9uWiA9IDAsIG0uZGVmYXVsdC5wcm90b3R5cGUuX3VwZGF0ZVBBY2NlbGVyYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwicEFjY2VsZXJhdGlvblhcIiwgdGhpcy5hY2NlbGVyYXRpb25YKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJwQWNjZWxlcmF0aW9uWVwiLCB0aGlzLmFjY2VsZXJhdGlvblkpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInBBY2NlbGVyYXRpb25aXCIsIHRoaXMuYWNjZWxlcmF0aW9uWik7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnJvdGF0aW9uWCA9IDAsIG0uZGVmYXVsdC5wcm90b3R5cGUucm90YXRpb25ZID0gMCwgbS5kZWZhdWx0LnByb3RvdHlwZS5yb3RhdGlvblogPSAwLCBtLmRlZmF1bHQucHJvdG90eXBlLnBSb3RhdGlvblggPSAwLCBtLmRlZmF1bHQucHJvdG90eXBlLnBSb3RhdGlvblkgPSAwO1xuICAgICAgdmFyIHkgPSBtLmRlZmF1bHQucHJvdG90eXBlLnBSb3RhdGlvblogPSAwLCB1ID0gMCwgaCA9IDAsIGcgPSBcImNsb2Nrd2lzZVwiLCBmID0gXCJjbG9ja3dpc2VcIiwgciA9IFwiY2xvY2t3aXNlXCIsIHMgPSAobS5kZWZhdWx0LnByb3RvdHlwZS5wUm90YXRlRGlyZWN0aW9uWCA9IHZvaWQgMCwgbS5kZWZhdWx0LnByb3RvdHlwZS5wUm90YXRlRGlyZWN0aW9uWSA9IHZvaWQgMCwgbS5kZWZhdWx0LnByb3RvdHlwZS5wUm90YXRlRGlyZWN0aW9uWiA9IHZvaWQgMCwgbS5kZWZhdWx0LnByb3RvdHlwZS5fdXBkYXRlUFJvdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShcInBSb3RhdGlvblhcIiwgdGhpcy5yb3RhdGlvblgpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInBSb3RhdGlvbllcIiwgdGhpcy5yb3RhdGlvblkpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInBSb3RhdGlvblpcIiwgdGhpcy5yb3RhdGlvblopO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS50dXJuQXhpcyA9IHZvaWQgMCwgMC41KSwgbyA9IDMwLCBpID0gKG0uZGVmYXVsdC5wcm90b3R5cGUuc2V0TW92ZVRocmVzaG9sZCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzZXRNb3ZlVGhyZXNob2xkXCIsIGFyZ3VtZW50cyksIHMgPSBsO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5zZXRTaGFrZVRocmVzaG9sZCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzZXRTaGFrZVRocmVzaG9sZFwiLCBhcmd1bWVudHMpLCBvID0gbDtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX29uZGV2aWNlb3JpZW50YXRpb24gPSBmdW5jdGlvbihsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBSb3RhdGlvbnMoKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJyb3RhdGlvblhcIiwgdGhpcy5fZnJvbURlZ3JlZXMobC5iZXRhKSksIHRoaXMuX3NldFByb3BlcnR5KFwicm90YXRpb25ZXCIsIHRoaXMuX2Zyb21EZWdyZWVzKGwuZ2FtbWEpKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJyb3RhdGlvblpcIiwgdGhpcy5fZnJvbURlZ3JlZXMobC5hbHBoYSkpLCB0aGlzLl9oYW5kbGVNb3Rpb24oKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX29uZGV2aWNlbW90aW9uID0gZnVuY3Rpb24obCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQQWNjZWxlcmF0aW9ucygpLCB0aGlzLl9zZXRQcm9wZXJ0eShcImFjY2VsZXJhdGlvblhcIiwgMiAqIGwuYWNjZWxlcmF0aW9uLngpLCB0aGlzLl9zZXRQcm9wZXJ0eShcImFjY2VsZXJhdGlvbllcIiwgMiAqIGwuYWNjZWxlcmF0aW9uLnkpLCB0aGlzLl9zZXRQcm9wZXJ0eShcImFjY2VsZXJhdGlvblpcIiwgMiAqIGwuYWNjZWxlcmF0aW9uLnopLCB0aGlzLl9oYW5kbGVNb3Rpb24oKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2hhbmRsZU1vdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cub3JpZW50YXRpb24gPT09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PT0gLTkwID8gdGhpcy5fc2V0UHJvcGVydHkoXCJkZXZpY2VPcmllbnRhdGlvblwiLCBcImxhbmRzY2FwZVwiKSA6IHdpbmRvdy5vcmllbnRhdGlvbiA9PT0gMCA/IHRoaXMuX3NldFByb3BlcnR5KFwiZGV2aWNlT3JpZW50YXRpb25cIiwgXCJwb3J0cmFpdFwiKSA6IHdpbmRvdy5vcmllbnRhdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuX3NldFByb3BlcnR5KFwiZGV2aWNlT3JpZW50YXRpb25cIiwgXCJ1bmRlZmluZWRcIik7XG4gICAgICAgIHZhciBsLCBuLCBhLCBjLCBwLCBqID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzO1xuICAgICAgICB0eXBlb2Ygai5kZXZpY2VNb3ZlZCA9PSBcImZ1bmN0aW9uXCIgJiYgKE1hdGguYWJzKHRoaXMuYWNjZWxlcmF0aW9uWCAtIHRoaXMucEFjY2VsZXJhdGlvblgpID4gcyB8fCBNYXRoLmFicyh0aGlzLmFjY2VsZXJhdGlvblkgLSB0aGlzLnBBY2NlbGVyYXRpb25ZKSA+IHMgfHwgTWF0aC5hYnModGhpcy5hY2NlbGVyYXRpb25aIC0gdGhpcy5wQWNjZWxlcmF0aW9uWikgPiBzKSAmJiBqLmRldmljZU1vdmVkKCksIHR5cGVvZiBqLmRldmljZVR1cm5lZCA9PSBcImZ1bmN0aW9uXCIgJiYgKG4gPSB0aGlzLl90b0RlZ3JlZXModGhpcy5yb3RhdGlvblgpICsgMTgwLCBhID0gdGhpcy5fdG9EZWdyZWVzKHRoaXMucFJvdGF0aW9uWCkgKyAxODAsIGwgPSB5ICsgMTgwLCAwIDwgbiAtIGEgJiYgbiAtIGEgPCAyNzAgfHwgbiAtIGEgPCAtMjcwID8gZyA9IFwiY2xvY2t3aXNlXCIgOiAobiAtIGEgPCAwIHx8IDI3MCA8IG4gLSBhKSAmJiAoZyA9IFwiY291bnRlci1jbG9ja3dpc2VcIiksIGcgIT09IHRoaXMucFJvdGF0ZURpcmVjdGlvblggJiYgKGwgPSBuKSwgOTAgPCBNYXRoLmFicyhuIC0gbCkgJiYgTWF0aC5hYnMobiAtIGwpIDwgMjcwICYmIChsID0gbiwgdGhpcy5fc2V0UHJvcGVydHkoXCJ0dXJuQXhpc1wiLCBcIlhcIiksIGouZGV2aWNlVHVybmVkKCkpLCB0aGlzLnBSb3RhdGVEaXJlY3Rpb25YID0gZywgeSA9IGwgLSAxODAsIGEgPSB0aGlzLl90b0RlZ3JlZXModGhpcy5yb3RhdGlvblkpICsgMTgwLCBuID0gdGhpcy5fdG9EZWdyZWVzKHRoaXMucFJvdGF0aW9uWSkgKyAxODAsIGwgPSB1ICsgMTgwLCAwIDwgYSAtIG4gJiYgYSAtIG4gPCAyNzAgfHwgYSAtIG4gPCAtMjcwID8gZiA9IFwiY2xvY2t3aXNlXCIgOiAoYSAtIG4gPCAwIHx8IDI3MCA8IGEgLSB0aGlzLnBSb3RhdGlvblkpICYmIChmID0gXCJjb3VudGVyLWNsb2Nrd2lzZVwiKSwgZiAhPT0gdGhpcy5wUm90YXRlRGlyZWN0aW9uWSAmJiAobCA9IGEpLCA5MCA8IE1hdGguYWJzKGEgLSBsKSAmJiBNYXRoLmFicyhhIC0gbCkgPCAyNzAgJiYgKGwgPSBhLCB0aGlzLl9zZXRQcm9wZXJ0eShcInR1cm5BeGlzXCIsIFwiWVwiKSwgai5kZXZpY2VUdXJuZWQoKSksIHRoaXMucFJvdGF0ZURpcmVjdGlvblkgPSBmLCB1ID0gbCAtIDE4MCwgMCA8IChuID0gdGhpcy5fdG9EZWdyZWVzKHRoaXMucm90YXRpb25aKSkgLSAoYSA9IHRoaXMuX3RvRGVncmVlcyh0aGlzLnBSb3RhdGlvblopKSAmJiBuIC0gYSA8IDI3MCB8fCBuIC0gYSA8IC0yNzAgPyByID0gXCJjbG9ja3dpc2VcIiA6IChuIC0gYSA8IDAgfHwgMjcwIDwgbiAtIGEpICYmIChyID0gXCJjb3VudGVyLWNsb2Nrd2lzZVwiKSwgciAhPT0gdGhpcy5wUm90YXRlRGlyZWN0aW9uWiAmJiAoaCA9IG4pLCA5MCA8IE1hdGguYWJzKG4gLSBoKSAmJiBNYXRoLmFicyhuIC0gaCkgPCAyNzAgJiYgKGggPSBuLCB0aGlzLl9zZXRQcm9wZXJ0eShcInR1cm5BeGlzXCIsIFwiWlwiKSwgai5kZXZpY2VUdXJuZWQoKSksIHRoaXMucFJvdGF0ZURpcmVjdGlvblogPSByLCB0aGlzLl9zZXRQcm9wZXJ0eShcInR1cm5BeGlzXCIsIHZvaWQgMCkpLCB0eXBlb2Ygai5kZXZpY2VTaGFrZW4gPT0gXCJmdW5jdGlvblwiICYmICh0aGlzLnBBY2NlbGVyYXRpb25YICE9PSBudWxsICYmIChjID0gTWF0aC5hYnModGhpcy5hY2NlbGVyYXRpb25YIC0gdGhpcy5wQWNjZWxlcmF0aW9uWCksIHAgPSBNYXRoLmFicyh0aGlzLmFjY2VsZXJhdGlvblkgLSB0aGlzLnBBY2NlbGVyYXRpb25ZKSksIG8gPCBjICsgcCAmJiBqLmRldmljZVNoYWtlbigpKTtcbiAgICAgIH0sIG0uZGVmYXVsdCk7XG4gICAgICBDLmRlZmF1bHQgPSBpO1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwIH1dLCAyOTg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5pc0tleVByZXNzZWQgPSAhMSwgbS5kZWZhdWx0LnByb3RvdHlwZS5rZXlJc1ByZXNzZWQgPSAhMSwgbS5kZWZhdWx0LnByb3RvdHlwZS5rZXkgPSBcIlwiLCBtLmRlZmF1bHQucHJvdG90eXBlLmtleUNvZGUgPSAwLCBtLmRlZmF1bHQucHJvdG90eXBlLl9vbmtleWRvd24gPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB0aGlzLl9kb3duS2V5c1t5LndoaWNoXSB8fCAodGhpcy5fc2V0UHJvcGVydHkoXCJpc0tleVByZXNzZWRcIiwgITApLCB0aGlzLl9zZXRQcm9wZXJ0eShcImtleUlzUHJlc3NlZFwiLCAhMCksIHRoaXMuX3NldFByb3BlcnR5KFwia2V5Q29kZVwiLCB5LndoaWNoKSwgdGhpcy5fZG93bktleXNbeS53aGljaF0gPSAhMCwgdGhpcy5fc2V0UHJvcGVydHkoXCJrZXlcIiwgeS5rZXkgfHwgU3RyaW5nLmZyb21DaGFyQ29kZSh5LndoaWNoKSB8fCB5LndoaWNoKSwgdHlwZW9mICh1ID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzKS5rZXlQcmVzc2VkICE9IFwiZnVuY3Rpb25cIiB8fCB5LmNoYXJDb2RlIHx8IHUua2V5UHJlc3NlZCh5KSA9PT0gITEgJiYgeS5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX29ua2V5dXAgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuX2Rvd25LZXlzW3kud2hpY2hdID0gITEsIHRoaXMuX2FyZURvd25LZXlzKCkgfHwgKHRoaXMuX3NldFByb3BlcnR5KFwiaXNLZXlQcmVzc2VkXCIsICExKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJrZXlJc1ByZXNzZWRcIiwgITEpKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJfbGFzdEtleUNvZGVUeXBlZFwiLCBudWxsKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJrZXlcIiwgeS5rZXkgfHwgU3RyaW5nLmZyb21DaGFyQ29kZSh5LndoaWNoKSB8fCB5LndoaWNoKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJrZXlDb2RlXCIsIHkud2hpY2gpO1xuICAgICAgICB2YXIgdSA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdHlwZW9mIHUua2V5UmVsZWFzZWQgPT0gXCJmdW5jdGlvblwiICYmIHUua2V5UmVsZWFzZWQoeSkgPT09ICExICYmIHkucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX29ua2V5cHJlc3MgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB5LndoaWNoICE9PSB0aGlzLl9sYXN0S2V5Q29kZVR5cGVkICYmICh0aGlzLl9zZXRQcm9wZXJ0eShcIl9sYXN0S2V5Q29kZVR5cGVkXCIsIHkud2hpY2gpLCB0aGlzLl9zZXRQcm9wZXJ0eShcImtleVwiLCB5LmtleSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKHkud2hpY2gpIHx8IHkud2hpY2gpLCB0eXBlb2YgKHUgPSB0aGlzLl9pc0dsb2JhbCA/IHdpbmRvdyA6IHRoaXMpLmtleVR5cGVkID09IFwiZnVuY3Rpb25cIiAmJiB1LmtleVR5cGVkKHkpID09PSAhMSAmJiB5LnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fb25ibHVyID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLl9kb3duS2V5cyA9IHt9O1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5rZXlJc0Rvd24gPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImtleUlzRG93blwiLCBhcmd1bWVudHMpLCB0aGlzLl9kb3duS2V5c1t5XSB8fCAhMTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX2FyZURvd25LZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHkgaW4gdGhpcy5fZG93bktleXMpXG4gICAgICAgICAgaWYgKHRoaXMuX2Rvd25LZXlzLmhhc093blByb3BlcnR5KHkpICYmIHRoaXMuX2Rvd25LZXlzW3ldID09PSAhMClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgdCA9IG0uZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCB9XSwgMjk5OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShmKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHI7XG4gICAgICAgIH0gOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHIgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgci5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHI7XG4gICAgICAgIH0pKGYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShmKSB7XG4gICAgICAgIHJldHVybiAoeSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gbShyKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gciAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiByLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgciAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKHIpO1xuICAgICAgICB9KShmKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9ICh1ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdS5fX2VzTW9kdWxlID8gdSA6IHsgZGVmYXVsdDogdSB9LCBoID0gZnVuY3Rpb24oZikge1xuICAgICAgICBpZiAoZiAmJiBmLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIGlmIChmID09PSBudWxsIHx8IHkoZikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGYgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IGYgfTtcbiAgICAgICAgdmFyIHIgPSBnKCk7XG4gICAgICAgIGlmIChyICYmIHIuaGFzKGYpKVxuICAgICAgICAgIHJldHVybiByLmdldChmKTtcbiAgICAgICAgdmFyIHMsIG8gPSB7fSwgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKHMgaW4gZikge1xuICAgICAgICAgIHZhciBsO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLCBzKSAmJiAoKGwgPSBpID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmLCBzKSA6IG51bGwpICYmIChsLmdldCB8fCBsLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgcywgbCkgOiBvW3NdID0gZltzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8uZGVmYXVsdCA9IGYsIHIgJiYgci5zZXQoZiwgbyksIG87XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAoZiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0sIGYpO1xuICAgICAgfVxuICAgICAgdS5kZWZhdWx0LnByb3RvdHlwZS5tb3ZlZFggPSAwLCB1LmRlZmF1bHQucHJvdG90eXBlLm1vdmVkWSA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUuX2hhc01vdXNlSW50ZXJhY3RlZCA9ICExLCB1LmRlZmF1bHQucHJvdG90eXBlLm1vdXNlWCA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUubW91c2VZID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS5wbW91c2VYID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS5wbW91c2VZID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS53aW5Nb3VzZVggPSAwLCB1LmRlZmF1bHQucHJvdG90eXBlLndpbk1vdXNlWSA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUucHdpbk1vdXNlWCA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUucHdpbk1vdXNlWSA9IDAsIHUuZGVmYXVsdC5wcm90b3R5cGUubW91c2VCdXR0b24gPSAwLCB1LmRlZmF1bHQucHJvdG90eXBlLm1vdXNlSXNQcmVzc2VkID0gITEsIHUuZGVmYXVsdC5wcm90b3R5cGUuX3VwZGF0ZU5leHRNb3VzZUNvb3JkcyA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHIsIHMsIG8sIGksIGw7XG4gICAgICAgIHRoaXMuX2N1ckVsZW1lbnQgIT09IG51bGwgJiYgKCFmLnRvdWNoZXMgfHwgMCA8IGYudG91Y2hlcy5sZW5ndGgpICYmIChyID0gdGhpcy5fY3VyRWxlbWVudC5lbHQsIHMgPSB0aGlzLndpZHRoLCBvID0gdGhpcy5oZWlnaHQsIChpID0gZikgJiYgIWkuY2xpZW50WCAmJiAoaS50b3VjaGVzID8gaSA9IGkudG91Y2hlc1swXSA6IGkuY2hhbmdlZFRvdWNoZXMgJiYgKGkgPSBpLmNoYW5nZWRUb3VjaGVzWzBdKSksIGwgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzID0gci5zY3JvbGxXaWR0aCAvIHMgfHwgMSwgciA9IHIuc2Nyb2xsSGVpZ2h0IC8gbyB8fCAxLCBvID0geyB4OiAoaS5jbGllbnRYIC0gbC5sZWZ0KSAvIHMsIHk6IChpLmNsaWVudFkgLSBsLnRvcCkgLyByLCB3aW5YOiBpLmNsaWVudFgsIHdpblk6IGkuY2xpZW50WSwgaWQ6IGkuaWRlbnRpZmllciB9LCB0aGlzLl9zZXRQcm9wZXJ0eShcIm1vdmVkWFwiLCBmLm1vdmVtZW50WCksIHRoaXMuX3NldFByb3BlcnR5KFwibW92ZWRZXCIsIGYubW92ZW1lbnRZKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJtb3VzZVhcIiwgby54KSwgdGhpcy5fc2V0UHJvcGVydHkoXCJtb3VzZVlcIiwgby55KSwgdGhpcy5fc2V0UHJvcGVydHkoXCJ3aW5Nb3VzZVhcIiwgby53aW5YKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJ3aW5Nb3VzZVlcIiwgby53aW5ZKSksIHRoaXMuX2hhc01vdXNlSW50ZXJhY3RlZCB8fCAodGhpcy5fdXBkYXRlTW91c2VDb29yZHMoKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJfaGFzTW91c2VJbnRlcmFjdGVkXCIsICEwKSk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl91cGRhdGVNb3VzZUNvb3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShcInBtb3VzZVhcIiwgdGhpcy5tb3VzZVgpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInBtb3VzZVlcIiwgdGhpcy5tb3VzZVkpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInB3aW5Nb3VzZVhcIiwgdGhpcy53aW5Nb3VzZVgpLCB0aGlzLl9zZXRQcm9wZXJ0eShcInB3aW5Nb3VzZVlcIiwgdGhpcy53aW5Nb3VzZVkpLCB0aGlzLl9zZXRQcm9wZXJ0eShcIl9wbW91c2VXaGVlbERlbHRhWVwiLCB0aGlzLl9tb3VzZVdoZWVsRGVsdGFZKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuX3NldE1vdXNlQnV0dG9uID0gZnVuY3Rpb24oZikge1xuICAgICAgICBmLmJ1dHRvbiA9PT0gMSA/IHRoaXMuX3NldFByb3BlcnR5KFwibW91c2VCdXR0b25cIiwgaC5DRU5URVIpIDogZi5idXR0b24gPT09IDIgPyB0aGlzLl9zZXRQcm9wZXJ0eShcIm1vdXNlQnV0dG9uXCIsIGguUklHSFQpIDogdGhpcy5fc2V0UHJvcGVydHkoXCJtb3VzZUJ1dHRvblwiLCBoLkxFRlQpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fb25tb3VzZW1vdmUgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzO1xuICAgICAgICB0aGlzLl91cGRhdGVOZXh0TW91c2VDb29yZHMoZiksIHRoaXMubW91c2VJc1ByZXNzZWQgPyB0eXBlb2Ygci5tb3VzZURyYWdnZWQgPT0gXCJmdW5jdGlvblwiID8gci5tb3VzZURyYWdnZWQoZikgPT09ICExICYmIGYucHJldmVudERlZmF1bHQoKSA6IHR5cGVvZiByLnRvdWNoTW92ZWQgPT0gXCJmdW5jdGlvblwiICYmIHIudG91Y2hNb3ZlZChmKSA9PT0gITEgJiYgZi5wcmV2ZW50RGVmYXVsdCgpIDogdHlwZW9mIHIubW91c2VNb3ZlZCA9PSBcImZ1bmN0aW9uXCIgJiYgci5tb3VzZU1vdmVkKGYpID09PSAhMSAmJiBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl9vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLl9pc0dsb2JhbCA/IHdpbmRvdyA6IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwibW91c2VJc1ByZXNzZWRcIiwgITApLCB0aGlzLl9zZXRNb3VzZUJ1dHRvbihmKSwgdGhpcy5fdXBkYXRlTmV4dE1vdXNlQ29vcmRzKGYpLCB0aGlzLnRvdWNoc3RhcnQgfHwgKHR5cGVvZiByLm1vdXNlUHJlc3NlZCA9PSBcImZ1bmN0aW9uXCIgPyByLm1vdXNlUHJlc3NlZChmKSA9PT0gITEgJiYgZi5wcmV2ZW50RGVmYXVsdCgpIDogdHlwZW9mIHIudG91Y2hTdGFydGVkID09IFwiZnVuY3Rpb25cIiAmJiByLnRvdWNoU3RhcnRlZChmKSA9PT0gITEgJiYgZi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnRvdWNoc3RhcnQgPSAhMSk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl9vbm1vdXNldXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzO1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShcIm1vdXNlSXNQcmVzc2VkXCIsICExKSwgdGhpcy50b3VjaGVuZCB8fCAodHlwZW9mIHIubW91c2VSZWxlYXNlZCA9PSBcImZ1bmN0aW9uXCIgPyByLm1vdXNlUmVsZWFzZWQoZikgPT09ICExICYmIGYucHJldmVudERlZmF1bHQoKSA6IHR5cGVvZiByLnRvdWNoRW5kZWQgPT0gXCJmdW5jdGlvblwiICYmIHIudG91Y2hFbmRlZChmKSA9PT0gITEgJiYgZi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnRvdWNoZW5kID0gITEpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fb25kcmFnZW5kID0gdS5kZWZhdWx0LnByb3RvdHlwZS5fb25tb3VzZXVwLCB1LmRlZmF1bHQucHJvdG90eXBlLl9vbmRyYWdvdmVyID0gdS5kZWZhdWx0LnByb3RvdHlwZS5fb25tb3VzZW1vdmUsIHUuZGVmYXVsdC5wcm90b3R5cGUuX29uY2xpY2sgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5faXNHbG9iYWwgPyB3aW5kb3cgOiB0aGlzO1xuICAgICAgICB0eXBlb2Ygci5tb3VzZUNsaWNrZWQgPT0gXCJmdW5jdGlvblwiICYmIHIubW91c2VDbGlja2VkKGYpID09PSAhMSAmJiBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl9vbmRibGNsaWNrID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgciA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdHlwZW9mIHIuZG91YmxlQ2xpY2tlZCA9PSBcImZ1bmN0aW9uXCIgJiYgci5kb3VibGVDbGlja2VkKGYpID09PSAhMSAmJiBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl9tb3VzZVdoZWVsRGVsdGFZID0gMCwgdS5kZWZhdWx0LnByb3RvdHlwZS5fcG1vdXNlV2hlZWxEZWx0YVkgPSAwLCB1LmRlZmF1bHQucHJvdG90eXBlLl9vbndoZWVsID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgciA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkoXCJfbW91c2VXaGVlbERlbHRhWVwiLCBmLmRlbHRhWSksIHR5cGVvZiByLm1vdXNlV2hlZWwgPT0gXCJmdW5jdGlvblwiICYmIChmLmRlbHRhID0gZi5kZWx0YVksIHIubW91c2VXaGVlbChmKSA9PT0gITEgJiYgZi5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucmVxdWVzdFBvaW50ZXJMb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5fY3VyRWxlbWVudC5lbHQ7XG4gICAgICAgIHJldHVybiBmLnJlcXVlc3RQb2ludGVyTG9jayA9IGYucmVxdWVzdFBvaW50ZXJMb2NrIHx8IGYubW96UmVxdWVzdFBvaW50ZXJMb2NrLCBmLnJlcXVlc3RQb2ludGVyTG9jayA/IChmLnJlcXVlc3RQb2ludGVyTG9jaygpLCAhMCkgOiAoY29uc29sZS5sb2coXCJyZXF1ZXN0UG9pbnRlckxvY2sgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgYnJvd3NlclwiKSwgITEpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5leGl0UG9pbnRlckxvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgICB9LCB0ID0gdS5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMwMDogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9LCB0LmRlZmF1bHQucHJvdG90eXBlLnRvdWNoZXMgPSBbXSwgdC5kZWZhdWx0LnByb3RvdHlwZS5fdXBkYXRlVG91Y2hDb29yZHMgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IFtdLCB1ID0gMDsgdSA8IG0udG91Y2hlcy5sZW5ndGg7IHUrKylcbiAgICAgICAgICAgIHlbdV0gPSBmdW5jdGlvbihsLCBpLCBuLCByKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gNCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbNF0gOiAwLCBvID0gbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaSA9IGwuc2Nyb2xsV2lkdGggLyBpIHx8IDEsIGwgPSBsLnNjcm9sbEhlaWdodCAvIG4gfHwgMSwgbiA9IHIudG91Y2hlc1tzXSB8fCByLmNoYW5nZWRUb3VjaGVzW3NdO1xuICAgICAgICAgICAgICByZXR1cm4geyB4OiAobi5jbGllbnRYIC0gby5sZWZ0KSAvIGksIHk6IChuLmNsaWVudFkgLSBvLnRvcCkgLyBsLCB3aW5YOiBuLmNsaWVudFgsIHdpblk6IG4uY2xpZW50WSwgaWQ6IG4uaWRlbnRpZmllciB9O1xuICAgICAgICAgICAgfSh0aGlzLl9jdXJFbGVtZW50LmVsdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG0sIHUpO1xuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwidG91Y2hlc1wiLCB5KTtcbiAgICAgICAgfVxuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5fb250b3VjaHN0YXJ0ID0gZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeSA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkoXCJtb3VzZUlzUHJlc3NlZFwiLCAhMCksIHRoaXMuX3VwZGF0ZVRvdWNoQ29vcmRzKG0pLCB0aGlzLl91cGRhdGVOZXh0TW91c2VDb29yZHMobSksIHRoaXMuX3VwZGF0ZU1vdXNlQ29vcmRzKCksIHR5cGVvZiB5LnRvdWNoU3RhcnRlZCA9PSBcImZ1bmN0aW9uXCIgJiYgKHkudG91Y2hTdGFydGVkKG0pID09PSAhMSAmJiBtLnByZXZlbnREZWZhdWx0KCksIHRoaXMudG91Y2hzdGFydCA9ICEwKTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUuX29udG91Y2htb3ZlID0gZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeSA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdGhpcy5fdXBkYXRlVG91Y2hDb29yZHMobSksIHRoaXMuX3VwZGF0ZU5leHRNb3VzZUNvb3JkcyhtKSwgdHlwZW9mIHkudG91Y2hNb3ZlZCA9PSBcImZ1bmN0aW9uXCIgPyB5LnRvdWNoTW92ZWQobSkgPT09ICExICYmIG0ucHJldmVudERlZmF1bHQoKSA6IHR5cGVvZiB5Lm1vdXNlRHJhZ2dlZCA9PSBcImZ1bmN0aW9uXCIgJiYgeS5tb3VzZURyYWdnZWQobSkgPT09ICExICYmIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUuX29udG91Y2hlbmQgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwibW91c2VJc1ByZXNzZWRcIiwgITEpLCB0aGlzLl91cGRhdGVUb3VjaENvb3JkcyhtKSwgdGhpcy5fdXBkYXRlTmV4dE1vdXNlQ29vcmRzKG0pO1xuICAgICAgICB2YXIgeSA9IHRoaXMuX2lzR2xvYmFsID8gd2luZG93IDogdGhpcztcbiAgICAgICAgdHlwZW9mIHkudG91Y2hFbmRlZCA9PSBcImZ1bmN0aW9uXCIgJiYgKHkudG91Y2hFbmRlZChtKSA9PT0gITEgJiYgbS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnRvdWNoZW5kID0gITApO1xuICAgICAgfSwgdCA9IHQuZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCB9XSwgMzAxOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDMyLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW50MzItYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtLCB5LCB1LCBoLCBnID0geyBfdG9QaXhlbHM6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHIsIHM7XG4gICAgICAgIHJldHVybiBmIGluc3RhbmNlb2YgSW1hZ2VEYXRhID8gZi5kYXRhIDogZi5nZXRDb250ZXh0KFwiMmRcIikgPyBmLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgZi53aWR0aCwgZi5oZWlnaHQpLmRhdGEgOiBmLmdldENvbnRleHQoXCJ3ZWJnbFwiKSA/IChzID0gKHIgPSBmLmdldENvbnRleHQoXCJ3ZWJnbFwiKSkuZHJhd2luZ0J1ZmZlcldpZHRoICogci5kcmF3aW5nQnVmZmVySGVpZ2h0ICogNCwgcyA9IG5ldyBVaW50OEFycmF5KHMpLCByLnJlYWRQaXhlbHMoMCwgMCwgZi53aWR0aCwgZi5oZWlnaHQsIHIuUkdCQSwgci5VTlNJR05FRF9CWVRFLCBzKSwgcykgOiB2b2lkIDA7XG4gICAgICB9LCBfZ2V0QVJHQjogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICByZXR1cm4gciAqPSA0LCBmWzMgKyByXSA8PCAyNCAmIDQyNzgxOTAwODAgfCBmW3JdIDw8IDE2ICYgMTY3MTE2ODAgfCBmWzEgKyByXSA8PCA4ICYgNjUyODAgfCAyNTUgJiBmWzIgKyByXTtcbiAgICAgIH0sIF9zZXRQaXhlbHM6IGZ1bmN0aW9uKGYsIHIpIHtcbiAgICAgICAgZm9yICh2YXIgcywgbyA9IDAsIGkgPSBmLmxlbmd0aDsgbyA8IGk7IG8rKylcbiAgICAgICAgICBmWzAgKyAocyA9IDQgKiBvKV0gPSAoMTY3MTE2ODAgJiByW29dKSA+Pj4gMTYsIGZbMSArIHNdID0gKDY1MjgwICYgcltvXSkgPj4+IDgsIGZbMiArIHNdID0gMjU1ICYgcltvXSwgZlszICsgc10gPSAoNDI3ODE5MDA4MCAmIHJbb10pID4+PiAyNDtcbiAgICAgIH0sIF90b0ltYWdlRGF0YTogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZiBpbnN0YW5jZW9mIEltYWdlRGF0YSA/IGYgOiBmLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgZi53aWR0aCwgZi5oZWlnaHQpO1xuICAgICAgfSwgX2NyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICByZXR1cm4gZy5fdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgZy5fdG1wQ3R4ID0gZy5fdG1wQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgdGhpcy5fdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YShmLCByKTtcbiAgICAgIH0sIGFwcGx5OiBmdW5jdGlvbihmLCBsLCBzKSB7XG4gICAgICAgIHZhciBvID0gZi5nZXRDb250ZXh0KFwiMmRcIiksIGkgPSBvLmdldEltYWdlRGF0YSgwLCAwLCBmLndpZHRoLCBmLmhlaWdodCksIGwgPSBsKGksIHMpO1xuICAgICAgICBsIGluc3RhbmNlb2YgSW1hZ2VEYXRhID8gby5wdXRJbWFnZURhdGEobCwgMCwgMCwgMCwgMCwgZi53aWR0aCwgZi5oZWlnaHQpIDogby5wdXRJbWFnZURhdGEoaSwgMCwgMCwgMCwgMCwgZi53aWR0aCwgZi5oZWlnaHQpO1xuICAgICAgfSwgdGhyZXNob2xkOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDAuNSwgcyA9IGcuX3RvUGl4ZWxzKGYpLCBvID0gTWF0aC5mbG9vcigyNTUgKiByKSwgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgdmFyIGwgPSB2b2lkIDAsIGwgPSBvIDw9IDAuMjEyNiAqIHNbaV0gKyAwLjcxNTIgKiBzW2kgKyAxXSArIDAuMDcyMiAqIHNbaSArIDJdID8gMjU1IDogMDtcbiAgICAgICAgICBzW2ldID0gc1tpICsgMV0gPSBzW2kgKyAyXSA9IGw7XG4gICAgICAgIH1cbiAgICAgIH0sIGdyYXk6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGcuX3RvUGl4ZWxzKGYpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzICs9IDQpIHtcbiAgICAgICAgICB2YXIgbyA9IHJbc10sIGkgPSByW3MgKyAxXSwgbCA9IHJbcyArIDJdO1xuICAgICAgICAgIHJbc10gPSByW3MgKyAxXSA9IHJbcyArIDJdID0gMC4yMTI2ICogbyArIDAuNzE1MiAqIGkgKyAwLjA3MjIgKiBsO1xuICAgICAgICB9XG4gICAgICB9LCBvcGFxdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGcuX3RvUGl4ZWxzKGYpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzICs9IDQpXG4gICAgICAgICAgcltzICsgM10gPSAyNTU7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgaW52ZXJ0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSBnLl90b1BpeGVscyhmKSwgcyA9IDA7IHMgPCByLmxlbmd0aDsgcyArPSA0KVxuICAgICAgICAgIHJbc10gPSAyNTUgLSByW3NdLCByW3MgKyAxXSA9IDI1NSAtIHJbcyArIDFdLCByW3MgKyAyXSA9IDI1NSAtIHJbcyArIDJdO1xuICAgICAgfSwgcG9zdGVyaXplOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiA0LCBzID0gZy5fdG9QaXhlbHMoZik7XG4gICAgICAgIGlmIChyIDwgMiB8fCAyNTUgPCByKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxldmVsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDIgYW5kIGxlc3MgdGhhbiAyNTUgZm9yIHBvc3Rlcml6ZVwiKTtcbiAgICAgICAgZm9yICh2YXIgbyA9IHIgLSAxLCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICB2YXIgbCA9IHNbaV0sIG4gPSBzW2kgKyAxXSwgYSA9IHNbaSArIDJdO1xuICAgICAgICAgIHNbaV0gPSAyNTUgKiAobCAqIHIgPj4gOCkgLyBvLCBzW2kgKyAxXSA9IDI1NSAqIChuICogciA+PiA4KSAvIG8sIHNbaSArIDJdID0gMjU1ICogKGEgKiByID4+IDgpIC8gbztcbiAgICAgICAgfVxuICAgICAgfSwgZGlsYXRlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGZvciAodmFyIHIsIHMsIG8sIGksIGwsIG4sIGEsIGMsIHAsIGogPSBnLl90b1BpeGVscyhmKSwgVCA9IDAsIF8gPSBqLmxlbmd0aCA/IGoubGVuZ3RoIC8gNCA6IDAsIFMgPSBuZXcgSW50MzJBcnJheShfKTsgVCA8IF87IClcbiAgICAgICAgICBmb3IgKHMgPSAociA9IFQpICsgZi53aWR0aDsgVCA8IHM7IClcbiAgICAgICAgICAgIGkgPSBvID0gZy5fZ2V0QVJHQihqLCBUKSwgKHAgPSBUIC0gMSkgPCByICYmIChwID0gVCksIHMgPD0gKGMgPSBUICsgMSkgJiYgKGMgPSBUKSwgKGwgPSBUIC0gZi53aWR0aCkgPCAwICYmIChsID0gMCksIF8gPD0gKG4gPSBUICsgZi53aWR0aCkgJiYgKG4gPSBUKSwgbCA9IGcuX2dldEFSR0IoaiwgbCksIHAgPSBnLl9nZXRBUkdCKGosIHApLCBuID0gZy5fZ2V0QVJHQihqLCBuKSwgKGkgPSA3NyAqIChpID4+IDE2ICYgMjU1KSArIDE1MSAqIChpID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgaSkpIDwgKGEgPSA3NyAqIChwID4+IDE2ICYgMjU1KSArIDE1MSAqIChwID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgcCkpICYmIChvID0gcCwgaSA9IGEpLCBpIDwgKGEgPSA3NyAqICgocCA9IGcuX2dldEFSR0IoaiwgYykpID4+IDE2ICYgMjU1KSArIDE1MSAqIChwID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgcCkpICYmIChvID0gcCwgaSA9IGEpLCBpIDwgKGMgPSA3NyAqIChsID4+IDE2ICYgMjU1KSArIDE1MSAqIChsID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgbCkpICYmIChvID0gbCwgaSA9IGMpLCBpIDwgKHAgPSA3NyAqIChuID4+IDE2ICYgMjU1KSArIDE1MSAqIChuID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgbikpICYmIChvID0gbiwgaSA9IHApLCBTW1QrK10gPSBvO1xuICAgICAgICBnLl9zZXRQaXhlbHMoaiwgUyk7XG4gICAgICB9LCBlcm9kZTogZnVuY3Rpb24oZikge1xuICAgICAgICBmb3IgKHZhciByLCBzLCBvLCBpLCBsLCBuLCBhLCBjLCBwLCBqID0gZy5fdG9QaXhlbHMoZiksIFQgPSAwLCBfID0gai5sZW5ndGggPyBqLmxlbmd0aCAvIDQgOiAwLCBTID0gbmV3IEludDMyQXJyYXkoXyk7IFQgPCBfOyApXG4gICAgICAgICAgZm9yIChzID0gKHIgPSBUKSArIGYud2lkdGg7IFQgPCBzOyApXG4gICAgICAgICAgICBpID0gbyA9IGcuX2dldEFSR0IoaiwgVCksIChwID0gVCAtIDEpIDwgciAmJiAocCA9IFQpLCBzIDw9IChjID0gVCArIDEpICYmIChjID0gVCksIChsID0gVCAtIGYud2lkdGgpIDwgMCAmJiAobCA9IDApLCBfIDw9IChuID0gVCArIGYud2lkdGgpICYmIChuID0gVCksIGwgPSBnLl9nZXRBUkdCKGosIGwpLCBwID0gZy5fZ2V0QVJHQihqLCBwKSwgbiA9IGcuX2dldEFSR0IoaiwgbiksIChhID0gNzcgKiAocCA+PiAxNiAmIDI1NSkgKyAxNTEgKiAocCA+PiA4ICYgMjU1KSArIDI4ICogKDI1NSAmIHApKSA8IChpID0gNzcgKiAoaSA+PiAxNiAmIDI1NSkgKyAxNTEgKiAoaSA+PiA4ICYgMjU1KSArIDI4ICogKDI1NSAmIGkpKSAmJiAobyA9IHAsIGkgPSBhKSwgKGEgPSA3NyAqICgocCA9IGcuX2dldEFSR0IoaiwgYykpID4+IDE2ICYgMjU1KSArIDE1MSAqIChwID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgcCkpIDwgaSAmJiAobyA9IHAsIGkgPSBhKSwgKGMgPSA3NyAqIChsID4+IDE2ICYgMjU1KSArIDE1MSAqIChsID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgbCkpIDwgaSAmJiAobyA9IGwsIGkgPSBjKSwgKHAgPSA3NyAqIChuID4+IDE2ICYgMjU1KSArIDE1MSAqIChuID4+IDggJiAyNTUpICsgMjggKiAoMjU1ICYgbikpIDwgaSAmJiAobyA9IG4sIGkgPSBwKSwgU1tUKytdID0gbztcbiAgICAgICAgZy5fc2V0UGl4ZWxzKGosIFMpO1xuICAgICAgfSwgYmx1cjogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICBmb3IgKHZhciBzLCBvLCBpLCBsLCBuLCBhLCBjLCBwLCBqLCBULCBfID0gZy5fdG9QaXhlbHMoZiksIFMgPSBmLndpZHRoLCBFID0gZi5oZWlnaHQsIEEgPSBTICogRSwgeCA9IG5ldyBJbnQzMkFycmF5KEEpLCBQID0gMDsgUCA8IEE7IFArKylcbiAgICAgICAgICB4W1BdID0gZy5fZ2V0QVJHQihfLCBQKTtcbiAgICAgICAgdmFyIE0sIFIsIEwsIEYsIFYsIEcsIFUsIFcsIFggPSBuZXcgSW50MzJBcnJheShBKSwgbmUgPSBuZXcgSW50MzJBcnJheShBKSwgYiA9IG5ldyBJbnQzMkFycmF5KEEpLCBPID0gbmV3IEludDMyQXJyYXkoQSksIEQgPSAwLCBCID0gMy41ICogciB8IDA7XG4gICAgICAgIGlmIChtICE9PSAoQiA9IEIgPCAxID8gMSA6IEIgPCAyNDggPyBCIDogMjQ4KSkge1xuICAgICAgICAgIHkgPSAxICsgKG0gPSBCKSA8PCAxLCB1ID0gbmV3IEludDMyQXJyYXkoeSksIGggPSBuZXcgQXJyYXkoeSk7XG4gICAgICAgICAgZm9yICh2YXIgWSA9IDA7IFkgPCB5OyBZKyspXG4gICAgICAgICAgICBoW1ldID0gbmV3IEludDMyQXJyYXkoMjU2KTtcbiAgICAgICAgICBmb3IgKHZhciBKID0gMSwgdGUgPSBCIC0gMTsgSiA8IEI7IEorKykge1xuICAgICAgICAgICAgdVtCICsgSl0gPSB1W3RlXSA9IEcgPSB0ZSAqIHRlLCBVID0gaFtCICsgSl0sIFcgPSBoW3RlLS1dO1xuICAgICAgICAgICAgZm9yICh2YXIgY2UgPSAwOyBjZSA8IDI1NjsgY2UrKylcbiAgICAgICAgICAgICAgVVtjZV0gPSBXW2NlXSA9IEcgKiBjZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgViA9IHVbQl0gPSBCICogQiwgVSA9IGhbQl07XG4gICAgICAgICAgZm9yICh2YXIgcmUgPSAwOyByZSA8IDI1NjsgcmUrKylcbiAgICAgICAgICAgIFVbcmVdID0gViAqIHJlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoUiA9IDA7IFIgPCBFOyBSKyspIHtcbiAgICAgICAgICBmb3IgKE0gPSAwOyBNIDwgUzsgTSsrKSB7XG4gICAgICAgICAgICBpZiAobCA9IGkgPSBvID0gbiA9IHMgPSAwLCAoYSA9IE0gLSBtKSA8IDApXG4gICAgICAgICAgICAgIFQgPSAtYSwgYSA9IDA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFMgPD0gYSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgVCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKEwgPSBUOyBMIDwgeSAmJiAhKFMgPD0gYSk7IEwrKykge1xuICAgICAgICAgICAgICB2YXIgdWUgPSB4W2EgKyBEXTtcbiAgICAgICAgICAgICAgRiA9IGhbTF0sIG4gKz0gRlsoLTE2Nzc3MjE2ICYgdWUpID4+PiAyNF0sIG8gKz0gRlsoMTY3MTE2ODAgJiB1ZSkgPj4gMTZdLCBpICs9IEZbKDY1MjgwICYgdWUpID4+IDhdLCBsICs9IEZbMjU1ICYgdWVdLCBzICs9IHVbTF0sIGErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFhbYyA9IEQgKyBNXSA9IG4gLyBzLCBuZVtjXSA9IG8gLyBzLCBiW2NdID0gaSAvIHMsIE9bY10gPSBsIC8gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgRCArPSBTO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IChwID0gLW0pICogUywgUiA9IEQgPSAwOyBSIDwgRTsgUisrKSB7XG4gICAgICAgICAgZm9yIChNID0gMDsgTSA8IFM7IE0rKykge1xuICAgICAgICAgICAgaWYgKGwgPSBpID0gbyA9IG4gPSBzID0gMCwgcCA8IDApXG4gICAgICAgICAgICAgIFQgPSBjID0gLXAsIGEgPSBNO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChFIDw9IHApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIFQgPSAwLCBjID0gcCwgYSA9IE0gKyBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChMID0gVDsgTCA8IHkgJiYgIShFIDw9IGMpOyBMKyspXG4gICAgICAgICAgICAgIEYgPSBoW0xdLCBuICs9IEZbWFthXV0sIG8gKz0gRltuZVthXV0sIGkgKz0gRltiW2FdXSwgbCArPSBGW09bYV1dLCBzICs9IHVbTF0sIGMrKywgYSArPSBTO1xuICAgICAgICAgICAgeFtNICsgRF0gPSBuIC8gcyA8PCAyNCB8IG8gLyBzIDw8IDE2IHwgaSAvIHMgPDwgOCB8IGwgLyBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBEICs9IFMsIGogKz0gUywgcCsrO1xuICAgICAgICB9XG4gICAgICAgIGcuX3NldFBpeGVscyhfLCB4KTtcbiAgICAgIH0gfTtcbiAgICAgIEMuZGVmYXVsdCA9IGc7XG4gICAgfSwgeyBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIjogMjE4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiOiAyMTksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCI6IDIyMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW50MzItYXJyYXlcIjogMjIyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiOiAyMjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIjogMjI0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCI6IDIyNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCI6IDIyNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCI6IDIyOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCI6IDIyNywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiOiAyMjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiOiAyMzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCI6IDIzMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiOiAyMzIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIjogMjMzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiOiAyMzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIjogMjM1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIjogMjM2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiOiAyMzkgfV0sIDMwMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSB1KHQoXCIuLi9jb3JlL21haW5cIikpLCB5ID0gdSh0KFwib21nZ2lmXCIpKTtcbiAgICAgIGZ1bmN0aW9uIHUoZykge1xuICAgICAgICByZXR1cm4gZyAmJiBnLl9fZXNNb2R1bGUgPyBnIDogeyBkZWZhdWx0OiBnIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoKGcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsIHMgPSBuZXcgQXJyYXkoZi5sZW5ndGgpOyByIDwgZi5sZW5ndGg7IHIrKylcbiAgICAgICAgICAgICAgc1tyXSA9IGZbcl07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgIH0oZykgfHwgZnVuY3Rpb24oZikge1xuICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGYpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIilcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGYpO1xuICAgICAgICB9KGcpIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfSgpO1xuICAgICAgfVxuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlSW1hZ2VcIiwgYXJndW1lbnRzKSwgbmV3IG0uZGVmYXVsdC5JbWFnZShnLCBmKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUNhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBnLCBmLCByLCBzLCBvLCBpLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheShsKSwgYSA9IDA7IGEgPCBsOyBhKyspXG4gICAgICAgICAgblthXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgc3dpdGNoIChtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNhdmVDYW52YXNcIiwgbiksIG5bMF0gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCA/IChnID0gblswXSwgbi5zaGlmdCgpKSA6IG5bMF0gaW5zdGFuY2VvZiBtLmRlZmF1bHQuRWxlbWVudCA/IChnID0gblswXS5lbHQsIG4uc2hpZnQoKSkgOiBuWzBdIGluc3RhbmNlb2YgbS5kZWZhdWx0LkZyYW1lYnVmZmVyID8gKHMgPSBuWzBdLCAobyA9IHRoaXMuY3JlYXRlR3JhcGhpY3Mocy53aWR0aCwgcy5oZWlnaHQpKS5waXhlbERlbnNpdHkocGl4ZWxEZW5zaXR5KCkpLCBzLmxvYWRQaXhlbHMoKSwgby5sb2FkUGl4ZWxzKCksIG8ucGl4ZWxzLnNldChzLnBpeGVscyksIG8udXBkYXRlUGl4ZWxzKCksIGcgPSBvLmVsdCwgbi5zaGlmdCgpKSA6IGcgPSB0aGlzLl9jdXJFbGVtZW50ICYmIHRoaXMuX2N1ckVsZW1lbnQuZWx0LCAxIDw9IG4ubGVuZ3RoICYmIChmID0gblswXSksIHIgPSAociA9IDIgPD0gbi5sZW5ndGggPyBuWzFdIDogcikgfHwgbS5kZWZhdWx0LnByb3RvdHlwZS5fY2hlY2tGaWxlRXh0ZW5zaW9uKGYsIHIpWzFdIHx8IFwicG5nXCIpIHtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaSA9IFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwianBlZ1wiOlxuICAgICAgICAgIGNhc2UgXCJqcGdcIjpcbiAgICAgICAgICAgIGkgPSBcImltYWdlL2pwZWdcIjtcbiAgICAgICAgfVxuICAgICAgICBnLnRvQmxvYihmdW5jdGlvbihjKSB7XG4gICAgICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5kb3dubG9hZEZpbGUoYywgZiwgciksIG8gJiYgby5yZW1vdmUoKTtcbiAgICAgICAgfSwgaSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmVuY29kZUFuZERvd25sb2FkR2lmID0gZnVuY3Rpb24oZywgZikge1xuICAgICAgICBmb3IgKHZhciByID0gZy5naWZQcm9wZXJ0aWVzLCBzID0gci5sb29wTGltaXQsIG8gPSAocyA9PT0gMSA/IHMgPSBudWxsIDogcyA9PT0gbnVsbCAmJiAocyA9IDApLCBuZXcgVWludDhBcnJheShnLndpZHRoICogZy5oZWlnaHQgKiByLm51bUZyYW1lcykpLCBpID0gW10sIGwgPSB7fSwgbiA9IDA7IG4gPCByLm51bUZyYW1lczsgbisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGMgPSByLmZyYW1lc1tuXS5pbWFnZS5kYXRhLCBwID0gYy5sZW5ndGgsIGogPSBuZXcgVWludDMyQXJyYXkoZy53aWR0aCAqIGcuaGVpZ2h0KSwgVCA9IDAsIF8gPSAwOyBUIDwgcDsgVCArPSA0LCBfKyspIHtcbiAgICAgICAgICAgIHZhciBTID0gY1tUICsgMF0gPDwgMTYgfCBjW1QgKyAxXSA8PCA4IHwgY1tUICsgMl0gPDwgMDtcbiAgICAgICAgICAgIGEuYWRkKFMpLCBqW19dID0gUztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEUgPSBoKGEpLnNvcnQoKS50b1N0cmluZygpO1xuICAgICAgICAgIGxbRV0gPT09IHZvaWQgMCA/IGxbRV0gPSB7IGZyZXE6IDEsIGZyYW1lczogW25dIH0gOiAobFtFXS5mcmVxICs9IDEsIGxbRV0uZnJhbWVzLnB1c2gobikpLCBpLnB1c2goaik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgUCA9IFtdLCBBID0gT2JqZWN0LmtleXMobCkuc29ydChmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgcmV0dXJuIGxbT10uZnJlcSAtIGxbYl0uZnJlcTtcbiAgICAgICAgfSksIHggPSBBWzBdLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludChiKTtcbiAgICAgICAgfSksIFAgPSBQLmNvbmNhdChsW3hdLmZyYW1lcyksIE0gPSBuZXcgU2V0KHgpLCBSID0gMTsgUiA8IEEubGVuZ3RoOyBSKyspIHtcbiAgICAgICAgICB2YXIgTCA9IEFbUl0uc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYik7XG4gICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHJldHVybiAhTS5oYXMoYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHgubGVuZ3RoICsgTC5sZW5ndGggPD0gMjU2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBGID0gMDsgRiA8IEwubGVuZ3RoOyBGKyspXG4gICAgICAgICAgICAgIHgucHVzaChMW0ZdKSwgTS5hZGQoTFtGXSk7XG4gICAgICAgICAgICBQID0gUC5jb25jYXQobFtBW1JdXS5mcmFtZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQID0gbmV3IFNldChQKTtcbiAgICAgICAgZm9yICh2YXIgViA9IHt9LCBHID0gMDsgRyA8IHgubGVuZ3RoOyBHKyspXG4gICAgICAgICAgVlt4W0ddXSB8fCAoVlt4W0ddXSA9IEcpO1xuICAgICAgICBmb3IgKHZhciBVID0gMTsgVSA8IHgubGVuZ3RoOyApXG4gICAgICAgICAgVSA8PD0gMTtcbiAgICAgICAgeC5sZW5ndGggPSBVO1xuICAgICAgICBmb3IgKHZhciBzID0geyBsb29wOiBzLCBwYWxldHRlOiBuZXcgVWludDMyQXJyYXkoeCkgfSwgVyA9IG5ldyB5LmRlZmF1bHQuR2lmV3JpdGVyKG8sIGcud2lkdGgsIGcuaGVpZ2h0LCBzKSwgWCA9IHt9LCBuZSA9IDA7IG5lIDwgci5udW1GcmFtZXM7IG5lKyspXG4gICAgICAgICAgKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIHZhciBEID0gIVAuaGFzKE8pLCBCID0gRCA/IFtdIDogeCwgWSA9IG5ldyBVaW50OEFycmF5KGcud2lkdGggKiBnLmhlaWdodCksIEogPSB7fSwgdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBjZSA9IChpW09dLmZvckVhY2goZnVuY3Rpb24oYWUsIGhlKSB7XG4gICAgICAgICAgICAgIEQgPyAoSlthZV0gPT09IHZvaWQgMCAmJiAoSlthZV0gPSBCLmxlbmd0aCwgQi5wdXNoKGFlKSksIFlbaGVdID0gSlthZV0pIDogWVtoZV0gPSBWW2FlXSwgMCA8IE8gJiYgaVtPIC0gMV1baGVdICE9PSBhZSAmJiB0ZS5hZGQoYWUpO1xuICAgICAgICAgICAgfSksIHt9KSwgcmUgPSBCLmZpbHRlcihmdW5jdGlvbihhZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIXRlLmhhcyhhZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgwIDwgcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciByZSA9IHJlWzBdLCB1ZSA9IChEID8gSiA6IFYpW3JlXTtcbiAgICAgICAgICAgICAgaWYgKDAgPCBPKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGUgPSAwOyBsZSA8IGlbT10ubGVuZ3RoOyBsZSsrKVxuICAgICAgICAgICAgICAgICAgaVtPIC0gMV1bbGVdID09PSBpW09dW2xlXSAmJiAoWVtsZV0gPSB1ZSk7XG4gICAgICAgICAgICAgICAgY2UudHJhbnNwYXJlbnQgPSB1ZSwgWC5mcmFtZU9wdHMuZGlzcG9zYWwgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2UuZGVsYXkgPSByLmZyYW1lc1tPXS5kZWxheSAvIDEwLCBEKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIEsgPSAxOyBLIDwgQi5sZW5ndGg7IClcbiAgICAgICAgICAgICAgICBLIDw8PSAxO1xuICAgICAgICAgICAgICBCLmxlbmd0aCA9IEssIGNlLnBhbGV0dGUgPSBuZXcgVWludDMyQXJyYXkoQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAwIDwgTyAmJiBXLmFkZEZyYW1lKDAsIDAsIGcud2lkdGgsIGcuaGVpZ2h0LCBYLnBpeGVsUGFsZXR0ZUluZGV4LCBYLmZyYW1lT3B0cyksIFggPSB7IHBpeGVsUGFsZXR0ZUluZGV4OiBZLCBmcmFtZU9wdHM6IGNlIH07XG4gICAgICAgICAgfSkobmUpO1xuICAgICAgICBYLmZyYW1lT3B0cy5kaXNwb3NhbCA9IDEsIFcuYWRkRnJhbWUoMCwgMCwgZy53aWR0aCwgZy5oZWlnaHQsIFgucGl4ZWxQYWxldHRlSW5kZXgsIFguZnJhbWVPcHRzKSwgcyA9IG5ldyBCbG9iKFtvLnNsaWNlKDAsIFcuZW5kKCkpXSwgeyB0eXBlOiBcImltYWdlL2dpZlwiIH0pLCBtLmRlZmF1bHQucHJvdG90eXBlLmRvd25sb2FkRmlsZShzLCBmLCBcImdpZlwiKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUZyYW1lcyA9IGZ1bmN0aW9uKGcsIGYsIHIsIGksIG8pIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzYXZlRnJhbWVzXCIsIGFyZ3VtZW50cyksIHIgPSBtLmRlZmF1bHQucHJvdG90eXBlLmNvbnN0cmFpbihyID0gciB8fCAzLCAwLCAxNSksIHIgKj0gMWUzO1xuICAgICAgICB2YXIgaSA9IG0uZGVmYXVsdC5wcm90b3R5cGUuY29uc3RyYWluKGkgfHwgMTUsIDAsIDIyKSwgbCA9IDAsIG4gPSBtLmRlZmF1bHQucHJvdG90eXBlLl9tYWtlRnJhbWUsIGEgPSB0aGlzLl9jdXJFbGVtZW50LmVsdCwgYyA9IFtdLCBwID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYy5wdXNoKG4oZyArIGwsIGYsIGEpKSwgbCsrO1xuICAgICAgICB9LCAxZTMgLyBpKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY2xlYXJJbnRlcnZhbChwKSwgbylcbiAgICAgICAgICAgIG8oYyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIFQgPSBjOyBqIDwgVC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgXyA9IFRbal07XG4gICAgICAgICAgICAgIG0uZGVmYXVsdC5wcm90b3R5cGUuZG93bmxvYWRGaWxlKF8uaW1hZ2VEYXRhLCBfLmZpbGVuYW1lLCBfLmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYyA9IFtdO1xuICAgICAgICB9LCAwLjAxICsgcik7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLl9tYWtlRnJhbWUgPSBmdW5jdGlvbihnLCBmLCBvKSB7XG4gICAgICAgIHZhciBzLCBvID0gdGhpcyA/IHRoaXMuX2N1ckVsZW1lbnQuZWx0IDogbztcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgc3dpdGNoIChmLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwbmdcIjpcbiAgICAgICAgICAgICAgcyA9IFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImpwZWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJqcGdcIjpcbiAgICAgICAgICAgICAgcyA9IFwiaW1hZ2UvanBlZ1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHMgPSBcImltYWdlL3BuZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGYgPSBcInBuZ1wiLCBzID0gXCJpbWFnZS9wbmdcIjtcbiAgICAgICAgdmFyIG8gPSAobyA9IG8udG9EYXRhVVJMKHMpKS5yZXBsYWNlKHMsIFwiaW1hZ2Uvb2N0ZXQtc3RyZWFtXCIpLCBpID0ge307XG4gICAgICAgIHJldHVybiBpLmltYWdlRGF0YSA9IG8sIGkuZmlsZW5hbWUgPSBnLCBpLmV4dCA9IGYsIGk7XG4gICAgICB9LCB0ID0gbS5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiOiAxNjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIjogMTg2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCI6IDE5NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIjogMjAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIjogMjE4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiOiAyMTksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCI6IDIyMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIjogMjIzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCI6IDIyNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiOiAyMjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiOiAyMjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiOiAyMjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiOiAyMjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIjogMjI5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIjogMjMwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiOiAyMzEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIjogMjMyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCI6IDIzMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIjogMjM0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCI6IDIzNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCI6IDIzNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5XCI6IDIzOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIjogMjM5LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMsIG9tZ2dpZjogMjUzIH1dLCAzMDM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKGEpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgYztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBjLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgYyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgYztcbiAgICAgICAgfSkoYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KGEpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBtKGMpO1xuICAgICAgICB9IDogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBjICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0oYyk7XG4gICAgICAgIH0pKGEpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb3B5LXdpdGhpblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtY2xhbXBlZC1hcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1jbGFtcGVkLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG4gICAgICB2YXIgdSA9IG8odChcIi4uL2NvcmUvbWFpblwiKSksIGggPSBvKHQoXCIuLi9jb3JlL2hlbHBlcnNcIikpLCBnID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBpZiAoYSAmJiBhLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGlmIChhID09PSBudWxsIHx8IHkoYSkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGEgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IGEgfTtcbiAgICAgICAgdmFyIGMgPSBzKCk7XG4gICAgICAgIGlmIChjICYmIGMuaGFzKGEpKVxuICAgICAgICAgIHJldHVybiBjLmdldChhKTtcbiAgICAgICAgdmFyIHAsIGogPSB7fSwgVCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKHAgaW4gYSkge1xuICAgICAgICAgIHZhciBfO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSAmJiAoKF8gPSBUID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBwKSA6IG51bGwpICYmIChfLmdldCB8fCBfLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaiwgcCwgXykgOiBqW3BdID0gYVtwXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGouZGVmYXVsdCA9IGEsIGMgJiYgYy5zZXQoYSwgaiksIGo7XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSksIGYgPSBvKHQoXCJvbWdnaWZcIikpLCByID0gdChcImdpZmVuY1wiKTtcbiAgICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChhID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSwgYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgJiYgYS5fX2VzTW9kdWxlID8gYSA6IHsgZGVmYXVsdDogYSB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShhLCBjLCBwLCBqLCBULCBfLCBTKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIEUgPSBhW19dKFMpLCBBID0gRS52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIHAoeCk7XG4gICAgICAgIH1cbiAgICAgICAgRS5kb25lID8gYyhBKSA6IFByb21pc2UucmVzb2x2ZShBKS50aGVuKGosIFQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbChhLCBjLCBwLCBqLCBULCBfLCBTLCBFLCBBLCB4LCBQKSB7XG4gICAgICAgIHZhciBNLCBSLCBMLCBGLCBWLCBHLCBVLCBXLCBYO1xuICAgICAgICByZXR1cm4gYSA9PT0gZy5DT1ZFUiAmJiAoTSA9IGMsIEwgPSBwLCBVID0gXywgVyA9IFMsIEcgPSBFLCBYID0gQSwgUiA9IHgsIEYgPSBQLCBWID0gTWF0aC5tYXgoVSAvIFIsIFcgLyBGKSwgVSAvPSBWLCBXIC89IFYsIFYgPSBHLCBHID0gWCwgTSA9PT0gZy5DRU5URVIgPyBWICs9IChSIC0gVSkgLyAyIDogTSA9PT0gZy5SSUdIVCAmJiAoViArPSBSIC0gVSksIEwgPT09IGcuQ0VOVEVSID8gRyArPSAoRiAtIFcpIC8gMiA6IEwgPT09IGcuQk9UVE9NICYmIChHICs9IEYgLSBXKSwgRSA9IChYID0geyB4OiBWLCB5OiBHLCB3OiBVLCBoOiBXIH0pLngsIEEgPSBYLnksIHggPSBYLncsIFAgPSBYLmgpLCBhID09PSBnLkNPTlRBSU4gJiYgKE0gPSBjLCBSID0gcCwgTCA9IGosIEYgPSBULCBWID0gXywgRyA9IFMsIFUgPSB4LCBXID0gUCwgWCA9IE1hdGgubWF4KFUgLyBWLCBXIC8gRyksIFUgLz0gWCwgVyAvPSBYLCBYID0gTCwgTCA9IEYsIE0gPT09IGcuQ0VOVEVSID8gWCArPSAoViAtIFUpIC8gMiA6IE0gPT09IGcuUklHSFQgJiYgKFggKz0gViAtIFUpLCBSID09PSBnLkNFTlRFUiA/IEwgKz0gKEcgLSBXKSAvIDIgOiBSID09PSBnLkJPVFRPTSAmJiAoTCArPSBHIC0gVyksIGogPSAoYSA9IHsgeDogWCwgeTogTCwgdzogVSwgaDogVyB9KS54LCBUID0gYS55LCBfID0gYS53LCBTID0gYS5oKSwgeyBzeDogRSwgc3k6IEEsIHN3OiB4LCBzaDogUCwgZHg6IGosIGR5OiBULCBkdzogXywgZGg6IFMgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG4oYSwgYykge1xuICAgICAgICByZXR1cm4gMCA8IGEgJiYgYSA8IGMgPyBhIDogYztcbiAgICAgIH1cbiAgICAgIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIiksIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiKSwgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCIpLCB1LmRlZmF1bHQucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKGEsIGMsIHApIHtcbiAgICAgICAgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsb2FkSW1hZ2VcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGogPSBuZXcgdS5kZWZhdWx0LkltYWdlKDEsIDEsIHRoaXMpLCBUID0gdGhpcywgXyA9IG5ldyBSZXF1ZXN0KGEsIHsgbWV0aG9kOiBcIkdFVFwiLCBtb2RlOiBcImNvcnNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGZldGNoKGEsIF8pLnRoZW4oZnVuY3Rpb24oUykge1xuICAgICAgICAgIHZhciBFLCBBID0gUy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICBBID09PSBudWxsICYmIGNvbnNvbGUud2FybihcIlRoZSBpbWFnZSB5b3UgbG9hZGVkIGRvZXMgbm90IGhhdmUgYSBDb250ZW50LVR5cGUgaGVhZGVyLiBJZiB5b3UgYXJlIHVzaW5nIHRoZSBvbmxpbmUgZWRpdG9yIGNvbnNpZGVyIHJldXBsb2FkaW5nIHRoZSBhc3NldC5cIiksIEEgJiYgQS5pbmNsdWRlcyhcImltYWdlL2dpZlwiKSA/IFMuYXJyYXlCdWZmZXIoKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSBuZXcgVWludDhBcnJheSh4KSwgUCA9IGosIE0gPSBjLCBSID0gcCwgTCA9IChmdW5jdGlvbihEKSB7XG4gICAgICAgICAgICAgICAgVC5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICAgICAgICAgICAgICB9KS5iaW5kKFQpLCBGID0gbmV3IGYuZGVmYXVsdC5HaWZSZWFkZXIoeCksIFYgPSAoUC53aWR0aCA9IFAuY2FudmFzLndpZHRoID0gRi53aWR0aCwgUC5oZWlnaHQgPSBQLmNhbnZhcy5oZWlnaHQgPSBGLmhlaWdodCwgW10pLCBHID0gRi5udW1GcmFtZXMoKSwgVSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShQLndpZHRoICogUC5oZWlnaHQgKiA0KSwgVyA9IDA7IFcgPCBHOyBXKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgWCA9IEYuZnJhbWVJbmZvKFcpLCBuZSA9IFAuZHJhd2luZ0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIFAud2lkdGgsIFAuaGVpZ2h0KSwgYiA9IChVID0gbmUuZGF0YS5zbGljZSgpLCBmdW5jdGlvbihELCBCKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBCLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoRCwgVSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChZKSB7XG4gICAgICAgICAgICAgICAgICAgIHUuZGVmYXVsdC5fZnJpZW5kbHlGaWxlTG9hZEVycm9yKDgsIFAuc3JjKSwgdHlwZW9mIFIgPT0gXCJmdW5jdGlvblwiID8gUihZKSA6IGNvbnNvbGUuZXJyb3IoWSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShXLCBGKSwgbmV3IEltYWdlRGF0YShVLCBQLndpZHRoLCBQLmhlaWdodCkpLCBiID0gKFAuZHJhd2luZ0NvbnRleHQucHV0SW1hZ2VEYXRhKGIsIDAsIDApLCBYLmRlbGF5KTtcbiAgICAgICAgICAgICAgICBiID09PSAwICYmIChiID0gMTApLCBWLnB1c2goeyBpbWFnZTogUC5kcmF3aW5nQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgUC53aWR0aCwgUC5oZWlnaHQpLCBkZWxheTogMTAgKiBiIH0pLCBYLmRpc3Bvc2FsID09PSAyID8gUC5kcmF3aW5nQ29udGV4dC5jbGVhclJlY3QoWC54LCBYLnksIFgud2lkdGgsIFguaGVpZ2h0KSA6IFguZGlzcG9zYWwgPT09IDMgJiYgUC5kcmF3aW5nQ29udGV4dC5wdXRJbWFnZURhdGEobmUsIDAsIDAsIFgueCwgWC55LCBYLndpZHRoLCBYLmhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKHggPSBGLmxvb3BDb3VudCgpKSA9PT0gbnVsbCA/IHggPSAxIDogeCA9PT0gMCAmJiAoeCA9IG51bGwpLCBQLmRyYXdpbmdDb250ZXh0LnB1dEltYWdlRGF0YShWWzBdLmltYWdlLCAwLCAwKSwgMSA8IFYubGVuZ3RoICYmIChQLmdpZlByb3BlcnRpZXMgPSB7IGRpc3BsYXlJbmRleDogMCwgbG9vcExpbWl0OiB4LCBsb29wQ291bnQ6IDAsIGZyYW1lczogViwgbnVtRnJhbWVzOiBHLCBwbGF5aW5nOiAhMCwgdGltZURpc3BsYXllZDogMCwgbGFzdENoYW5nZVRpbWU6IDAgfSksIHR5cGVvZiBNID09IFwiZnVuY3Rpb25cIiAmJiBNKFApLCBMKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgdHlwZW9mIHAgPT0gXCJmdW5jdGlvblwiID8gKHAoeCksIFQuX2RlY3JlbWVudFByZWxvYWQoKSkgOiBjb25zb2xlLmVycm9yKHgpO1xuICAgICAgICAgIH0pIDogKChFID0gbmV3IEltYWdlKCkpLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgai53aWR0aCA9IGouY2FudmFzLndpZHRoID0gRS53aWR0aCwgai5oZWlnaHQgPSBqLmNhbnZhcy5oZWlnaHQgPSBFLmhlaWdodCwgai5kcmF3aW5nQ29udGV4dC5kcmF3SW1hZ2UoRSwgMCwgMCksIGoubW9kaWZpZWQgPSAhMCwgdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiICYmIGMoaiksIFQuX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgICAgICB9LCBFLm9uZXJyb3IgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICB1LmRlZmF1bHQuX2ZyaWVuZGx5RmlsZUxvYWRFcnJvcigwLCBFLnNyYyksIHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIiA/IChwKHgpLCBULl9kZWNyZW1lbnRQcmVsb2FkKCkpIDogY29uc29sZS5lcnJvcih4KTtcbiAgICAgICAgICB9LCBhLmluZGV4T2YoXCJkYXRhOmltYWdlL1wiKSAhPT0gMCAmJiAoRS5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCIpLCBFLnNyYyA9IGEpLCBqLm1vZGlmaWVkID0gITA7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICB1LmRlZmF1bHQuX2ZyaWVuZGx5RmlsZUxvYWRFcnJvcigwLCBhKSwgdHlwZW9mIHAgPT0gXCJmdW5jdGlvblwiID8gKHAoUyksIFQuX2RlY3JlbWVudFByZWxvYWQoKSkgOiBjb25zb2xlLmVycm9yKFMpO1xuICAgICAgICB9KSwgajtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUdpZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhID0gcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gcChqLCBUKSB7XG4gICAgICAgICAgdmFyIF8sIFMsIEUsIEEsIHgsIFAsIE0sIFIsIEwsIEYsIFYsIEcsIFUsIFcsIFgsIG5lLCBiLCBPLCBELCBCLCBZLCBKLCB0ZSwgY2UsIHJlLCB1ZSwgbGUgPSBhcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uKEspIHtcbiAgICAgICAgICAgIGZvciAoOyA7IClcbiAgICAgICAgICAgICAgc3dpdGNoIChLLnByZXYgPSBLLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAoXyA9IDIgPCBsZS5sZW5ndGggJiYgbGVbMl0gIT09IHZvaWQgMCA/IGxlWzJdIDogeyBkZWxheTogMCwgdW5pdHM6IFwic2Vjb25kc1wiLCBzaWxlbnQ6ICExLCBub3RpZmljYXRpb25EdXJhdGlvbjogMCwgbm90aWZpY2F0aW9uSUQ6IFwicHJvZ3Jlc3NCYXJcIiB9LCB0eXBlb2YgaiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWxlTmFtZSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgIEsubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiRHVyYXRpb24gcGFyYW1ldGVyIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgICBLLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgaWYgKFMgPSBfICYmIF8uZGVsYXkgfHwgMCwgRSA9IF8gJiYgXy51bml0cyB8fCBcInNlY29uZHNcIiwgQSA9IF8gJiYgXy5zaWxlbnQgfHwgITEsIHggPSBfICYmIF8ubm90aWZpY2F0aW9uRHVyYXRpb24gfHwgMCwgUCA9IF8gJiYgXy5ub3RpZmljYXRpb25JRCB8fCBcInByb2dyZXNzQmFyXCIsIHR5cGVvZiBTICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkRlbGF5IHBhcmFtZXRlciBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgICAgSy5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgaWYgKEUgIT09IFwic2Vjb25kc1wiICYmIEUgIT09IFwiZnJhbWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignVW5pdHMgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIFwiZnJhbWVzXCIgb3IgXCJzZWNvbmRzXCInKTtcbiAgICAgICAgICAgICAgICAgIEsubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiU2lsZW50IHBhcmFtZXRlciBtdXN0IGJlIGEgYm9vbGVhblwiKTtcbiAgICAgICAgICAgICAgICAgIEsubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3RpZmljYXRpb24gZHVyYXRpb24gcGFyYW1ldGVyIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgICBLLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFAgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90aWZpY2F0aW9uIElEIHBhcmFtZXRlciBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgSy5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZGluZyA9ICEwLCBGID0gdGhpcy5fdGFyZ2V0RnJhbWVSYXRlLCBNID0gKE0gPSAxIC8gKEYgPSBGICE9PSAxIC8gMCAmJiBGICE9PSB2b2lkIDAgJiYgRiAhPT0gMCA/IEYgOiA2MCkgKiAxZTMpIDwgMjAgPyAyMCA6IE0sIEwgPSAoUiA9IEUgPT09IFwic2Vjb25kc1wiID8gVCAqIEYgOiBUKSArIChGID0gRSA9PT0gXCJzZWNvbmRzXCIgPyBTICogRiA6IFMpLCBGID0gRiwgdGhpcy5mcmFtZUNvdW50ID0gRiwgViA9IHRoaXMuX3BpeGVsRGVuc2l0eSwgdGhpcy5waXhlbERlbnNpdHkoMSksIEcgPSBbXSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoUCkgIT09IG51bGwgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoUCkucmVtb3ZlKCksIEEgfHwgKChVID0gdGhpcy5jcmVhdGVQKFwiXCIpKS5pZChQKSwgVS5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjE2cHhcIiksIFUuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk1vbnRzZXJyYXRcIiksIFUuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZmZmZmEwXCIpLCBVLnN0eWxlKFwicGFkZGluZ1wiLCBcIjhweFwiKSwgVS5zdHlsZShcImJvcmRlci1yYWRpdXNcIiwgXCIxMHB4XCIpLCBVLnBvc2l0aW9uKDAsIDApKSwgdGhpcy5fcmVuZGVyZXIgaW5zdGFuY2VvZiB1LmRlZmF1bHQuUmVuZGVyZXJHTCAmJiAoWCA9IHRoaXMuZHJhd2luZ0NvbnRleHQsIFcgPSBuZXcgVWludDhBcnJheShYLmRyYXdpbmdCdWZmZXJXaWR0aCAqIFguZHJhd2luZ0J1ZmZlckhlaWdodCAqIDQpKSwgdGhpcy5ub0xvb3AoKSwgSy5uZXh0ID0gMzksIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICBpZiAoRiA8IEwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHJhdygpLCBjZSA9IHZvaWQgMCwgY2UgPSB0aGlzLl9yZW5kZXJlciBpbnN0YW5jZW9mIHUuZGVmYXVsdC5SZW5kZXJlckdMID8gKFcgPSBuZXcgVWludDhBcnJheShYLmRyYXdpbmdCdWZmZXJXaWR0aCAqIFguZHJhd2luZ0J1ZmZlckhlaWdodCAqIDQpLCBYLnJlYWRQaXhlbHMoMCwgMCwgWC5kcmF3aW5nQnVmZmVyV2lkdGgsIFguZHJhd2luZ0J1ZmZlckhlaWdodCwgWC5SR0JBLCBYLlVOU0lHTkVEX0JZVEUsIFcpLCBmdW5jdGlvbihhZSwgaGUsIF9lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmUgPSBwYXJzZUludChfZSAvIDIpLCBnZSA9IDQgKiBoZSwgeGUgPSBuZXcgVWludDhBcnJheSg0ICogaGUpLCBEZSA9IDA7IERlIDwgZmU7ICsrRGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNZSA9IERlICogZ2UsIFFlID0gKF9lIC0gRGUgLSAxKSAqIGdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGUuc2V0KGFlLnN1YmFycmF5KE1lLCBNZSArIGdlKSksIGFlLmNvcHlXaXRoaW4oTWUsIFFlLCBRZSArIGdlKSwgYWUuc2V0KHhlLCBRZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZTtcbiAgICAgICAgICAgICAgICAgICAgfShXLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpIDogdGhpcy5kcmF3aW5nQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLmRhdGEsIEcucHVzaChjZSksIEYrKywgQSB8fCBVLmh0bWwoXCJTYXZlZCBmcmFtZSA8Yj5cIiArIEcubGVuZ3RoLnRvU3RyaW5nKCkgKyBcIjwvYj4gb3V0IG9mIFwiICsgUi50b1N0cmluZygpKSwgSy5uZXh0ID0gNDgsIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoYWUsIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIEsubmV4dCA9IDUwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgICAgIEsubmV4dCA9IDM5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MDpcbiAgICAgICAgICAgICAgICAgIEEgfHwgVS5odG1sKFwiRnJhbWVzIHByb2Nlc3NlZCwgZ2VuZXJhdGluZyBjb2xvciBwYWxldHRlLi4uXCIpLCB0aGlzLmxvb3AoKSwgdGhpcy5waXhlbERlbnNpdHkoViksIG5lID0gKDAsIHIuR0lGRW5jb2RlcikoKSwgYiA9IGZ1bmN0aW9uKGFlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlID0gbmV3IFVpbnQ4QXJyYXkoYWUubGVuZ3RoICogYWVbMF0ubGVuZ3RoKSwgX2UgPSAwOyBfZSA8IGFlLmxlbmd0aDsgX2UrKylcbiAgICAgICAgICAgICAgICAgICAgICBoZS5zZXQoYWVbX2VdLCBfZSAqIGFlWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZSA9ICgwLCByLnF1YW50aXplKShoZSwgMjU2LCB7IGZvcm1hdDogXCJyZ2JhNDQ0NFwiLCBvbmVCaXRBbHBoYTogITAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZS5sZW5ndGggPT09IDI1NiA/IGZlW2ZlLmxlbmd0aCAtIDFdID0gWzI1NSAqIE1hdGgucmFuZG9tKCksIDI1NSAqIE1hdGgucmFuZG9tKCksIDI1NSAqIE1hdGgucmFuZG9tKCksIDBdIDogZmUucHVzaChbMjU1ICogTWF0aC5yYW5kb20oKSwgMjU1ICogTWF0aC5yYW5kb20oKSwgMjU1ICogTWF0aC5yYW5kb20oKSwgMF0pLCBmZTtcbiAgICAgICAgICAgICAgICAgIH0oRyksIE8gPSB7fSwgRCA9IGZ1bmN0aW9uKGFlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlID0gYWUubGVuZ3RoIC8gNCwgX2UgPSBuZXcgVWludDhBcnJheShoZSksIGZlID0gMDsgZmUgPCBoZTsgZmUrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBnZSA9IGFlWzQgKiBmZV0gPDwgMjQgfCBhZVs0ICogZmUgKyAxXSA8PCAxNiB8IGFlWzQgKiBmZSArIDJdIDw8IDggfCBhZVs0ICogZmUgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICBPW2dlXSA9PT0gdm9pZCAwICYmIChPW2dlXSA9ICgwLCByLm5lYXJlc3RDb2xvckluZGV4KShiLCBhZS5zbGljZSg0ICogZmUsIDQgKiAoZmUgKyAxKSkpKSwgX2VbZmVdID0gT1tnZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lO1xuICAgICAgICAgICAgICAgICAgfSwgQiA9IGIubGVuZ3RoIC0gMSwgWSA9IFtdLCBKID0gMDtcbiAgICAgICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICAgICAgaWYgKCEoSiA8IEcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBLLm5leHQgPSA3MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodGUgPSBEKEdbSl0pLCBjZSA9IHRlLnNsaWNlKCksIEogPT09IDApXG4gICAgICAgICAgICAgICAgICAgIG5lLndyaXRlRnJhbWUodGUsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7IHBhbGV0dGU6IGIsIGRlbGF5OiBNLCBkaXNwb3NlOiAxIH0pO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocmUgPSAwOyByZSA8IHRlLmxlbmd0aDsgcmUrKylcbiAgICAgICAgICAgICAgICAgICAgICB0ZVtyZV0gPT09IFlbcmVdICYmICh0ZVtyZV0gPSBCKTtcbiAgICAgICAgICAgICAgICAgICAgbmUud3JpdGVGcmFtZSh0ZSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHsgZGVsYXk6IE0sIHRyYW5zcGFyZW50OiAhMCwgdHJhbnNwYXJlbnRJbmRleDogQiwgZGlzcG9zZTogMSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBZID0gY2UsIEEgfHwgVS5odG1sKFwiUmVuZGVyZWQgZnJhbWUgPGI+XCIgKyBKLnRvU3RyaW5nKCkgKyBcIjwvYj4gb3V0IG9mIFwiICsgUi50b1N0cmluZygpKSwgSy5uZXh0ID0gNjgsIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGFlLCAwKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgNjg6XG4gICAgICAgICAgICAgICAgICBKKyssIEsubmV4dCA9IDYwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICAgICAgICAgIG5lLmZpbmlzaCgpLCB1ZSA9IG5lLmJ5dGVzVmlldygpLCB1ZSA9IG5ldyBCbG9iKFt1ZV0sIHsgdHlwZTogXCJpbWFnZS9naWZcIiB9KSwgRyA9IFtdLCB0aGlzLl9yZWNvcmRpbmcgPSAhMSwgdGhpcy5sb29wKCksIEEgfHwgKFUuaHRtbChcIkRvbmUuIERvd25sb2FkaW5nIHlvdXIgZ2lmIfCfjLhcIiksIDAgPCB4ICYmIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgfSwgMWUzICogeCkpLCB1LmRlZmF1bHQucHJvdG90eXBlLmRvd25sb2FkRmlsZSh1ZSwgaiwgXCJnaWZcIik7XG4gICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gSy5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBwLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhLCBjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzLCBqID0gYXJndW1lbnRzO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihULCBfKSB7XG4gICAgICAgICAgICB2YXIgUyA9IGEuYXBwbHkocCwgaik7XG4gICAgICAgICAgICBmdW5jdGlvbiBFKHgpIHtcbiAgICAgICAgICAgICAgaShTLCBULCBfLCBFLCBBLCBcIm5leHRcIiwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBBKHgpIHtcbiAgICAgICAgICAgICAgaShTLCBULCBfLCBFLCBBLCBcInRocm93XCIsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRSh2b2lkIDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocCwgaikge1xuICAgICAgICAgIHJldHVybiBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCksIHUuZGVmYXVsdC5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihhLCBjLCBwLCBqLCBGLCBWLCBHLCBVLCBYLCB4LCBQLCBNKSB7XG4gICAgICAgIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiaW1hZ2VcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIFcgPSBhLndpZHRoLCBSID0gYS5oZWlnaHQsIEwgPSAoTSA9IE0gfHwgZy5DRU5URVIsIFAgPSBQIHx8IGcuQ0VOVEVSLCBhLmVsdCAmJiAoVyA9IFcgIT09IHZvaWQgMCA/IFcgOiBhLmVsdC53aWR0aCwgUiA9IFIgIT09IHZvaWQgMCA/IFIgOiBhLmVsdC5oZWlnaHQpLCBhLmVsdCAmJiBhLmVsdC52aWRlb1dpZHRoICYmICFhLmNhbnZhcyAmJiAoVyA9IFcgIT09IHZvaWQgMCA/IFcgOiBhLmVsdC52aWRlb1dpZHRoLCBSID0gUiAhPT0gdm9pZCAwID8gUiA6IGEuZWx0LnZpZGVvSGVpZ2h0KSwgaiB8fCBXKSwgRiA9IEYgfHwgUiwgViA9IFYgfHwgMCwgRyA9IEcgfHwgMCwgVSA9IG4oVSAhPT0gdm9pZCAwID8gVSA6IFcsIFcpLCBXID0gbihYICE9PSB2b2lkIDAgPyBYIDogUiwgUiksIFggPSAxO1xuICAgICAgICBhLmVsdCAmJiAhYS5jYW52YXMgJiYgYS5lbHQuc3R5bGUud2lkdGggJiYgKFggPSBhLmVsdC52aWRlb1dpZHRoICYmICFqID8gYS5lbHQudmlkZW9XaWR0aCA6IGEuZWx0LndpZHRoLCBYIC89IHBhcnNlSW50KGEuZWx0LnN0eWxlLndpZHRoLCAxMCkpLCBWICo9IFgsIEcgKj0gWCwgVyAqPSBYLCBVICo9IFgsIFIgPSBsKHgsIFAsIE0sIChSID0gaC5kZWZhdWx0Lm1vZGVBZGp1c3QoYywgcCwgTCwgRiwgdGhpcy5fcmVuZGVyZXIuX2ltYWdlTW9kZSkpLngsIFIueSwgUi53LCBSLmgsIFYsIEcsIFUsIFcpLCB0aGlzLl9yZW5kZXJlci5pbWFnZShhLCBSLnN4LCBSLnN5LCBSLnN3LCBSLnNoLCBSLmR4LCBSLmR5LCBSLmR3LCBSLmRoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUudGludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCwgYyA9IG5ldyBBcnJheShhKSwgcCA9IDA7IHAgPCBhOyBwKyspXG4gICAgICAgICAgY1twXSA9IGFyZ3VtZW50c1twXTtcbiAgICAgICAgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0aW50XCIsIGMpO1xuICAgICAgICB2YXIgaiA9IHRoaXMuY29sb3IuYXBwbHkodGhpcywgYyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl90aW50ID0gai5sZXZlbHM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLm5vVGludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5fdGludCA9IG51bGw7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl9nZXRUaW50ZWRJbWFnZUNhbnZhcyA9IHUuZGVmYXVsdC5SZW5kZXJlcjJELnByb3RvdHlwZS5fZ2V0VGludGVkSW1hZ2VDYW52YXMsIHUuZGVmYXVsdC5wcm90b3R5cGUuaW1hZ2VNb2RlID0gZnVuY3Rpb24oYSkge1xuICAgICAgICB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImltYWdlTW9kZVwiLCBhcmd1bWVudHMpLCBhICE9PSBnLkNPUk5FUiAmJiBhICE9PSBnLkNPUk5FUlMgJiYgYSAhPT0gZy5DRU5URVIgfHwgKHRoaXMuX3JlbmRlcmVyLl9pbWFnZU1vZGUgPSBhKTtcbiAgICAgIH0sIHQgPSB1LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9mZXNfY29yZVwiOiAyNzEsIFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvZmlsZV9lcnJvcnNcIjogMjcyLCBcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL3ZhbGlkYXRlX3BhcmFtc1wiOiAyNzUsIFwiLi4vY29yZS9oZWxwZXJzXCI6IDI3NiwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb3B5LXdpdGhpblwiOiAxNTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCI6IDE2MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIjogMTYzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCI6IDE4OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCI6IDIxMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIjogMjExLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCI6IDIxMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCI6IDIxMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiOiAyMTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIjogMjE0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiOiAyMTgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCI6IDIxOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIjogMjIwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiOiAyMjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIjogMjI0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCI6IDIyNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCI6IDIyNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCI6IDIyOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCI6IDIyNywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiOiAyMjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiOiAyMzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCI6IDIzMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiOiAyMzIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIjogMjMzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiOiAyMzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIjogMjM1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIjogMjM2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiOiAyMzksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWNsYW1wZWQtYXJyYXlcIjogMjQwLCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzLCBnaWZlbmM6IDI1MCwgb21nZ2lmOiAyNTMsIFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCI6IDI1NyB9XSwgMzA0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtID0gdSh0KFwiLi4vY29yZS9tYWluXCIpKSwgeSA9IHUodChcIi4vZmlsdGVyc1wiKSk7XG4gICAgICBmdW5jdGlvbiB1KGcpIHtcbiAgICAgICAgcmV0dXJuIGcgJiYgZy5fX2VzTW9kdWxlID8gZyA6IHsgZGVmYXVsdDogZyB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaChnLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZi5sZW5ndGg7IHIrKykge1xuICAgICAgICAgIHZhciBzID0gZltyXTtcbiAgICAgICAgICBzLmVudW1lcmFibGUgPSBzLmVudW1lcmFibGUgfHwgITEsIHMuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBzICYmIChzLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZywgcy5rZXksIHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtLmRlZmF1bHQuSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZyhzLCBvKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gcywgdGhpcy5oZWlnaHQgPSBvLCB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHRoaXMuZHJhd2luZ0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksICh0aGlzLl9waXhlbHNTdGF0ZSA9IHRoaXMpLl9waXhlbERlbnNpdHkgPSAxLCB0aGlzLmdpZlByb3BlcnRpZXMgPSBudWxsLCB0aGlzLl9tb2RpZmllZCA9ICExLCB0aGlzLnBpeGVscyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmLCByO1xuICAgICAgICByZXR1cm4gZiA9IGcsIChyID0gW3sga2V5OiBcInBpeGVsRGVuc2l0eVwiLCB2YWx1ZTogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICE9PSB2b2lkIDAgPyAocyA8PSAwICYmIChtLmRlZmF1bHQuX2ZyaWVuZGx5UGFyYW1FcnJvcih7IHR5cGU6IFwiSU5WQUxJRF9WQUxVRVwiLCBmb3JtYXQ6IHsgdHlwZXM6IFtcIk51bWJlclwiXSB9LCBwb3NpdGlvbjogMSB9LCBcInBpeGVsRGVuc2l0eVwiKSwgcyA9IDEpLCB0aGlzLl9waXhlbERlbnNpdHkgPSBzLCB0aGlzLndpZHRoIC89IHMsIHRoaXMuaGVpZ2h0IC89IHMsIHRoaXMpIDogdGhpcy5fcGl4ZWxEZW5zaXR5O1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hbmltYXRlR2lmXCIsIHZhbHVlOiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgdmFyIG8sIGkgPSB0aGlzLmdpZlByb3BlcnRpZXMsIGwgPSBsLl9sYXN0UmVhbEZyYW1lVGltZSB8fCB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaS5sYXN0Q2hhbmdlVGltZSA9PT0gMCAmJiAoaS5sYXN0Q2hhbmdlVGltZSA9IGwpLCBpLnBsYXlpbmcgJiYgKGkudGltZURpc3BsYXllZCA9IGwgLSBpLmxhc3RDaGFuZ2VUaW1lLCBvID0gaS5mcmFtZXNbaS5kaXNwbGF5SW5kZXhdLmRlbGF5LCBpLnRpbWVEaXNwbGF5ZWQgPj0gbyAmJiAobyA9IE1hdGguZmxvb3IoaS50aW1lRGlzcGxheWVkIC8gbyksIGkudGltZURpc3BsYXllZCA9IDAsIGkubGFzdENoYW5nZVRpbWUgPSBsLCBpLmRpc3BsYXlJbmRleCArPSBvLCBpLmxvb3BDb3VudCA9IE1hdGguZmxvb3IoaS5kaXNwbGF5SW5kZXggLyBpLm51bUZyYW1lcyksIGkubG9vcExpbWl0ICE9PSBudWxsICYmIGkubG9vcENvdW50ID49IGkubG9vcExpbWl0ID8gaS5wbGF5aW5nID0gITEgOiAobCA9IGkuZGlzcGxheUluZGV4ICUgaS5udW1GcmFtZXMsIHRoaXMuZHJhd2luZ0NvbnRleHQucHV0SW1hZ2VEYXRhKGkuZnJhbWVzW2xdLmltYWdlLCAwLCAwKSwgaS5kaXNwbGF5SW5kZXggPSBsLCB0aGlzLnNldE1vZGlmaWVkKCEwKSkpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfc2V0UHJvcGVydHlcIiwgdmFsdWU6IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgICB0aGlzW3NdID0gbywgdGhpcy5zZXRNb2RpZmllZCghMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibG9hZFBpeGVsc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbS5kZWZhdWx0LlJlbmRlcmVyMkQucHJvdG90eXBlLmxvYWRQaXhlbHMuY2FsbCh0aGlzKSwgdGhpcy5zZXRNb2RpZmllZCghMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXBkYXRlUGl4ZWxzXCIsIHZhbHVlOiBmdW5jdGlvbihzLCBvLCBpLCBsKSB7XG4gICAgICAgICAgbS5kZWZhdWx0LlJlbmRlcmVyMkQucHJvdG90eXBlLnVwZGF0ZVBpeGVscy5jYWxsKHRoaXMsIHMsIG8sIGksIGwpLCB0aGlzLnNldE1vZGlmaWVkKCEwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKHMsIG8sIGksIGwpIHtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJwNS5JbWFnZS5nZXRcIiwgYXJndW1lbnRzKSwgbS5kZWZhdWx0LlJlbmRlcmVyMkQucHJvdG90eXBlLmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRQaXhlbFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkocyksIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgICAgICAgb1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICByZXR1cm4gbS5kZWZhdWx0LlJlbmRlcmVyMkQucHJvdG90eXBlLl9nZXRQaXhlbC5hcHBseSh0aGlzLCBvKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKHMsIG8sIGkpIHtcbiAgICAgICAgICBtLmRlZmF1bHQuUmVuZGVyZXIyRC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgcywgbywgaSksIHRoaXMuc2V0TW9kaWZpZWQoITApO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlc2l6ZVwiLCB2YWx1ZTogZnVuY3Rpb24ocywgbykge1xuICAgICAgICAgIHMgPT09IDAgJiYgbyA9PT0gMCA/IChzID0gdGhpcy5jYW52YXMud2lkdGgsIG8gPSB0aGlzLmNhbnZhcy5oZWlnaHQpIDogcyA9PT0gMCA/IHMgPSB0aGlzLmNhbnZhcy53aWR0aCAqIG8gLyB0aGlzLmNhbnZhcy5oZWlnaHQgOiBvID09PSAwICYmIChvID0gdGhpcy5jYW52YXMuaGVpZ2h0ICogcyAvIHRoaXMuY2FudmFzLndpZHRoKSwgcyA9IE1hdGguZmxvb3IocyksIG8gPSBNYXRoLmZsb29yKG8pO1xuICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICBpZiAoaS53aWR0aCA9IHMsIGkuaGVpZ2h0ID0gbywgdGhpcy5naWZQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMuZ2lmUHJvcGVydGllcywgbiA9IDA7IG4gPCBsLm51bUZyYW1lczsgbisrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGEgPSB0aGlzLmRyYXdpbmdDb250ZXh0LmNyZWF0ZUltYWdlRGF0YShzLCBvKSwgYyA9IChTID0gUyA9IF8gPSBUID0gaiA9IHZvaWQgMCwgbC5mcmFtZXNbbl0uaW1hZ2UpLCBwID0gYSwgaiA9IDAsIFQgPSAwOyBUIDwgcC5oZWlnaHQ7IFQrKylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IHAud2lkdGg7IF8rKykge1xuICAgICAgICAgICAgICAgICAgdmFyIFMgPSBNYXRoLmZsb29yKF8gKiBjLndpZHRoIC8gcC53aWR0aCksIFMgPSA0ICogKE1hdGguZmxvb3IoVCAqIGMuaGVpZ2h0IC8gcC5oZWlnaHQpICogYy53aWR0aCArIFMpO1xuICAgICAgICAgICAgICAgICAgcC5kYXRhW2orK10gPSBjLmRhdGFbUysrXSwgcC5kYXRhW2orK10gPSBjLmRhdGFbUysrXSwgcC5kYXRhW2orK10gPSBjLmRhdGFbUysrXSwgcC5kYXRhW2orK10gPSBjLmRhdGFbK1NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbC5mcmFtZXNbbl0uaW1hZ2UgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGkuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCwgMCwgMCwgaS53aWR0aCwgaS5oZWlnaHQpLCB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGggPSBzLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodCA9IG8sIHRoaXMuZHJhd2luZ0NvbnRleHQuZHJhd0ltYWdlKGksIDAsIDAsIHMsIG8sIDAsIDAsIHMsIG8pLCAwIDwgdGhpcy5waXhlbHMubGVuZ3RoICYmIHRoaXMubG9hZFBpeGVscygpLCB0aGlzLnNldE1vZGlmaWVkKCEwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjb3B5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShzKSwgaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICAgICAgICBvW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIG0uZGVmYXVsdC5wcm90b3R5cGUuY29weS5hcHBseSh0aGlzLCBvKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtYXNrXCIsIHZhbHVlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmRyYXdpbmdDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiwgaSA9IHRoaXMuX3BpeGVsRGVuc2l0eSwgbCA9IDEsIG4gPSBbcyA9IHMgPT09IHZvaWQgMCA/IHRoaXMgOiBzLCAwLCAwLCAobCA9IHMgaW5zdGFuY2VvZiBtLmRlZmF1bHQuUmVuZGVyZXIgPyBzLl9wSW5zdC5fcGl4ZWxEZW5zaXR5IDogbCkgKiBzLndpZHRoLCBsICogcy5oZWlnaHQsIDAsIDAsIGkgKiB0aGlzLndpZHRoLCBpICogdGhpcy5oZWlnaHRdO1xuICAgICAgICAgIGlmICh0aGlzLmRyYXdpbmdDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIiwgdGhpcy5naWZQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMuZ2lmUHJvcGVydGllcy5mcmFtZXMubGVuZ3RoOyBhKyspXG4gICAgICAgICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuZ2lmUHJvcGVydGllcy5mcmFtZXNbYV0uaW1hZ2UsIDAsIDApLCB0aGlzLmNvcHkuYXBwbHkodGhpcywgbiksIHRoaXMuZ2lmUHJvcGVydGllcy5mcmFtZXNbYV0uaW1hZ2UgPSB0aGlzLmRyYXdpbmdDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpICogdGhpcy53aWR0aCwgaSAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuZ2lmUHJvcGVydGllcy5mcmFtZXNbdGhpcy5naWZQcm9wZXJ0aWVzLmRpc3BsYXlJbmRleF0uaW1hZ2UsIDAsIDApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhpcy5jb3B5LmFwcGx5KHRoaXMsIG4pO1xuICAgICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbywgdGhpcy5zZXRNb2RpZmllZCghMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZmlsdGVyXCIsIHZhbHVlOiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgICAgeS5kZWZhdWx0LmFwcGx5KHRoaXMuY2FudmFzLCB5LmRlZmF1bHRbc10sIG8pLCB0aGlzLnNldE1vZGlmaWVkKCEwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJibGVuZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkocyksIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgICAgICAgb1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInA1LkltYWdlLmJsZW5kXCIsIGFyZ3VtZW50cyksIG0uZGVmYXVsdC5wcm90b3R5cGUuYmxlbmQuYXBwbHkodGhpcywgbyksIHRoaXMuc2V0TW9kaWZpZWQoITApO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldE1vZGlmaWVkXCIsIHZhbHVlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgdGhpcy5fbW9kaWZpZWQgPSBzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzTW9kaWZpZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RpZmllZDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzYXZlXCIsIHZhbHVlOiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgICAgdGhpcy5naWZQcm9wZXJ0aWVzID8gbS5kZWZhdWx0LnByb3RvdHlwZS5lbmNvZGVBbmREb3dubG9hZEdpZih0aGlzLCBzKSA6IG0uZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUNhbnZhcyh0aGlzLmNhbnZhcywgcywgbyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIHRoaXMuZ2lmUHJvcGVydGllcyAmJiAoKHMgPSB0aGlzLmdpZlByb3BlcnRpZXMpLnBsYXlpbmcgPSAhMCwgcy50aW1lU2luY2VTdGFydCA9IDAsIHMudGltZURpc3BsYXllZCA9IDAsIHMubGFzdENoYW5nZVRpbWUgPSAwLCBzLmxvb3BDb3VudCA9IDAsIHMuZGlzcGxheUluZGV4ID0gMCwgdGhpcy5kcmF3aW5nQ29udGV4dC5wdXRJbWFnZURhdGEocy5mcmFtZXNbMF0uaW1hZ2UsIDAsIDApKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRDdXJyZW50RnJhbWVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIGlmICh0aGlzLmdpZlByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gKHMgPSB0aGlzLmdpZlByb3BlcnRpZXMpLmRpc3BsYXlJbmRleCAlIHMubnVtRnJhbWVzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldEZyYW1lXCIsIHZhbHVlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgdmFyIG87XG4gICAgICAgICAgdGhpcy5naWZQcm9wZXJ0aWVzICYmIChzIDwgKG8gPSB0aGlzLmdpZlByb3BlcnRpZXMpLm51bUZyYW1lcyAmJiAwIDw9IHMgPyAoby50aW1lRGlzcGxheWVkID0gMCwgby5sYXN0Q2hhbmdlVGltZSA9IDAsIG8uZGlzcGxheUluZGV4ID0gcywgdGhpcy5kcmF3aW5nQ29udGV4dC5wdXRJbWFnZURhdGEoby5mcmFtZXNbc10uaW1hZ2UsIDAsIDApKSA6IGNvbnNvbGUubG9nKFwiQ2Fubm90IHNldCBHSUYgdG8gYSBmcmFtZSBudW1iZXIgdGhhdCBpcyBoaWdoZXIgdGhhbiB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIG9yIGJlbG93IHplcm8uXCIpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJudW1GcmFtZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLmdpZlByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5naWZQcm9wZXJ0aWVzLm51bUZyYW1lcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJwbGF5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmdpZlByb3BlcnRpZXMgJiYgKHRoaXMuZ2lmUHJvcGVydGllcy5wbGF5aW5nID0gITApO1xuICAgICAgICB9IH0sIHsga2V5OiBcInBhdXNlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmdpZlByb3BlcnRpZXMgJiYgKHRoaXMuZ2lmUHJvcGVydGllcy5wbGF5aW5nID0gITEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRlbGF5XCIsIHZhbHVlOiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2lmUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdpZlByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAobyA8IGkubnVtRnJhbWVzICYmIDAgPD0gbylcbiAgICAgICAgICAgICAgaS5mcmFtZXNbb10uZGVsYXkgPSBzO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBsID0gITAsIG8gPSAhMSwgbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhLCBjID0gaS5mcmFtZXNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKGwgPSAoYSA9IGMubmV4dCgpKS5kb25lKTsgbCA9ICEwKVxuICAgICAgICAgICAgICAgICAgYS52YWx1ZS5kZWxheSA9IHM7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGopIHtcbiAgICAgICAgICAgICAgICBvID0gITAsIG4gPSBqO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBsIHx8IGMucmV0dXJuID09IG51bGwgfHwgYy5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dKSAmJiBoKGYucHJvdG90eXBlLCByKSwgZztcbiAgICAgIH0oKSwgdCA9IG0uZGVmYXVsdC5JbWFnZSwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuL2ZpbHRlcnNcIjogMzAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMzA1OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IHUodChcIi4uL2NvcmUvbWFpblwiKSksIHkgPSB1KHQoXCIuL2ZpbHRlcnNcIikpO1xuICAgICAgZnVuY3Rpb24gdShoKSB7XG4gICAgICAgIHJldHVybiBoICYmIGguX19lc01vZHVsZSA/IGggOiB7IGRlZmF1bHQ6IGggfTtcbiAgICAgIH1cbiAgICAgIHQoXCIuLi9jb2xvci9wNS5Db2xvclwiKSwgbS5kZWZhdWx0LnByb3RvdHlwZS5waXhlbHMgPSBbXSwgbS5kZWZhdWx0LnByb3RvdHlwZS5ibGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBoLCBnID0gYXJndW1lbnRzLmxlbmd0aCwgZiA9IG5ldyBBcnJheShnKSwgciA9IDA7IHIgPCBnOyByKyspXG4gICAgICAgICAgZltyXSA9IGFyZ3VtZW50c1tyXTtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJibGVuZFwiLCBmKSwgdGhpcy5fcmVuZGVyZXIgPyAoaCA9IHRoaXMuX3JlbmRlcmVyKS5ibGVuZC5hcHBseShoLCBmKSA6IG0uZGVmYXVsdC5SZW5kZXJlcjJELnByb3RvdHlwZS5ibGVuZC5hcHBseSh0aGlzLCBmKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBoLCBnLCBmLCByLCBzLCBvLCBpLCBsLCBuLCBhID0gYXJndW1lbnRzLmxlbmd0aCwgYyA9IG5ldyBBcnJheShhKSwgcCA9IDA7IHAgPCBhOyBwKyspXG4gICAgICAgICAgY1twXSA9IGFyZ3VtZW50c1twXTtcbiAgICAgICAgaWYgKG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY29weVwiLCBjKSwgYy5sZW5ndGggPT09IDkpXG4gICAgICAgICAgaCA9IGNbMF0sIGcgPSBjWzFdLCBmID0gY1syXSwgciA9IGNbM10sIHMgPSBjWzRdLCBvID0gY1s1XSwgaSA9IGNbNl0sIGwgPSBjWzddLCBuID0gY1s4XTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoICE9PSA4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgaCA9IHRoaXMsIGcgPSBjWzBdLCBmID0gY1sxXSwgciA9IGNbMl0sIHMgPSBjWzNdLCBvID0gY1s0XSwgaSA9IGNbNV0sIGwgPSBjWzZdLCBuID0gY1s3XTtcbiAgICAgICAgfVxuICAgICAgICBtLmRlZmF1bHQucHJvdG90eXBlLl9jb3B5SGVscGVyKHRoaXMsIGgsIGcsIGYsIHIsIHMsIG8sIGksIGwsIG4pO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5fY29weUhlbHBlciA9IGZ1bmN0aW9uKGgsIGcsIGYsIHIsIHMsIG8sIGksIGwsIG4sIGEpIHtcbiAgICAgICAgdmFyIGMgPSBnLmNhbnZhcy53aWR0aCAvIGcud2lkdGgsIHAgPSAwLCBqID0gMDtcbiAgICAgICAgZy5fcmVuZGVyZXIgJiYgZy5fcmVuZGVyZXIuaXNQM0QgJiYgKHAgPSBnLndpZHRoIC8gMiwgaiA9IGcuaGVpZ2h0IC8gMiksIGguX3JlbmRlcmVyICYmIGguX3JlbmRlcmVyLmlzUDNEID8gKGgucHVzaCgpLCBoLnJlc2V0TWF0cml4KCksIGgubm9MaWdodHMoKSwgaC5ibGVuZE1vZGUoaC5CTEVORCksIGguaW1hZ2VNb2RlKGguQ09STkVSKSwgbS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLmltYWdlLmNhbGwoaC5fcmVuZGVyZXIsIGcsIGYgKyBwLCByICsgaiwgcywgbywgaSwgbCwgbiwgYSksIGgucG9wKCkpIDogaC5kcmF3aW5nQ29udGV4dC5kcmF3SW1hZ2UoZy5jYW52YXMsIGMgKiAoZiArIHApLCBjICogKHIgKyBqKSwgYyAqIHMsIGMgKiBvLCBpLCBsLCBuLCBhKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuZ2V0RmlsdGVyR3JhcGhpY3NMYXllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0RmlsdGVyR3JhcGhpY3NMYXllcigpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IGFyZ3VtZW50cy5sZW5ndGgsIGcgPSBuZXcgQXJyYXkoaCksIGYgPSAwOyBmIDwgaDsgZisrKVxuICAgICAgICAgIGdbZl0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZmlsdGVyXCIsIGcpO1xuICAgICAgICB2YXIgaSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbCwgbiA9IHsgc2hhZGVyOiB2b2lkIDAsIG9wZXJhdGlvbjogdm9pZCAwLCB2YWx1ZTogdm9pZCAwLCB1c2VXZWJHTDogITAgfTtcbiAgICAgICAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuU2hhZGVyID8gbi5zaGFkZXIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0gOiAobi5vcGVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSA9PSBcIm51bWJlclwiICYmIChuLnZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSwgKChsID0gYXJndW1lbnRzLmxlbmd0aCAtIDEpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGwgPyB2b2lkIDAgOiBhcmd1bWVudHNbbF0pID09PSAhMSAmJiAobi51c2VXZWJHTCA9ICExKSksIG47XG4gICAgICAgIH0pLmFwcGx5KHZvaWQgMCwgZyksIHIgPSBpLnNoYWRlciwgcyA9IGkub3BlcmF0aW9uLCBvID0gaS52YWx1ZSwgaSA9IGkudXNlV2ViR0w7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmlzUDNEICYmIHIgPyBtLmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGhpcy5fcmVuZGVyZXIsIHIpIDogaSB8fCB0aGlzLl9yZW5kZXJlci5pc1AzRCA/ICghaSAmJiB0aGlzLl9yZW5kZXJlci5pc1AzRCAmJiBjb25zb2xlLndhcm4oXCJmaWx0ZXIoKSB3aXRoIHVzZVdlYkdMPWZhbHNlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gV0VCR0xcIiksIHRoaXMuX3JlbmRlcmVyLmlzUDNEID8gbS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuX3JlbmRlcmVyLCBzLCBvKSA6ICgociA9IHRoaXMuZ2V0RmlsdGVyR3JhcGhpY3NMYXllcigpKS5jb3B5KHRoaXMuX3JlbmRlcmVyLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgLXRoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHRoaXMuX3JlbmRlcmVyLmNsZWFyKCksIHRoaXMuX3JlbmRlcmVyLnJlc2V0TWF0cml4KCksIHIuZmlsdGVyLmFwcGx5KHIsIGcpLCB0aGlzLmNvcHkoci5fcmVuZGVyZXIsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHIuY2xlYXIoKSkpIDogdGhpcy5jYW52YXMgIT09IHZvaWQgMCA/IHkuZGVmYXVsdC5hcHBseSh0aGlzLmNhbnZhcywgeS5kZWZhdWx0W3NdLCBvKSA6IHkuZGVmYXVsdC5hcHBseSh0aGlzLmVsdCwgeS5kZWZhdWx0W3NdLCBvKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaCwgZywgZiwgcikge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZ2V0XCIsIGFyZ3VtZW50cyksIChzID0gdGhpcy5fcmVuZGVyZXIpLmdldC5hcHBseShzLCBhcmd1bWVudHMpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5sb2FkUGl4ZWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGggPSBhcmd1bWVudHMubGVuZ3RoLCBnID0gbmV3IEFycmF5KGgpLCBmID0gMDsgZiA8IGg7IGYrKylcbiAgICAgICAgICBnW2ZdID0gYXJndW1lbnRzW2ZdO1xuICAgICAgICBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImxvYWRQaXhlbHNcIiwgZyksIHRoaXMuX3JlbmRlcmVyLmxvYWRQaXhlbHMoKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaCwgZywgZikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXQoaCwgZywgZik7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnVwZGF0ZVBpeGVscyA9IGZ1bmN0aW9uKGgsIGcsIGYsIHIpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ1cGRhdGVQaXhlbHNcIiwgYXJndW1lbnRzKSwgdGhpcy5waXhlbHMubGVuZ3RoICE9PSAwICYmIHRoaXMuX3JlbmRlcmVyLnVwZGF0ZVBpeGVscyhoLCBnLCBmLCByKTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvbG9yL3A1LkNvbG9yXCI6IDI2NywgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vZmlsdGVyc1wiOiAzMDEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiOiAxNTYgfV0sIDMwNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBpO1xuICAgICAgICB9KShvKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5mcm9tLWVudHJpZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIudXJsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5sYXN0LWluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZnJvbS1lbnRyaWVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLnVybFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHkgPSBnKHQoXCIuLi9jb3JlL21haW5cIikpLCB1ID0gKHQoXCJ3aGF0d2ctZmV0Y2hcIiksIHQoXCJlczYtcHJvbWlzZS9hdXRvXCIpLCBnKHQoXCJmZXRjaC1qc29ucFwiKSkpLCBoID0gZyh0KFwiZmlsZS1zYXZlclwiKSk7XG4gICAgICBmdW5jdGlvbiBnKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gJiYgby5fX2VzTW9kdWxlID8gbyA6IHsgZGVmYXVsdDogbyB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihvKSB7XG4gICAgICAgIHJldHVybiAoZiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gbShpKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBpLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgaSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKGkpO1xuICAgICAgICB9KShvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIobykge1xuICAgICAgICByZXR1cm4gby5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHMobywgaSkge1xuICAgICAgICBpICYmIGkgIT09ICEwICYmIGkgIT09IFwidHJ1ZVwiIHx8IChpID0gXCJcIik7XG4gICAgICAgIHZhciBsID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIChvID0gbyB8fCBcInVudGl0bGVkXCIpICYmIG8uaW5jbHVkZXMoXCIuXCIpICYmIChsID0gby5zcGxpdChcIi5cIikucG9wKCkpLCBpICYmIGwgIT09IGkgJiYgKGwgPSBpLCBvID0gXCJcIi5jb25jYXQobywgXCIuXCIpLmNvbmNhdChsKSksIFtvLCBsXTtcbiAgICAgIH1cbiAgICAgIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIiksIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiKSwgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCIpLCB5LmRlZmF1bHQucHJvdG90eXBlLmxvYWRKU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KG8pLCBsID0gMDsgbCA8IG87IGwrKylcbiAgICAgICAgICBpW2xdID0gYXJndW1lbnRzW2xdO1xuICAgICAgICB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImxvYWRKU09OXCIsIGkpO1xuICAgICAgICBmb3IgKHZhciBuLCBhLCBjLCBwID0gaVswXSwgaiA9IHt9LCBUID0gXCJqc29uXCIsIF8gPSAxOyBfIDwgaS5sZW5ndGg7IF8rKykge1xuICAgICAgICAgIHZhciBTID0gaVtfXTtcbiAgICAgICAgICB0eXBlb2YgUyA9PSBcInN0cmluZ1wiID8gUyAhPT0gXCJqc29ucFwiICYmIFMgIT09IFwianNvblwiIHx8IChUID0gUykgOiB0eXBlb2YgUyA9PSBcImZ1bmN0aW9uXCIgPyBuID8gYSA9IFMgOiBuID0gUyA6IGYoUykgPT09IFwib2JqZWN0XCIgJiYgKFMuaGFzT3duUHJvcGVydHkoXCJqc29ucENhbGxiYWNrXCIpIHx8IFMuaGFzT3duUHJvcGVydHkoXCJqc29ucENhbGxiYWNrRnVuY3Rpb25cIikpICYmIChUID0gXCJqc29ucFwiLCBjID0gUyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwRG8ocCwgXCJHRVRcIiwgYywgVCwgZnVuY3Rpb24oQSkge1xuICAgICAgICAgIGZvciAodmFyIHggaW4gQSlcbiAgICAgICAgICAgIGpbeF0gPSBBW3hdO1xuICAgICAgICAgIG4gIT09IHZvaWQgMCAmJiBuKEEpLCBFLl9kZWNyZW1lbnRQcmVsb2FkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgICBpZiAoeS5kZWZhdWx0Ll9mcmllbmRseUZpbGVMb2FkRXJyb3IoNSwgcCksICFhKVxuICAgICAgICAgICAgdGhyb3cgQTtcbiAgICAgICAgICBhKEEpO1xuICAgICAgICB9KSwgajtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUubG9hZFN0cmluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkobyksIGwgPSAwOyBsIDwgbzsgbCsrKVxuICAgICAgICAgIGlbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwibG9hZFN0cmluZ3NcIiwgaSk7XG4gICAgICAgIGZvciAodmFyIG4sIGEsIGMgPSBbXSwgcCA9IDE7IHAgPCBpLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIGogPSBpW3BdO1xuICAgICAgICAgIHR5cGVvZiBqID09IFwiZnVuY3Rpb25cIiAmJiAobiA9PT0gdm9pZCAwID8gbiA9IGogOiBhID09PSB2b2lkIDAgJiYgKGEgPSBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFQgPSB0aGlzO1xuICAgICAgICByZXR1cm4geS5kZWZhdWx0LnByb3RvdHlwZS5odHRwRG8uY2FsbCh0aGlzLCBpWzBdLCBcIkdFVFwiLCBcInRleHRcIiwgZnVuY3Rpb24oXykge1xuICAgICAgICAgIGZvciAodmFyIFMgPSBfLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcclwiKS5yZXBsYWNlKC9cXG4vZywgXCJcXHJcIikuc3BsaXQoL1xcci8pLCBFID0gMCwgQSA9IFMubGVuZ3RoOyBFIDwgQTsgRSArPSAzMjc2OClcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGMsIFMuc2xpY2UoRSwgTWF0aC5taW4oRSArIDMyNzY4LCBBKSkpO1xuICAgICAgICAgIG4gIT09IHZvaWQgMCAmJiBuKGMpLCBULl9kZWNyZW1lbnRQcmVsb2FkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICBpZiAoeS5kZWZhdWx0Ll9mcmllbmRseUZpbGVMb2FkRXJyb3IoMywgXyksICFhKVxuICAgICAgICAgICAgdGhyb3cgXztcbiAgICAgICAgICBhKF8pO1xuICAgICAgICB9KSwgYztcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUubG9hZFRhYmxlID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgaSwgbCwgbiwgYSA9ICExLCBjID0gby5zdWJzdHJpbmcoby5sYXN0SW5kZXhPZihcIi5cIikgKyAxLCBvLmxlbmd0aCk7XG4gICAgICAgIGMgPT09IFwiY3N2XCIgPyBuID0gXCIsXCIgOiBjID09PSBcInNzdlwiID8gbiA9IFwiO1wiIDogYyA9PT0gXCJ0c3ZcIiAmJiAobiA9IFwiXHRcIik7XG4gICAgICAgIGZvciAodmFyIHAgPSAxOyBwIDwgYXJndW1lbnRzLmxlbmd0aDsgcCsrKVxuICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbcF0gPT0gXCJmdW5jdGlvblwiID8gaSA9PT0gdm9pZCAwID8gaSA9IGFyZ3VtZW50c1twXSA6IGwgPT09IHZvaWQgMCAmJiAobCA9IGFyZ3VtZW50c1twXSkgOiB0eXBlb2YgYXJndW1lbnRzW3BdID09IFwic3RyaW5nXCIgJiYgKGFyZ3VtZW50c1twXSA9PT0gXCJoZWFkZXJcIiAmJiAoYSA9ICEwKSwgYXJndW1lbnRzW3BdID09PSBcImNzdlwiID8gbiA9IFwiLFwiIDogYXJndW1lbnRzW3BdID09PSBcInNzdlwiID8gbiA9IFwiO1wiIDogYXJndW1lbnRzW3BdID09PSBcInRzdlwiICYmIChuID0gXCJcdFwiKSk7XG4gICAgICAgIHZhciBqID0gbmV3IHkuZGVmYXVsdC5UYWJsZSgpLCBUID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cERvKG8sIFwiR0VUXCIsIFwidGFibGVcIiwgZnVuY3Rpb24oXykge1xuICAgICAgICAgIGZvciAodmFyIFMsIEUsIEEgPSB7fSwgeCA9IDAsIFAgPSBbXSwgTSA9IDAsIFIgPSBudWxsLCBMID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBLmN1cnJlbnRTdGF0ZSA9IHgsIEEudG9rZW4gPSBcIlwiO1xuICAgICAgICAgIH0sIEYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFIucHVzaChBLnRva2VuKSwgTCgpO1xuICAgICAgICAgIH0sIFYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEEuY3VycmVudFN0YXRlID0gNCwgUC5wdXNoKFIpLCBSID0gbnVsbDtcbiAgICAgICAgICB9OyA7ICkge1xuICAgICAgICAgICAgaWYgKChTID0gX1tNKytdKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChBLmVzY2FwZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jbG9zZWQgcXVvdGUgaW4gZmlsZS5cIik7XG4gICAgICAgICAgICAgIGlmIChSKSB7XG4gICAgICAgICAgICAgICAgRigpLCBWKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSID09PSBudWxsICYmIChBLmVzY2FwZWQgPSAhMSwgUiA9IFtdLCBMKCkpLCBBLmN1cnJlbnRTdGF0ZSA9PT0geCkge1xuICAgICAgICAgICAgICBpZiAoUyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIEEuZXNjYXBlZCA9ICEwLCBBLmN1cnJlbnRTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgQS5jdXJyZW50U3RhdGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEEuY3VycmVudFN0YXRlID09PSAxICYmIEEuZXNjYXBlZClcbiAgICAgICAgICAgICAgaWYgKFMgPT09ICdcIicpXG4gICAgICAgICAgICAgICAgX1tNXSA9PT0gJ1wiJyA/IChBLnRva2VuICs9ICdcIicsIE0rKykgOiAoQS5lc2NhcGVkID0gITEsIEEuY3VycmVudFN0YXRlID0gMik7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChTID09PSBcIlxcclwiKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgQS50b2tlbiArPSBTO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIFMgPT09IFwiXFxyXCIgPyAoX1tNXSA9PT0gYFxuYCAmJiBNKyssIEYoKSwgVigpKSA6IFMgPT09IGBcbmAgPyAoRigpLCBWKCkpIDogUyA9PT0gbiA/IEYoKSA6IEEuY3VycmVudFN0YXRlID09PSAxICYmIChBLnRva2VuICs9IFMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIGouY29sdW1ucyA9IFAuc2hpZnQoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKHZhciBHID0gMDsgRyA8IFBbMF0ubGVuZ3RoOyBHKyspXG4gICAgICAgICAgICAgIGouY29sdW1uc1tHXSA9IFwibnVsbFwiO1xuICAgICAgICAgIGZvciAodmFyIFUgPSAwOyBVIDwgUC5sZW5ndGg7IFUrKylcbiAgICAgICAgICAgIChQW1VdLmxlbmd0aCAhPT0gMSB8fCBQW1VdWzBdICE9PSBcInVuZGVmaW5lZFwiICYmIFBbVV1bMF0gIT09IFwiXCIpICYmICgoRSA9IG5ldyB5LmRlZmF1bHQuVGFibGVSb3coKSkuYXJyID0gUFtVXSwgRS5vYmogPSBmdW5jdGlvbihXLCBYKSB7XG4gICAgICAgICAgICAgIGlmICgoWCA9IFggfHwgW10pID09PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmUgPSAwOyBuZSA8IFcubGVuZ3RoOyBuZSsrKVxuICAgICAgICAgICAgICAgICAgWFtuZS50b1N0cmluZygpXSA9IG5lO1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFgubWFwKGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2IsIFdbT11dO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KFBbVV0sIGouY29sdW1ucyksIGouYWRkUm93KEUpKTtcbiAgICAgICAgICB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgJiYgaShqKSwgVC5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgeS5kZWZhdWx0Ll9mcmllbmRseUZpbGVMb2FkRXJyb3IoMiwgbyksIGwgPyBsKF8pIDogY29uc29sZS5lcnJvcihfKTtcbiAgICAgICAgfSksIGo7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmxvYWRYTUwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkobyksIGwgPSAwOyBsIDwgbzsgbCsrKVxuICAgICAgICAgIGlbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICAgIGZvciAodmFyIG4sIGEsIGMgPSBuZXcgeS5kZWZhdWx0LlhNTCgpLCBwID0gMTsgcCA8IGkubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICB2YXIgaiA9IGlbcF07XG4gICAgICAgICAgdHlwZW9mIGogPT0gXCJmdW5jdGlvblwiICYmIChuID09PSB2b2lkIDAgPyBuID0gaiA6IGEgPT09IHZvaWQgMCAmJiAoYSA9IGopKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVCA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBEbyhpWzBdLCBcIkdFVFwiLCBcInhtbFwiLCBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgZm9yICh2YXIgUyBpbiBfKVxuICAgICAgICAgICAgY1tTXSA9IF9bU107XG4gICAgICAgICAgbiAhPT0gdm9pZCAwICYmIG4oYyksIFQuX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oXykge1xuICAgICAgICAgIGlmICh5LmRlZmF1bHQuX2ZyaWVuZGx5RmlsZUxvYWRFcnJvcigxLCBfKSwgIWEpXG4gICAgICAgICAgICB0aHJvdyBfO1xuICAgICAgICAgIGEoXyk7XG4gICAgICAgIH0pLCBjO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5sb2FkQnl0ZXMgPSBmdW5jdGlvbihvLCBpLCBsKSB7XG4gICAgICAgIHZhciBuID0ge30sIGEgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwRG8obywgXCJHRVRcIiwgXCJhcnJheUJ1ZmZlclwiLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgbi5ieXRlcyA9IG5ldyBVaW50OEFycmF5KGMpLCB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgJiYgaShuKSwgYS5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgaWYgKHkuZGVmYXVsdC5fZnJpZW5kbHlGaWxlTG9hZEVycm9yKDYsIG8pLCAhbClcbiAgICAgICAgICAgIHRocm93IGM7XG4gICAgICAgICAgbChjKTtcbiAgICAgICAgfSksIG47XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLmh0dHBHZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkobyksIGwgPSAwOyBsIDwgbzsgbCsrKVxuICAgICAgICAgIGlbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImh0dHBHZXRcIiwgaSksIGkuc3BsaWNlKDEsIDAsIFwiR0VUXCIpLCB5LmRlZmF1bHQucHJvdG90eXBlLmh0dHBEby5hcHBseSh0aGlzLCBpKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuaHR0cFBvc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkobyksIGwgPSAwOyBsIDwgbzsgbCsrKVxuICAgICAgICAgIGlbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICAgIHJldHVybiB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImh0dHBQb3N0XCIsIGkpLCBpLnNwbGljZSgxLCAwLCBcIlBPU1RcIiksIHkuZGVmYXVsdC5wcm90b3R5cGUuaHR0cERvLmFwcGx5KHRoaXMsIGkpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5odHRwRG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbywgaSwgbCwgbiA9IHt9LCBhID0gMCwgYyA9IFwidGV4dC9wbGFpblwiLCBwID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IDAgPCBwICYmIHR5cGVvZiAocCA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBwID8gdm9pZCAwIDogYXJndW1lbnRzW3BdKSA9PSBcImZ1bmN0aW9uXCI7IHAtLSlcbiAgICAgICAgICBhKys7XG4gICAgICAgIHZhciBqID0gYXJndW1lbnRzLmxlbmd0aCAtIGEsIFQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChqID09IDIgJiYgdHlwZW9mIFQgPT0gXCJzdHJpbmdcIiAmJiBmKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgUCA9IG5ldyBSZXF1ZXN0KFQsIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSksIGkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0sIGwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgPyB2b2lkIDAgOiBhcmd1bWVudHNbM107XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF8sIFMgPSBcIkdFVFwiLCBFID0gMTsgRSA8IGFyZ3VtZW50cy5sZW5ndGg7IEUrKykge1xuICAgICAgICAgICAgdmFyIEEgPSBFIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IEUgPyB2b2lkIDAgOiBhcmd1bWVudHNbRV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIEEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgQSA9PT0gXCJHRVRcIiB8fCBBID09PSBcIlBPU1RcIiB8fCBBID09PSBcIlBVVFwiIHx8IEEgPT09IFwiREVMRVRFXCIgPyBTID0gQSA6IEEgPT09IFwianNvblwiIHx8IEEgPT09IFwianNvbnBcIiB8fCBBID09PSBcImJpbmFyeVwiIHx8IEEgPT09IFwiYXJyYXlCdWZmZXJcIiB8fCBBID09PSBcInhtbFwiIHx8IEEgPT09IFwidGV4dFwiIHx8IEEgPT09IFwidGFibGVcIiA/IG8gPSBBIDogXyA9IEE7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgQSA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBfID0gQS50b1N0cmluZygpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZihBKSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgaWYgKEEuaGFzT3duUHJvcGVydHkoXCJqc29ucENhbGxiYWNrXCIpIHx8IEEuaGFzT3duUHJvcGVydHkoXCJqc29ucENhbGxiYWNrRnVuY3Rpb25cIikpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBBKVxuICAgICAgICAgICAgICAgICAgblt4XSA9IEFbeF07XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjID0gQSBpbnN0YW5jZW9mIHkuZGVmYXVsdC5YTUwgPyAoXyA9IEEuc2VyaWFsaXplKCksIFwiYXBwbGljYXRpb24veG1sXCIpIDogKF8gPSBKU09OLnN0cmluZ2lmeShBKSwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0eXBlb2YgQSA9PSBcImZ1bmN0aW9uXCIgJiYgKGkgPyBsID0gQSA6IGkgPSBBKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGogPSBTID09PSBcIkdFVFwiID8gbmV3IEhlYWRlcnMoKSA6IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogYyB9KSwgUCA9IG5ldyBSZXF1ZXN0KFQsIHsgbWV0aG9kOiBTLCBtb2RlOiBcImNvcnNcIiwgYm9keTogXywgaGVhZGVyczogaiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGogPSAoaiA9IChvID0gbyB8fCAoVC5pbmNsdWRlcyhcImpzb25cIikgPyBcImpzb25cIiA6IFQuaW5jbHVkZXMoXCJ4bWxcIikgPyBcInhtbFwiIDogXCJ0ZXh0XCIpKSA9PT0gXCJqc29ucFwiID8gKDAsIHUuZGVmYXVsdCkoVCwgbikgOiBmZXRjaChQKSkudGhlbihmdW5jdGlvbihNKSB7XG4gICAgICAgICAgaWYgKCFNLm9rKVxuICAgICAgICAgICAgdGhyb3cgKFIgPSBuZXcgRXJyb3IoTS5ib2R5KSkuc3RhdHVzID0gTS5zdGF0dXMsIFIub2sgPSAhMSwgUjtcbiAgICAgICAgICB2YXIgUiA9IDA7XG4gICAgICAgICAgc3dpdGNoICgoUiA9IG8gIT09IFwianNvbnBcIiA/IE0uaGVhZGVycy5nZXQoXCJjb250ZW50LWxlbmd0aFwiKSA6IFIpICYmIDY0ZTYgPCBSICYmIHkuZGVmYXVsdC5fZnJpZW5kbHlGaWxlTG9hZEVycm9yKDcsIFQpLCBvKSB7XG4gICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgY2FzZSBcImpzb25wXCI6XG4gICAgICAgICAgICAgIHJldHVybiBNLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIE0uYmxvYigpO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5QnVmZmVyXCI6XG4gICAgICAgICAgICAgIHJldHVybiBNLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICAgIHJldHVybiBNLnRleHQoKS50aGVuKGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoTCwgXCJ0ZXh0L3htbFwiKSwgbmV3IHkuZGVmYXVsdC5YTUwoTC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBNLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKS50aGVuKGkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIH0pLCBqLmNhdGNoKGwgfHwgY29uc29sZS5lcnJvciksIGo7XG4gICAgICB9LCB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMLCB5LmRlZmF1bHQucHJvdG90eXBlLl9wV3JpdGVycyA9IFtdLCB5LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZVdyaXRlciA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgICAgdmFyIGwsIG47XG4gICAgICAgIGZvciAobiBpbiB5LmRlZmF1bHQucHJvdG90eXBlLl9wV3JpdGVycylcbiAgICAgICAgICBpZiAoeS5kZWZhdWx0LnByb3RvdHlwZS5fcFdyaXRlcnNbbl0ubmFtZSA9PT0gbylcbiAgICAgICAgICAgIHJldHVybiBsID0gbmV3IHkuZGVmYXVsdC5QcmludFdyaXRlcihvICsgdGhpcy5taWxsaXMoKSwgaSksIHkuZGVmYXVsdC5wcm90b3R5cGUuX3BXcml0ZXJzLnB1c2gobCksIGw7XG4gICAgICAgIHJldHVybiBsID0gbmV3IHkuZGVmYXVsdC5QcmludFdyaXRlcihvLCBpKSwgeS5kZWZhdWx0LnByb3RvdHlwZS5fcFdyaXRlcnMucHVzaChsKSwgbDtcbiAgICAgIH0sIHkuZGVmYXVsdC5QcmludFdyaXRlciA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWUgPSBvLCB0aGlzLmNvbnRlbnQgPSBcIlwiLCB0aGlzLndyaXRlID0gZnVuY3Rpb24obikge1xuICAgICAgICAgIHRoaXMuY29udGVudCArPSBuO1xuICAgICAgICB9LCB0aGlzLnByaW50ID0gZnVuY3Rpb24obikge1xuICAgICAgICAgIHRoaXMuY29udGVudCArPSBcIlwiLmNvbmNhdChuLCBgXG5gKTtcbiAgICAgICAgfSwgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XG4gICAgICAgIH0sIHRoaXMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbiwgYSA9IFtdO1xuICAgICAgICAgIGZvciAobiBpbiBhLnB1c2godGhpcy5jb250ZW50KSwgeS5kZWZhdWx0LnByb3RvdHlwZS53cml0ZUZpbGUoYSwgbywgaSksIHkuZGVmYXVsdC5wcm90b3R5cGUuX3BXcml0ZXJzKVxuICAgICAgICAgICAgeS5kZWZhdWx0LnByb3RvdHlwZS5fcFdyaXRlcnNbbl0ubmFtZSA9PT0gdGhpcy5uYW1lICYmIHkuZGVmYXVsdC5wcm90b3R5cGUuX3BXcml0ZXJzLnNwbGljZShuLCAxKTtcbiAgICAgICAgICBsLmNsZWFyKCksIGwgPSB7fTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKG8sIGksIGwpIHtcbiAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMsIGEgPSAodGhpcy5fY3VyRWxlbWVudCB8fCB0aGlzKS5lbHQ7XG4gICAgICAgIGlmIChuLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICB5LmRlZmF1bHQucHJvdG90eXBlLnNhdmVDYW52YXMoYSk7XG4gICAgICAgIGVsc2UgaWYgKG5bMF0gaW5zdGFuY2VvZiB5LmRlZmF1bHQuUmVuZGVyZXIgfHwgblswXSBpbnN0YW5jZW9mIHkuZGVmYXVsdC5HcmFwaGljcylcbiAgICAgICAgICB5LmRlZmF1bHQucHJvdG90eXBlLnNhdmVDYW52YXMoblswXS5lbHQsIG5bMV0sIG5bMl0pO1xuICAgICAgICBlbHNlIGlmIChuLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgblswXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUNhbnZhcyhhLCBuWzBdKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN3aXRjaCAocyhuWzFdLCBuWzJdKVsxXSkge1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgeS5kZWZhdWx0LnByb3RvdHlwZS5zYXZlSlNPTihuWzBdLCBuWzFdLCBuWzJdKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0eHRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgeS5kZWZhdWx0LnByb3RvdHlwZS5zYXZlU3RyaW5ncyhuWzBdLCBuWzFdLCBuWzJdKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5bMF0gaW5zdGFuY2VvZiBBcnJheSA/IHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZVN0cmluZ3MoblswXSwgblsxXSwgblsyXSkgOiBuWzBdIGluc3RhbmNlb2YgeS5kZWZhdWx0LlRhYmxlID8geS5kZWZhdWx0LnByb3RvdHlwZS5zYXZlVGFibGUoblswXSwgblsxXSwgblsyXSkgOiBuWzBdIGluc3RhbmNlb2YgeS5kZWZhdWx0LkltYWdlID8geS5kZWZhdWx0LnByb3RvdHlwZS5zYXZlQ2FudmFzKG5bMF0uY2FudmFzLCBuWzFdKSA6IG5bMF0gaW5zdGFuY2VvZiB5LmRlZmF1bHQuU291bmRGaWxlICYmIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZVNvdW5kKG5bMF0sIG5bMV0sIG5bMl0sIG5bM10pO1xuICAgICAgICAgIH1cbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUpTT04gPSBmdW5jdGlvbihvLCBpLCBsKSB7XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic2F2ZUpTT05cIiwgYXJndW1lbnRzKSwgbCA9IGwgPyBKU09OLnN0cmluZ2lmeShvKSA6IEpTT04uc3RyaW5naWZ5KG8sIHZvaWQgMCwgMiksIHRoaXMuc2F2ZVN0cmluZ3MobC5zcGxpdChgXG5gKSwgaSwgXCJqc29uXCIpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5zYXZlSlNPTk9iamVjdCA9IHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUpTT04sIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUpTT05BcnJheSA9IHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZUpTT04sIHkuZGVmYXVsdC5wcm90b3R5cGUuc2F2ZVN0cmluZ3MgPSBmdW5jdGlvbihvLCBpLCBsLCBuKSB7XG4gICAgICAgIHkuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic2F2ZVN0cmluZ3NcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgZm9yICh2YXIgYSA9IHRoaXMuY3JlYXRlV3JpdGVyKGksIGwgfHwgXCJ0eHRcIiksIGMgPSAwOyBjIDwgby5sZW5ndGg7IGMrKylcbiAgICAgICAgICBuID8gYS53cml0ZShvW2NdICsgYFxcclxuYCkgOiBhLndyaXRlKG9bY10gKyBgXG5gKTtcbiAgICAgICAgYS5jbG9zZSgpLCBhLmNsZWFyKCk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLnNhdmVUYWJsZSA9IGZ1bmN0aW9uKG8sIGksIGwpIHtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzYXZlVGFibGVcIiwgYXJndW1lbnRzKSwgbiA9IGwgPT09IHZvaWQgMCA/IGkuc3Vic3RyaW5nKGkubGFzdEluZGV4T2YoXCIuXCIpICsgMSwgaS5sZW5ndGgpIDogbDtcbiAgICAgICAgdmFyIG4sIGEgPSB0aGlzLmNyZWF0ZVdyaXRlcihpLCBuKSwgYyA9IG8uY29sdW1ucywgcCA9IG4gPT09IFwidHN2XCIgPyBcIlx0XCIgOiBcIixcIjtcbiAgICAgICAgaWYgKG4gIT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgaWYgKGNbMF0gIT09IFwiMFwiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIGogPCBjLmxlbmd0aCAtIDEgPyBhLndyaXRlKGNbal0gKyBwKSA6IGEud3JpdGUoY1tqXSk7XG4gICAgICAgICAgICBhLndyaXRlKGBcbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBUID0gMDsgVCA8IG8ucm93cy5sZW5ndGg7IFQrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgXyA9IHZvaWQgMCwgXyA9IDA7IF8gPCBvLnJvd3NbVF0uYXJyLmxlbmd0aDsgXysrKVxuICAgICAgICAgICAgICBfIDwgby5yb3dzW1RdLmFyci5sZW5ndGggLSAxID8gbiA9PT0gXCJjc3ZcIiAmJiBTdHJpbmcoby5yb3dzW1RdLmFycltfXSkuaW5jbHVkZXMoXCIsXCIpID8gYS53cml0ZSgnXCInICsgby5yb3dzW1RdLmFycltfXSArICdcIicgKyBwKSA6IGEud3JpdGUoby5yb3dzW1RdLmFycltfXSArIHApIDogbiA9PT0gXCJjc3ZcIiAmJiBTdHJpbmcoby5yb3dzW1RdLmFycltfXSkuaW5jbHVkZXMoXCIsXCIpID8gYS53cml0ZSgnXCInICsgby5yb3dzW1RdLmFycltfXSArICdcIicpIDogYS53cml0ZShvLnJvd3NbVF0uYXJyW19dKTtcbiAgICAgICAgICAgIGEud3JpdGUoYFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhLnByaW50KFwiPGh0bWw+XCIpLCBhLnByaW50KFwiPGhlYWQ+XCIpLCBhLnByaW50KCcgIDxtZXRhIGh0dHAtZXF1aXY9XCJjb250ZW50LXR5cGVcIiBjb250ZW50PVwidGV4dC9odG1sO2NoYXJzZXQ9dXRmLThcIiAvPicpLCBhLnByaW50KFwiPC9oZWFkPlwiKSwgYS5wcmludChcIjxib2R5PlwiKSwgYS5wcmludChcIiAgPHRhYmxlPlwiKSwgY1swXSAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIGEucHJpbnQoXCIgICAgPHRyPlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIFMgPSAwOyBTIDwgYy5sZW5ndGg7IFMrKykge1xuICAgICAgICAgICAgICB2YXIgRSA9IHIoY1tTXSk7XG4gICAgICAgICAgICAgIGEucHJpbnQoXCIgICAgICA8dGQ+XCIuY29uY2F0KEUpKSwgYS5wcmludChcIiAgICAgIDwvdGQ+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS5wcmludChcIiAgICA8L3RyPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgQSA9IDA7IEEgPCBvLnJvd3MubGVuZ3RoOyBBKyspIHtcbiAgICAgICAgICAgIGEucHJpbnQoXCIgICAgPHRyPlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgby5jb2x1bW5zLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIHZhciBQID0gcihvLnJvd3NbQV0uZ2V0U3RyaW5nKHgpKTtcbiAgICAgICAgICAgICAgYS5wcmludChcIiAgICAgIDx0ZD5cIi5jb25jYXQoUCkpLCBhLnByaW50KFwiICAgICAgPC90ZD5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnByaW50KFwiICAgIDwvdHI+XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhLnByaW50KFwiICA8L3RhYmxlPlwiKSwgYS5wcmludChcIjwvYm9keT5cIiksIGEucHJpbnQoXCI8L2h0bWw+XCIpO1xuICAgICAgICB9XG4gICAgICAgIGEuY2xvc2UoKSwgYS5jbGVhcigpO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS53cml0ZUZpbGUgPSBmdW5jdGlvbihhLCBpLCBsKSB7XG4gICAgICAgIHZhciBuID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiwgYSA9ICh5LmRlZmF1bHQucHJvdG90eXBlLl9pc1NhZmFyaSgpICYmIChuID0gXCJ0ZXh0L3BsYWluXCIpLCBuZXcgQmxvYihhLCB7IHR5cGU6IG4gfSkpO1xuICAgICAgICB5LmRlZmF1bHQucHJvdG90eXBlLmRvd25sb2FkRmlsZShhLCBpLCBsKTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuZG93bmxvYWRGaWxlID0gZnVuY3Rpb24obywgYSwgYykge1xuICAgICAgICB2YXIgbiwgYSA9IHMoYSwgYyksIGMgPSBhWzBdO1xuICAgICAgICBvIGluc3RhbmNlb2YgQmxvYiA/IGguZGVmYXVsdC5zYXZlQXMobywgYykgOiAoKG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSkuaHJlZiA9IG8sIG4uZG93bmxvYWQgPSBjLCBuLm9uY2xpY2sgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwLnRhcmdldCksIHAuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sIG4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG4pLCB5LmRlZmF1bHQucHJvdG90eXBlLl9pc1NhZmFyaSgpICYmIChvID0gKG8gPSBgSGVsbG8sIFNhZmFyaSB1c2VyISBUbyBkb3dubG9hZCB0aGlzIGZpbGUuLi5cbjEuIEdvIHRvIEZpbGUgLS0+IFNhdmUgQXMuXG4yLiBDaG9vc2UgXCJQYWdlIFNvdXJjZVwiIGFzIHRoZSBGb3JtYXQuXG5gKSArICczLiBOYW1lIGl0IHdpdGggdGhpcyBleHRlbnNpb246IC5cIicuY29uY2F0KGFbMV0sICdcIicpLCBhbGVydChvKSksIG4uY2xpY2soKSk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLl9jaGVja0ZpbGVFeHRlbnNpb24gPSBzLCB5LmRlZmF1bHQucHJvdG90eXBlLl9pc1NhZmFyaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LkhUTUxFbGVtZW50LnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJDb25zdHJ1Y3RvclwiKTtcbiAgICAgIH0sIHQgPSB5LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCI6IDI3MSwgXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiOiAyNzIsIFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvdmFsaWRhdGVfcGFyYW1zXCI6IDI3NSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubGFzdC1pbmRleC1vZlwiOiAxNjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCI6IDE3MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiOiAxNzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5mcm9tLWVudHJpZXNcIjogMTgyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZVwiOiAxODgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlXCI6IDIwMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIjogMjEwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiOiAyMTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIjogMjEyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIjogMjEzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCI6IDIxNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiOiAyMTQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCI6IDIxOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIjogMjE5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiOiAyMjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCI6IDIyMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiOiAyMjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIjogMjI1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIjogMjI2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIjogMjI4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIjogMjI3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCI6IDIyOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCI6IDIzMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIjogMjMxLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCI6IDIzMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiOiAyMzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCI6IDIzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiOiAyMzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiOiAyMzYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCI6IDIzOSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi51cmxcIjogMjQ1LCBcImVzNi1wcm9taXNlL2F1dG9cIjogMjQ2LCBcImZldGNoLWpzb25wXCI6IDI0OCwgXCJmaWxlLXNhdmVyXCI6IDI0OSwgXCJ3aGF0d2ctZmV0Y2hcIjogMjU4IH1dLCAzMDc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIHkodSwgaCkge1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGgubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGhbZ107XG4gICAgICAgICAgZi5lbnVtZXJhYmxlID0gZi5lbnVtZXJhYmxlIHx8ICExLCBmLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gZiAmJiAoZi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIGYua2V5LCBmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbS5kZWZhdWx0LlRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgdmFyIGYgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdLCByID0gdGhpcywgcyA9IHU7XG4gICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mIHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXSwgdGhpcy5yb3dzID0gZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCwgZztcbiAgICAgICAgcmV0dXJuIGggPSB1LCAoZyA9IFt7IGtleTogXCJhZGRSb3dcIiwgdmFsdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBpZiAoZiA9IGYgfHwgbmV3IG0uZGVmYXVsdC5UYWJsZVJvdygpLCBmLmFyciA9PT0gdm9pZCAwIHx8IGYub2JqID09PSB2b2lkIDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRhYmxlUm93OiBcIi5jb25jYXQoZikpO1xuICAgICAgICAgIHJldHVybiAoZi50YWJsZSA9IHRoaXMpLnJvd3MucHVzaChmKSwgZjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1vdmVSb3dcIiwgdmFsdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB0aGlzLnJvd3NbZl0udGFibGUgPSBudWxsLCBmID0gdGhpcy5yb3dzLnNwbGljZShmICsgMSwgdGhpcy5yb3dzLmxlbmd0aCksIHRoaXMucm93cy5wb3AoKSwgdGhpcy5yb3dzID0gdGhpcy5yb3dzLmNvbmNhdChmKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRSb3dcIiwgdmFsdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzW2ZdO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldFJvd3NcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZmluZFJvd1wiLCB2YWx1ZTogZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMucm93cy5sZW5ndGg7IHMrKylcbiAgICAgICAgICAgICAgaWYgKHRoaXMucm93c1tzXS5vYmpbcl0gPT09IGYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93c1tzXTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5yb3dzLmxlbmd0aDsgbysrKVxuICAgICAgICAgICAgICBpZiAodGhpcy5yb3dzW29dLmFycltyXSA9PT0gZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzW29dO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZpbmRSb3dzXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgdmFyIHMgPSBbXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5yb3dzLmxlbmd0aDsgbysrKVxuICAgICAgICAgICAgICB0aGlzLnJvd3Nbb10ub2JqW3JdID09PSBmICYmIHMucHVzaCh0aGlzLnJvd3Nbb10pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICB0aGlzLnJvd3NbaV0uYXJyW3JdID09PSBmICYmIHMucHVzaCh0aGlzLnJvd3NbaV0pO1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1hdGNoUm93XCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5yb3dzLmxlbmd0aDsgcysrKVxuICAgICAgICAgICAgICBpZiAodGhpcy5yb3dzW3NdLmFycltyXS5tYXRjaChmKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzW3NdO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCB0aGlzLnJvd3MubGVuZ3RoOyBvKyspXG4gICAgICAgICAgICAgIGlmICh0aGlzLnJvd3Nbb10ub2JqW3JdLm1hdGNoKGYpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3Nbb107XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWF0Y2hSb3dzXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgdmFyIHMgPSBbXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5yb3dzLmxlbmd0aDsgbysrKVxuICAgICAgICAgICAgICB0aGlzLnJvd3Nbb10uYXJyW3JdLm1hdGNoKGYpICYmIHMucHVzaCh0aGlzLnJvd3Nbb10pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICB0aGlzLnJvd3NbaV0ub2JqW3JdLm1hdGNoKGYpICYmIHMucHVzaCh0aGlzLnJvd3NbaV0pO1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldENvbHVtblwiLCB2YWx1ZTogZnVuY3Rpb24oZikge1xuICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgaWYgKHR5cGVvZiBmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMucm93cy5sZW5ndGg7IHMrKylcbiAgICAgICAgICAgICAgci5wdXNoKHRoaXMucm93c1tzXS5vYmpbZl0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5yb3dzLmxlbmd0aDsgbysrKVxuICAgICAgICAgICAgICByLnB1c2godGhpcy5yb3dzW29dLmFycltmXSk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJSb3dzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yb3dzLCB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJhZGRDb2x1bW5cIiwgdmFsdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChmIHx8IG51bGwpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldENvbHVtbkNvdW50XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRSb3dDb3VudFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucm93cy5sZW5ndGg7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlVG9rZW5zXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IFtdLCBvID0gMDsgbyA8IGYubGVuZ3RoOyBvKyspXG4gICAgICAgICAgICBzLnB1c2goZi5jaGFyQXQobykucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIikpO1xuICAgICAgICAgIHZhciBpID0gbmV3IFJlZ0V4cChzLmpvaW4oXCJ8XCIpLCBcImdcIik7XG4gICAgICAgICAgaWYgKHIgPT09IHZvaWQgMClcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgbCsrKVxuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMucm93cy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gKGEgPSB0aGlzLnJvd3Nbbl0uYXJyW2xdKS5yZXBsYWNlKGksIFwiXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucm93c1tuXS5hcnJbbF0gPSBhLCB0aGlzLnJvd3Nbbl0ub2JqW3RoaXMuY29sdW1uc1tsXV0gPSBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5yb3dzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gKHAgPSB0aGlzLnJvd3NbY10ub2JqW3JdKS5yZXBsYWNlKGksIFwiXCIpLCBqID0gKHRoaXMucm93c1tjXS5vYmpbcl0gPSBwLCB0aGlzLmNvbHVtbnMuaW5kZXhPZihyKSk7XG4gICAgICAgICAgICAgIHRoaXMucm93c1tjXS5hcnJbal0gPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgdGhpcy5yb3dzLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICAgIHZhciBfID0gKF8gPSB0aGlzLnJvd3NbVF0uYXJyW3JdKS5yZXBsYWNlKGksIFwiXCIpO1xuICAgICAgICAgICAgICB0aGlzLnJvd3NbVF0uYXJyW3JdID0gXywgdGhpcy5yb3dzW1RdLm9ialt0aGlzLmNvbHVtbnNbcl1dID0gXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB7IGtleTogXCJ0cmltXCIsIHZhbHVlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiIFwiLCBcImdcIik7XG4gICAgICAgICAgaWYgKGYgPT09IHZvaWQgMClcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgcysrKVxuICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHRoaXMucm93cy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gKGkgPSB0aGlzLnJvd3Nbb10uYXJyW3NdKS5yZXBsYWNlKHIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucm93c1tvXS5hcnJbc10gPSBpLCB0aGlzLnJvd3Nbb10ub2JqW3RoaXMuY29sdW1uc1tzXV0gPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5yb3dzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgIHZhciBuID0gKG4gPSB0aGlzLnJvd3NbbF0ub2JqW2ZdKS5yZXBsYWNlKHIsIFwiXCIpLCBhID0gKHRoaXMucm93c1tsXS5vYmpbZl0gPSBuLCB0aGlzLmNvbHVtbnMuaW5kZXhPZihmKSk7XG4gICAgICAgICAgICAgIHRoaXMucm93c1tsXS5hcnJbYV0gPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5yb3dzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gKHAgPSB0aGlzLnJvd3NbY10uYXJyW2ZdKS5yZXBsYWNlKHIsIFwiXCIpO1xuICAgICAgICAgICAgICB0aGlzLnJvd3NbY10uYXJyW2ZdID0gcCwgdGhpcy5yb3dzW2NdLm9ialt0aGlzLmNvbHVtbnNbZl1dID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1vdmVDb2x1bW5cIiwgdmFsdWU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8gcyA9IHRoaXMuY29sdW1ucy5pbmRleE9mKHIgPSBvKSA6IHIgPSB0aGlzLmNvbHVtbnNbcyA9IG9dO1xuICAgICAgICAgIHZhciByLCBzLCBvID0gdGhpcy5jb2x1bW5zLnNwbGljZShzICsgMSwgdGhpcy5jb2x1bW5zLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5jb2x1bW5zLnBvcCgpLCB0aGlzLmNvbHVtbnMgPSB0aGlzLmNvbHVtbnMuY29uY2F0KG8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMucm93c1tpXS5hcnIsIG4gPSBsLnNwbGljZShzICsgMSwgbC5sZW5ndGgpO1xuICAgICAgICAgICAgbC5wb3AoKSwgdGhpcy5yb3dzW2ldLmFyciA9IGwuY29uY2F0KG4pLCBkZWxldGUgdGhpcy5yb3dzW2ldLm9ialtyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0XCIsIHZhbHVlOiBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgICAgdGhpcy5yb3dzW2ZdLnNldChyLCBzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXROdW1cIiwgdmFsdWU6IGZ1bmN0aW9uKGYsIHIsIHMpIHtcbiAgICAgICAgICB0aGlzLnJvd3NbZl0uc2V0TnVtKHIsIHMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFN0cmluZ1wiLCB2YWx1ZTogZnVuY3Rpb24oZiwgciwgcykge1xuICAgICAgICAgIHRoaXMucm93c1tmXS5zZXRTdHJpbmcociwgcyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucm93c1tmXS5nZXQocik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0TnVtXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucm93c1tmXS5nZXROdW0ocik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0U3RyaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucm93c1tmXS5nZXRTdHJpbmcocik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0T2JqZWN0XCIsIHZhbHVlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgZm9yICh2YXIgciwgcyA9IHt9LCBvID0gMDsgbyA8IHRoaXMucm93cy5sZW5ndGg7IG8rKylcbiAgICAgICAgICAgIGlmIChyID0gdGhpcy5yb3dzW29dLm9iaiwgdHlwZW9mIGYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBpZiAoISgwIDw9IHRoaXMuY29sdW1ucy5pbmRleE9mKGYpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdGFibGUgaGFzIG5vIGNvbHVtbiBuYW1lZCBcIicuY29uY2F0KGYsICdcIicpKTtcbiAgICAgICAgICAgICAgc1tyW2ZdXSA9IHI7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgc1tvXSA9IHRoaXMucm93c1tvXS5vYmo7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0QXJyYXlcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGYgPSBbXSwgciA9IDA7IHIgPCB0aGlzLnJvd3MubGVuZ3RoOyByKyspXG4gICAgICAgICAgICBmLnB1c2godGhpcy5yb3dzW3JdLmFycik7XG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gfV0pICYmIHkoaC5wcm90b3R5cGUsIGcpLCB1O1xuICAgICAgfSgpLCB0ID0gbS5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIjogMTcwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3JcIjogMTkxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiOiAxOTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2hcIjogMTk4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiOiAyMDEgfV0sIDMwODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmZyb20tZW50cmllc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmZyb20tZW50cmllc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24gbSh5LCB1KSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgdS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBnID0gdVtoXTtcbiAgICAgICAgICBnLmVudW1lcmFibGUgPSBnLmVudW1lcmFibGUgfHwgITEsIGcuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBnICYmIChnLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoeSwgZy5rZXksIGcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0LmRlZmF1bHQuVGFibGVSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24geShnLCBmKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgIGcgJiYgKHIgPSBnLnNwbGl0KGYgPSBmIHx8IFwiLFwiKSksIHRoaXMuYXJyID0gciwgdGhpcy5vYmogPSBPYmplY3QuZnJvbUVudHJpZXMoci5lbnRyaWVzKCkpLCB0aGlzLnRhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSwgaDtcbiAgICAgICAgcmV0dXJuIHUgPSB5LCAoaCA9IFt7IGtleTogXCJzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGcgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnRhYmxlLmNvbHVtbnMuaW5kZXhPZihnKTtcbiAgICAgICAgICAgIGlmICghKDAgPD0gcikpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0YWJsZSBoYXMgbm8gY29sdW1uIG5hbWVkIFwiJy5jb25jYXQoZywgJ1wiJykpO1xuICAgICAgICAgICAgdGhpcy5vYmpbZ10gPSBmLCB0aGlzLmFycltyXSA9IGY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGcgPCB0aGlzLnRhYmxlLmNvbHVtbnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uICNcIi5jb25jYXQoZywgXCIgaXMgb3V0IG9mIHRoZSByYW5nZSBvZiB0aGlzIHRhYmxlXCIpKTtcbiAgICAgICAgICAgIHRoaXMuYXJyW2ddID0gZiwgciA9IHRoaXMudGFibGUuY29sdW1uc1tnXSwgdGhpcy5vYmpbcl0gPSBmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXROdW1cIiwgdmFsdWU6IGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgICBmID0gcGFyc2VGbG9hdChmKSwgdGhpcy5zZXQoZywgZik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0U3RyaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihnLCBmKSB7XG4gICAgICAgICAgZiA9IGYudG9TdHJpbmcoKSwgdGhpcy5zZXQoZywgZik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuICh0eXBlb2YgZyA9PSBcInN0cmluZ1wiID8gdGhpcy5vYmogOiB0aGlzLmFycilbZ107XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0TnVtXCIsIHZhbHVlOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgdmFyIGYgPSBwYXJzZUZsb2F0KHR5cGVvZiBnID09IFwic3RyaW5nXCIgPyB0aGlzLm9ialtnXSA6IHRoaXMuYXJyW2ddKTtcbiAgICAgICAgICBpZiAoZi50b1N0cmluZygpID09PSBcIk5hTlwiKVxuICAgICAgICAgICAgdGhyb3cgXCJFcnJvcjogXCIuY29uY2F0KHRoaXMub2JqW2ddLCBcIiBpcyBOYU4gKE5vdCBhIE51bWJlcilcIik7XG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0U3RyaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuICh0eXBlb2YgZyA9PSBcInN0cmluZ1wiID8gdGhpcy5vYmogOiB0aGlzLmFycilbZ10udG9TdHJpbmcoKTtcbiAgICAgICAgfSB9XSkgJiYgbSh1LnByb3RvdHlwZSwgaCksIHk7XG4gICAgICB9KCksIHQgPSB0LmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCI6IDE2MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZnJvbS1lbnRyaWVzXCI6IDE4MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiOiAyMDMsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMDk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24geShoLCBnKSB7XG4gICAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgZy5sZW5ndGg7IGYrKykge1xuICAgICAgICAgIHZhciByID0gZ1tmXTtcbiAgICAgICAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaCwgci5rZXksIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KGgpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IFtdLCBmID0gMDsgZiA8IGgubGVuZ3RoOyBmKyspXG4gICAgICAgICAgZy5wdXNoKG5ldyBtLmRlZmF1bHQuWE1MKGhbZl0pKTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgICBtLmRlZmF1bHQuWE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGgocikge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgciA/IHRoaXMuRE9NID0gciA6IChyID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQobnVsbCwgXCJkb2NcIiksIHRoaXMuRE9NID0gci5jcmVhdGVFbGVtZW50KFwicm9vdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGcsIGY7XG4gICAgICAgIHJldHVybiBnID0gaCwgKGYgPSBbeyBrZXk6IFwiZ2V0UGFyZW50XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG0uZGVmYXVsdC5YTUwodGhpcy5ET00ucGFyZW50RWxlbWVudCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0TmFtZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuRE9NLnRhZ05hbWU7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0TmFtZVwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5ET00uaW5uZXJIVE1MLCBvID0gdGhpcy5ET00uYXR0cmlidXRlcywgaSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KG51bGwsIFwiZGVmYXVsdFwiKS5jcmVhdGVFbGVtZW50KHIpO1xuICAgICAgICAgIGkuaW5uZXJIVE1MID0gcztcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICBpLnNldEF0dHJpYnV0ZShvW2xdLm5vZGVOYW1lLCBvW2xdLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgdGhpcy5ET00gPSBpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImhhc0NoaWxkcmVuXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMCA8IHRoaXMuRE9NLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJsaXN0Q2hpbGRyZW5cIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSBbXSwgcyA9IDA7IHMgPCB0aGlzLkRPTS5jaGlsZE5vZGVzLmxlbmd0aDsgcysrKVxuICAgICAgICAgICAgci5wdXNoKHRoaXMuRE9NLmNoaWxkTm9kZXNbc10ubm9kZU5hbWUpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldENoaWxkcmVuXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHUociA/IHRoaXMuRE9NLmdldEVsZW1lbnRzQnlUYWdOYW1lKHIpIDogdGhpcy5ET00uY2hpbGRyZW4pO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldENoaWxkXCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IG0uZGVmYXVsdC5YTUwodGhpcy5ET00uY2hpbGRyZW5bcl0pO1xuICAgICAgICAgIHZhciBzID0gITAsIG8gPSAhMSwgaSA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbCwgbiA9IHRoaXMuRE9NLmNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShzID0gKGwgPSBuLm5leHQoKSkuZG9uZSk7IHMgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IGwudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChhLnRhZ05hbWUgPT09IHIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtLmRlZmF1bHQuWE1MKGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgICAgIG8gPSAhMCwgaSA9IGM7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHMgfHwgbi5yZXR1cm4gPT0gbnVsbCB8fCBuLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkQ2hpbGRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByIGluc3RhbmNlb2YgbS5kZWZhdWx0LlhNTCAmJiB0aGlzLkRPTS5hcHBlbmRDaGlsZChyLkRPTSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlQ2hpbGRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgcyA9IC0xO1xuICAgICAgICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHRoaXMuRE9NLmNoaWxkcmVuLmxlbmd0aDsgbysrKVxuICAgICAgICAgICAgICBpZiAodGhpcy5ET00uY2hpbGRyZW5bb10udGFnTmFtZSA9PT0gcikge1xuICAgICAgICAgICAgICAgIHMgPSBvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBzID0gcjtcbiAgICAgICAgICBzICE9PSAtMSAmJiB0aGlzLkRPTS5yZW1vdmVDaGlsZCh0aGlzLkRPTS5jaGlsZHJlbltzXSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0QXR0cmlidXRlQ291bnRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLkRPTS5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJsaXN0QXR0cmlidXRlc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHIgPSBbXSwgcyA9ICEwLCBvID0gITEsIGkgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGwsIG4gPSB0aGlzLkRPTS5hdHRyaWJ1dGVzW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShzID0gKGwgPSBuLm5leHQoKSkuZG9uZSk7IHMgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IGwudmFsdWU7XG4gICAgICAgICAgICAgIHIucHVzaChhLm5vZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgICAgICBvID0gITAsIGkgPSBjO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzIHx8IG4ucmV0dXJuID09IG51bGwgfHwgbi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICAgIHRocm93IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IH0sIHsga2V5OiBcImhhc0F0dHJpYnV0ZVwiLCB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgICAgIHZhciBzID0ge30sIG8gPSAhMCwgaSA9ICExLCBsID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuLCBhID0gdGhpcy5ET00uYXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCk7ICEobyA9IChuID0gYS5uZXh0KCkpLmRvbmUpOyBvID0gITApIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBuLnZhbHVlO1xuICAgICAgICAgICAgICBzW2Mubm9kZU5hbWVdID0gYy5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICAgICAgaSA9ICEwLCBsID0gcDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbyB8fCBhLnJldHVybiA9PSBudWxsIHx8IGEucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gISFzW3JdO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldE51bVwiLCB2YWx1ZTogZnVuY3Rpb24ociwgcykge1xuICAgICAgICAgIHZhciBvID0ge30sIGkgPSAhMCwgbCA9ICExLCBuID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhLCBjID0gdGhpcy5ET00uYXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCk7ICEoaSA9IChhID0gYy5uZXh0KCkpLmRvbmUpOyBpID0gITApIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSBhLnZhbHVlO1xuICAgICAgICAgICAgICBvW3Aubm9kZU5hbWVdID0gcC5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoaikge1xuICAgICAgICAgICAgbCA9ICEwLCBuID0gajtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaSB8fCBjLnJldHVybiA9PSBudWxsIHx8IGMucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgICAgICB0aHJvdyBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTnVtYmVyKG9bcl0pIHx8IHMgfHwgMDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRTdHJpbmdcIiwgdmFsdWU6IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgICAgICB2YXIgbyA9IHt9LCBpID0gITAsIGwgPSAhMSwgbiA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYSwgYyA9IHRoaXMuRE9NLmF0dHJpYnV0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKGkgPSAoYSA9IGMubmV4dCgpKS5kb25lKTsgaSA9ICEwKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gYS52YWx1ZTtcbiAgICAgICAgICAgICAgb1twLm5vZGVOYW1lXSA9IHAubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGopIHtcbiAgICAgICAgICAgIGwgPSAhMCwgbiA9IGo7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGkgfHwgYy5yZXR1cm4gPT0gbnVsbCB8fCBjLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9bcl0gPyBTdHJpbmcob1tyXSkgOiBzIHx8IG51bGw7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0QXR0cmlidXRlXCIsIHZhbHVlOiBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgICAgdGhpcy5ET00uc2V0QXR0cmlidXRlKHIsIHMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldENvbnRlbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMuRE9NLnRleHRDb250ZW50O1xuICAgICAgICAgIHJldHVybiAocyA9IHMucmVwbGFjZSgvXFxzXFxzKy9nLCBcIixcIikpIHx8IHIgfHwgbnVsbDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXRDb250ZW50XCIsIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdGhpcy5ET00uY2hpbGRyZW4ubGVuZ3RoIHx8ICh0aGlzLkRPTS50ZXh0Q29udGVudCA9IHIpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNlcmlhbGl6ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5ET00pO1xuICAgICAgICB9IH1dKSAmJiB5KGcucHJvdG90eXBlLCBmKSwgaDtcbiAgICAgIH0oKSwgdCA9IG0uZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIjogMTc4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiOiAyMDEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMTA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3RcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3RcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIHkodSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGgpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMCwgZiA9IG5ldyBBcnJheShoLmxlbmd0aCk7IGcgPCBoLmxlbmd0aDsgZysrKVxuICAgICAgICAgICAgICBmW2ddID0gaFtnXTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSh1KSB8fCBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaCkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaCk7XG4gICAgICAgIH0odSkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgICAgICB9KCk7XG4gICAgICB9XG4gICAgICBtLmRlZmF1bHQucHJvdG90eXBlLmFicyA9IE1hdGguYWJzLCBtLmRlZmF1bHQucHJvdG90eXBlLmNlaWwgPSBNYXRoLmNlaWwsIG0uZGVmYXVsdC5wcm90b3R5cGUuY29uc3RyYWluID0gZnVuY3Rpb24odSwgaCwgZykge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJjb25zdHJhaW5cIiwgYXJndW1lbnRzKSwgTWF0aC5tYXgoTWF0aC5taW4odSwgZyksIGgpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5kaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSBhcmd1bWVudHMubGVuZ3RoLCBoID0gbmV3IEFycmF5KHUpLCBnID0gMDsgZyA8IHU7IGcrKylcbiAgICAgICAgICBoW2ddID0gYXJndW1lbnRzW2ddO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJkaXN0XCIsIGgpLCBoLmxlbmd0aCA9PT0gNCA/IE1hdGguaHlwb3QoaFsyXSAtIGhbMF0sIGhbM10gLSBoWzFdKSA6IGgubGVuZ3RoID09PSA2ID8gTWF0aC5oeXBvdChoWzNdIC0gaFswXSwgaFs0XSAtIGhbMV0sIGhbNV0gLSBoWzJdKSA6IHZvaWQgMDtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuZXhwID0gTWF0aC5leHAsIG0uZGVmYXVsdC5wcm90b3R5cGUuZmxvb3IgPSBNYXRoLmZsb29yLCBtLmRlZmF1bHQucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImxlcnBcIiwgYXJndW1lbnRzKSwgZyAqIChoIC0gdSkgKyB1O1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5sb2cgPSBNYXRoLmxvZywgbS5kZWZhdWx0LnByb3RvdHlwZS5tYWcgPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcIm1hZ1wiLCBhcmd1bWVudHMpLCBNYXRoLmh5cG90KHUsIGgpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbih1LCBoLCBnLCBmLCByLCBzKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcIm1hcFwiLCBhcmd1bWVudHMpLCB1ID0gKHUgLSBoKSAvIChnIC0gaCkgKiAociAtIGYpICsgZiwgcyA/IGYgPCByID8gdGhpcy5jb25zdHJhaW4odSwgZiwgcikgOiB0aGlzLmNvbnN0cmFpbih1LCByLCBmKSA6IHU7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB1ID0gZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCB5KHIpKTtcbiAgICAgICAgfSwgaCA9IGFyZ3VtZW50cy5sZW5ndGgsIGcgPSBuZXcgQXJyYXkoaCksIGYgPSAwOyBmIDwgaDsgZisrKVxuICAgICAgICAgIGdbZl0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGdbMF0pID8gdShnWzBdKSA6IHUoZyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB1ID0gZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCB5KHIpKTtcbiAgICAgICAgfSwgaCA9IGFyZ3VtZW50cy5sZW5ndGgsIGcgPSBuZXcgQXJyYXkoaCksIGYgPSAwOyBmIDwgaDsgZisrKVxuICAgICAgICAgIGdbZl0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGdbMF0pID8gdShnWzBdKSA6IHUoZyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcIm5vcm1cIiwgYXJndW1lbnRzKSwgdGhpcy5tYXAodSwgaCwgZywgMCwgMSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnBvdyA9IE1hdGgucG93LCBtLmRlZmF1bHQucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24odSwgaCkge1xuICAgICAgICByZXR1cm4gaCA/IChoID0gTWF0aC5wb3coMTAsIGgpLCBNYXRoLnJvdW5kKHUgKiBoKSAvIGgpIDogTWF0aC5yb3VuZCh1KTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc3EgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1ICogdTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc3FydCA9IE1hdGguc3FydCwgbS5kZWZhdWx0LnByb3RvdHlwZS5mcmFjdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJmcmFjdFwiLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgaCwgZyA9IDAsIGYgPSBOdW1iZXIoZik7XG4gICAgICAgIHJldHVybiBpc05hTihmKSB8fCBNYXRoLmFicyhmKSA9PT0gMSAvIDAgPyBmIDogKGYgPCAwICYmIChmID0gLWYsIGcgPSAxKSwgU3RyaW5nKGYpLmluY2x1ZGVzKFwiLlwiKSAmJiAhU3RyaW5nKGYpLmluY2x1ZGVzKFwiZVwiKSA/IChoID0gU3RyaW5nKGYpLCBoID0gKyhcIjBcIiArIGguc2xpY2UoaC5pbmRleE9mKFwiLlwiKSkpLCBNYXRoLmFicyhnIC0gaCkpIDogZiA8IDEgPyBNYXRoLmFicyhnIC0gZikgOiAwKTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCI6IDE2MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3RcIjogMTc1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIjogMTc4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMTE6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24geShoLCBnLCBmKSB7XG4gICAgICAgIHJldHVybiAoeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIH0pKSwgMTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QgOiBmdW5jdGlvbihyLCBzLCBvKSB7XG4gICAgICAgICAgdmFyIGkgPSBbbnVsbF07XG4gICAgICAgICAgcmV0dXJuIGkucHVzaC5hcHBseShpLCBzKSwgcyA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShyLCBpKSkoKSwgbyAmJiB1KHMsIG8ucHJvdG90eXBlKSwgcztcbiAgICAgICAgfSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHUoaCwgZykge1xuICAgICAgICByZXR1cm4gKHUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oZiwgcikge1xuICAgICAgICAgIHJldHVybiBmLl9fcHJvdG9fXyA9IHIsIGY7XG4gICAgICAgIH0pKGgsIGcpO1xuICAgICAgfVxuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVWZWN0b3IgPSBmdW5jdGlvbihoLCBnLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgbS5kZWZhdWx0ID8geShtLmRlZmF1bHQuVmVjdG9yLCBbdGhpcy5fZnJvbVJhZGlhbnMuYmluZCh0aGlzKSwgdGhpcy5fdG9SYWRpYW5zLmJpbmQodGhpcyldLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSkgOiBuZXcgbS5kZWZhdWx0LlZlY3RvcihoLCBnLCBmKTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0XCI6IDE4OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMgfV0sIDMxMjogW2Z1bmN0aW9uKGYsIEgsIEMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgZiA9IChmID0gZihcIi4uL2NvcmUvbWFpblwiKSkgJiYgZi5fX2VzTW9kdWxlID8gZiA6IHsgZGVmYXVsdDogZiB9O1xuICAgICAgZnVuY3Rpb24gbShyKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKHIgKiBNYXRoLlBJKSk7XG4gICAgICB9XG4gICAgICB2YXIgeSwgdSA9IDQwOTUsIGggPSA0LCBnID0gMC41LCBmID0gKGYuZGVmYXVsdC5wcm90b3R5cGUubm9pc2UgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciBzID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwLCBvID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgICAgeSA9IG5ldyBBcnJheSg0MDk2KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOTY7IGkrKylcbiAgICAgICAgICAgIHlbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIHIgPCAwICYmIChyID0gLXIpLCBzIDwgMCAmJiAocyA9IC1zKSwgbyA8IDAgJiYgKG8gPSAtbyk7XG4gICAgICAgIGZvciAodmFyIGwsIG4sIGEgPSBNYXRoLmZsb29yKHIpLCBjID0gTWF0aC5mbG9vcihzKSwgcCA9IE1hdGguZmxvb3IobyksIGogPSByIC0gYSwgVCA9IHMgLSBjLCBfID0gbyAtIHAsIFMgPSAwLCBFID0gMC41LCBBID0gMDsgQSA8IGg7IEErKykge1xuICAgICAgICAgIHZhciB4ID0gYSArIChjIDw8IDQpICsgKHAgPDwgOCksIFAgPSBtKGopLCBNID0gbShUKSwgUiA9IHlbeCAmIHVdO1xuICAgICAgICAgIFIgKz0gUCAqICh5W3ggKyAxICYgdV0gLSBSKSwgbCA9IHlbeCArIDE2ICYgdV0sIFIgKz0gTSAqICgobCArPSBQICogKHlbeCArIDE2ICsgMSAmIHVdIC0gbCkpIC0gUiksIGwgPSB5Wyh4ICs9IDI1NikgJiB1XSwgbCArPSBQICogKHlbeCArIDEgJiB1XSAtIGwpLCBuID0geVt4ICsgMTYgJiB1XSwgbCArPSBNICogKChuICs9IFAgKiAoeVt4ICsgMTYgKyAxICYgdV0gLSBuKSkgLSBsKSwgUyArPSAoUiArPSBtKF8pICogKGwgLSBSKSkgKiBFLCBFICo9IGcsIGEgPDw9IDEsIGMgPDw9IDEsIHAgPDw9IDEsIDEgPD0gKGogKj0gMikgJiYgKGErKywgai0tKSwgMSA8PSAoVCAqPSAyKSAmJiAoYysrLCBULS0pLCAxIDw9IChfICo9IDIpICYmIChwKyssIF8tLSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFM7XG4gICAgICB9LCBmLmRlZmF1bHQucHJvdG90eXBlLm5vaXNlRGV0YWlsID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICAwIDwgciAmJiAoaCA9IHIpLCAwIDwgcyAmJiAoZyA9IHMpO1xuICAgICAgfSwgZi5kZWZhdWx0LnByb3RvdHlwZS5ub2lzZVNlZWQgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIGkgPSA0Mjk0OTY3Mjk2O1xuICAgICAgICB2YXIgcywgbywgaSwgbCA9IHsgc2V0U2VlZDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgIG8gPSBzID0gKGEgPz8gTWF0aC5yYW5kb20oKSAqIGkpID4+PiAwO1xuICAgICAgICB9LCBnZXRTZWVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgcmFuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIChvID0gKDE2NjQ1MjUgKiBvICsgMTAxMzkwNDIyMykgJSBpKSAvIGk7XG4gICAgICAgIH0gfTtcbiAgICAgICAgbC5zZXRTZWVkKHIpLCB5ID0gbmV3IEFycmF5KDQwOTYpO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQwOTY7IG4rKylcbiAgICAgICAgICB5W25dID0gbC5yYW5kKCk7XG4gICAgICB9LCBmLmRlZmF1bHQpO1xuICAgICAgQy5kZWZhdWx0ID0gZjtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCB9XSwgMzEzOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShzKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG87XG4gICAgICAgIH0gOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gICAgICAgIH0pKHMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShzKSB7XG4gICAgICAgIHJldHVybiAoeSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbShvKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKG8pO1xuICAgICAgICB9KShzKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5zaWduXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuaXMtZmluaXRlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN1YlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5ldmVyeVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguc2lnblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLWZpbml0ZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChyID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgci5fX2VzTW9kdWxlID8gciA6IHsgZGVmYXVsdDogciB9LCBoID0gZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocyAmJiBzLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIGlmIChzID09PSBudWxsIHx8IHkocykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IHMgfTtcbiAgICAgICAgdmFyIG8gPSBnKCk7XG4gICAgICAgIGlmIChvICYmIG8uaGFzKHMpKVxuICAgICAgICAgIHJldHVybiBvLmdldChzKTtcbiAgICAgICAgdmFyIGksIGwgPSB7fSwgbiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGkgaW4gcykge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBpKSAmJiAoKGEgPSBuID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzLCBpKSA6IG51bGwpICYmIChhLmdldCB8fCBhLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgaSwgYSkgOiBsW2ldID0gc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGwuZGVmYXVsdCA9IHMsIG8gJiYgby5zZXQocywgbCksIGw7XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sIHMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihzLCBvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsID0gb1tpXTtcbiAgICAgICAgICBsLmVudW1lcmFibGUgPSBsLmVudW1lcmFibGUgfHwgITEsIGwuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBsICYmIChsLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgbC5rZXksIGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQuVmVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzLCBuID0gcztcbiAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIHZhciBhLCBjLCBwID0gdHlwZW9mIChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pID09IFwiZnVuY3Rpb25cIiA/ICh0aGlzLmlzUEluc3QgPSAhMCwgdGhpcy5fZnJvbVJhZGlhbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIHRoaXMuX3RvUmFkaWFucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgYSA9IChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0pIHx8IDAsIGMgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdm9pZCAwIDogYXJndW1lbnRzWzNdKSB8fCAwLCAoYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdm9pZCAwIDogYXJndW1lbnRzWzRdKSB8fCAwKSA6IChhID0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgfHwgMCwgYyA9IChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pIHx8IDAsIChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB2b2lkIDAgOiBhcmd1bWVudHNbMl0pIHx8IDApO1xuICAgICAgICAgIHRoaXMueCA9IGEsIHRoaXMueSA9IGMsIHRoaXMueiA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG8sIGksIGw7XG4gICAgICAgIHJldHVybiBvID0gcywgbCA9IFt7IGtleTogXCJmcm9tQW5nbGVcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgICAgICByZXR1cm4gbmV3IHUuZGVmYXVsdC5WZWN0b3IoYSAqIE1hdGguY29zKG4pLCBhICogTWF0aC5zaW4obiksIDApO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZyb21BbmdsZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKF8sIGopIHtcbiAgICAgICAgICB2YXIgYyA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMSwgcCA9IE1hdGguY29zKGopLCBqID0gTWF0aC5zaW4oaiksIFQgPSBNYXRoLmNvcyhfKSwgXyA9IE1hdGguc2luKF8pO1xuICAgICAgICAgIHJldHVybiBuZXcgdS5kZWZhdWx0LlZlY3RvcihjICogXyAqIGosIC1jICogVCwgYyAqIF8gKiBwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyYW5kb20yRFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFuZ2xlKE1hdGgucmFuZG9tKCkgKiBoLlRXT19QSSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmFuZG9tM0RcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuID0gTWF0aC5yYW5kb20oKSAqIGguVFdPX1BJLCBhID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxLCBwID0gTWF0aC5zcXJ0KDEgLSBhICogYSksIGMgPSBwICogTWF0aC5jb3MobiksIHAgPSBwICogTWF0aC5zaW4obik7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1LmRlZmF1bHQuVmVjdG9yKGMsIHAsIGEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNvcHlcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5jb3B5KG4pO1xuICAgICAgICB9IH0sIHsga2V5OiBcImFkZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgICAgICAgYVtjXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgICB2YXIgcCA9IGFbMF0sIGogPSBhWzFdLCBUID0gYVsyXTtcbiAgICAgICAgICByZXR1cm4gVCA/IFQuc2V0KHApIDogKFQgPSBwLmNvcHkoKSwgYS5sZW5ndGggPT09IDMgJiYgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCBpdCBzaG91bGQgYmUgb2YgdHlwZSBwNS5WZWN0b3JcIiwgXCJwNS5WZWN0b3IuYWRkXCIpKSwgVC5hZGQoaiksIFQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtXCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yICYmIGEgaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIChuID0gbi5jb3B5KCkpLnJlbShhKSwgbjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzdWJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KG4pLCBjID0gMDsgYyA8IG47IGMrKylcbiAgICAgICAgICAgIGFbY10gPSBhcmd1bWVudHNbY107XG4gICAgICAgICAgdmFyIHAgPSBhWzBdLCBqID0gYVsxXSwgVCA9IGFbMl07XG4gICAgICAgICAgcmV0dXJuIFQgPyBULnNldChwKSA6IChUID0gcC5jb3B5KCksIGEubGVuZ3RoID09PSAzICYmIHUuZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIlRoZSB0YXJnZXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgaXQgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLnN1YlwiKSksIFQuc3ViKGopLCBUO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm11bHRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KG4pLCBjID0gMDsgYyA8IG47IGMrKylcbiAgICAgICAgICAgIGFbY10gPSBhcmd1bWVudHNbY107XG4gICAgICAgICAgdmFyIHAgPSBhWzBdLCBqID0gYVsxXSwgVCA9IGFbMl07XG4gICAgICAgICAgcmV0dXJuIFQgPyBULnNldChwKSA6IChUID0gcC5jb3B5KCksIGEubGVuZ3RoID09PSAzICYmIHUuZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIlRoZSB0YXJnZXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgaXQgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLm11bHRcIikpLCBULm11bHQoaiksIFQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicm90YXRlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgYyA9IDA7IGMgPCBuOyBjKyspXG4gICAgICAgICAgICBhW2NdID0gYXJndW1lbnRzW2NdO1xuICAgICAgICAgIHZhciBwID0gYVswXSwgaiA9IGFbMV0sIFQgPSBhWzJdO1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMiA/IFQgPSBwLmNvcHkoKSA6IChUIGluc3RhbmNlb2YgdS5kZWZhdWx0LlZlY3RvciB8fCB1LmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJUaGUgdGFyZ2V0IHBhcmFtZXRlciBzaG91bGQgYmUgb2YgdHlwZSBwNS5WZWN0b3JcIiwgXCJwNS5WZWN0b3Iucm90YXRlXCIpLCBULnNldChwKSksIFQucm90YXRlKGopLCBUO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRpdlwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgICAgICAgYVtjXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgICB2YXIgcCA9IGFbMF0sIGogPSBhWzFdLCBUID0gYVsyXTtcbiAgICAgICAgICByZXR1cm4gVCA/IFQuc2V0KHApIDogKFQgPSBwLmNvcHkoKSwgYS5sZW5ndGggPT09IDMgJiYgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCBpdCBzaG91bGQgYmUgb2YgdHlwZSBwNS5WZWN0b3JcIiwgXCJwNS5WZWN0b3IuZGl2XCIpKSwgVC5kaXYoaiksIFQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZG90XCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIG4uZG90KGEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNyb3NzXCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIG4uY3Jvc3MoYSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZGlzdFwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSkge1xuICAgICAgICAgIHJldHVybiBuLmRpc3QoYSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibGVycFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgICAgICAgYVtjXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgICB2YXIgcCA9IGFbMF0sIGogPSBhWzFdLCBUID0gYVsyXSwgXyA9IGFbM107XG4gICAgICAgICAgcmV0dXJuIF8gPyBfLnNldChwKSA6IChfID0gcC5jb3B5KCksIGEubGVuZ3RoID09PSA0ICYmIHUuZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIlRoZSB0YXJnZXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgaXQgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLmxlcnBcIikpLCBfLmxlcnAoaiwgVCksIF87XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2xlcnBcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KG4pLCBjID0gMDsgYyA8IG47IGMrKylcbiAgICAgICAgICAgIGFbY10gPSBhcmd1bWVudHNbY107XG4gICAgICAgICAgdmFyIHAgPSBhWzBdLCBqID0gYVsxXSwgVCA9IGFbMl0sIF8gPSBhWzNdO1xuICAgICAgICAgIHJldHVybiBfID8gXy5zZXQocCkgOiAoXyA9IHAuY29weSgpLCBhLmxlbmd0aCA9PT0gNCAmJiB1LmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJUaGUgdGFyZ2V0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQsIGl0IHNob3VsZCBiZSBvZiB0eXBlIHA1LlZlY3RvclwiLCBcInA1LlZlY3Rvci5zbGVycFwiKSksIF8uc2xlcnAoaiwgVCksIF87XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWFnXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4ubWFnKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWFnU3FcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5tYWdTcSgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm5vcm1hbGl6ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgICAgICAgYVtjXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgICB2YXIgcCA9IGFbMF0sIGogPSBhWzFdO1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA8IDIgPyBqID0gcC5jb3B5KCkgOiAoaiBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgfHwgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLm5vcm1hbGl6ZVwiKSwgai5zZXQocCkpLCBqLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxpbWl0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgYyA9IDA7IGMgPCBuOyBjKyspXG4gICAgICAgICAgICBhW2NdID0gYXJndW1lbnRzW2NdO1xuICAgICAgICAgIHZhciBwID0gYVswXSwgaiA9IGFbMV0sIFQgPSBhWzJdO1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA8IDMgPyBUID0gcC5jb3B5KCkgOiAoVCBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgfHwgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLmxpbWl0XCIpLCBULnNldChwKSksIFQubGltaXQoaik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0TWFnXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgYyA9IDA7IGMgPCBuOyBjKyspXG4gICAgICAgICAgICBhW2NdID0gYXJndW1lbnRzW2NdO1xuICAgICAgICAgIHZhciBwID0gYVswXSwgaiA9IGFbMV0sIFQgPSBhWzJdO1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA8IDMgPyBUID0gcC5jb3B5KCkgOiAoVCBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgfHwgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLnNldE1hZ1wiKSwgVC5zZXQocCkpLCBULnNldE1hZyhqKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJoZWFkaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uaGVhZGluZygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImFuZ2xlQmV0d2VlblwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSkge1xuICAgICAgICAgIHJldHVybiBuLmFuZ2xlQmV0d2VlbihhKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZWZsZWN0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgYyA9IDA7IGMgPCBuOyBjKyspXG4gICAgICAgICAgICBhW2NdID0gYXJndW1lbnRzW2NdO1xuICAgICAgICAgIHZhciBwID0gYVswXSwgaiA9IGFbMV0sIFQgPSBhWzJdO1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA8IDMgPyBUID0gcC5jb3B5KCkgOiAoVCBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgfHwgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiVGhlIHRhcmdldCBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9mIHR5cGUgcDUuVmVjdG9yXCIsIFwicDUuVmVjdG9yLnJlZmxlY3RcIiksIFQuc2V0KHApKSwgVC5yZWZsZWN0KGopO1xuICAgICAgICB9IH0sIHsga2V5OiBcImFycmF5XCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uYXJyYXkoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlcXVhbHNcIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgPyBjID0gbiA6IEFycmF5LmlzQXJyYXkobikgPyBjID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoKS5zZXQobikgOiB1LmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJUaGUgdjEgcGFyYW1ldGVyIHNob3VsZCBiZSBvZiB0eXBlIEFycmF5IG9yIHA1LlZlY3RvclwiLCBcInA1LlZlY3Rvci5lcXVhbHNcIiksIGMuZXF1YWxzKGEpO1xuICAgICAgICB9IH1dLCAoaSA9IFt7IGtleTogXCJ0b1N0cmluZ1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFwicDUuVmVjdG9yIE9iamVjdCA6IFtcIi5jb25jYXQodGhpcy54LCBcIiwgXCIpLmNvbmNhdCh0aGlzLnksIFwiLCBcIikuY29uY2F0KHRoaXMueiwgXCJdXCIpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSwgYykge1xuICAgICAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgdS5kZWZhdWx0LlZlY3RvciA/ICh0aGlzLnggPSBuLnggfHwgMCwgdGhpcy55ID0gbi55IHx8IDAsIHRoaXMueiA9IG4ueiB8fCAwKSA6IEFycmF5LmlzQXJyYXkobikgPyAodGhpcy54ID0gblswXSB8fCAwLCB0aGlzLnkgPSBuWzFdIHx8IDAsIHRoaXMueiA9IG5bMl0gfHwgMCkgOiAodGhpcy54ID0gbiB8fCAwLCB0aGlzLnkgPSBhIHx8IDAsIHRoaXMueiA9IGMgfHwgMCksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY29weVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNQSW5zdCA/IG5ldyB1LmRlZmF1bHQuVmVjdG9yKHRoaXMuX2Zyb21SYWRpYW5zLCB0aGlzLl90b1JhZGlhbnMsIHRoaXMueCwgdGhpcy55LCB0aGlzLnopIDogbmV3IHUuZGVmYXVsdC5WZWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkXCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIG4gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yID8gKHRoaXMueCArPSBuLnggfHwgMCwgdGhpcy55ICs9IG4ueSB8fCAwLCB0aGlzLnogKz0gbi56IHx8IDApIDogQXJyYXkuaXNBcnJheShuKSA/ICh0aGlzLnggKz0gblswXSB8fCAwLCB0aGlzLnkgKz0gblsxXSB8fCAwLCB0aGlzLnogKz0gblsyXSB8fCAwKSA6ICh0aGlzLnggKz0gbiB8fCAwLCB0aGlzLnkgKz0gYSB8fCAwLCB0aGlzLnogKz0gYyB8fCAwKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJjYWxjdWxhdGVSZW1haW5kZXIyRFwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSkge1xuICAgICAgICAgIHJldHVybiBuICE9PSAwICYmICh0aGlzLnggPSB0aGlzLnggJSBuKSwgYSAhPT0gMCAmJiAodGhpcy55ID0gdGhpcy55ICUgYSksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2FsY3VsYXRlUmVtYWluZGVyM0RcIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEsIGMpIHtcbiAgICAgICAgICByZXR1cm4gbiAhPT0gMCAmJiAodGhpcy54ID0gdGhpcy54ICUgbiksIGEgIT09IDAgJiYgKHRoaXMueSA9IHRoaXMueSAlIGEpLCBjICE9PSAwICYmICh0aGlzLnogPSB0aGlzLnogJSBjKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1cIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KG4pLCBjID0gMDsgYyA8IG47IGMrKylcbiAgICAgICAgICAgIGFbY10gPSBhcmd1bWVudHNbY107XG4gICAgICAgICAgdmFyIHAsIGosIFQsIF8gPSBhWzBdLCBTID0gYVsxXSwgRSA9IGFbMl07XG4gICAgICAgICAgaWYgKF8gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoW18ueCwgXy55LCBfLnpdLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkpXG4gICAgICAgICAgICAgIHJldHVybiBwID0gcGFyc2VGbG9hdChfLngpLCBqID0gcGFyc2VGbG9hdChfLnkpLCBUID0gcGFyc2VGbG9hdChfLnopLCB0aGlzLmNhbGN1bGF0ZVJlbWFpbmRlcjNEKHAsIGosIFQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfKSkge1xuICAgICAgICAgICAgaWYgKF8uZXZlcnkoTnVtYmVyLmlzRmluaXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIF8ubGVuZ3RoID09PSAyID8gdGhpcy5jYWxjdWxhdGVSZW1haW5kZXIyRChfWzBdLCBfWzFdKSA6IF8ubGVuZ3RoID09PSAzID8gdGhpcy5jYWxjdWxhdGVSZW1haW5kZXIzRChfWzBdLCBfWzFdLCBfWzJdKSA6IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKF8pICYmIF8gIT09IDApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnggPSB0aGlzLnggJSBfLCB0aGlzLnkgPSB0aGlzLnkgJSBfLCB0aGlzLnogPSB0aGlzLnogJSBfLCB0aGlzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChhLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJlbWFpbmRlcjJEKF8sIFMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDMgJiYgYS5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlUmVtYWluZGVyM0QoXywgUywgRSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic3ViXCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIG4gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yID8gKHRoaXMueCAtPSBuLnggfHwgMCwgdGhpcy55IC09IG4ueSB8fCAwLCB0aGlzLnogLT0gbi56IHx8IDApIDogQXJyYXkuaXNBcnJheShuKSA/ICh0aGlzLnggLT0gblswXSB8fCAwLCB0aGlzLnkgLT0gblsxXSB8fCAwLCB0aGlzLnogLT0gblsyXSB8fCAwKSA6ICh0aGlzLnggLT0gbiB8fCAwLCB0aGlzLnkgLT0gYSB8fCAwLCB0aGlzLnogLT0gYyB8fCAwKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJtdWx0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgYyA9IDA7IGMgPCBuOyBjKyspXG4gICAgICAgICAgICBhW2NdID0gYXJndW1lbnRzW2NdO1xuICAgICAgICAgIHZhciBwLCBqID0gYVswXSwgVCA9IGFbMV0sIF8gPSBhWzJdO1xuICAgICAgICAgIHJldHVybiBqIGluc3RhbmNlb2YgdS5kZWZhdWx0LlZlY3RvciA/IE51bWJlci5pc0Zpbml0ZShqLngpICYmIE51bWJlci5pc0Zpbml0ZShqLnkpICYmIE51bWJlci5pc0Zpbml0ZShqLnopICYmIHR5cGVvZiBqLnggPT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygai55ID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGoueiA9PSBcIm51bWJlclwiID8gKHRoaXMueCAqPSBqLngsIHRoaXMueSAqPSBqLnksIHRoaXMueiAqPSBqLnopIDogY29uc29sZS53YXJuKFwicDUuVmVjdG9yLnByb3RvdHlwZS5tdWx0OlwiLCBcInggY29udGFpbnMgY29tcG9uZW50cyB0aGF0IGFyZSBlaXRoZXIgdW5kZWZpbmVkIG9yIG5vdCBmaW5pdGUgbnVtYmVyc1wiKSA6IEFycmF5LmlzQXJyYXkoaikgPyBqLmV2ZXJ5KGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoUyk7XG4gICAgICAgICAgfSkgJiYgai5ldmVyeShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIFMgPT0gXCJudW1iZXJcIjtcbiAgICAgICAgICB9KSA/IGoubGVuZ3RoID09PSAxID8gKHRoaXMueCAqPSBqWzBdLCB0aGlzLnkgKj0galswXSwgdGhpcy56ICo9IGpbMF0pIDogai5sZW5ndGggPT09IDIgPyAodGhpcy54ICo9IGpbMF0sIHRoaXMueSAqPSBqWzFdKSA6IGoubGVuZ3RoID09PSAzICYmICh0aGlzLnggKj0galswXSwgdGhpcy55ICo9IGpbMV0sIHRoaXMueiAqPSBqWzJdKSA6IGNvbnNvbGUud2FybihcInA1LlZlY3Rvci5wcm90b3R5cGUubXVsdDpcIiwgXCJ4IGNvbnRhaW5zIGVsZW1lbnRzIHRoYXQgYXJlIGVpdGhlciB1bmRlZmluZWQgb3Igbm90IGZpbml0ZSBudW1iZXJzXCIpIDogKHAgPSBhKS5ldmVyeShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKFMpO1xuICAgICAgICAgIH0pICYmIHAuZXZlcnkoZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBTID09IFwibnVtYmVyXCI7XG4gICAgICAgICAgfSkgPyAoYS5sZW5ndGggPT09IDEgJiYgKHRoaXMueCAqPSBqLCB0aGlzLnkgKj0gaiwgdGhpcy56ICo9IGopLCBhLmxlbmd0aCA9PT0gMiAmJiAodGhpcy54ICo9IGosIHRoaXMueSAqPSBUKSwgYS5sZW5ndGggPT09IDMgJiYgKHRoaXMueCAqPSBqLCB0aGlzLnkgKj0gVCwgdGhpcy56ICo9IF8pKSA6IGNvbnNvbGUud2FybihcInA1LlZlY3Rvci5wcm90b3R5cGUubXVsdDpcIiwgXCJ4LCB5LCBvciB6IGFyZ3VtZW50cyBhcmUgZWl0aGVyIHVuZGVmaW5lZCBvciBub3QgYSBmaW5pdGUgbnVtYmVyXCIpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRpdlwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGMgPSAwOyBjIDwgbjsgYysrKVxuICAgICAgICAgICAgYVtjXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgICB2YXIgcCA9IGFbMF0sIGogPSBhWzFdLCBUID0gYVsyXTtcbiAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IpXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHAueCkgJiYgTnVtYmVyLmlzRmluaXRlKHAueSkgJiYgTnVtYmVyLmlzRmluaXRlKHAueikgJiYgdHlwZW9mIHAueCA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwLnkgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcC56ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFyIF8gPSBwLnogPT09IDAgJiYgdGhpcy56ID09PSAwO1xuICAgICAgICAgICAgICBpZiAocC54ID09PSAwIHx8IHAueSA9PT0gMCB8fCAhXyAmJiBwLnogPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcInA1LlZlY3Rvci5wcm90b3R5cGUuZGl2OlwiLCBcImRpdmlkZSBieSAwXCIpLCB0aGlzO1xuICAgICAgICAgICAgICB0aGlzLnggLz0gcC54LCB0aGlzLnkgLz0gcC55LCBfIHx8ICh0aGlzLnogLz0gcC56KTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwNS5WZWN0b3IucHJvdG90eXBlLmRpdjpcIiwgXCJ4IGNvbnRhaW5zIGNvbXBvbmVudHMgdGhhdCBhcmUgZWl0aGVyIHVuZGVmaW5lZCBvciBub3QgZmluaXRlIG51bWJlcnNcIik7XG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwKSlcbiAgICAgICAgICAgIGlmIChwLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkgJiYgcC5ldmVyeShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgUyA9PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgaWYgKHAuc29tZShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFMgPT09IDA7XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJwNS5WZWN0b3IucHJvdG90eXBlLmRpdjpcIiwgXCJkaXZpZGUgYnkgMFwiKSwgdGhpcztcbiAgICAgICAgICAgICAgcC5sZW5ndGggPT09IDEgPyAodGhpcy54IC89IHBbMF0sIHRoaXMueSAvPSBwWzBdLCB0aGlzLnogLz0gcFswXSkgOiBwLmxlbmd0aCA9PT0gMiA/ICh0aGlzLnggLz0gcFswXSwgdGhpcy55IC89IHBbMV0pIDogcC5sZW5ndGggPT09IDMgJiYgKHRoaXMueCAvPSBwWzBdLCB0aGlzLnkgLz0gcFsxXSwgdGhpcy56IC89IHBbMl0pO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInA1LlZlY3Rvci5wcm90b3R5cGUuZGl2OlwiLCBcInggY29udGFpbnMgY29tcG9uZW50cyB0aGF0IGFyZSBlaXRoZXIgdW5kZWZpbmVkIG9yIG5vdCBmaW5pdGUgbnVtYmVyc1wiKTtcbiAgICAgICAgICBlbHNlIGlmIChhLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkgJiYgYS5ldmVyeShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIFMgPT0gXCJudW1iZXJcIjtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKGEuc29tZShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTID09PSAwO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJwNS5WZWN0b3IucHJvdG90eXBlLmRpdjpcIiwgXCJkaXZpZGUgYnkgMFwiKSwgdGhpcztcbiAgICAgICAgICAgIGEubGVuZ3RoID09PSAxICYmICh0aGlzLnggLz0gcCwgdGhpcy55IC89IHAsIHRoaXMueiAvPSBwKSwgYS5sZW5ndGggPT09IDIgJiYgKHRoaXMueCAvPSBwLCB0aGlzLnkgLz0gaiksIGEubGVuZ3RoID09PSAzICYmICh0aGlzLnggLz0gcCwgdGhpcy55IC89IGosIHRoaXMueiAvPSBUKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInA1LlZlY3Rvci5wcm90b3R5cGUuZGl2OlwiLCBcIngsIHksIG9yIHogYXJndW1lbnRzIGFyZSBlaXRoZXIgdW5kZWZpbmVkIG9yIG5vdCBhIGZpbml0ZSBudW1iZXJcIik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWFnXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubWFnU3EoKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWFnU3FcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy54LCBhID0gdGhpcy55LCBjID0gdGhpcy56O1xuICAgICAgICAgIHJldHVybiBuICogbiArIGEgKiBhICsgYyAqIGM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZG90XCIsIHZhbHVlOiBmdW5jdGlvbihuLCBhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIG4gaW5zdGFuY2VvZiB1LmRlZmF1bHQuVmVjdG9yID8gdGhpcy5kb3Qobi54LCBuLnksIG4ueikgOiB0aGlzLnggKiAobiB8fCAwKSArIHRoaXMueSAqIChhIHx8IDApICsgdGhpcy56ICogKGMgfHwgMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY3Jvc3NcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMueSAqIHAueiAtIHRoaXMueiAqIHAueSwgYyA9IHRoaXMueiAqIHAueCAtIHRoaXMueCAqIHAueiwgcCA9IHRoaXMueCAqIHAueSAtIHRoaXMueSAqIHAueDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1BJbnN0ID8gbmV3IHUuZGVmYXVsdC5WZWN0b3IodGhpcy5fZnJvbVJhZGlhbnMsIHRoaXMuX3RvUmFkaWFucywgYSwgYywgcCkgOiBuZXcgdS5kZWZhdWx0LlZlY3RvcihhLCBjLCBwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkaXN0XCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uY29weSgpLnN1Yih0aGlzKS5tYWcoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJub3JtYWxpemVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5tYWcoKTtcbiAgICAgICAgICByZXR1cm4gbiAhPT0gMCAmJiB0aGlzLm11bHQoMSAvIG4pLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxpbWl0XCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLm1hZ1NxKCk7XG4gICAgICAgICAgcmV0dXJuIG4gKiBuIDwgYSAmJiB0aGlzLmRpdihNYXRoLnNxcnQoYSkpLm11bHQobiksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0TWFnXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdChuKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJoZWFkaW5nXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbiA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzUEluc3QgPyB0aGlzLl9mcm9tUmFkaWFucyhuKSA6IG47XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0SGVhZGluZ1wiLCB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgICAgIHRoaXMuaXNQSW5zdCAmJiAobiA9IHRoaXMuX3RvUmFkaWFucyhuKSk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLm1hZygpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnggPSBhICogTWF0aC5jb3MobiksIHRoaXMueSA9IGEgKiBNYXRoLnNpbihuKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJyb3RhdGVcIiwgdmFsdWU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuaGVhZGluZygpICsgYSwgYyA9ICh0aGlzLmlzUEluc3QgJiYgKGEgPSB0aGlzLl90b1JhZGlhbnMoYSkpLCB0aGlzLm1hZygpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jb3MoYSkgKiBjLCB0aGlzLnkgPSBNYXRoLnNpbihhKSAqIGMsIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYW5nbGVCZXR3ZWVuXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFnU3EoKSAqIG4ubWFnU3EoKSA9PSAwID8gTmFOIDogKGEgPSB0aGlzLmNyb3NzKG4pLCBuID0gTWF0aC5hdGFuMihhLm1hZygpLCB0aGlzLmRvdChuKSkgKiBNYXRoLnNpZ24oYS56IHx8IDEpLCB0aGlzLmlzUEluc3QgPyB0aGlzLl9mcm9tUmFkaWFucyhuKSA6IG4pO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxlcnBcIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEsIGMsIHApIHtcbiAgICAgICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgPyB0aGlzLmxlcnAobi54LCBuLnksIG4ueiwgYSkgOiAodGhpcy54ICs9IChuIC0gdGhpcy54KSAqIHAgfHwgMCwgdGhpcy55ICs9IChhIC0gdGhpcy55KSAqIHAgfHwgMCwgdGhpcy56ICs9IChjIC0gdGhpcy56KSAqIHAgfHwgMCwgdGhpcyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2xlcnBcIiwgdmFsdWU6IGZ1bmN0aW9uKG4sIGEpIHtcbiAgICAgICAgICBpZiAoYSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGEgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChuKTtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5tYWcoKSwgcCA9IG4ubWFnKCk7XG4gICAgICAgICAgICBpZiAoYyAqIHAgPT0gMClcbiAgICAgICAgICAgICAgdGhpcy5tdWx0KDEgLSBhKS5hZGQobi54ICogYSwgbi55ICogYSwgbi56ICogYSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGogPSB0aGlzLmNyb3NzKG4pLCBUID0gai5tYWcoKSwgXyA9IE1hdGguYXRhbjIoVCwgdGhpcy5kb3QobikpO1xuICAgICAgICAgICAgICBpZiAoMCA8IFQpXG4gICAgICAgICAgICAgICAgai54IC89IFQsIGoueSAvPSBULCBqLnogLz0gVDtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF8gPCAwLjUgKiBNYXRoLlBJKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdCgxIC0gYSkuYWRkKG4ueCAqIGEsIG4ueSAqIGEsIG4ueiAqIGEpLCB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMueiA9PT0gMCAmJiBuLnogPT09IDAgPyBqLnNldCgwLCAwLCAxKSA6IHRoaXMueCAhPT0gMCA/IGouc2V0KHRoaXMueSwgLXRoaXMueCwgMCkubm9ybWFsaXplKCkgOiBqLnNldCgxLCAwLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBUID0gai5jcm9zcyh0aGlzKSwgbiA9IDEgLSBhICsgYSAqIHAgLyBjLCBqID0gbiAqIE1hdGguY29zKGEgKiBfKSwgcCA9IG4gKiBNYXRoLnNpbihhICogXyksIHRoaXMueCA9IHRoaXMueCAqIGogKyBULnggKiBwLCB0aGlzLnkgPSB0aGlzLnkgKiBqICsgVC55ICogcCwgdGhpcy56ID0gdGhpcy56ICogaiArIFQueiAqIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlZmxlY3RcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5ub3JtYWxpemUoKSwgdGhpcy5zdWIobi5tdWx0KDIgKiB0aGlzLmRvdChuKSkpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImFycmF5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW3RoaXMueCB8fCAwLCB0aGlzLnkgfHwgMCwgdGhpcy56IHx8IDBdO1xuICAgICAgICB9IH0sIHsga2V5OiBcImVxdWFsc1wiLCB2YWx1ZTogZnVuY3Rpb24oVCwgYSwgYykge1xuICAgICAgICAgIHZhciBwLCBqLCBUID0gVCBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgPyAocCA9IFQueCB8fCAwLCBqID0gVC55IHx8IDAsIFQueiB8fCAwKSA6IEFycmF5LmlzQXJyYXkoVCkgPyAocCA9IFRbMF0gfHwgMCwgaiA9IFRbMV0gfHwgMCwgVFsyXSB8fCAwKSA6IChwID0gVCB8fCAwLCBqID0gYSB8fCAwLCBjIHx8IDApO1xuICAgICAgICAgIHJldHVybiB0aGlzLnggPT09IHAgJiYgdGhpcy55ID09PSBqICYmIHRoaXMueiA9PT0gVDtcbiAgICAgICAgfSB9XSkgJiYgZihvLnByb3RvdHlwZSwgaSksIGwgJiYgZihvLCBsKSwgcztcbiAgICAgIH0oKTtcbiAgICAgIHZhciByID0gdS5kZWZhdWx0LlZlY3RvcjtcbiAgICAgIEMuZGVmYXVsdCA9IHI7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5ldmVyeVwiOiAxNTQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiOiAxNjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguc2lnblwiOiAxNzcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiOiAxNzgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5pcy1maW5pdGVcIjogMTc5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdWJcIjogMjA1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMTQ6IFtmdW5jdGlvbihnLCBILCBDKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IChnID0gZyhcIi4uL2NvcmUvbWFpblwiKSkgJiYgZy5fX2VzTW9kdWxlID8gZyA6IHsgZGVmYXVsdDogZyB9LCB5ID0gXCJfbGNnX3JhbmRvbV9zdGF0ZVwiLCB1ID0gNDI5NDk2NzI5NiwgaCA9IDAsIGcgPSAobS5kZWZhdWx0LnByb3RvdHlwZS5fbGNnID0gZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gdGhpc1tmXSA9ICgxNjY0NTI1ICogdGhpc1tmXSArIDEwMTM5MDQyMjMpICUgdSwgdGhpc1tmXSAvIHU7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLl9sY2dTZXRTZWVkID0gZnVuY3Rpb24oZiwgcikge1xuICAgICAgICB0aGlzW2ZdID0gKHIgPz8gTWF0aC5yYW5kb20oKSAqIHUpID4+PiAwO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5yYW5kb21TZWVkID0gZnVuY3Rpb24oZikge1xuICAgICAgICB0aGlzLl9sY2dTZXRTZWVkKHksIGYpLCB0aGlzLl9nYXVzc2lhbl9wcmV2aW91cyA9ICExO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgIHZhciBzLCBvO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJyYW5kb21cIiwgYXJndW1lbnRzKSwgcyA9IHRoaXNbeV0gIT0gbnVsbCA/IHRoaXMuX2xjZyh5KSA6IE1hdGgucmFuZG9tKCksIGYgPT09IHZvaWQgMCA/IHMgOiByID09PSB2b2lkIDAgPyBBcnJheS5pc0FycmF5KGYpID8gZltNYXRoLmZsb29yKHMgKiBmLmxlbmd0aCldIDogcyAqIGYgOiAociA8IGYgJiYgKG8gPSBmLCBmID0gciwgciA9IG8pLCBzICogKHIgLSBmKSArIGYpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5yYW5kb21HYXVzc2lhbiA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHIsIHMsIG8sIGksIGwgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgIGlmICh0aGlzLl9nYXVzc2lhbl9wcmV2aW91cylcbiAgICAgICAgICByID0gaCwgdGhpcy5fZ2F1c3NpYW5fcHJldmlvdXMgPSAhMTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICg7IDEgPD0gKGkgPSAocyA9IHRoaXMucmFuZG9tKDIpIC0gMSkgKiBzICsgKG8gPSB0aGlzLnJhbmRvbSgyKSAtIDEpICogbyk7IClcbiAgICAgICAgICAgIDtcbiAgICAgICAgICByID0gcyAqIChpID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2coaSkgLyBpKSksIGggPSBvICogaSwgdGhpcy5fZ2F1c3NpYW5fcHJldmlvdXMgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gciAqIGwgKyAoZiB8fCAwKTtcbiAgICAgIH0sIG0uZGVmYXVsdCk7XG4gICAgICBDLmRlZmF1bHQgPSBnO1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwIH1dLCAzMTU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHIpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgcztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBzLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgcztcbiAgICAgICAgfSkocik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHIpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBtKHMpO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0ocyk7XG4gICAgICAgIH0pKHIpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKGYgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiBmLl9fZXNNb2R1bGUgPyBmIDogeyBkZWZhdWx0OiBmIH0sIGggPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmIChyICYmIHIuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgaWYgKHIgPT09IG51bGwgfHwgeShyKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogciB9O1xuICAgICAgICB2YXIgcyA9IGcoKTtcbiAgICAgICAgaWYgKHMgJiYgcy5oYXMocikpXG4gICAgICAgICAgcmV0dXJuIHMuZ2V0KHIpO1xuICAgICAgICB2YXIgbywgaSA9IHt9LCBsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAobyBpbiByKSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG8pICYmICgobiA9IGwgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIG8pIDogbnVsbCkgJiYgKG4uZ2V0IHx8IG4uc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCBuKSA6IGlbb10gPSByW29dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5kZWZhdWx0ID0gciwgcyAmJiBzLnNldChyLCBpKSwgaTtcbiAgICAgIH0odChcIi4uL2NvcmUvY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSwgcik7XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQucHJvdG90eXBlLl9hbmdsZU1vZGUgPSBoLlJBRElBTlMsIHUuZGVmYXVsdC5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21SYWRpYW5zKE1hdGguYWNvcyhyKSk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcm9tUmFkaWFucyhNYXRoLmFzaW4ocikpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJvbVJhZGlhbnMoTWF0aC5hdGFuKHIpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuYXRhbjIgPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcm9tUmFkaWFucyhNYXRoLmF0YW4yKHIsIHMpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuY29zID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gTWF0aC5jb3ModGhpcy5fdG9SYWRpYW5zKHIpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4odGhpcy5fdG9SYWRpYW5zKHIpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gTWF0aC50YW4odGhpcy5fdG9SYWRpYW5zKHIpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZGVncmVlcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgKiBoLlJBRF9UT19ERUc7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnJhZGlhbnMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiByICogaC5ERUdfVE9fUkFEO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5hbmdsZU1vZGUgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmICh1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImFuZ2xlTW9kZVwiLCBhcmd1bWVudHMpLCByID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FuZ2xlTW9kZTtcbiAgICAgICAgciAhPT0gaC5ERUdSRUVTICYmIHIgIT09IGguUkFESUFOUyB8fCByICE9PSB0aGlzLl9hbmdsZU1vZGUgJiYgKHIgPT09IGguUkFESUFOUyA/ICh0aGlzLl9zZXRQcm9wZXJ0eShcInBSb3RhdGlvblhcIiwgdGhpcy5wUm90YXRpb25YICogaC5ERUdfVE9fUkFEKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJwUm90YXRpb25ZXCIsIHRoaXMucFJvdGF0aW9uWSAqIGguREVHX1RPX1JBRCksIHRoaXMuX3NldFByb3BlcnR5KFwicFJvdGF0aW9uWlwiLCB0aGlzLnBSb3RhdGlvblogKiBoLkRFR19UT19SQUQpKSA6ICh0aGlzLl9zZXRQcm9wZXJ0eShcInBSb3RhdGlvblhcIiwgdGhpcy5wUm90YXRpb25YICogaC5SQURfVE9fREVHKSwgdGhpcy5fc2V0UHJvcGVydHkoXCJwUm90YXRpb25ZXCIsIHRoaXMucFJvdGF0aW9uWSAqIGguUkFEX1RPX0RFRyksIHRoaXMuX3NldFByb3BlcnR5KFwicFJvdGF0aW9uWlwiLCB0aGlzLnBSb3RhdGlvblogKiBoLlJBRF9UT19ERUcpKSwgdGhpcy5fYW5nbGVNb2RlID0gcik7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLl90b1JhZGlhbnMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmdsZU1vZGUgPT09IGguREVHUkVFUyA/IHIgKiBoLkRFR19UT19SQUQgOiByO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fdG9EZWdyZWVzID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5nbGVNb2RlID09PSBoLlJBRElBTlMgPyByICogaC5SQURfVE9fREVHIDogcjtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuX2Zyb21SYWRpYW5zID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5nbGVNb2RlID09PSBoLkRFR1JFRVMgPyByICogaC5SQURfVE9fREVHIDogcjtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuX2Zyb21EZWdyZWVzID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5nbGVNb2RlID09PSBoLlJBRElBTlMgPyByICogaC5ERUdfVE9fUkFEIDogcjtcbiAgICAgIH07XG4gICAgICB2YXIgZiA9IHUuZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IGY7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMzE2OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS50ZXh0QWxpZ24gPSBmdW5jdGlvbih5LCB1KSB7XG4gICAgICAgIHZhciBoO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0QWxpZ25cIiwgYXJndW1lbnRzKSwgKGggPSB0aGlzLl9yZW5kZXJlcikudGV4dEFsaWduLmFwcGx5KGgsIGFyZ3VtZW50cyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnRleHRMZWFkaW5nID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwidGV4dExlYWRpbmdcIiwgYXJndW1lbnRzKSwgKHUgPSB0aGlzLl9yZW5kZXJlcikudGV4dExlYWRpbmcuYXBwbHkodSwgYXJndW1lbnRzKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUudGV4dFNpemUgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0U2l6ZVwiLCBhcmd1bWVudHMpLCAodSA9IHRoaXMuX3JlbmRlcmVyKS50ZXh0U2l6ZS5hcHBseSh1LCBhcmd1bWVudHMpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS50ZXh0U3R5bGUgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0U3R5bGVcIiwgYXJndW1lbnRzKSwgKHUgPSB0aGlzLl9yZW5kZXJlcikudGV4dFN0eWxlLmFwcGx5KHUsIGFyZ3VtZW50cyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnRleHRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCwgdSA9IG5ldyBBcnJheSh5KSwgaCA9IDA7IGggPCB5OyBoKyspXG4gICAgICAgICAgdVtoXSA9IGFyZ3VtZW50c1toXTtcbiAgICAgICAgaWYgKHVbMF0gKz0gXCJcIiwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0V2lkdGhcIiwgdSksIHVbMF0ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBmb3IgKHZhciBnID0gdVswXS5yZXBsYWNlKC9cXHQvZywgXCIgIFwiKS5zcGxpdCgvXFxyP1xcbnxcXHJ8XFxuL2cpLCBmID0gW10sIHIgPSAwOyByIDwgZy5sZW5ndGg7IHIrKylcbiAgICAgICAgICBmLnB1c2godGhpcy5fcmVuZGVyZXIudGV4dFdpZHRoKGdbcl0pKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGYpO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS50ZXh0QXNjZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoLCB1ID0gbmV3IEFycmF5KHkpLCBoID0gMDsgaCA8IHk7IGgrKylcbiAgICAgICAgICB1W2hdID0gYXJndW1lbnRzW2hdO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0QXNjZW50XCIsIHUpLCB0aGlzLl9yZW5kZXJlci50ZXh0QXNjZW50KCk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnRleHREZXNjZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoLCB1ID0gbmV3IEFycmF5KHkpLCBoID0gMDsgaCA8IHk7IGgrKylcbiAgICAgICAgICB1W2hdID0gYXJndW1lbnRzW2hdO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0RGVzY2VudFwiLCB1KSwgdGhpcy5fcmVuZGVyZXIudGV4dERlc2NlbnQoKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuX3VwZGF0ZVRleHRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5fdXBkYXRlVGV4dE1ldHJpY3MoKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUudGV4dFdyYXAgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInRleHRXcmFwXCIsIFt5XSksIHRoaXMuX3JlbmRlcmVyLnRleHRXcmFwKHkpO1xuICAgICAgfSwgdCA9IG0uZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiOiAyMDEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiOiAyMDMgfV0sIDMxNzogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBpO1xuICAgICAgICB9KShvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkobykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIG0oaSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgaS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGkgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShpKTtcbiAgICAgICAgfSkobyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5sYXN0LWluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChzID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgcy5fX2VzTW9kdWxlID8gcyA6IHsgZGVmYXVsdDogcyB9LCBoID0gcih0KFwiLi4vY29yZS9jb25zdGFudHNcIikpLCBnID0gcih0KFwib3BlbnR5cGUuanNcIikpO1xuICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9LCBvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIobykge1xuICAgICAgICBpZiAobyAmJiBvLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIGlmIChvID09PSBudWxsIHx8IHkobykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IG8gfTtcbiAgICAgICAgdmFyIGkgPSBmKCk7XG4gICAgICAgIGlmIChpICYmIGkuaGFzKG8pKVxuICAgICAgICAgIHJldHVybiBpLmdldChvKTtcbiAgICAgICAgdmFyIGwsIG4sIGEgPSB7fSwgYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGwgaW4gbylcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgbCkgJiYgKChuID0gYyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgbCkgOiBudWxsKSAmJiAobi5nZXQgfHwgbi5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGwsIG4pIDogYVtsXSA9IG9bbF0pO1xuICAgICAgICByZXR1cm4gYS5kZWZhdWx0ID0gbywgaSAmJiBpLnNldChvLCBhKSwgYTtcbiAgICAgIH1cbiAgICAgIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy92YWxpZGF0ZV9wYXJhbXNcIiksIHQoXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiKSwgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCIpLCB1LmRlZmF1bHQucHJvdG90eXBlLmxvYWRGb250ID0gZnVuY3Rpb24obywgaSwgbCkge1xuICAgICAgICB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImxvYWRGb250XCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBuID0gbmV3IHUuZGVmYXVsdC5Gb250KHRoaXMpLCBhID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGcubG9hZChvLCBmdW5jdGlvbihqLCBUKSB7XG4gICAgICAgICAgaWYgKGopXG4gICAgICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll9mcmllbmRseUZpbGVMb2FkRXJyb3IoNCwgbyksIGwgIT09IHZvaWQgMCA/IGwoaikgOiB2b2lkIGNvbnNvbGUuZXJyb3Ioaiwgbyk7XG4gICAgICAgICAgbi5mb250ID0gVCwgaSAhPT0gdm9pZCAwICYmIGkobiksIGEuX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgICAgICB2YXIgaiA9IG8uc3BsaXQoXCJcXFxcXCIpLnBvcCgpLnNwbGl0KFwiL1wiKS5wb3AoKSwgVCA9IGoubGFzdEluZGV4T2YoXCIuXCIpLCBfID0gVCA8IDEgPyBudWxsIDogai5zbGljZShUICsgMSk7XG4gICAgICAgICAgW1widHRmXCIsIFwib3RmXCIsIFwid29mZlwiLCBcIndvZmYyXCJdLmluY2x1ZGVzKF8pICYmIChfID0gai5zbGljZSgwLCBUICE9PSAtMSA/IFQgOiAwKSwgKGogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIikpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBcbkBmb250LWZhY2Uge1xuZm9udC1mYW1pbHk6IGAuY29uY2F0KF8sIGA7XG5zcmM6IHVybChgKS5jb25jYXQobywgYCk7XG59XG5gKSkpLCBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGopKTtcbiAgICAgICAgfSksIG47XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihvLCBpLCBsLCBuLCBhKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0ZXh0XCIsIGFyZ3VtZW50cyksIHRoaXMuX3JlbmRlcmVyLl9kb0ZpbGwgfHwgdGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlID8gKGMgPSB0aGlzLl9yZW5kZXJlcikudGV4dC5hcHBseShjLCBhcmd1bWVudHMpIDogdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUudGV4dEZvbnQgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgICAgIGlmICh1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInRleHRGb250XCIsIGFyZ3VtZW50cyksIGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5fc2V0UHJvcGVydHkoXCJfdGV4dEZvbnRcIiwgbyksIGkgJiYgKHRoaXMuX3JlbmRlcmVyLl9zZXRQcm9wZXJ0eShcIl90ZXh0U2l6ZVwiLCBpKSwgdGhpcy5fcmVuZGVyZXIuX2xlYWRpbmdTZXQgfHwgdGhpcy5fcmVuZGVyZXIuX3NldFByb3BlcnR5KFwiX3RleHRMZWFkaW5nXCIsIGkgKiBoLl9ERUZBVUxUX0xFQURNVUxUKSksIHRoaXMuX3JlbmRlcmVyLl9hcHBseVRleHRQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibnVsbCBmb250IHBhc3NlZCB0byB0ZXh0Rm9udFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX3RleHRGb250O1xuICAgICAgfTtcbiAgICAgIHZhciBzID0gdS5kZWZhdWx0O1xuICAgICAgQy5kZWZhdWx0ID0gcztcbiAgICB9LCB7IFwiLi4vY29yZS9jb25zdGFudHNcIjogMjY5LCBcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCI6IDI3MSwgXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiOiAyNzIsIFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvdmFsaWRhdGVfcGFyYW1zXCI6IDI3NSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiOiAxNjIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubGFzdC1pbmRleC1vZlwiOiAxNjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiOiAxOTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiOiAyMDMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMsIFwib3BlbnR5cGUuanNcIjogMjU0IH1dLCAzMTg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKFMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgRTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgICByZXR1cm4gRSAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBFLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgRSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgRTtcbiAgICAgICAgfSkoUyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB5ID0gKHkgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB5Ll9fZXNNb2R1bGUgPyB5IDogeyBkZWZhdWx0OiB5IH0sIHUgPSBmdW5jdGlvbihTKSB7XG4gICAgICAgIGlmIChTICYmIFMuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgaWYgKFMgPT09IG51bGwgfHwgZyhTKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogUyB9O1xuICAgICAgICB2YXIgRSA9IGgoKTtcbiAgICAgICAgaWYgKEUgJiYgRS5oYXMoUykpXG4gICAgICAgICAgcmV0dXJuIEUuZ2V0KFMpO1xuICAgICAgICB2YXIgQSwgeCA9IHt9LCBQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAoQSBpbiBTKSB7XG4gICAgICAgICAgdmFyIE07XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFMsIEEpICYmICgoTSA9IFAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFMsIEEpIDogbnVsbCkgJiYgKE0uZ2V0IHx8IE0uc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LCBBLCBNKSA6IHhbQV0gPSBTW0FdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geC5kZWZhdWx0ID0gUywgRSAmJiBFLnNldChTLCB4KSwgeDtcbiAgICAgIH0odChcIi4uL2NvcmUvY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHZhciBTO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfSwgUyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKFMpIHtcbiAgICAgICAgcmV0dXJuIChnID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHJldHVybiBtKEUpO1xuICAgICAgICB9IDogZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHJldHVybiBFICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIEUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBFICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0oRSk7XG4gICAgICAgIH0pKFMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihTLCBFKSB7XG4gICAgICAgIGZvciAodmFyIEEgPSAwOyBBIDwgRS5sZW5ndGg7IEErKykge1xuICAgICAgICAgIHZhciB4ID0gRVtBXTtcbiAgICAgICAgICB4LmVudW1lcmFibGUgPSB4LmVudW1lcmFibGUgfHwgITEsIHguY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiB4ICYmICh4LndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoUywgeC5rZXksIHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKFMsIEUpIHtcbiAgICAgICAgdmFyIEEgPSBTLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIFNbRSA8IDAgPyBFICUgQSArIEEgOiBFICUgQV07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKFMsIEUsIEEsIHgpIHtcbiAgICAgICAgdmFyIFAsIE0sIFI7XG4gICAgICAgIHJldHVybiB4ID8gKHMudG1wUG9pbnQxID09PSB2b2lkIDAgJiYgKHMudG1wUG9pbnQxID0gW10sIHMudG1wUG9pbnQyID0gW10pLCBNID0gcy50bXBQb2ludDEsIFIgPSBzLnRtcFBvaW50MiwgTS54ID0gRS54IC0gUy54LCBNLnkgPSBFLnkgLSBTLnksIFIueCA9IEEueCAtIEUueCwgUi55ID0gQS55IC0gRS55LCBQID0gTS54ICogUi54ICsgTS55ICogUi55LCBNID0gTWF0aC5zcXJ0KE0ueCAqIE0ueCArIE0ueSAqIE0ueSksIFIgPSBNYXRoLnNxcnQoUi54ICogUi54ICsgUi55ICogUi55KSwgTWF0aC5hY29zKFAgLyAoTSAqIFIpKSA8IHgpIDogKEVbMF0gLSBTWzBdKSAqIChBWzFdIC0gU1sxXSkgLSAoQVswXSAtIFNbMF0pICogKEVbMV0gLSBTWzFdKSA9PSAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbyhPLCBCLCBELCBZLCBKLCBNLCBSLCBMLCBGKSB7XG4gICAgICAgIHZhciBWID0gMSAtIEYsIFUgPSBNYXRoLnBvdyhWLCAzKSwgVyA9IE1hdGgucG93KFYsIDIpLCBiID0gRiAqIEYsIFggPSBiICogRiwgRyA9IFUgKiBPICsgMyAqIFcgKiBGICogRCArIDMgKiBWICogRiAqIEYgKiBKICsgWCAqIFIsIFUgPSBVICogQiArIDMgKiBXICogRiAqIFkgKyAzICogViAqIEYgKiBGICogTSArIFggKiBMLCBXID0gTyArIDIgKiBGICogKEQgLSBPKSArIGIgKiAoSiAtIDIgKiBEICsgTyksIFggPSBCICsgMiAqIEYgKiAoWSAtIEIpICsgYiAqIChNIC0gMiAqIFkgKyBCKSwgbmUgPSBEICsgMiAqIEYgKiAoSiAtIEQpICsgYiAqIChSIC0gMiAqIEogKyBEKSwgYiA9IFkgKyAyICogRiAqIChNIC0gWSkgKyBiICogKEwgLSAyICogTSArIFkpLCBPID0gViAqIE8gKyBGICogRCwgRCA9IFYgKiBCICsgRiAqIFksIEIgPSBWICogSiArIEYgKiBSLCBZID0gViAqIE0gKyBGICogTCwgSiA9IDkwIC0gMTgwICogTWF0aC5hdGFuMihXIC0gbmUsIFggLSBiKSAvIE1hdGguUEk7XG4gICAgICAgIHJldHVybiAobmUgPCBXIHx8IFggPCBiKSAmJiAoSiArPSAxODApLCB7IHg6IEcsIHk6IFUsIG06IHsgeDogVywgeTogWCB9LCBuOiB7IHg6IG5lLCB5OiBiIH0sIHN0YXJ0OiB7IHg6IE8sIHk6IEQgfSwgZW5kOiB7IHg6IEIsIHk6IFkgfSwgYWxwaGE6IEogfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoUywgRSwgQSwgeCwgUCwgTSwgUiwgTCwgRikge1xuICAgICAgICByZXR1cm4gRiA9PSBudWxsID8gVChTLCBFLCBBLCB4LCBQLCBNLCBSLCBMKSA6IG8oUywgRSwgQSwgeCwgUCwgTSwgUiwgTCwgZnVuY3Rpb24oViwgRywgVSwgVywgWCwgbmUsIGIsIE8sIEQpIHtcbiAgICAgICAgICBpZiAoIShEIDwgMCB8fCBUKFYsIEcsIFUsIFcsIFgsIG5lLCBiLCBPKSA8IEQpKSB7XG4gICAgICAgICAgICB2YXIgQiwgWSA9IDAuNSwgSiA9IDEgLSBZO1xuICAgICAgICAgICAgZm9yIChCID0gVChWLCBHLCBVLCBXLCBYLCBuZSwgYiwgTywgSik7IDAuMDEgPCBNYXRoLmFicyhCIC0gRCk7IClcbiAgICAgICAgICAgICAgQiA9IFQoViwgRywgVSwgVywgWCwgbmUsIGIsIE8sIEogKz0gKEIgPCBEID8gMSA6IC0xKSAqIChZIC89IDIpKTtcbiAgICAgICAgICAgIHJldHVybiBKO1xuICAgICAgICAgIH1cbiAgICAgICAgfShTLCBFLCBBLCB4LCBQLCBNLCBSLCBMLCBGKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKFMsIEUsIEEpIHtcbiAgICAgICAgZm9yICh2YXIgeCwgUCwgTSwgUiwgTCwgRiA9IDAsIFYgPSAwLCBHID0gKFMgPSBmdW5jdGlvbihVLCBXKSB7XG4gICAgICAgICAgZnVuY3Rpb24gWChmZSwgZ2UsIHhlKSB7XG4gICAgICAgICAgICB2YXIgRGUsIE1lO1xuICAgICAgICAgICAgaWYgKCFmZSlcbiAgICAgICAgICAgICAgcmV0dXJuIFtcIkNcIiwgZ2UueCwgZ2UueSwgZ2UueCwgZ2UueSwgZ2UueCwgZ2UueV07XG4gICAgICAgICAgICBzd2l0Y2ggKGZlWzBdIGluIHsgVDogMSwgUTogMSB9IHx8IChnZS5xeCA9IGdlLnF5ID0gbnVsbCksIGZlWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgZ2UuWCA9IGZlWzFdLCBnZS5ZID0gZmVbMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgZmUgPSBbXCJDXCJdLmNvbmNhdChhLmFwcGx5KDAsIFtnZS54LCBnZS55XS5jb25jYXQoZmUuc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgTWUgPSB4ZSA9PT0gXCJDXCIgfHwgeGUgPT09IFwiU1wiID8gKERlID0gMiAqIGdlLnggLSBnZS5ieCwgMiAqIGdlLnkgLSBnZS5ieSkgOiAoRGUgPSBnZS54LCBnZS55KSwgZmUgPSBbXCJDXCIsIERlLCBNZV0uY29uY2F0KGZlLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgICAgICB4ZSA9PT0gXCJRXCIgfHwgeGUgPT09IFwiVFwiID8gKGdlLnF4ID0gMiAqIGdlLnggLSBnZS5xeCwgZ2UucXkgPSAyICogZ2UueSAtIGdlLnF5KSA6IChnZS5xeCA9IGdlLngsIGdlLnF5ID0gZ2UueSksIGZlID0gW1wiQ1wiXS5jb25jYXQoaihnZS54LCBnZS55LCBnZS5xeCwgZ2UucXksIGZlWzFdLCBmZVsyXSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgIGdlLnF4ID0gZmVbMV0sIGdlLnF5ID0gZmVbMl0sIGZlID0gW1wiQ1wiXS5jb25jYXQoaihnZS54LCBnZS55LCBmZVsxXSwgZmVbMl0sIGZlWzNdLCBmZVs0XSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgIGZlID0gW1wiQ1wiXS5jb25jYXQocChnZS54LCBnZS55LCBmZVsxXSwgZmVbMl0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICBmZSA9IFtcIkNcIl0uY29uY2F0KHAoZ2UueCwgZ2UueSwgZmVbMV0sIGdlLnkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICBmZSA9IFtcIkNcIl0uY29uY2F0KHAoZ2UueCwgZ2UueSwgZ2UueCwgZmVbMV0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICBmZSA9IFtcIkNcIl0uY29uY2F0KHAoZ2UueCwgZ2UueSwgZ2UuWCwgZ2UuWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBuZShmZSwgZ2UpIHtcbiAgICAgICAgICAgIGlmICg3IDwgZmVbZ2VdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBmZVtnZV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgeGUgPSBmZVtnZV07IHhlLmxlbmd0aDsgKVxuICAgICAgICAgICAgICAgIHRlW2dlXSA9IFwiQVwiLCBCICYmIChjZVtnZV0gPSBcIkFcIiksIGZlLnNwbGljZShnZSsrLCAwLCBbXCJDXCJdLmNvbmNhdCh4ZS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgZmUuc3BsaWNlKGdlLCAxKSwgTyA9IE1hdGgubWF4KEQubGVuZ3RoLCBCICYmIEIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBiKGZlLCBnZSwgeGUsIERlLCBNZSkge1xuICAgICAgICAgICAgZmUgJiYgZ2UgJiYgZmVbTWVdWzBdID09PSBcIk1cIiAmJiBnZVtNZV1bMF0gIT09IFwiTVwiICYmIChnZS5zcGxpY2UoTWUsIDAsIFtcIk1cIiwgRGUueCwgRGUueV0pLCB4ZS5ieCA9IDAsIHhlLmJ5ID0gMCwgeGUueCA9IGZlW01lXVsxXSwgeGUueSA9IGZlW01lXVsyXSwgTyA9IE1hdGgubWF4KEQubGVuZ3RoLCBCICYmIEIubGVuZ3RoIHx8IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIE8sIEQgPSBuKFUpLCBCID0gVyAmJiBuKFcpLCBZID0geyB4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbCB9LCBKID0geyB4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbCB9LCB0ZSA9IFtdLCBjZSA9IFtdLCByZSA9IFwiXCIsIHVlID0gXCJcIjtcbiAgICAgICAgICBPID0gTWF0aC5tYXgoRC5sZW5ndGgsIEIgJiYgQi5sZW5ndGggfHwgMCk7XG4gICAgICAgICAgZm9yICh2YXIgbGUgPSAwOyBsZSA8IE87IGxlKyspIHtcbiAgICAgICAgICAgIChyZSA9IERbbGVdID8gRFtsZV1bMF0gOiByZSkgIT09IFwiQ1wiICYmICh0ZVtsZV0gPSByZSwgbGUgJiYgKHVlID0gdGVbbGUgLSAxXSkpLCBEW2xlXSA9IFgoRFtsZV0sIFksIHVlKSwgdGVbbGVdICE9PSBcIkFcIiAmJiByZSA9PT0gXCJDXCIgJiYgKHRlW2xlXSA9IFwiQ1wiKSwgbmUoRCwgbGUpLCBCICYmICgocmUgPSBCW2xlXSA/IEJbbGVdWzBdIDogcmUpICE9PSBcIkNcIiAmJiAoY2VbbGVdID0gcmUsIGxlICYmICh1ZSA9IGNlW2xlIC0gMV0pKSwgQltsZV0gPSBYKEJbbGVdLCBKLCB1ZSksIGNlW2xlXSAhPT0gXCJBXCIgJiYgcmUgPT09IFwiQ1wiICYmIChjZVtsZV0gPSBcIkNcIiksIG5lKEIsIGxlKSksIGIoRCwgQiwgWSwgSiwgbGUpLCBiKEIsIEQsIEosIFksIGxlKTtcbiAgICAgICAgICAgIHZhciBLID0gRFtsZV0sIGFlID0gQiAmJiBCW2xlXSwgaGUgPSBLLmxlbmd0aCwgX2UgPSBCICYmIGFlLmxlbmd0aDtcbiAgICAgICAgICAgIFkueCA9IEtbaGUgLSAyXSwgWS55ID0gS1toZSAtIDFdLCBZLmJ4ID0gcGFyc2VGbG9hdChLW2hlIC0gNF0pIHx8IFkueCwgWS5ieSA9IHBhcnNlRmxvYXQoS1toZSAtIDNdKSB8fCBZLnksIEouYnggPSBCICYmIChwYXJzZUZsb2F0KGFlW19lIC0gNF0pIHx8IEoueCksIEouYnkgPSBCICYmIChwYXJzZUZsb2F0KGFlW19lIC0gM10pIHx8IEoueSksIEoueCA9IEIgJiYgYWVbX2UgLSAyXSwgSi55ID0gQiAmJiBhZVtfZSAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gQiA/IFtELCBCXSA6IEQ7XG4gICAgICAgIH0oUykpLmxlbmd0aDsgViA8IEc7IFYrKykge1xuICAgICAgICAgIGlmICgoTSA9IFNbVl0pWzBdID09PSBcIk1cIilcbiAgICAgICAgICAgIHggPSArTVsxXSwgUCA9ICtNWzJdO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEUgPCBGICsgKFIgPSBpKHgsIFAsIE1bMV0sIE1bMl0sIE1bM10sIE1bNF0sIE1bNV0sIE1bNl0pKSAmJiAhQSlcbiAgICAgICAgICAgICAgcmV0dXJuIHsgeDogKEwgPSBpKHgsIFAsIE1bMV0sIE1bMl0sIE1bM10sIE1bNF0sIE1bNV0sIE1bNl0sIEUgLSBGKSkueCwgeTogTC55LCBhbHBoYTogTC5hbHBoYSB9O1xuICAgICAgICAgICAgRiArPSBSLCB4ID0gK01bNV0sIFAgPSArTVs2XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMID0gKEwgPSBBID8gRiA6IG8oeCwgUCwgTVswXSwgTVsxXSwgTVsyXSwgTVszXSwgTVs0XSwgTVs1XSwgMSkpLmFscGhhID8geyB4OiBMLngsIHk6IEwueSwgYWxwaGE6IEwuYWxwaGEgfSA6IEw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuKFMpIHtcbiAgICAgICAgdmFyIEUgPSBbXSwgQSA9IDAsIHggPSAwLCBQID0gMCwgTSA9IDAsIFIgPSAwO1xuICAgICAgICBpZiAoUykge1xuICAgICAgICAgIFNbMF1bMF0gPT09IFwiTVwiICYmIChQID0gQSA9ICtTWzBdWzFdLCBNID0geCA9ICtTWzBdWzJdLCBSKyssIEVbMF0gPSBbXCJNXCIsIEEsIHhdKTtcbiAgICAgICAgICBmb3IgKHZhciBMLCBGLCBWID0gUy5sZW5ndGggPT09IDMgJiYgU1swXVswXSA9PT0gXCJNXCIgJiYgU1sxXVswXS50b1VwcGVyQ2FzZSgpID09PSBcIlJcIiAmJiBTWzJdWzBdLnRvVXBwZXJDYXNlKCkgPT09IFwiWlwiLCBHID0gUiwgVSA9IFMubGVuZ3RoOyBHIDwgVTsgRysrKSB7XG4gICAgICAgICAgICBpZiAoRS5wdXNoKEwgPSBbXSksIChGID0gU1tHXSlbMF0gIT09IEZbMF0udG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgc3dpdGNoIChMWzBdID0gRlswXS50b1VwcGVyQ2FzZSgpLCBMWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgIExbMV0gPSBGWzFdLCBMWzJdID0gRlsyXSwgTFszXSA9IEZbM10sIExbNF0gPSBGWzRdLCBMWzVdID0gRls1XSwgTFs2XSA9ICsoRls2XSArIEEpLCBMWzddID0gKyhGWzddICsgeCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgTFsxXSA9ICtGWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICBMWzFdID0gK0ZbMV0gKyBBO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJcIjpcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIFcsIFggPSAyLCBuZSA9IChXID0gW0EsIHhdLmNvbmNhdChGLnNsaWNlKDEpKSkubGVuZ3RoOyBYIDwgbmU7IFgrKylcbiAgICAgICAgICAgICAgICAgICAgV1tYXSA9ICtXW1hdICsgQSwgV1srK1hdID0gK1dbWF0gKyB4O1xuICAgICAgICAgICAgICAgICAgRS5wb3AoKSwgRSA9IEUuY29uY2F0KGMoVywgVikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgIFAgPSArRlsxXSArIEEsIE0gPSArRlsyXSArIHg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDEsIE8gPSBGLmxlbmd0aDsgYiA8IE87IGIrKylcbiAgICAgICAgICAgICAgICAgICAgTFtiXSA9ICtGW2JdICsgKGIgJSAyID8gQSA6IHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChGWzBdID09PSBcIlJcIilcbiAgICAgICAgICAgICAgVyA9IFtBLCB4XS5jb25jYXQoRi5zbGljZSgxKSksIEUucG9wKCksIEUgPSBFLmNvbmNhdChjKFcsIFYpKSwgTCA9IFtcIlJcIl0uY29uY2F0KEYuc2xpY2UoLTIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yICh2YXIgRCA9IDAsIEIgPSBGLmxlbmd0aDsgRCA8IEI7IEQrKylcbiAgICAgICAgICAgICAgICBMW0RdID0gRltEXTtcbiAgICAgICAgICAgIHN3aXRjaCAoTFswXSkge1xuICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgIEEgPSBQLCB4ID0gTTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICBBID0gTFsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICB4ID0gTFsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICBQID0gTFtMLmxlbmd0aCAtIDJdLCBNID0gTFtMLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIEEgPSBMW0wubGVuZ3RoIC0gMl0sIHggPSBMW0wubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYShTLCBFLCBBLCB4LCBCLCB0ZSwgWSwgTCwgRiwgVikge1xuICAgICAgICBmdW5jdGlvbiBHKF9lLCBmZSwgZ2UpIHtcbiAgICAgICAgICByZXR1cm4geyB4OiBfZSAqIE1hdGguY29zKGdlKSAtIGZlICogTWF0aC5zaW4oZ2UpLCB5OiBfZSAqIE1hdGguc2luKGdlKSArIGZlICogTWF0aC5jb3MoZ2UpIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFUsIE8gPSBNYXRoLlBJLCBEID0gMTIwICogTyAvIDE4MCwgVyA9IE8gLyAxODAgKiAoK0IgfHwgMCksIFggPSBbXSwgbmUgPSAoViA/IChsZSA9IFZbMF0sIFUgPSBWWzFdLCByZSA9IFZbMl0sIHVlID0gVlszXSkgOiAoUyA9IChKID0gRyhTLCBFLCAtVykpLngsIEUgPSBKLnksIDEgPCAobmUgPSAoYiA9IChTIC0gKEwgPSAoSiA9IEcoTCwgRiwgLVcpKS54KSkgLyAyKSAqIGIgLyAoQSAqIEEpICsgKEogPSAoRSAtIChGID0gSi55KSkgLyAyKSAqIEogLyAoeCAqIHgpKSAmJiAoQSAqPSBuZSA9IE1hdGguc3FydChuZSksIHggKj0gbmUpLCBuZSA9IEEgKiBBLCBjZSA9IHggKiB4LCByZSA9ICh0ZSA9ICh0ZSA9PT0gWSA/IC0xIDogMSkgKiBNYXRoLnNxcnQoTWF0aC5hYnMoKG5lICogY2UgLSBuZSAqIEogKiBKIC0gY2UgKiBiICogYikgLyAobmUgKiBKICogSiArIGNlICogYiAqIGIpKSkpICogQSAqIEogLyB4ICsgKFMgKyBMKSAvIDIsIHVlID0gdGUgKiAteCAqIGIgLyBBICsgKEUgKyBGKSAvIDIsIGxlID0gTWF0aC5hc2luKCgoRSAtIHVlKSAvIHgpLnRvRml4ZWQoOSkpLCBVID0gTWF0aC5hc2luKCgoRiAtIHVlKSAvIHgpLnRvRml4ZWQoOSkpLCAobGUgPSBTIDwgcmUgPyBPIC0gbGUgOiBsZSkgPCAwICYmIChsZSA9IDIgKiBPICsgbGUpLCAoVSA9IEwgPCByZSA/IE8gLSBVIDogVSkgPCAwICYmIChVID0gMiAqIE8gKyBVKSwgWSAmJiBVIDwgbGUgJiYgKGxlIC09IDIgKiBPKSwgIVkgJiYgbGUgPCBVICYmIChVIC09IDIgKiBPKSksIFUgLSBsZSksIGIgPSAoTWF0aC5hYnMobmUpID4gRCAmJiAoY2UgPSBVLCBKID0gTCwgdGUgPSBGLCBVID0gbGUgKyBEICogKFkgJiYgbGUgPCBVID8gMSA6IC0xKSwgWCA9IGEoTCA9IHJlICsgQSAqIE1hdGguY29zKFUpLCBGID0gdWUgKyB4ICogTWF0aC5zaW4oVSksIEEsIHgsIEIsIDAsIFksIEosIHRlLCBbVSwgY2UsIHJlLCB1ZV0pKSwgbmUgPSBVIC0gbGUsIE1hdGguY29zKGxlKSksIE8gPSBNYXRoLnNpbihsZSksIEQgPSBNYXRoLmNvcyhVKSwgQiA9IE1hdGguc2luKFUpLCBZID0gTWF0aC50YW4obmUgLyA0KSwgSiA9IDQgLyAzICogQSAqIFksIHRlID0gNCAvIDMgKiB4ICogWSwgY2UgPSBbUywgRV0sIHJlID0gW1MgKyBKICogTywgRSAtIHRlICogYl0sIHVlID0gW0wgKyBKICogQiwgRiAtIHRlICogRF0sIGxlID0gW0wsIEZdO1xuICAgICAgICBpZiAocmVbMF0gPSAyICogY2VbMF0gLSByZVswXSwgcmVbMV0gPSAyICogY2VbMV0gLSByZVsxXSwgVilcbiAgICAgICAgICByZXR1cm4gW3JlLCB1ZSwgbGVdLmNvbmNhdChYKTtcbiAgICAgICAgZm9yICh2YXIgSyA9IFtdLCBhZSA9IDAsIGhlID0gKFggPSBbcmUsIHVlLCBsZV0uY29uY2F0KFgpLmpvaW4oKS5zcGxpdChcIixcIikpLmxlbmd0aDsgYWUgPCBoZTsgYWUrKylcbiAgICAgICAgICBLW2FlXSA9IGFlICUgMiA/IEcoWFthZSAtIDFdLCBYW2FlXSwgVykueSA6IEcoWFthZV0sIFhbYWUgKyAxXSwgVykueDtcbiAgICAgICAgcmV0dXJuIEs7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKFMsIEUpIHtcbiAgICAgICAgZm9yICh2YXIgQSA9IFtdLCB4ID0gMCwgUCA9IFMubGVuZ3RoOyB4IDwgUCAtIDIgKiAhRTsgeCArPSAyKSB7XG4gICAgICAgICAgdmFyIE0gPSBbeyB4OiArU1t4IC0gMl0sIHk6ICtTW3ggLSAxXSB9LCB7IHg6ICtTW3hdLCB5OiArU1t4ICsgMV0gfSwgeyB4OiArU1t4ICsgMl0sIHk6ICtTW3ggKyAzXSB9LCB7IHg6ICtTW3ggKyA0XSwgeTogK1NbeCArIDVdIH1dO1xuICAgICAgICAgIEUgPyB4ID8gUCAtIDQgPT09IHggPyBNWzNdID0geyB4OiArU1swXSwgeTogK1NbMV0gfSA6IFAgLSAyID09PSB4ICYmIChNWzJdID0geyB4OiArU1swXSwgeTogK1NbMV0gfSwgTVszXSA9IHsgeDogK1NbMl0sIHk6ICtTWzNdIH0pIDogTVswXSA9IHsgeDogK1NbUCAtIDJdLCB5OiArU1tQIC0gMV0gfSA6IFAgLSA0ID09PSB4ID8gTVszXSA9IE1bMl0gOiB4IHx8IChNWzBdID0geyB4OiArU1t4XSwgeTogK1NbeCArIDFdIH0pLCBBLnB1c2goW1wiQ1wiLCAoLU1bMF0ueCArIDYgKiBNWzFdLnggKyBNWzJdLngpIC8gNiwgKC1NWzBdLnkgKyA2ICogTVsxXS55ICsgTVsyXS55KSAvIDYsIChNWzFdLnggKyA2ICogTVsyXS54IC0gTVszXS54KSAvIDYsIChNWzFdLnkgKyA2ICogTVsyXS55IC0gTVszXS55KSAvIDYsIE1bMl0ueCwgTVsyXS55XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwKFMsIEUsIEEsIHgpIHtcbiAgICAgICAgcmV0dXJuIFtTLCBFLCBBLCB4LCBBLCB4XTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGooUywgRSwgQSwgeCwgUCwgTSkge1xuICAgICAgICByZXR1cm4gWzEgLyAzICogUyArIDIgLyAzICogQSwgMSAvIDMgKiBFICsgMiAvIDMgKiB4LCAxIC8gMyAqIFAgKyAyIC8gMyAqIEEsIDEgLyAzICogTSArIDIgLyAzICogeCwgUCwgTV07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUKFMsIEUsIEEsIHgsIFAsIE0sIFIsIEwsIEYpIHtcbiAgICAgICAgZm9yICh2YXIgViA9IChGID0gMSA8IChGID0gRiA/PyAxKSA/IDEgOiBGIDwgMCA/IDAgOiBGKSAvIDIsIEcgPSBbLTAuMTI1MiwgMC4xMjUyLCAtMC4zNjc4LCAwLjM2NzgsIC0wLjU4NzMsIDAuNTg3MywgLTAuNzY5OSwgMC43Njk5LCAtMC45MDQxLCAwLjkwNDEsIC0wLjk4MTYsIDAuOTgxNl0sIFUgPSAwLCBXID0gWzAuMjQ5MSwgMC4yNDkxLCAwLjIzMzUsIDAuMjMzNSwgMC4yMDMyLCAwLjIwMzIsIDAuMTYwMSwgMC4xNjAxLCAwLjEwNjksIDAuMTA2OSwgMC4wNDcyLCAwLjA0NzJdLCBYID0gMDsgWCA8IDEyOyBYKyspIHtcbiAgICAgICAgICB2YXIgYiA9IFYgKiBHW1hdICsgViwgbmUgPSBfKGIsIFMsIEEsIFAsIFIpLCBiID0gXyhiLCBFLCB4LCBNLCBMKTtcbiAgICAgICAgICBVICs9IFdbWF0gKiBNYXRoLnNxcnQobmUgKiBuZSArIGIgKiBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gViAqIFU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfKFMsIEUsIEEsIHgsIFApIHtcbiAgICAgICAgcmV0dXJuIFMgKiAoUyAqICgtMyAqIEUgKyA5ICogQSAtIDkgKiB4ICsgMyAqIFApICsgNiAqIEUgLSAxMiAqIEEgKyA2ICogeCkgLSAzICogRSArIDMgKiBBO1xuICAgICAgfVxuICAgICAgeS5kZWZhdWx0LkZvbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUyh4KSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHgsIHRoaXMuY2FjaGUgPSB7fSwgdGhpcy5mb250ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBFLCBBO1xuICAgICAgICByZXR1cm4gRSA9IFMsIChBID0gW3sga2V5OiBcInRleHRCb3VuZHNcIiwgdmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgUCA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMCwgTSA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMCwgViA9IDMgPCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzNdIDogdm9pZCAwLCBSID0gNCA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbNF0gOiB2b2lkIDAsIEwgPSBSICYmIFIucmVuZGVyZXIgJiYgUi5yZW5kZXJlci5fcEluc3QgfHwgdGhpcy5wYXJlbnQsIEYgPSBMLl9yZW5kZXJlci5kcmF3aW5nQ29udGV4dCwgViA9IChGLnRleHRBbGlnbiB8fCB1LkxFRlQsIEYudGV4dEJhc2VsaW5lIHx8IHUuQkFTRUxJTkUsIFYgfHwgTC5fcmVuZGVyZXIuX3RleHRTaXplKTtcbiAgICAgICAgICBpZiAoIUopIHtcbiAgICAgICAgICAgIGZvciAodmFyIEcgPSBbXSwgVSA9IFtdLCBXID0gW10sIFggPSAoV1swXSA9IFtdLCBbXSksIG5lID0gdGhpcy5fc2NhbGUoViksIGIgPSBMLl9yZW5kZXJlci50ZXh0TGVhZGluZygpLCBPID0gMCwgRCA9ICh0aGlzLmZvbnQuZm9yRWFjaEdseXBoKHgsIFAsIE0sIFYsIFIsIGZ1bmN0aW9uKHJlLCB1ZSwgbGUsIEspIHtcbiAgICAgICAgICAgICAgdmFyIGFlID0gcmUuZ2V0TWV0cmljcygpO1xuICAgICAgICAgICAgICByZS5pbmRleCA9PT0gMCA/IFdbTyArPSAxXSA9IFtdIDogKFdbT10ucHVzaCh1ZSArIGFlLnhNaW4gKiBuZSksIFdbT10ucHVzaCh1ZSArIGFlLnhNYXggKiBuZSksIFgucHVzaChsZSArIE8gKiBiICsgLWFlLnlNaW4gKiBuZSksIFgucHVzaChsZSArIE8gKiBiICsgLWFlLnlNYXggKiBuZSkpO1xuICAgICAgICAgICAgfSksIDAgPCBXW09dLmxlbmd0aCAmJiAoR1tPXSA9IE1hdGgubWluLmFwcGx5KG51bGwsIFdbT10pLCBVW09dID0gTWF0aC5tYXguYXBwbHkobnVsbCwgV1tPXSkpLCAwKSwgQiA9IDA7IEIgPD0gTzsgQisrKSB7XG4gICAgICAgICAgICAgIEdbQl0gPSBNYXRoLm1pbi5hcHBseShudWxsLCBXW0JdKSwgVVtCXSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIFdbQl0pO1xuICAgICAgICAgICAgICB2YXIgWSA9IFVbQl0gLSBHW0JdO1xuICAgICAgICAgICAgICBEIDwgWSAmJiAoRCA9IFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEYgPSBNYXRoLm1pbi5hcHBseShudWxsLCBHKSwgSiA9IHsgeDogRiwgeTogTSA9IE1hdGgubWluLmFwcGx5KG51bGwsIFgpLCBoOiBNYXRoLm1heC5hcHBseShudWxsLCBYKSAtIE0sIHc6IEQsIGFkdmFuY2U6IEYgLSBQIH0sIFYgPSB0aGlzLl9oYW5kbGVBbGlnbm1lbnQoTC5fcmVuZGVyZXIsIHgsIEoueCwgSi55LCBKLncgKyBKLmFkdmFuY2UpO1xuICAgICAgICAgICAgSi54ID0gVi54LCBKLnkgPSBWLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKO1xuICAgICAgICB9IH0sIHsga2V5OiBcInRleHRUb1BvaW50c1wiLCB2YWx1ZTogZnVuY3Rpb24oeCwgUCwgTSwgUiwgTCkge1xuICAgICAgICAgIHZhciBGID0gUCwgViA9IFtdLCBHID0geC5zcGxpdCgvXFxyP1xcbnxcXHJ8XFxuL2cpO1xuICAgICAgICAgIFIgPSBSIHx8IHRoaXMucGFyZW50Ll9yZW5kZXJlci5fdGV4dFNpemU7XG4gICAgICAgICAgZm9yICh2YXIgVSwgVywgWCwgbmUgPSAwOyBuZSA8IEcubGVuZ3RoOyBuZSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICBQID0gRjtcbiAgICAgICAgICAgIGZvciAodmFyIE8gPSAoTyA9IEdbbmVdKS5yZXBsYWNlKFwiXHRcIiwgXCIgIFwiKSwgRCA9IHRoaXMuX2dldEdseXBocyhPKSwgQiA9IDA7IEIgPCBELmxlbmd0aDsgQisrKSB7XG4gICAgICAgICAgICAgIGlmIChXID0gTywgISgoWCA9IEQpW1UgPSBCXS5uYW1lICYmIFhbVV0ubmFtZSA9PT0gXCJzcGFjZVwiIHx8IFcubGVuZ3RoID09PSBYLmxlbmd0aCAmJiBXW1VdID09PSBcIiBcIikpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgWSA9IGZ1bmN0aW9uKHJlKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ZSwgbGUgPSBbXSwgSyA9IDA7IEsgPCByZS5sZW5ndGg7IEsrKylcbiAgICAgICAgICAgICAgICAgICAgcmVbS10udHlwZSA9PT0gXCJNXCIgJiYgKHVlICYmIGxlLnB1c2godWUpLCB1ZSA9IFtdKSwgdWUucHVzaChmdW5jdGlvbihhZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBoZSA9IFthZS50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWUudHlwZSA9PT0gXCJNXCIgfHwgYWUudHlwZSA9PT0gXCJMXCIgPyBoZS5wdXNoKGFlLngsIGFlLnkpIDogYWUudHlwZSA9PT0gXCJDXCIgPyBoZS5wdXNoKGFlLngxLCBhZS55MSwgYWUueDIsIGFlLnkyLCBhZS54LCBhZS55KSA6IGFlLnR5cGUgPT09IFwiUVwiICYmIGhlLnB1c2goYWUueDEsIGFlLnkxLCBhZS54LCBhZS55KSwgaGU7XG4gICAgICAgICAgICAgICAgICAgIH0ocmVbS10pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsZS5wdXNoKHVlKSwgbGU7XG4gICAgICAgICAgICAgICAgfShEW0JdLmdldFBhdGgoUCwgTSwgUikuY29tbWFuZHMpLCBKID0gMDsgSiA8IFkubGVuZ3RoOyBKKyspXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ZSA9IGZ1bmN0aW9uKHJlLCB1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ZSA9IGZ1bmN0aW9uKGZlLCBnZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChnKGZlKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlID0gZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeGUgaW4gZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZlW3hlXSA9PT0gdm9pZCAwICYmIChmZVt4ZV0gPSBnZVt4ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmZTtcbiAgICAgICAgICAgICAgICAgICAgfSh1ZSwgeyBzYW1wbGVGYWN0b3I6IDAuMSwgc2ltcGxpZnlUaHJlc2hvbGQ6IDAgfSksIGxlID0gbChyZSwgMCwgMSksIEsgPSBsZSAvIChsZSAqIHVlLnNhbXBsZUZhY3RvciksIGFlID0gW10sIGhlID0gMDsgaGUgPCBsZTsgaGUgKz0gSylcbiAgICAgICAgICAgICAgICAgICAgICBhZS5wdXNoKGwocmUsIGhlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1ZS5zaW1wbGlmeVRocmVzaG9sZCAmJiBmdW5jdGlvbihfZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZlID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwLCBnZSA9IDAsIHhlID0gX2UubGVuZ3RoIC0gMTsgMyA8IF9lLmxlbmd0aCAmJiAwIDw9IHhlOyAtLXhlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcyhyKF9lLCB4ZSAtIDEpLCByKF9lLCB4ZSksIHIoX2UsIHhlICsgMSksIGZlKSAmJiAoX2Uuc3BsaWNlKHhlICUgX2UubGVuZ3RoLCAxKSwgZ2UrKyk7XG4gICAgICAgICAgICAgICAgICAgIH0oYWUsIHVlLnNpbXBsaWZ5VGhyZXNob2xkKSwgYWU7XG4gICAgICAgICAgICAgICAgICB9KFlbSl0sIEwpLCBjZSA9IDA7IGNlIDwgdGUubGVuZ3RoOyBjZSsrKVxuICAgICAgICAgICAgICAgICAgICB0ZVtjZV0ueCArPSBiLCBWLnB1c2godGVbY2VdKTtcbiAgICAgICAgICAgICAgYiArPSBEW0JdLmFkdmFuY2VXaWR0aCAqIHRoaXMuX3NjYWxlKFIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTSArPSB0aGlzLnBhcmVudC5fcmVuZGVyZXIuX3RleHRMZWFkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0R2x5cGhzXCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5zdHJpbmdUb0dseXBocyh4KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0UGF0aFwiLCB2YWx1ZTogZnVuY3Rpb24oeCwgRiwgTSwgUikge1xuICAgICAgICAgIHZhciBMID0gKFIgJiYgUi5yZW5kZXJlciAmJiBSLnJlbmRlcmVyLl9wSW5zdCB8fCB0aGlzLnBhcmVudCkuX3JlbmRlcmVyLCBGID0gdGhpcy5faGFuZGxlQWxpZ25tZW50KEwsIHgsIEYsIE0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvbnQuZ2V0UGF0aCh4LCBGLngsIEYueSwgTC5fdGV4dFNpemUsIFIpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRQYXRoRGF0YVwiLCB2YWx1ZTogZnVuY3Rpb24oeCwgUCwgTSwgUikge1xuICAgICAgICAgIHZhciBMID0gMztcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiAyIDwgYXJndW1lbnRzLmxlbmd0aCA/IHggPSB0aGlzLl9nZXRQYXRoKHgsIFAsIE0sIFIpIDogZyhQKSA9PT0gXCJvYmplY3RcIiAmJiAoUiA9IFApLCBSICYmIHR5cGVvZiBSLmRlY2ltYWxzID09IFwibnVtYmVyXCIgJiYgKEwgPSBSLmRlY2ltYWxzKSwgeC50b1BhdGhEYXRhKEwpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRTVkdcIiwgdmFsdWU6IGZ1bmN0aW9uKHgsIFAsIE0sIFIpIHtcbiAgICAgICAgICB2YXIgTCA9IDM7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYgMiA8IGFyZ3VtZW50cy5sZW5ndGggPyB4ID0gdGhpcy5fZ2V0UGF0aCh4LCBQLCBNLCBSKSA6IGcoUCkgPT09IFwib2JqZWN0XCIgJiYgKFIgPSBQKSwgUiAmJiAodHlwZW9mIFIuZGVjaW1hbHMgPT0gXCJudW1iZXJcIiAmJiAoTCA9IFIuZGVjaW1hbHMpLCB0eXBlb2YgUi5zdHJva2VXaWR0aCA9PSBcIm51bWJlclwiICYmICh4LnN0cm9rZVdpZHRoID0gUi5zdHJva2VXaWR0aCksIFIuZmlsbCAhPT0gdm9pZCAwICYmICh4LmZpbGwgPSBSLmZpbGwpLCBSLnN0cm9rZSAhPT0gdm9pZCAwICYmICh4LnN0cm9rZSA9IFIuc3Ryb2tlKSksIHgudG9TVkcoTCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3JlbmRlclBhdGhcIiwgdmFsdWU6IGZ1bmN0aW9uKFYsIFUsIFcsIFIpIHtcbiAgICAgICAgICB2YXIgTCA9IFIgJiYgUi5yZW5kZXJlciB8fCB0aGlzLnBhcmVudC5fcmVuZGVyZXIsIEYgPSBMLmRyYXdpbmdDb250ZXh0LCBWID0gKGcoVikgPT09IFwib2JqZWN0XCIgJiYgVi5jb21tYW5kcyA/IFYgOiB0aGlzLl9nZXRQYXRoKFYsIFUsIFcsIFIpKS5jb21tYW5kcywgRyA9IChGLmJlZ2luUGF0aCgpLCAhMCksIFUgPSAhMSwgVyA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgWCwgbmUgPSBWW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShHID0gKFggPSBuZS5uZXh0KCkpLmRvbmUpOyBHID0gITApIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSBYLnZhbHVlO1xuICAgICAgICAgICAgICBiLnR5cGUgPT09IFwiTVwiID8gRi5tb3ZlVG8oYi54LCBiLnkpIDogYi50eXBlID09PSBcIkxcIiA/IEYubGluZVRvKGIueCwgYi55KSA6IGIudHlwZSA9PT0gXCJDXCIgPyBGLmJlemllckN1cnZlVG8oYi54MSwgYi55MSwgYi54MiwgYi55MiwgYi54LCBiLnkpIDogYi50eXBlID09PSBcIlFcIiA/IEYucXVhZHJhdGljQ3VydmVUbyhiLngxLCBiLnkxLCBiLngsIGIueSkgOiBiLnR5cGUgPT09IFwiWlwiICYmIEYuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoTykge1xuICAgICAgICAgICAgVSA9ICEwLCBXID0gTztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRyB8fCBuZS5yZXR1cm4gPT0gbnVsbCB8fCBuZS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChVKVxuICAgICAgICAgICAgICAgIHRocm93IFc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBMLl9kb1N0cm9rZSAmJiBMLl9zdHJva2VTZXQgJiYgIUwuX2NsaXBwaW5nICYmIEYuc3Ryb2tlKCksIEwuX2RvRmlsbCAmJiAhTC5fY2xpcHBpbmcgJiYgKEwuX2ZpbGxTZXQgfHwgTC5fc2V0RmlsbCh1Ll9ERUZBVUxUX1RFWFRfRklMTCksIEYuZmlsbCgpKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfdGV4dFdpZHRoXCIsIHZhbHVlOiBmdW5jdGlvbih4LCBQKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5nZXRBZHZhbmNlV2lkdGgoeCwgUCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3RleHRBc2NlbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb250LmFzY2VuZGVyICogdGhpcy5fc2NhbGUoeCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3RleHREZXNjZW50XCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLmZvbnQuZGVzY2VuZGVyICogdGhpcy5fc2NhbGUoeCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NjYWxlXCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqICh4IHx8IHRoaXMucGFyZW50Ll9yZW5kZXJlci5fdGV4dFNpemUpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9oYW5kbGVBbGlnbm1lbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKHgsIFAsIE0sIFIsIEwpIHtcbiAgICAgICAgICB2YXIgRiA9IHguX3RleHRTaXplO1xuICAgICAgICAgIHN3aXRjaCAoTCA9PT0gdm9pZCAwICYmIChMID0gdGhpcy5fdGV4dFdpZHRoKFAsIEYpKSwgeC5fdGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlIHUuQ0VOVEVSOlxuICAgICAgICAgICAgICBNIC09IEwgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdS5SSUdIVDpcbiAgICAgICAgICAgICAgTSAtPSBMO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHguX3RleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSB1LlRPUDpcbiAgICAgICAgICAgICAgUiArPSB0aGlzLl90ZXh0QXNjZW50KEYpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdS5DRU5URVI6XG4gICAgICAgICAgICAgIFIgKz0gdGhpcy5fdGV4dEFzY2VudChGKSAvIDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB1LkJPVFRPTTpcbiAgICAgICAgICAgICAgUiAtPSB0aGlzLl90ZXh0RGVzY2VudChGKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgeDogTSwgeTogUiB9O1xuICAgICAgICB9IH1dKSAmJiBmKEUucHJvdG90eXBlLCBBKSwgUztcbiAgICAgIH0oKSwgdCA9IHkuZGVmYXVsdCwgQy5kZWZhdWx0ID0gdDtcbiAgICB9LCB7IFwiLi4vY29yZS9jb25zdGFudHNcIjogMjY5LCBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIjogMTU1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiOiAxNzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWVcIjogMTczLCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWRcIjogMTgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIjogMjAxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMTk6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwLCB0ID0gKHQgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH0sIHQuZGVmYXVsdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgICByZXR1cm4gbS5wdXNoKHkpLCBtO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5hcnJheUNvcHkgPSBmdW5jdGlvbihtLCB5LCB1LCBoLCBnKSB7XG4gICAgICAgIHZhciBmLCByO1xuICAgICAgICBtID0gZyAhPT0gdm9pZCAwID8gKHIgPSBNYXRoLm1pbihnLCBtLmxlbmd0aCksIGYgPSBoLCBtLnNsaWNlKHksIHIgKyB5KSkgOiAociA9IHUgIT09IHZvaWQgMCA/IChyID0gdSwgTWF0aC5taW4ociwgbS5sZW5ndGgpKSA6IG0ubGVuZ3RoLCB1ID0geSwgbS5zbGljZShmID0gMCwgcikpLCBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHUsIFtmLCByXS5jb25jYXQobSkpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbihtLCB5KSB7XG4gICAgICAgIHJldHVybiBtLmNvbmNhdCh5KTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ucmV2ZXJzZSgpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5zaG9ydGVuID0gZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5wb3AoKSwgbTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgICAgZm9yICh2YXIgdSwgaCwgZyA9IEFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcobSksIGYgPSAobSA9IHkgfHwgZyA/IG0gOiBtLnNsaWNlKCkpLmxlbmd0aDsgMSA8IGY7IClcbiAgICAgICAgICB1ID0gdGhpcy5yYW5kb20oMCwgMSkgKiBmIHwgMCwgaCA9IG1bLS1mXSwgbVtmXSA9IG1bdV0sIG1bdV0gPSBoO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKG0sIGgpIHtcbiAgICAgICAgdmFyIHUgPSBoID8gbS5zbGljZSgwLCBNYXRoLm1pbihoLCBtLmxlbmd0aCkpIDogbSwgaCA9IGggPyBtLnNsaWNlKE1hdGgubWluKGgsIG0ubGVuZ3RoKSkgOiBbXTtcbiAgICAgICAgcmV0dXJuICh1ID0gdHlwZW9mIHVbMF0gPT0gXCJzdHJpbmdcIiA/IHUuc29ydCgpIDogdS5zb3J0KGZ1bmN0aW9uKGcsIGYpIHtcbiAgICAgICAgICByZXR1cm4gZyAtIGY7XG4gICAgICAgIH0pKS5jb25jYXQoaCk7XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKG0sIHksIHUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkobSwgW3UsIDBdLmNvbmNhdCh5KSksIG07XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLnN1YnNldCA9IGZ1bmN0aW9uKG0sIHksIHUpIHtcbiAgICAgICAgcmV0dXJuIHUgIT09IHZvaWQgMCA/IG0uc2xpY2UoeSwgeSArIHUpIDogbS5zbGljZSh5LCBtLmxlbmd0aCk7XG4gICAgICB9LCB0ID0gdC5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuY29uc3RydWN0b3JcIjogMTUxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZVwiOiAxNzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3IH1dLCAzMjA6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBlYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGVhdFwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIG0uZGVmYXVsdC5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5IGluc3RhbmNlb2YgQXJyYXkgPyB5Lm1hcChwYXJzZUZsb2F0KSA6IHBhcnNlRmxvYXQoeSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmludCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHUgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDEwO1xuICAgICAgICByZXR1cm4geSA9PT0gMSAvIDAgfHwgeSA9PT0gXCJJbmZpbml0eVwiID8gMSAvIDAgOiB5ID09PSAtMSAvIDAgfHwgeSA9PT0gXCItSW5maW5pdHlcIiA/IC0xIC8gMCA6IHR5cGVvZiB5ID09IFwic3RyaW5nXCIgPyBwYXJzZUludCh5LCB1KSA6IHR5cGVvZiB5ID09IFwibnVtYmVyXCIgPyAwIHwgeSA6IHR5cGVvZiB5ID09IFwiYm9vbGVhblwiID8geSA/IDEgOiAwIDogeSBpbnN0YW5jZW9mIEFycmF5ID8geS5tYXAoZnVuY3Rpb24oaCkge1xuICAgICAgICAgIHJldHVybiBtLmRlZmF1bHQucHJvdG90eXBlLmludChoLCB1KTtcbiAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgaW5zdGFuY2VvZiBBcnJheSA/IHkubWFwKG0uZGVmYXVsdC5wcm90b3R5cGUuc3RyKSA6IFN0cmluZyh5KTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB5ID09IFwibnVtYmVyXCIgPyB5ICE9PSAwIDogdHlwZW9mIHkgPT0gXCJzdHJpbmdcIiA/IHkudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIgOiB0eXBlb2YgeSA9PSBcImJvb2xlYW5cIiA/IHkgOiB5IGluc3RhbmNlb2YgQXJyYXkgPyB5Lm1hcChtLmRlZmF1bHQucHJvdG90eXBlLmJvb2xlYW4pIDogdm9pZCAwO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5ieXRlID0gZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9IG0uZGVmYXVsdC5wcm90b3R5cGUuaW50KHksIDEwKSwgdHlwZW9mIHkgPT0gXCJudW1iZXJcIiA/ICh5ICsgMTI4KSAlIDI1NiAtIDEyOCA6IHkgaW5zdGFuY2VvZiBBcnJheSA/IHkubWFwKG0uZGVmYXVsdC5wcm90b3R5cGUuYnl0ZSkgOiB2b2lkIDA7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmNoYXIgPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHkpID8geSBpbnN0YW5jZW9mIEFycmF5ID8geS5tYXAobS5kZWZhdWx0LnByb3RvdHlwZS5jaGFyKSA6IHR5cGVvZiB5ID09IFwic3RyaW5nXCIgPyBtLmRlZmF1bHQucHJvdG90eXBlLmNoYXIocGFyc2VJbnQoeSwgMTApKSA6IHZvaWQgMCA6IFN0cmluZy5mcm9tQ2hhckNvZGUoeSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnVuY2hhciA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB5ID09IFwic3RyaW5nXCIgJiYgeS5sZW5ndGggPT09IDEgPyB5LmNoYXJDb2RlQXQoMCkgOiB5IGluc3RhbmNlb2YgQXJyYXkgPyB5Lm1hcChtLmRlZmF1bHQucHJvdG90eXBlLnVuY2hhcikgOiB2b2lkIDA7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uKHksIHUpIHtcbiAgICAgICAgaWYgKHUgPSB1ID8/IDgsIHkgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICByZXR1cm4geS5tYXAoZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5wcm90b3R5cGUuaGV4KGcsIHUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoeSA9PT0gMSAvIDAgfHwgeSA9PT0gLTEgLyAwKVxuICAgICAgICAgIHJldHVybiAoeSA9PT0gMSAvIDAgPyBcIkZcIiA6IFwiMFwiKS5yZXBlYXQodSk7XG4gICAgICAgIGlmICh0eXBlb2YgeSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgeSA8IDAgJiYgKHkgPSA0Mjk0OTY3Mjk1ICsgeSArIDEpO1xuICAgICAgICAgIGZvciAodmFyIGggPSBOdW1iZXIoeSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGgubGVuZ3RoIDwgdTsgKVxuICAgICAgICAgICAgaCA9IFwiMFwiLmNvbmNhdChoKTtcbiAgICAgICAgICByZXR1cm4gaCA9IGgubGVuZ3RoID49IHUgPyBoLnN1YnN0cmluZyhoLmxlbmd0aCAtIHUsIGgubGVuZ3RoKSA6IGg7XG4gICAgICAgIH1cbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUudW5oZXggPSBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5IGluc3RhbmNlb2YgQXJyYXkgPyB5Lm1hcChtLmRlZmF1bHQucHJvdG90eXBlLnVuaGV4KSA6IHBhcnNlSW50KFwiMHhcIi5jb25jYXQoeSksIDE2KTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiOiAxNzgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGVhdFwiOiAyMDAgfV0sIDMyMTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlY1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnBhZC1zdGFydFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5wYWQtc3RhcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbSA9IChyID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgci5fX2VzTW9kdWxlID8gciA6IHsgZGVmYXVsdDogciB9O1xuICAgICAgZnVuY3Rpb24geShzLCBvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfShzKSB8fCBmdW5jdGlvbihpLCBsKSB7XG4gICAgICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaSkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSB7XG4gICAgICAgICAgICB2YXIgbiA9IFtdLCBhID0gITAsIGMgPSAhMSwgcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGosIFQgPSBpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShhID0gKGogPSBULm5leHQoKSkuZG9uZSkgJiYgKG4ucHVzaChqLnZhbHVlKSwgIWwgfHwgbi5sZW5ndGggIT09IGwpOyBhID0gITApXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICBjID0gITAsIHAgPSBfO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhIHx8IFQucmV0dXJuID09IG51bGwgfHwgVC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgIHRocm93IHA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfShzLCBvKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdShzLCBvLCBpKSB7XG4gICAgICAgIHZhciBuID0geShzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLCAyKSwgbCA9IG5bMF0sIG4gPSBuWzFdO1xuICAgICAgICByZXR1cm4gaSA9PT0gdm9pZCAwID8gKGwgPSBsLnBhZFN0YXJ0KG8sIFwiMFwiKSwgbiA/IGwgKyBcIi5cIiArIG4gOiBsKSA6IChsID0gKHMgPSB5KHMudG9GaXhlZChpKS50b1N0cmluZygpLnNwbGl0KFwiLlwiKSwgMikpWzBdLCBuID0gc1sxXSwgbCA9IGwucGFkU3RhcnQobywgXCIwXCIpLCBuID09PSB2b2lkIDAgPyBsIDogbCArIFwiLlwiICsgbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoKG4sIG8pIHtcbiAgICAgICAgdmFyIGkgPSAobiA9IG4udG9TdHJpbmcoKSkuaW5kZXhPZihcIi5cIiksIGwgPSBpICE9PSAtMSA/IG4uc3Vic3RyaW5nKGkpIDogXCJcIiwgbiA9IChuID0gaSAhPT0gLTEgPyBuLnN1YnN0cmluZygwLCBpKSA6IG4pLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIsXCIpO1xuICAgICAgICBpZiAobyA9PT0gMClcbiAgICAgICAgICBsID0gXCJcIjtcbiAgICAgICAgZWxzZSBpZiAobyAhPT0gdm9pZCAwKVxuICAgICAgICAgIGlmIChvID4gbC5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gbyAtIChsICs9IGkgPT09IC0xID8gXCIuXCIgOiBcIlwiKS5sZW5ndGggKyAxLCBjID0gMDsgYyA8IGE7IGMrKylcbiAgICAgICAgICAgICAgbCArPSBcIjBcIjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsID0gbC5zdWJzdHJpbmcoMCwgbyArIDEpO1xuICAgICAgICByZXR1cm4gbiArIGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKHMpIHtcbiAgICAgICAgcmV0dXJuIDAgPCBwYXJzZUZsb2F0KHMpID8gXCIrXCIuY29uY2F0KHMudG9TdHJpbmcoKSkgOiBzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKHMpIHtcbiAgICAgICAgcmV0dXJuIDAgPD0gcGFyc2VGbG9hdChzKSA/IFwiIFwiLmNvbmNhdChzLnRvU3RyaW5nKCkpIDogcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL3ZhbGlkYXRlX3BhcmFtc1wiKSwgdChcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2ZpbGVfZXJyb3JzXCIpLCB0KFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvZmVzX2NvcmVcIiksIG0uZGVmYXVsdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiam9pblwiLCBhcmd1bWVudHMpLCBzLmpvaW4obyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJtYXRjaFwiLCBhcmd1bWVudHMpLCBzLm1hdGNoKG8pO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5tYXRjaEFsbCA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJtYXRjaEFsbFwiLCBhcmd1bWVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gbmV3IFJlZ0V4cChvLCBcImdcIiksIGwgPSBpLmV4ZWMocyksIG4gPSBbXTsgbCAhPT0gbnVsbDsgKVxuICAgICAgICAgIG4ucHVzaChsKSwgbCA9IGkuZXhlYyhzKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm5mID0gZnVuY3Rpb24ocywgbywgaSkge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJuZlwiLCBhcmd1bWVudHMpLCBzIGluc3RhbmNlb2YgQXJyYXkgPyBzLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgICAgcmV0dXJuIHUobCwgbywgaSk7XG4gICAgICAgIH0pIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiID8gcy5sZW5ndGggPT09IDMgPyB0aGlzLm5mKHNbMF0sIHNbMV0sIHNbMl0pIDogcy5sZW5ndGggPT09IDIgPyB0aGlzLm5mKHNbMF0sIHNbMV0pIDogdGhpcy5uZihzWzBdKSA6IHUocywgbywgaSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm5mYyA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwibmZjXCIsIGFyZ3VtZW50cyksIHMgaW5zdGFuY2VvZiBBcnJheSA/IHMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gaChpLCBvKTtcbiAgICAgICAgfSkgOiBoKHMsIG8pO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5uZnAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkocyksIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgICAgIG9baV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwibmZwXCIsIG8pO1xuICAgICAgICB2YXIgbCA9IG0uZGVmYXVsdC5wcm90b3R5cGUubmYuYXBwbHkodGhpcywgbyk7XG4gICAgICAgIHJldHVybiBsIGluc3RhbmNlb2YgQXJyYXkgPyBsLm1hcChnKSA6IGcobCk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm5mcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShzKSwgaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICAgICAgb1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJuZnNcIiwgbyk7XG4gICAgICAgIHZhciBsID0gbS5kZWZhdWx0LnByb3RvdHlwZS5uZi5hcHBseSh0aGlzLCBvKTtcbiAgICAgICAgcmV0dXJuIGwgaW5zdGFuY2VvZiBBcnJheSA/IGwubWFwKGYpIDogZihsKTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgIHJldHVybiBtLmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNwbGl0XCIsIGFyZ3VtZW50cyksIHMuc3BsaXQobyk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnNwbGl0VG9rZW5zID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic3BsaXRUb2tlbnNcIiwgYXJndW1lbnRzKSwgbCA9IG8gIT09IHZvaWQgMCA/IChsID0gL1xcXS9nLmV4ZWMobyA9IG8pLCAoaSA9IC9cXFsvZy5leGVjKG8pKSAmJiBsID8gKG8gPSBvLnNsaWNlKDAsIGwuaW5kZXgpICsgby5zbGljZShsLmluZGV4ICsgMSksIGkgPSAvXFxbL2cuZXhlYyhvKSwgbyA9IG8uc2xpY2UoMCwgaS5pbmRleCkgKyBvLnNsaWNlKGkuaW5kZXggKyAxKSwgbmV3IFJlZ0V4cChcIltcXFxcW1wiLmNvbmNhdChvLCBcIlxcXFxdXVwiKSwgXCJnXCIpKSA6IGwgPyAobyA9IG8uc2xpY2UoMCwgbC5pbmRleCkgKyBvLnNsaWNlKGwuaW5kZXggKyAxKSwgbmV3IFJlZ0V4cChcIltcIi5jb25jYXQobywgXCJcXFxcXV1cIiksIFwiZ1wiKSkgOiBpID8gKG8gPSBvLnNsaWNlKDAsIGkuaW5kZXgpICsgby5zbGljZShpLmluZGV4ICsgMSksIG5ldyBSZWdFeHAoXCJbXCIuY29uY2F0KG8sIFwiXFxcXFtdXCIpLCBcImdcIikpIDogbmV3IFJlZ0V4cChcIltcIi5jb25jYXQobywgXCJdXCIpLCBcImdcIikpIDogL1xccy9nLCBzLnNwbGl0KGwpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0cmltXCIsIGFyZ3VtZW50cyksIHMgaW5zdGFuY2VvZiBBcnJheSA/IHMubWFwKHRoaXMudHJpbSkgOiBzLnRyaW0oKTtcbiAgICAgIH07XG4gICAgICB2YXIgciA9IG0uZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IHI7XG4gICAgfSwgeyBcIi4uL2NvcmUvZnJpZW5kbHlfZXJyb3JzL2Zlc19jb3JlXCI6IDI3MSwgXCIuLi9jb3JlL2ZyaWVuZGx5X2Vycm9ycy9maWxlX2Vycm9yc1wiOiAyNzIsIFwiLi4vY29yZS9mcmllbmRseV9lcnJvcnMvdmFsaWRhdGVfcGFyYW1zXCI6IDI3NSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiOiAxNjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCI6IDE4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3RvclwiOiAxOTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCI6IDE5MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaFwiOiAxOTgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5wYWQtc3RhcnRcIjogMTk5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZVwiOiAyMDEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiOiAyMDMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCI6IDIwNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMyMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9LCB0LmRlZmF1bHQucHJvdG90eXBlLmRheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXREYXRlKCk7XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLmhvdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0SG91cnMoKTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUubWludXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldE1pbnV0ZXMoKTtcbiAgICAgIH0sIHQuZGVmYXVsdC5wcm90b3R5cGUubWlsbGlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taWxsaXNTdGFydCA9PT0gLTEgPyAwIDogd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fbWlsbGlzU3RhcnQ7XG4gICAgICB9LCB0LmRlZmF1bHQucHJvdG90eXBlLm1vbnRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldE1vbnRoKCkgKyAxO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS5zZWNvbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0U2Vjb25kcygpO1xuICAgICAgfSwgdC5kZWZhdWx0LnByb3RvdHlwZS55ZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9LCB0ID0gdC5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwIH1dLCAzMjM6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgICAgICAgfSkocyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHMpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBtKG8pO1xuICAgICAgICB9IDogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBvICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0obyk7XG4gICAgICAgIH0pKHMpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnNpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnNpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKHIgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiByLl9fZXNNb2R1bGUgPyByIDogeyBkZWZhdWx0OiByIH0sIGggPSAodChcIi4vcDUuR2VvbWV0cnlcIiksIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCB5KHMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBzIH07XG4gICAgICAgIHZhciBvID0gZygpO1xuICAgICAgICBpZiAobyAmJiBvLmhhcyhzKSlcbiAgICAgICAgICByZXR1cm4gby5nZXQocyk7XG4gICAgICAgIHZhciBpLCBsID0ge30sIG4gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChpIGluIHMpIHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgaSkgJiYgKChhID0gbiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocywgaSkgOiBudWxsKSAmJiAoYS5nZXQgfHwgYS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGksIGEpIDogbFtpXSA9IHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsLmRlZmF1bHQgPSBzLCBvICYmIG8uc2V0KHMsIGwpLCBsO1xuICAgICAgfSh0KFwiLi4vY29yZS9jb25zdGFudHNcIikpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgcyk7XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQucHJvdG90eXBlLmJlZ2luR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmJlZ2luR2VvbWV0cnkoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuZW5kR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmVuZEdlb21ldHJ5KCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmJ1aWxkR2VvbWV0cnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5idWlsZEdlb21ldHJ5KHMpO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5mcmVlR2VvbWV0cnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9mcmVlQnVmZmVycyhzLmdpZCk7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnBsYW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzLCBvID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiA1MCwgaSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogbywgbCA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMSwgbiA9IDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1szXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzNdIDogMSwgYSA9ICh0aGlzLl9hc3NlcnQzZChcInBsYW5lXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInBsYW5lXCIsIGFyZ3VtZW50cyksIFwicGxhbmV8XCIuY29uY2F0KGwsIFwifFwiKS5jb25jYXQobikpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2VvbWV0cnlJbkhhc2goYSkgfHwgKChzID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShsLCBuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBjLCBwLCBqID0gMDsgaiA8PSB0aGlzLmRldGFpbFk7IGorKylcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSBqIC8gdGhpcy5kZXRhaWxZLCBfID0gMDsgXyA8PSB0aGlzLmRldGFpbFg7IF8rKylcbiAgICAgICAgICAgICAgYyA9IF8gLyB0aGlzLmRldGFpbFgsIHAgPSBuZXcgdS5kZWZhdWx0LlZlY3RvcihjIC0gMC41LCBUIC0gMC41LCAwKSwgdGhpcy52ZXJ0aWNlcy5wdXNoKHApLCB0aGlzLnV2cy5wdXNoKGMsIFQpO1xuICAgICAgICB9KSkuY29tcHV0ZUZhY2VzKCkuY29tcHV0ZU5vcm1hbHMoKSwgbCA8PSAxICYmIG4gPD0gMSA/IHMuX21ha2VUcmlhbmdsZUVkZ2VzKCkuX2VkZ2VzVG9WZXJ0aWNlcygpIDogdGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlICYmIGNvbnNvbGUubG9nKFwiQ2Fubm90IGRyYXcgc3Ryb2tlIG9uIHBsYW5lIG9iamVjdHMgd2l0aCBtb3JlIHRoYW4gMSBkZXRhaWxYIG9yIDEgZGV0YWlsWVwiKSwgdGhpcy5fcmVuZGVyZXIuY3JlYXRlQnVmZmVycyhhLCBzKSksIHRoaXMuX3JlbmRlcmVyLmRyYXdCdWZmZXJzU2NhbGVkKGEsIG8sIGksIDEpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbihzLCBvLCBpLCBsLCBuKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwiYm94XCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImJveFwiLCBhcmd1bWVudHMpLCBzID09PSB2b2lkIDAgJiYgKHMgPSA1MCksIG8gPT09IHZvaWQgMCAmJiAobyA9IHMpLCBpID09PSB2b2lkIDAgJiYgKGkgPSBvKTtcbiAgICAgICAgdmFyIGEsIGMgPSB0aGlzLl9yZW5kZXJlci5hdHRyaWJ1dGVzICYmIHRoaXMuX3JlbmRlcmVyLmF0dHJpYnV0ZXMucGVyUGl4ZWxMaWdodGluZywgYyA9IChuID09PSB2b2lkIDAgJiYgKG4gPSBjID8gMSA6IDQpLCBcImJveHxcIi5jb25jYXQobCA9IGwgPT09IHZvaWQgMCA/IGMgPyAxIDogNCA6IGwsIFwifFwiKS5jb25jYXQobikpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2VvbWV0cnlJbkhhc2goYykgfHwgKChhID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShsLCBuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5lZGdlcyA9IFtbMCwgMV0sIFsxLCAzXSwgWzMsIDJdLCBbNiwgN10sIFs4LCA5XSwgWzksIDExXSwgWzE0LCAxNV0sIFsxNiwgMTddLCBbMTcsIDE5XSwgWzE4LCAxOV0sIFsyMCwgMjFdLCBbMjIsIDIzXV0sIFtbMCwgNCwgMiwgNl0sIFsxLCAzLCA1LCA3XSwgWzAsIDEsIDQsIDVdLCBbMiwgNiwgMywgN10sIFswLCAyLCAxLCAzXSwgWzQsIDUsIDYsIDddXS5mb3JFYWNoKGZ1bmN0aW9uKGosIFQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSA0ICogVCwgXyA9IDA7IF8gPCA0OyBfKyspIHtcbiAgICAgICAgICAgICAgdmFyIFMgPSBqW19dLCBTID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoKDIgKiAoMSAmIFMpIC0gMSkgLyAyLCAoKDIgJiBTKSAtIDEpIC8gMiwgKCg0ICYgUykgLyAyIC0gMSkgLyAyKTtcbiAgICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKFMpLCBwLnV2cy5wdXNoKDEgJiBfLCAoMiAmIF8pIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmZhY2VzLnB1c2goW1QsIDEgKyBULCAyICsgVF0pLCBwLmZhY2VzLnB1c2goWzIgKyBULCAxICsgVCwgMyArIFRdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLmNvbXB1dGVOb3JtYWxzKCksIGwgPD0gNCAmJiBuIDw9IDQgPyBhLl9lZGdlc1RvVmVydGljZXMoKSA6IHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSAmJiBjb25zb2xlLmxvZyhcIkNhbm5vdCBkcmF3IHN0cm9rZSBvbiBib3ggb2JqZWN0cyB3aXRoIG1vcmUgdGhhbiA0IGRldGFpbFggb3IgNCBkZXRhaWxZXCIpLCB0aGlzLl9yZW5kZXJlci5jcmVhdGVCdWZmZXJzKGMsIGEpKSwgdGhpcy5fcmVuZGVyZXIuZHJhd0J1ZmZlcnNTY2FsZWQoYywgcywgbywgaSksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnNwaGVyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogNTAsIG8gPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDI0LCBpID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAxNjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwic3BoZXJlXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNwaGVyZVwiLCBhcmd1bWVudHMpLCB0aGlzLmVsbGlwc29pZChzLCBzLCBzLCBvLCBpKSwgdGhpcztcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBmKHMsIG8sIGksIGwsIG4sIGEsIGMpIHtcbiAgICAgICAgcyA9IHMgPD0gMCA/IDEgOiBzLCBvID0gbyA8IDAgPyAwIDogbywgaSA9IGkgPD0gMCA/IHMgOiBpLCBsID0gbCA8IDMgPyAzIDogbDtcbiAgICAgICAgZm9yICh2YXIgcCwgaiwgVCA9IChhID0gYSA9PT0gdm9pZCAwIHx8IGEpID8gLTIgOiAwLCBfID0gKG4gPSBuIDwgMSA/IDEgOiBuKSArICgoYyA9IGMgPT09IHZvaWQgMCA/IG8gIT09IDAgOiBjKSA/IDIgOiAwKSwgUyA9IE1hdGguYXRhbjIocyAtIG8sIGkpLCBFID0gTWF0aC5zaW4oUyksIEEgPSBNYXRoLmNvcyhTKSwgeCA9IFQ7IHggPD0gXzsgKyt4KSB7XG4gICAgICAgICAgdmFyIFAgPSB4IC8gbiwgTSA9IGkgKiBQLCBSID0gdm9pZCAwLCBSID0geCA8IDAgPyAoUCA9IE0gPSAwLCBzKSA6IG4gPCB4ID8gKE0gPSBpLCBQID0gMSwgbykgOiBzICsgKG8gLSBzKSAqIFA7XG4gICAgICAgICAgZm9yICh4ICE9PSAtMiAmJiB4ICE9PSBuICsgMiB8fCAoUiA9IDApLCBNIC09IGkgLyAyLCBwID0gMDsgcCA8IGw7ICsrcCkge1xuICAgICAgICAgICAgdmFyIEwgPSBwIC8gKGwgLSAxKSwgViA9IDIgKiBNYXRoLlBJICogTCwgRiA9IE1hdGguc2luKFYpLCBWID0gTWF0aC5jb3MoViksIEcgPSAodGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyB1LmRlZmF1bHQuVmVjdG9yKEYgKiBSLCBNLCBWICogUikpLCB2b2lkIDApLCBHID0geCA8IDAgPyBuZXcgdS5kZWZhdWx0LlZlY3RvcigwLCAtMSwgMCkgOiBuIDwgeCAmJiBvID8gbmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMSwgMCkgOiBuZXcgdS5kZWZhdWx0LlZlY3RvcihGICogQSwgRSwgViAqIEEpO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzLnB1c2goRyksIHRoaXMudXZzLnB1c2goTCwgUCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBVID0gMDtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgKytqKVxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKFtVICsgaiwgVSArIGwgKyAoaiArIDEpICUgbCwgVSArIGwgKyBqXSk7XG4gICAgICAgICAgVSArPSAyICogbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyB4IDwgbjsgKyt4KSB7XG4gICAgICAgICAgZm9yIChwID0gMDsgcCA8IGw7ICsrcCkge1xuICAgICAgICAgICAgdmFyIFcgPSAocCArIDEpICUgbDtcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChbVSArIHAsIFUgKyBXLCBVICsgbCArIFddKSwgdGhpcy5mYWNlcy5wdXNoKFtVICsgcCwgVSArIGwgKyBXLCBVICsgbCArIHBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVSArPSBsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIGZvciAoVSArPSBsLCBwID0gMDsgcCA8IGw7ICsrcClcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChbVSArIHAsIFUgKyAocCArIDEpICUgbCwgVSArIGxdKTtcbiAgICAgIH1cbiAgICAgIHUuZGVmYXVsdC5wcm90b3R5cGUuY3lsaW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMsIG8gPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IDUwLCBpID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBvLCBsID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAyNCwgbiA9IDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1szXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzNdIDogMSwgYSA9ICEoNCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1s0XSwgYyA9ICEoNSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzVdICE9PSB2b2lkIDApIHx8IGFyZ3VtZW50c1s1XSwgcCA9ICh0aGlzLl9hc3NlcnQzZChcImN5bGluZGVyXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImN5bGluZGVyXCIsIGFyZ3VtZW50cyksIFwiY3lsaW5kZXJ8XCIuY29uY2F0KGwsIFwifFwiKS5jb25jYXQobiwgXCJ8XCIpLmNvbmNhdChhLCBcInxcIikuY29uY2F0KGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmdlb21ldHJ5SW5IYXNoKHApIHx8IChzID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShsLCBuKSwgZi5jYWxsKHMsIDEsIDEsIDEsIGwsIG4sIGEsIGMpLCBsIDw9IDI0ICYmIG4gPD0gMTYgPyBzLl9tYWtlVHJpYW5nbGVFZGdlcygpLl9lZGdlc1RvVmVydGljZXMoKSA6IHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSAmJiBjb25zb2xlLmxvZyhcIkNhbm5vdCBkcmF3IHN0cm9rZSBvbiBjeWxpbmRlciBvYmplY3RzIHdpdGggbW9yZSB0aGFuIDI0IGRldGFpbFggb3IgMTYgZGV0YWlsWVwiKSwgdGhpcy5fcmVuZGVyZXIuY3JlYXRlQnVmZmVycyhwLCBzKSksIHRoaXMuX3JlbmRlcmVyLmRyYXdCdWZmZXJzU2NhbGVkKHAsIG8sIGksIG8pLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS5jb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzLCBvID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiA1MCwgaSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogbywgbCA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMjQsIG4gPSAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IDEsIGEgPSAhKDQgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1s0XSAhPT0gdm9pZCAwKSB8fCBhcmd1bWVudHNbNF0sIGMgPSAodGhpcy5fYXNzZXJ0M2QoXCJjb25lXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNvbmVcIiwgYXJndW1lbnRzKSwgXCJjb25lfFwiLmNvbmNhdChsLCBcInxcIikuY29uY2F0KG4sIFwifFwiKS5jb25jYXQoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2VvbWV0cnlJbkhhc2goYykgfHwgKHMgPSBuZXcgdS5kZWZhdWx0Lkdlb21ldHJ5KGwsIG4pLCBmLmNhbGwocywgMSwgMCwgMSwgbCwgbiwgYSwgITEpLCBsIDw9IDI0ICYmIG4gPD0gMTYgPyBzLl9tYWtlVHJpYW5nbGVFZGdlcygpLl9lZGdlc1RvVmVydGljZXMoKSA6IHRoaXMuX3JlbmRlcmVyLl9kb1N0cm9rZSAmJiBjb25zb2xlLmxvZyhcIkNhbm5vdCBkcmF3IHN0cm9rZSBvbiBjb25lIG9iamVjdHMgd2l0aCBtb3JlIHRoYW4gMjQgZGV0YWlsWCBvciAxNiBkZXRhaWxZXCIpLCB0aGlzLl9yZW5kZXJlci5jcmVhdGVCdWZmZXJzKGMsIHMpKSwgdGhpcy5fcmVuZGVyZXIuZHJhd0J1ZmZlcnNTY2FsZWQoYywgbywgaSwgbyksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmVsbGlwc29pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcywgbyA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogNTAsIGkgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IG8sIGwgPSAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IG8sIG4gPSAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IDI0LCBhID0gNCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzRdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbNF0gOiAxNiwgYyA9ICh0aGlzLl9hc3NlcnQzZChcImVsbGlwc29pZFwiKSwgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJlbGxpcHNvaWRcIiwgYXJndW1lbnRzKSwgXCJlbGxpcHNvaWR8XCIuY29uY2F0KG4sIFwifFwiKS5jb25jYXQoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2VvbWV0cnlJbkhhc2goYykgfHwgKChzID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShuLCBhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8PSB0aGlzLmRldGFpbFk7IHArKylcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBwIC8gdGhpcy5kZXRhaWxZLCBUID0gTWF0aC5QSSAqIGogLSBNYXRoLlBJIC8gMiwgXyA9IE1hdGguY29zKFQpLCBTID0gTWF0aC5zaW4oVCksIEUgPSAwOyBFIDw9IHRoaXMuZGV0YWlsWDsgRSsrKSB7XG4gICAgICAgICAgICAgIHZhciBBID0gRSAvIHRoaXMuZGV0YWlsWCwgUCA9IDIgKiBNYXRoLlBJICogQSwgeCA9IE1hdGguY29zKFApLCBQID0gTWF0aC5zaW4oUCksIFAgPSBuZXcgdS5kZWZhdWx0LlZlY3RvcihfICogUCwgUywgXyAqIHgpO1xuICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goUCksIHRoaXMudmVydGV4Tm9ybWFscy5wdXNoKFApLCB0aGlzLnV2cy5wdXNoKEEsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkuY29tcHV0ZUZhY2VzKCksIG4gPD0gMjQgJiYgYSA8PSAyNCA/IHMuX21ha2VUcmlhbmdsZUVkZ2VzKCkuX2VkZ2VzVG9WZXJ0aWNlcygpIDogdGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlICYmIGNvbnNvbGUubG9nKFwiQ2Fubm90IGRyYXcgc3Ryb2tlIG9uIGVsbGlwc29pZHMgd2l0aCBtb3JlIHRoYW4gMjQgZGV0YWlsWCBvciAyNCBkZXRhaWxZXCIpLCB0aGlzLl9yZW5kZXJlci5jcmVhdGVCdWZmZXJzKGMsIHMpKSwgdGhpcy5fcmVuZGVyZXIuZHJhd0J1ZmZlcnNTY2FsZWQoYywgbywgaSwgbCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnRvcnVzID0gZnVuY3Rpb24ocywgYywgaSwgbCkge1xuICAgICAgICBpZiAodGhpcy5fYXNzZXJ0M2QoXCJ0b3J1c1wiKSwgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJ0b3J1c1wiLCBhcmd1bWVudHMpLCBzID09PSB2b2lkIDApXG4gICAgICAgICAgcyA9IDUwO1xuICAgICAgICBlbHNlIGlmICghcylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjID09PSB2b2lkIDApXG4gICAgICAgICAgYyA9IDEwO1xuICAgICAgICBlbHNlIGlmICghYylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGkgPT09IHZvaWQgMCAmJiAoaSA9IDI0KSwgbCA9PT0gdm9pZCAwICYmIChsID0gMTYpO1xuICAgICAgICB2YXIgbiwgYSA9IChjIC8gcykudG9QcmVjaXNpb24oNCksIGMgPSBcInRvcnVzfFwiLmNvbmNhdChhLCBcInxcIikuY29uY2F0KGksIFwifFwiKS5jb25jYXQobCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5nZW9tZXRyeUluSGFzaChjKSB8fCAoKG4gPSBuZXcgdS5kZWZhdWx0Lkdlb21ldHJ5KGksIGwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDw9IHRoaXMuZGV0YWlsWTsgcCsrKVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHAgLyB0aGlzLmRldGFpbFksIFQgPSAyICogTWF0aC5QSSAqIGosIF8gPSBNYXRoLmNvcyhUKSwgUyA9IE1hdGguc2luKFQpLCBFID0gMSArIGEgKiBfLCBBID0gMDsgQSA8PSB0aGlzLmRldGFpbFg7IEErKykge1xuICAgICAgICAgICAgICB2YXIgeCA9IEEgLyB0aGlzLmRldGFpbFgsIFAgPSAyICogTWF0aC5QSSAqIHgsIFIgPSBNYXRoLmNvcyhQKSwgUCA9IE1hdGguc2luKFApLCBNID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoRSAqIFIsIEUgKiBQLCBhICogUyksIFIgPSBuZXcgdS5kZWZhdWx0LlZlY3RvcihfICogUiwgXyAqIFAsIFMpO1xuICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goTSksIHRoaXMudmVydGV4Tm9ybWFscy5wdXNoKFIpLCB0aGlzLnV2cy5wdXNoKHgsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkuY29tcHV0ZUZhY2VzKCksIGkgPD0gMjQgJiYgbCA8PSAxNiA/IG4uX21ha2VUcmlhbmdsZUVkZ2VzKCkuX2VkZ2VzVG9WZXJ0aWNlcygpIDogdGhpcy5fcmVuZGVyZXIuX2RvU3Ryb2tlICYmIGNvbnNvbGUubG9nKFwiQ2Fubm90IGRyYXcgc3Ryb2tlcyBvbiB0b3J1cyBvYmplY3Qgd2l0aCBtb3JlIHRoYW4gMjQgZGV0YWlsWCBvciAxNiBkZXRhaWxZXCIpLCB0aGlzLl9yZW5kZXJlci5jcmVhdGVCdWZmZXJzKGMsIG4pKSwgdGhpcy5fcmVuZGVyZXIuZHJhd0J1ZmZlcnNTY2FsZWQoYywgcywgcywgcyksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgIHZhciBpID0gW107XG4gICAgICAgIHJldHVybiBpLnB1c2gobmV3IHUuZGVmYXVsdC5WZWN0b3IocywgbywgMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAwKSksIHRoaXMuX2RyYXdQb2ludHMoaSwgdGhpcy5pbW1lZGlhdGVNb2RlLmJ1ZmZlcnMucG9pbnQpLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgbyA9IGNbMF0sIGkgPSBjWzFdLCBsID0gY1syXSwgbiA9IGNbM10sIGEgPSBjWzRdLCBjID0gY1s1XSwgcCA9ICh0aGlzLmdlb21ldHJ5SW5IYXNoKFwidHJpXCIpIHx8ICgocCA9IG5ldyB1LmRlZmF1bHQuR2VvbWV0cnkoMSwgMSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF8gPSBbXTtcbiAgICAgICAgICBfLnB1c2gobmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMCwgMCkpLCBfLnB1c2gobmV3IHUuZGVmYXVsdC5WZWN0b3IoMSwgMCwgMCkpLCBfLnB1c2gobmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMSwgMCkpLCB0aGlzLmVkZ2VzID0gW1swLCAxXSwgWzEsIDJdLCBbMiwgMF1dLCB0aGlzLnZlcnRpY2VzID0gXywgdGhpcy5mYWNlcyA9IFtbMCwgMSwgMl1dLCB0aGlzLnV2cyA9IFswLCAwLCAxLCAwLCAxLCAxXTtcbiAgICAgICAgfSkpLl9lZGdlc1RvVmVydGljZXMoKSwgcC5jb21wdXRlTm9ybWFscygpLCB0aGlzLmNyZWF0ZUJ1ZmZlcnMoXCJ0cmlcIiwgcCkpLCB0aGlzLnVNVk1hdHJpeC5jb3B5KCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBqID0gTWF0aC5zaWduKG8gKiBuIC0gbCAqIGkgKyBsICogYyAtIGEgKiBuICsgYSAqIGkgLSBvICogYyksIFQgPSBuZXcgdS5kZWZhdWx0Lk1hdHJpeChbbCAtIG8sIG4gLSBpLCAwLCAwLCBhIC0gbywgYyAtIGksIDAsIDAsIDAsIDAsIGosIDAsIG8sIGksIDAsIDFdKS5tdWx0KHRoaXMudU1WTWF0cml4KTtcbiAgICAgICAgICB0aGlzLnVNVk1hdHJpeCA9IFQsIHRoaXMuZHJhd0J1ZmZlcnMoXCJ0cmlcIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy51TVZNYXRyaXggPSBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHRoaXMuYXJjKHNbMF0sIHNbMV0sIHNbMl0sIHNbM10sIDAsIGguVFdPX1BJLCBoLk9QRU4sIHNbNF0pO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcywgbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSwgaSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSwgbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXSwgYSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCA/IHZvaWQgMCA6IGFyZ3VtZW50c1s0XSwgYyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNSA/IHZvaWQgMCA6IGFyZ3VtZW50c1s1XSwgcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNiA/IHZvaWQgMCA6IGFyZ3VtZW50c1s2XSwgaiA9IChhcmd1bWVudHMubGVuZ3RoIDw9IDcgPyB2b2lkIDAgOiBhcmd1bWVudHNbN10pIHx8IDI1LCBUID0gKE1hdGguYWJzKGMgLSBhKSA+PSBoLlRXT19QSSA/IFwiXCIuY29uY2F0KF8gPSBcImVsbGlwc2VcIiwgXCJ8XCIpIDogXCJcIi5jb25jYXQoXyA9IFwiYXJjXCIsIFwifFwiKS5jb25jYXQoYSwgXCJ8XCIpLmNvbmNhdChjLCBcInxcIikuY29uY2F0KHAsIFwifFwiKSkuY29uY2F0KGosIFwifFwiKSwgXyA9ICh0aGlzLmdlb21ldHJ5SW5IYXNoKFQpIHx8ICgocyA9IG5ldyB1LmRlZmF1bHQuR2VvbWV0cnkoaiwgMSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGEudG9GaXhlZCgxMCkgIT09IGMudG9GaXhlZCgxMCkpIHtcbiAgICAgICAgICAgIHAgIT09IGguUElFICYmIHAgIT09IHZvaWQgMCB8fCAodGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyB1LmRlZmF1bHQuVmVjdG9yKDAuNSwgMC41LCAwKSksIHRoaXMudXZzLnB1c2goWzAuNSwgMC41XSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgUyA9IDA7IFMgPD0gajsgUysrKSB7XG4gICAgICAgICAgICAgIHZhciBBID0gKGMgLSBhKSAqIChTIC8gaikgKyBhLCBFID0gMC41ICsgTWF0aC5jb3MoQSkgLyAyLCBBID0gMC41ICsgTWF0aC5zaW4oQSkgLyAyO1xuICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IHUuZGVmYXVsdC5WZWN0b3IoRSwgQSwgMCkpLCB0aGlzLnV2cy5wdXNoKFtFLCBBXSksIFMgPCBqIC0gMSAmJiAodGhpcy5mYWNlcy5wdXNoKFswLCBTICsgMSwgUyArIDJdKSwgdGhpcy5lZGdlcy5wdXNoKFtTICsgMSwgUyArIDJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgICAgY2FzZSBoLlBJRTpcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goWzAsIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMiwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXSksIHRoaXMuZWRnZXMucHVzaChbMCwgMV0pLCB0aGlzLmVkZ2VzLnB1c2goW3RoaXMudmVydGljZXMubGVuZ3RoIC0gMiwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXSksIHRoaXMuZWRnZXMucHVzaChbMCwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgaC5DSE9SRDpcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzLnB1c2goWzAsIDFdKSwgdGhpcy5lZGdlcy5wdXNoKFswLCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBoLk9QRU46XG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKFswLCAxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKFswLCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDIsIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMV0pLCB0aGlzLmVkZ2VzLnB1c2goW3RoaXMudmVydGljZXMubGVuZ3RoIC0gMiwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSkuY29tcHV0ZU5vcm1hbHMoKSwgaiA8PSA1MCA/IHMuX2VkZ2VzVG9WZXJ0aWNlcyhzKSA6IHRoaXMuX2RvU3Ryb2tlICYmIGNvbnNvbGUubG9nKFwiQ2Fubm90IGFwcGx5IGEgc3Ryb2tlIHRvIGFuIFwiLmNvbmNhdChfLCBcIiB3aXRoIG1vcmUgdGhhbiA1MCBkZXRhaWxcIikpLCB0aGlzLmNyZWF0ZUJ1ZmZlcnMoVCwgcykpLCB0aGlzLnVNVk1hdHJpeC5jb3B5KCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudU1WTWF0cml4LnRyYW5zbGF0ZShbbywgaSwgMF0pLCB0aGlzLnVNVk1hdHJpeC5zY2FsZShsLCBuLCAxKSwgdGhpcy5kcmF3QnVmZmVycyhUKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLnVNVk1hdHJpeCA9IF87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIG8gPSBzWzBdLCBpID0gc1sxXSwgbCA9IHNbMl0sIG4gPSBzWzNdO1xuICAgICAgICBpZiAoc1s0XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLnBlclBpeGVsTGlnaHRpbmcsIGEgPSBzWzRdIHx8IChwID8gMSA6IDI0KSwgYyA9IHNbNV0gfHwgKHAgPyAxIDogMTYpLCBwID0gXCJyZWN0fFwiLmNvbmNhdChhLCBcInxcIikuY29uY2F0KGMpLCBqID0gKHRoaXMuZ2VvbWV0cnlJbkhhc2gocCkgfHwgKChqID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShhLCBjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIEcgPSAwOyBHIDw9IHRoaXMuZGV0YWlsWTsgRysrKVxuICAgICAgICAgICAgICBmb3IgKHZhciBVID0gRyAvIHRoaXMuZGV0YWlsWSwgVyA9IDA7IFcgPD0gdGhpcy5kZXRhaWxYOyBXKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgWCA9IFcgLyB0aGlzLmRldGFpbFgsIG5lID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoWCwgVSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5lKSwgdGhpcy51dnMucHVzaChYLCBVKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgMCA8IGEgJiYgMCA8IGMgJiYgKHRoaXMuZWRnZXMgPSBbWzAsIGFdLCBbYSwgKGEgKyAxKSAqIChjICsgMSkgLSAxXSwgWyhhICsgMSkgKiAoYyArIDEpIC0gMSwgKGEgKyAxKSAqIGNdLCBbKGEgKyAxKSAqIGMsIDBdXSk7XG4gICAgICAgICAgfSkpLmNvbXB1dGVGYWNlcygpLmNvbXB1dGVOb3JtYWxzKCkuX2VkZ2VzVG9WZXJ0aWNlcygpLCB0aGlzLmNyZWF0ZUJ1ZmZlcnMocCwgaikpLCB0aGlzLnVNVk1hdHJpeC5jb3B5KCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVNVk1hdHJpeC50cmFuc2xhdGUoW28sIGksIDBdKSwgdGhpcy51TVZNYXRyaXguc2NhbGUobCwgbiwgMSksIHRoaXMuZHJhd0J1ZmZlcnMocCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudU1WTWF0cml4ID0gajtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSBzWzRdLCBqID0gc1s1XSA9PT0gdm9pZCAwID8gcCA6IHNbNV0sIFQgPSBzWzZdID09PSB2b2lkIDAgPyBqIDogc1s2XSwgcyA9IHNbN10gPT09IHZvaWQgMCA/IFQgOiBzWzddLCBQID0gbCwgXyA9IG4sIEEgPSAoKFAgKz0gbykgPCBvICYmIChBID0gbywgbyA9IFAsIFAgPSBBKSwgKF8gKz0gaSkgPCBpICYmIChBID0gaSwgaSA9IF8sIF8gPSBBKSwgTWF0aC5taW4oKFAgLSBvKSAvIDIsIChfIC0gaSkgLyAyKSksIFMgPSAoQSA8IHAgJiYgKHAgPSBBKSwgQSA8IGogJiYgKGogPSBBKSwgQSA8IFQgJiYgKFQgPSBBKSwgQSA8IHMgJiYgKHMgPSBBKSwgbyksIEUgPSBpLCBBID0gUCwgbyA9IF8sIHggPSAodGhpcy5iZWdpblNoYXBlKCksIGogIT09IDAgPyAodGhpcy52ZXJ0ZXgoQSAtIGosIEUpLCB0aGlzLnF1YWRyYXRpY1ZlcnRleChBLCBFLCBBLCBFICsgaikpIDogdGhpcy52ZXJ0ZXgoQSwgRSksIFQgIT09IDAgPyAodGhpcy52ZXJ0ZXgoQSwgbyAtIFQpLCB0aGlzLnF1YWRyYXRpY1ZlcnRleChBLCBvLCBBIC0gVCwgbykpIDogdGhpcy52ZXJ0ZXgoQSwgbyksIHMgIT09IDAgPyAodGhpcy52ZXJ0ZXgoUyArIHMsIG8pLCB0aGlzLnF1YWRyYXRpY1ZlcnRleChTLCBvLCBTLCBvIC0gcykpIDogdGhpcy52ZXJ0ZXgoUywgbyksIHAgIT09IDAgPyAodGhpcy52ZXJ0ZXgoUywgRSArIHApLCB0aGlzLnF1YWRyYXRpY1ZlcnRleChTLCBFLCBTICsgcCwgRSkpIDogdGhpcy52ZXJ0ZXgoUywgRSksICEodGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnV2cy5sZW5ndGggPSAwKSksIGkgPSAhMSwgUCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgTSwgUiA9IHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0aWNlc1tTeW1ib2wuaXRlcmF0b3JdKCk7ICEoeCA9IChNID0gUi5uZXh0KCkpLmRvbmUpOyB4ID0gITApIHtcbiAgICAgICAgICAgICAgdmFyIEwgPSBNLnZhbHVlLCBGID0gKEwueCAtIFMpIC8gbCwgViA9IChMLnkgLSBFKSAvIG47XG4gICAgICAgICAgICAgIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS51dnMucHVzaChGLCBWKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChiKSB7XG4gICAgICAgICAgICBpID0gITAsIFAgPSBiO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB4IHx8IFIucmV0dXJuID09IG51bGwgfHwgUi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHRocm93IFA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW5kU2hhcGUoaC5DTE9TRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUucXVhZCA9IGZ1bmN0aW9uKHMsIG8sIGksIGwsIG4sIGEsIGMsIHAsIGosIFQsIF8sIFMpIHtcbiAgICAgICAgdmFyIEUgPSAxMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzEyXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzEyXSA6IDIsIEEgPSAxMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzEzXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzEzXSA6IDIsIHggPSBcInF1YWR8XCIuY29uY2F0KHMsIFwifFwiKS5jb25jYXQobywgXCJ8XCIpLmNvbmNhdChpLCBcInxcIikuY29uY2F0KGwsIFwifFwiKS5jb25jYXQobiwgXCJ8XCIpLmNvbmNhdChhLCBcInxcIikuY29uY2F0KGMsIFwifFwiKS5jb25jYXQocCwgXCJ8XCIpLmNvbmNhdChqLCBcInxcIikuY29uY2F0KFQsIFwifFwiKS5jb25jYXQoXywgXCJ8XCIpLmNvbmNhdChTLCBcInxcIikuY29uY2F0KEUsIFwifFwiKS5jb25jYXQoQSk7XG4gICAgICAgIGlmICghdGhpcy5nZW9tZXRyeUluSGFzaCh4KSkge1xuICAgICAgICAgIHZhciBQID0gbmV3IHUuZGVmYXVsdC5HZW9tZXRyeShFLCBBLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFcgPSAxIC8gKHRoaXMuZGV0YWlsWCAtIDEpLCBYID0gMSAvICh0aGlzLmRldGFpbFkgLSAxKSwgbmUgPSAwOyBuZSA8IHRoaXMuZGV0YWlsWTsgbmUrKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB0aGlzLmRldGFpbFg7IGIrKykge1xuICAgICAgICAgICAgICAgIHZhciBPID0gYiAqIFcsIEQgPSBuZSAqIFg7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyB1LmRlZmF1bHQuVmVjdG9yKCgxIC0gTykgKiAoKDEgLSBEKSAqIHMgKyBEICogVCkgKyBPICogKCgxIC0gRCkgKiBsICsgRCAqIGMpLCAoMSAtIE8pICogKCgxIC0gRCkgKiBvICsgRCAqIF8pICsgTyAqICgoMSAtIEQpICogbiArIEQgKiBwKSwgKDEgLSBPKSAqICgoMSAtIEQpICogaSArIEQgKiBTKSArIE8gKiAoKDEgLSBEKSAqIGEgKyBEICogaikpKSwgdGhpcy51dnMucHVzaChbTywgRF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgUC5mYWNlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIE0gPSAwOyBNIDwgQSAtIDE7IE0rKylcbiAgICAgICAgICAgIGZvciAodmFyIFIgPSAwOyBSIDwgRSAtIDE7IFIrKykge1xuICAgICAgICAgICAgICB2YXIgTCA9IFIgKyBNICogRSwgRiA9IFIgKyAxICsgKE0gKyAxKSAqIEUsIFYgPSBSICsgKE0gKyAxKSAqIEU7XG4gICAgICAgICAgICAgIFAuZmFjZXMucHVzaChbTCwgUiArIDEgKyBNICogRSwgRl0pLCBQLmZhY2VzLnB1c2goW0wsIEYsIFZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBQLmNvbXB1dGVOb3JtYWxzKCk7XG4gICAgICAgICAgZm9yICh2YXIgRyA9IFtQLmVkZ2VzLmxlbmd0aCA9IDAsIDIsIDMsIDFdLCBVID0gMDsgVSA8IEcubGVuZ3RoOyBVKyspXG4gICAgICAgICAgICBQLmVkZ2VzLnB1c2goW0dbVV0sIEdbKFUgKyAxKSAlIEcubGVuZ3RoXV0pO1xuICAgICAgICAgIFAuX2VkZ2VzVG9WZXJ0aWNlcygpLCB0aGlzLmNyZWF0ZUJ1ZmZlcnMoeCwgUCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0J1ZmZlcnMoeCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuYmV6aWVyID0gZnVuY3Rpb24ocywgbywgaSwgbCwgbiwgYSwgYywgcCwgaiwgVCwgXywgUykge1xuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSA4ICYmIChfID0gcCwgVCA9IGMsIHAgPSBhLCBjID0gbiwgbiA9IGwsIGwgPSBpLCBpID0gYSA9IGogPSBTID0gMCk7XG4gICAgICAgIHZhciBFID0gdGhpcy5fcEluc3QuX2JlemllckRldGFpbCB8fCAyMDtcbiAgICAgICAgdGhpcy5iZWdpblNoYXBlKCk7XG4gICAgICAgIGZvciAodmFyIEEgPSAwOyBBIDw9IEU7IEErKykge1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIEEgLyBFLCAzKSwgUCA9IEEgLyBFICogMyAqIE1hdGgucG93KDEgLSBBIC8gRSwgMiksIE0gPSAzICogTWF0aC5wb3coQSAvIEUsIDIpICogKDEgLSBBIC8gRSksIFIgPSBNYXRoLnBvdyhBIC8gRSwgMyk7XG4gICAgICAgICAgdGhpcy52ZXJ0ZXgocyAqIHggKyBsICogUCArIGMgKiBNICsgVCAqIFIsIG8gKiB4ICsgbiAqIFAgKyBwICogTSArIF8gKiBSLCBpICogeCArIGEgKiBQICsgaiAqIE0gKyBTICogUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU2hhcGUoKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5jdXJ2ZSA9IGZ1bmN0aW9uKHMsIG8sIGksIGwsIG4sIGEsIGMsIHAsIGosIFQsIF8sIFMpIHtcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gOCAmJiAoVCA9IGMsIF8gPSBwLCBjID0gbiwgcCA9IGwsIG4gPSBsID0gaSwgaSA9IGEgPSBqID0gUyA9IDApO1xuICAgICAgICB2YXIgRSA9IHRoaXMuX3BJbnN0Ll9jdXJ2ZURldGFpbDtcbiAgICAgICAgdGhpcy5iZWdpblNoYXBlKCk7XG4gICAgICAgIGZvciAodmFyIEEgPSAwOyBBIDw9IEU7IEErKykge1xuICAgICAgICAgIHZhciB4ID0gMC41ICogTWF0aC5wb3coQSAvIEUsIDMpLCBQID0gMC41ICogTWF0aC5wb3coQSAvIEUsIDIpLCBNID0gQSAvIEUgKiAwLjU7XG4gICAgICAgICAgdGhpcy52ZXJ0ZXgoeCAqICgzICogbCAtIHMgLSAzICogYyArIFQpICsgUCAqICgyICogcyAtIDUgKiBsICsgNCAqIGMgLSBUKSArIE0gKiAoLXMgKyBjKSArIDIgKiBsICogMC41LCB4ICogKDMgKiBuIC0gbyAtIDMgKiBwICsgXykgKyBQICogKDIgKiBvIC0gNSAqIG4gKyA0ICogcCAtIF8pICsgTSAqICgtbyArIHApICsgMiAqIG4gKiAwLjUsIHggKiAoMyAqIGEgLSBpIC0gMyAqIGogKyBTKSArIFAgKiAoMiAqIGkgLSA1ICogYSArIDQgKiBqIC0gUykgKyBNICogKC1pICsgaikgKyAyICogYSAqIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU2hhcGUoKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSA2ID8gKHRoaXMuYmVnaW5TaGFwZShoLkxJTkVTKSwgdGhpcy52ZXJ0ZXgoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSksIHRoaXMudmVydGV4KGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXSwgYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdm9pZCAwIDogYXJndW1lbnRzWzRdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDUgPyB2b2lkIDAgOiBhcmd1bWVudHNbNV0pLCB0aGlzLmVuZFNoYXBlKCkpIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiAodGhpcy5iZWdpblNoYXBlKGguTElORVMpLCB0aGlzLnZlcnRleChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgMCksIHRoaXMudmVydGV4KGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdm9pZCAwIDogYXJndW1lbnRzWzNdLCAwKSwgdGhpcy5lbmRTaGFwZSgpKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5iZXppZXJWZXJ0ZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcInZlcnRleCgpIG11c3QgYmUgdXNlZCBvbmNlIGJlZm9yZSBjYWxsaW5nIGJlemllclZlcnRleCgpXCIpO1xuICAgICAgICB2YXIgcywgbywgaSwgbCwgbiwgYSwgYyA9IFtdLCBwID0gW10sIGogPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbG9va1VwVGFibGVCZXppZXIubGVuZ3RoID09PSAwIHx8IHRoaXMuX2x1dEJlemllckRldGFpbCAhPT0gdGhpcy5fcEluc3QuX2N1cnZlRGV0YWlsKSB7XG4gICAgICAgICAgdGhpcy5fbG9va1VwVGFibGVCZXppZXIgPSBbXSwgdGhpcy5fbHV0QmV6aWVyRGV0YWlsID0gdGhpcy5fcEluc3QuX2N1cnZlRGV0YWlsO1xuICAgICAgICAgIGZvciAodmFyIFQgPSAxIC8gdGhpcy5fbHV0QmV6aWVyRGV0YWlsLCBfID0gMCwgUyA9IDEsIEUgPSAwOyBfIDwgMTsgKSB7XG4gICAgICAgICAgICBpZiAoYSA9IHBhcnNlRmxvYXQoXy50b0ZpeGVkKDYpKSwgdGhpcy5fbG9va1VwVGFibGVCZXppZXJbRV0gPSB0aGlzLl9iZXppZXJDb2VmZmljaWVudHMoYSksIFMudG9GaXhlZCg2KSA9PT0gVC50b0ZpeGVkKDYpKSB7XG4gICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KFMudG9GaXhlZCg2KSkgKyBwYXJzZUZsb2F0KF8udG9GaXhlZCg2KSksICsrRSwgdGhpcy5fbG9va1VwVGFibGVCZXppZXJbRV0gPSB0aGlzLl9iZXppZXJDb2VmZmljaWVudHMoYSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXyArPSBULCBTIC09IFQsICsrRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgQSA9IHRoaXMuX2xvb2tVcFRhYmxlQmV6aWVyLmxlbmd0aCwgeCA9IFtdLCBQID0gMDsgUCA8IDQ7IFArKylcbiAgICAgICAgICB4LnB1c2goW10pO1xuICAgICAgICB4WzBdID0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleENvbG9ycy5zbGljZSgtNCksIHhbM10gPSB0aGlzLmN1ckZpbGxDb2xvci5zbGljZSgpO1xuICAgICAgICB2YXIgTSA9IFtdO1xuICAgICAgICBmb3IgKFAgPSAwOyBQIDwgNDsgUCsrKVxuICAgICAgICAgIE0ucHVzaChbXSk7XG4gICAgICAgIGlmIChNWzBdID0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleFN0cm9rZUNvbG9ycy5zbGljZSgtNCksIE1bM10gPSB0aGlzLmN1clN0cm9rZUNvbG9yLnNsaWNlKCksIGogPT09IDYpIHtcbiAgICAgICAgICB0aGlzLmlzQmV6aWVyID0gITA7XG4gICAgICAgICAgdmFyIGMgPSBbdGhpcy5pbW1lZGlhdGVNb2RlLl9iZXppZXJWZXJ0ZXhbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDQgPyB2b2lkIDAgOiBhcmd1bWVudHNbNF1dLCBwID0gW3RoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4WzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXSwgYXJndW1lbnRzLmxlbmd0aCA8PSA1ID8gdm9pZCAwIDogYXJndW1lbnRzWzVdXSwgUiA9IE1hdGguaHlwb3QoY1swXSAtIGNbMV0sIHBbMF0gLSBwWzFdKSwgRiA9IE1hdGguaHlwb3QoY1sxXSAtIGNbMl0sIHBbMV0gLSBwWzJdKSwgTCA9IE1hdGguaHlwb3QoY1syXSAtIGNbM10sIHBbMl0gLSBwWzNdKSwgRiA9IFIgKyBGICsgTDtcbiAgICAgICAgICBmb3IgKFIgLz0gRiwgTCAvPSBGLCBuID0gMDsgbiA8IDQ7IG4rKylcbiAgICAgICAgICAgIHhbMV0ucHVzaCh4WzBdW25dICogKDEgLSBSKSArIHhbM11bbl0gKiBSKSwgeFsyXS5wdXNoKHhbMF1bbl0gKiBMICsgeFszXVtuXSAqICgxIC0gTCkpLCBNWzFdLnB1c2goTVswXVtuXSAqICgxIC0gUikgKyBNWzNdW25dICogUiksIE1bMl0ucHVzaChNWzBdW25dICogTCArIE1bM11bbl0gKiAoMSAtIEwpKTtcbiAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgQTsgbCsrKSB7XG4gICAgICAgICAgICBmb3IgKHRoaXMuY3VyRmlsbENvbG9yID0gWzAsIDAsIDAsIDBdLCB0aGlzLmN1clN0cm9rZUNvbG9yID0gWzAsIDAsIDAsIDBdLCBQID0gcyA9IG8gPSAwOyBQIDwgNDsgUCsrKSB7XG4gICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCA0OyBuKyspXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJGaWxsQ29sb3Jbbl0gKz0gdGhpcy5fbG9va1VwVGFibGVCZXppZXJbbF1bUF0gKiB4W1BdW25dLCB0aGlzLmN1clN0cm9rZUNvbG9yW25dICs9IHRoaXMuX2xvb2tVcFRhYmxlQmV6aWVyW2xdW1BdICogTVtQXVtuXTtcbiAgICAgICAgICAgICAgcyArPSBjW1BdICogdGhpcy5fbG9va1VwVGFibGVCZXppZXJbbF1bUF0sIG8gKz0gcFtQXSAqIHRoaXMuX2xvb2tVcFRhYmxlQmV6aWVyW2xdW1BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXgocywgbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VyRmlsbENvbG9yID0geFszXSwgdGhpcy5jdXJTdHJva2VDb2xvciA9IE1bM10sIHRoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4WzBdID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdm9pZCAwIDogYXJndW1lbnRzWzRdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2JlemllclZlcnRleFsxXSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNSA/IHZvaWQgMCA6IGFyZ3VtZW50c1s1XTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09PSA5KSB7XG4gICAgICAgICAgdGhpcy5pc0JlemllciA9ICEwLCBjID0gW3RoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4WzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXSwgYXJndW1lbnRzLmxlbmd0aCA8PSA2ID8gdm9pZCAwIDogYXJndW1lbnRzWzZdXSwgcCA9IFt0aGlzLmltbWVkaWF0ZU1vZGUuX2JlemllclZlcnRleFsxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDQgPyB2b2lkIDAgOiBhcmd1bWVudHNbNF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gNyA/IHZvaWQgMCA6IGFyZ3VtZW50c1s3XV07XG4gICAgICAgICAgdmFyIFYgPSBbdGhpcy5pbW1lZGlhdGVNb2RlLl9iZXppZXJWZXJ0ZXhbMl0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSwgYXJndW1lbnRzLmxlbmd0aCA8PSA1ID8gdm9pZCAwIDogYXJndW1lbnRzWzVdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDggPyB2b2lkIDAgOiBhcmd1bWVudHNbOF1dLCBHID0gTWF0aC5oeXBvdChjWzBdIC0gY1sxXSwgcFswXSAtIHBbMV0sIFZbMF0gLSBWWzFdKSwgRiA9IE1hdGguaHlwb3QoY1sxXSAtIGNbMl0sIHBbMV0gLSBwWzJdLCBWWzFdIC0gVlsyXSksIFUgPSBNYXRoLmh5cG90KGNbMl0gLSBjWzNdLCBwWzJdIC0gcFszXSwgVlsyXSAtIFZbM10pLCBqID0gRyArIEYgKyBVO1xuICAgICAgICAgIGZvciAoRyAvPSBqLCBVIC89IGosIG4gPSAwOyBuIDwgNDsgbisrKVxuICAgICAgICAgICAgeFsxXS5wdXNoKHhbMF1bbl0gKiAoMSAtIEcpICsgeFszXVtuXSAqIEcpLCB4WzJdLnB1c2goeFswXVtuXSAqIFUgKyB4WzNdW25dICogKDEgLSBVKSksIE1bMV0ucHVzaChNWzBdW25dICogKDEgLSBHKSArIE1bM11bbl0gKiBHKSwgTVsyXS5wdXNoKE1bMF1bbl0gKiBVICsgTVszXVtuXSAqICgxIC0gVSkpO1xuICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBBOyBsKyspIHtcbiAgICAgICAgICAgIGZvciAodGhpcy5jdXJGaWxsQ29sb3IgPSBbMCwgMCwgMCwgMF0sIHRoaXMuY3VyU3Ryb2tlQ29sb3IgPSBbMCwgMCwgMCwgMF0sIFAgPSBzID0gbyA9IGkgPSAwOyBQIDwgNDsgUCsrKSB7XG4gICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCA0OyBuKyspXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJGaWxsQ29sb3Jbbl0gKz0gdGhpcy5fbG9va1VwVGFibGVCZXppZXJbbF1bUF0gKiB4W1BdW25dLCB0aGlzLmN1clN0cm9rZUNvbG9yW25dICs9IHRoaXMuX2xvb2tVcFRhYmxlQmV6aWVyW2xdW1BdICogTVtQXVtuXTtcbiAgICAgICAgICAgICAgcyArPSBjW1BdICogdGhpcy5fbG9va1VwVGFibGVCZXppZXJbbF1bUF0sIG8gKz0gcFtQXSAqIHRoaXMuX2xvb2tVcFRhYmxlQmV6aWVyW2xdW1BdLCBpICs9IFZbUF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltsXVtQXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmVydGV4KHMsIG8sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmN1ckZpbGxDb2xvciA9IHhbM10sIHRoaXMuY3VyU3Ryb2tlQ29sb3IgPSBNWzNdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2JlemllclZlcnRleFswXSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNiA/IHZvaWQgMCA6IGFyZ3VtZW50c1s2XSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9iZXppZXJWZXJ0ZXhbMV0gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDcgPyB2b2lkIDAgOiBhcmd1bWVudHNbN10sIHRoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4WzJdID0gYXJndW1lbnRzLmxlbmd0aCA8PSA4ID8gdm9pZCAwIDogYXJndW1lbnRzWzhdO1xuICAgICAgICB9XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUucXVhZHJhdGljVmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleC5sZW5ndGggPT09IDApXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJ2ZXJ0ZXgoKSBtdXN0IGJlIHVzZWQgb25jZSBiZWZvcmUgY2FsbGluZyBxdWFkcmF0aWNWZXJ0ZXgoKVwiKTtcbiAgICAgICAgdmFyIHMsIG8sIGksIGwsIG4sIGEsIGMgPSBbXSwgcCA9IFtdLCBqID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9sdXRRdWFkcmF0aWNEZXRhaWwgIT09IHRoaXMuX3BJbnN0Ll9jdXJ2ZURldGFpbCkge1xuICAgICAgICAgIHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljID0gW10sIHRoaXMuX2x1dFF1YWRyYXRpY0RldGFpbCA9IHRoaXMuX3BJbnN0Ll9jdXJ2ZURldGFpbDtcbiAgICAgICAgICBmb3IgKHZhciBUID0gMSAvIHRoaXMuX2x1dFF1YWRyYXRpY0RldGFpbCwgXyA9IDAsIFMgPSAxLCBFID0gMDsgXyA8IDE7ICkge1xuICAgICAgICAgICAgaWYgKGEgPSBwYXJzZUZsb2F0KF8udG9GaXhlZCg2KSksIHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljW0VdID0gdGhpcy5fcXVhZHJhdGljQ29lZmZpY2llbnRzKGEpLCBTLnRvRml4ZWQoNikgPT09IFQudG9GaXhlZCg2KSkge1xuICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChTLnRvRml4ZWQoNikpICsgcGFyc2VGbG9hdChfLnRvRml4ZWQoNikpLCArK0UsIHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljW0VdID0gdGhpcy5fcXVhZHJhdGljQ29lZmZpY2llbnRzKGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8gKz0gVCwgUyAtPSBULCArK0U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIEEgPSB0aGlzLl9sb29rVXBUYWJsZVF1YWRyYXRpYy5sZW5ndGgsIHggPSBbXSwgUCA9IDA7IFAgPCAzOyBQKyspXG4gICAgICAgICAgeC5wdXNoKFtdKTtcbiAgICAgICAgeFswXSA9IHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0ZXhDb2xvcnMuc2xpY2UoLTQpLCB4WzJdID0gdGhpcy5jdXJGaWxsQ29sb3Iuc2xpY2UoKTtcbiAgICAgICAgdmFyIE0gPSBbXTtcbiAgICAgICAgZm9yIChQID0gMDsgUCA8IDM7IFArKylcbiAgICAgICAgICBNLnB1c2goW10pO1xuICAgICAgICBpZiAoTVswXSA9IHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0ZXhTdHJva2VDb2xvcnMuc2xpY2UoLTQpLCBNWzJdID0gdGhpcy5jdXJTdHJva2VDb2xvci5zbGljZSgpLCBqID09PSA0KSB7XG4gICAgICAgICAgdGhpcy5pc1F1YWRyYXRpYyA9ICEwO1xuICAgICAgICAgIHZhciBjID0gW3RoaXMuaW1tZWRpYXRlTW9kZS5fcXVhZHJhdGljVmVydGV4WzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXV0sIHAgPSBbdGhpcy5pbW1lZGlhdGVNb2RlLl9xdWFkcmF0aWNWZXJ0ZXhbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdm9pZCAwIDogYXJndW1lbnRzWzNdXSwgUiA9IE1hdGguaHlwb3QoY1swXSAtIGNbMV0sIHBbMF0gLSBwWzFdKTtcbiAgICAgICAgICBmb3IgKFIgLz0gUiArIE1hdGguaHlwb3QoY1sxXSAtIGNbMl0sIHBbMV0gLSBwWzJdKSwgbiA9IDA7IG4gPCA0OyBuKyspXG4gICAgICAgICAgICB4WzFdLnB1c2goeFswXVtuXSAqICgxIC0gUikgKyB4WzJdW25dICogUiksIE1bMV0ucHVzaChNWzBdW25dICogKDEgLSBSKSArIE1bMl1bbl0gKiBSKTtcbiAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgQTsgbCsrKSB7XG4gICAgICAgICAgICBmb3IgKHRoaXMuY3VyRmlsbENvbG9yID0gWzAsIDAsIDAsIDBdLCB0aGlzLmN1clN0cm9rZUNvbG9yID0gWzAsIDAsIDAsIDBdLCBQID0gcyA9IG8gPSAwOyBQIDwgMzsgUCsrKSB7XG4gICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCA0OyBuKyspXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJGaWxsQ29sb3Jbbl0gKz0gdGhpcy5fbG9va1VwVGFibGVRdWFkcmF0aWNbbF1bUF0gKiB4W1BdW25dLCB0aGlzLmN1clN0cm9rZUNvbG9yW25dICs9IHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljW2xdW1BdICogTVtQXVtuXTtcbiAgICAgICAgICAgICAgcyArPSBjW1BdICogdGhpcy5fbG9va1VwVGFibGVRdWFkcmF0aWNbbF1bUF0sIG8gKz0gcFtQXSAqIHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljW2xdW1BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXgocywgbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VyRmlsbENvbG9yID0geFsyXSwgdGhpcy5jdXJTdHJva2VDb2xvciA9IE1bMl0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fcXVhZHJhdGljVmVydGV4WzBdID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleFsxXSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09PSA2KSB7XG4gICAgICAgICAgdGhpcy5pc1F1YWRyYXRpYyA9ICEwLCBjID0gW3RoaXMuaW1tZWRpYXRlTW9kZS5fcXVhZHJhdGljVmVydGV4WzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXV0sIHAgPSBbdGhpcy5pbW1lZGlhdGVNb2RlLl9xdWFkcmF0aWNWZXJ0ZXhbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdm9pZCAwIDogYXJndW1lbnRzWzRdXTtcbiAgICAgICAgICB2YXIgTCA9IFt0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleFsyXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDUgPyB2b2lkIDAgOiBhcmd1bWVudHNbNV1dLCBGID0gTWF0aC5oeXBvdChjWzBdIC0gY1sxXSwgcFswXSAtIHBbMV0sIExbMF0gLSBMWzFdKTtcbiAgICAgICAgICBmb3IgKEYgLz0gRiArIE1hdGguaHlwb3QoY1sxXSAtIGNbMl0sIHBbMV0gLSBwWzJdLCBMWzFdIC0gTFsyXSksIG4gPSAwOyBuIDwgNDsgbisrKVxuICAgICAgICAgICAgeFsxXS5wdXNoKHhbMF1bbl0gKiAoMSAtIEYpICsgeFsyXVtuXSAqIEYpLCBNWzFdLnB1c2goTVswXVtuXSAqICgxIC0gRikgKyBNWzJdW25dICogRik7XG4gICAgICAgICAgZm9yIChsID0gMDsgbCA8IEE7IGwrKykge1xuICAgICAgICAgICAgZm9yICh0aGlzLmN1ckZpbGxDb2xvciA9IFswLCAwLCAwLCAwXSwgdGhpcy5jdXJTdHJva2VDb2xvciA9IFswLCAwLCAwLCAwXSwgUCA9IHMgPSBvID0gaSA9IDA7IFAgPCAzOyBQKyspIHtcbiAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IDQ7IG4rKylcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckZpbGxDb2xvcltuXSArPSB0aGlzLl9sb29rVXBUYWJsZVF1YWRyYXRpY1tsXVtQXSAqIHhbUF1bbl0sIHRoaXMuY3VyU3Ryb2tlQ29sb3Jbbl0gKz0gdGhpcy5fbG9va1VwVGFibGVRdWFkcmF0aWNbbF1bUF0gKiBNW1BdW25dO1xuICAgICAgICAgICAgICBzICs9IGNbUF0gKiB0aGlzLl9sb29rVXBUYWJsZVF1YWRyYXRpY1tsXVtQXSwgbyArPSBwW1BdICogdGhpcy5fbG9va1VwVGFibGVRdWFkcmF0aWNbbF1bUF0sIGkgKz0gTFtQXSAqIHRoaXMuX2xvb2tVcFRhYmxlUXVhZHJhdGljW2xdW1BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXgocywgbywgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VyRmlsbENvbG9yID0geFsyXSwgdGhpcy5jdXJTdHJva2VDb2xvciA9IE1bMl0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fcXVhZHJhdGljVmVydGV4WzBdID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdm9pZCAwIDogYXJndW1lbnRzWzNdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleFsxXSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCA/IHZvaWQgMCA6IGFyZ3VtZW50c1s0XSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9xdWFkcmF0aWNWZXJ0ZXhbMl0gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgPyB2b2lkIDAgOiBhcmd1bWVudHNbNV07XG4gICAgICAgIH1cbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5jdXJ2ZVZlcnRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcywgbywgaSwgbCwgbiwgYSwgYyA9IFtdLCBwID0gW10sIGogPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbG9va1VwVGFibGVCZXppZXIubGVuZ3RoID09PSAwIHx8IHRoaXMuX2x1dEJlemllckRldGFpbCAhPT0gdGhpcy5fcEluc3QuX2N1cnZlRGV0YWlsKSB7XG4gICAgICAgICAgdGhpcy5fbG9va1VwVGFibGVCZXppZXIgPSBbXSwgdGhpcy5fbHV0QmV6aWVyRGV0YWlsID0gdGhpcy5fcEluc3QuX2N1cnZlRGV0YWlsO1xuICAgICAgICAgIGZvciAodmFyIFQgPSAxIC8gdGhpcy5fbHV0QmV6aWVyRGV0YWlsLCBfID0gMCwgUyA9IDEsIEUgPSAwOyBfIDwgMTsgKSB7XG4gICAgICAgICAgICBpZiAoYSA9IHBhcnNlRmxvYXQoXy50b0ZpeGVkKDYpKSwgdGhpcy5fbG9va1VwVGFibGVCZXppZXJbRV0gPSB0aGlzLl9iZXppZXJDb2VmZmljaWVudHMoYSksIFMudG9GaXhlZCg2KSA9PT0gVC50b0ZpeGVkKDYpKSB7XG4gICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KFMudG9GaXhlZCg2KSkgKyBwYXJzZUZsb2F0KF8udG9GaXhlZCg2KSksICsrRSwgdGhpcy5fbG9va1VwVGFibGVCZXppZXJbRV0gPSB0aGlzLl9iZXppZXJDb2VmZmljaWVudHMoYSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXyArPSBULCBTIC09IFQsICsrRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEEgPSB0aGlzLl9sb29rVXBUYWJsZUJlemllci5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSAyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXgucHVzaChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4LnB1c2goYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleC5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgICAgIGZvciAodGhpcy5pc0N1cnZlID0gITAsIGMgPSB0aGlzLl9iZXppZXJUb0NhdG11bGwoW3RoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMF0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMl0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbNF0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbNl1dKSwgcCA9IHRoaXMuX2JlemllclRvQ2F0bXVsbChbdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleFsxXSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleFszXSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleFs1XSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleFs3XV0pLCBuID0gMDsgbiA8IEE7IG4rKylcbiAgICAgICAgICAgICAgbyA9IGNbMF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVswXSArIGNbMV0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsxXSArIGNbMl0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsyXSArIGNbM10gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVszXSwgaSA9IHBbMF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVswXSArIHBbMV0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsxXSArIHBbMl0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsyXSArIHBbM10gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVszXSwgdGhpcy52ZXJ0ZXgobywgaSk7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgajsgbisrKVxuICAgICAgICAgICAgICB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4LnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGogPT09IDMgJiYgKHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXgucHVzaChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0pLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4LnB1c2goYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSwgdGhpcy5pbW1lZGlhdGVNb2RlLl9jdXJ2ZVZlcnRleC5wdXNoKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHZvaWQgMCA6IGFyZ3VtZW50c1syXSksIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXgubGVuZ3RoID09PSAxMikpIHtcbiAgICAgICAgICBmb3IgKHRoaXMuaXNDdXJ2ZSA9ICEwLCBjID0gdGhpcy5fYmV6aWVyVG9DYXRtdWxsKFt0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4WzBdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4WzNdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4WzZdLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4WzldXSksIHAgPSB0aGlzLl9iZXppZXJUb0NhdG11bGwoW3RoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMV0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbNF0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbN10sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMTBdXSksIHMgPSB0aGlzLl9iZXppZXJUb0NhdG11bGwoW3RoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMl0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbNV0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbOF0sIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXhbMTFdXSksIG4gPSAwOyBuIDwgQTsgbisrKVxuICAgICAgICAgICAgbyA9IGNbMF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVswXSArIGNbMV0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsxXSArIGNbMl0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsyXSArIGNbM10gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVszXSwgaSA9IHBbMF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVswXSArIHBbMV0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsxXSArIHBbMl0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsyXSArIHBbM10gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVszXSwgbCA9IHNbMF0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVswXSArIHNbMV0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsxXSArIHNbMl0gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVsyXSArIHNbM10gKiB0aGlzLl9sb29rVXBUYWJsZUJlemllcltuXVszXSwgdGhpcy52ZXJ0ZXgobywgaSwgbCk7XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IGo7IG4rKylcbiAgICAgICAgICAgIHRoaXMuaW1tZWRpYXRlTW9kZS5fY3VydmVWZXJ0ZXguc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24ocywgUywgaSwgRSwgbiwgYSwgYywgcCwgaikge1xuICAgICAgICB0aGlzLl9pc0VyYXNpbmcgJiYgdGhpcy5ibGVuZE1vZGUodGhpcy5fY2FjaGVkQmxlbmRNb2RlKSwgdGhpcy5fcEluc3QucHVzaCgpLCB0aGlzLl9wSW5zdC5ub0xpZ2h0cygpLCB0aGlzLl9wSW5zdC5ub1N0cm9rZSgpLCB0aGlzLl9wSW5zdC50ZXh0dXJlKHMpLCB0aGlzLl9wSW5zdC50ZXh0dXJlTW9kZShoLk5PUk1BTCk7XG4gICAgICAgIHZhciBUID0gMCwgXyA9IChTIDw9IHMud2lkdGggJiYgKFQgPSBTIC8gcy53aWR0aCksIDEpLCBTID0gKFMgKyBFIDw9IHMud2lkdGggJiYgKF8gPSAoUyArIEUpIC8gcy53aWR0aCksIDApLCBFID0gKGkgPD0gcy5oZWlnaHQgJiYgKFMgPSBpIC8gcy5oZWlnaHQpLCAxKTtcbiAgICAgICAgaSArIG4gPD0gcy5oZWlnaHQgJiYgKEUgPSAoaSArIG4pIC8gcy5oZWlnaHQpLCB0aGlzLmJlZ2luU2hhcGUoKSwgdGhpcy52ZXJ0ZXgoYSwgYywgMCwgVCwgUyksIHRoaXMudmVydGV4KGEgKyBwLCBjLCAwLCBfLCBTKSwgdGhpcy52ZXJ0ZXgoYSArIHAsIGMgKyBqLCAwLCBfLCBFKSwgdGhpcy52ZXJ0ZXgoYSwgYyArIGosIDAsIFQsIEUpLCB0aGlzLmVuZFNoYXBlKGguQ0xPU0UpLCB0aGlzLl9wSW5zdC5wb3AoKSwgdGhpcy5faXNFcmFzaW5nICYmIHRoaXMuYmxlbmRNb2RlKGguUkVNT1ZFKTtcbiAgICAgIH07XG4gICAgICB2YXIgciA9IHUuZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IHI7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vcDUuR2VvbWV0cnlcIjogMzMyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiOiAxNjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIjogMTY4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmh5cG90XCI6IDE3NSwgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5zaWduXCI6IDE3NywgXCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkXCI6IDE4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiOiAyNDEsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMjQ6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKG8pIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgaTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBpLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgaSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgaTtcbiAgICAgICAgfSkobyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KG8pIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBtKGkpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0oaSk7XG4gICAgICAgIH0pKG8pO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5ldmVyeVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChzID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgcy5fX2VzTW9kdWxlID8gcyA6IHsgZGVmYXVsdDogcyB9LCBoID0gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAobyAmJiBvLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIGlmIChvID09PSBudWxsIHx8IHkobykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IG8gfTtcbiAgICAgICAgdmFyIGkgPSBnKCk7XG4gICAgICAgIGlmIChpICYmIGkuaGFzKG8pKVxuICAgICAgICAgIHJldHVybiBpLmdldChvKTtcbiAgICAgICAgdmFyIGwsIG4gPSB7fSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGwgaW4gbykge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBsKSAmJiAoKGMgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBsKSA6IG51bGwpICYmIChjLmdldCB8fCBjLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgbCwgYykgOiBuW2xdID0gb1tsXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZGVmYXVsdCA9IG8sIGkgJiYgaS5zZXQobywgbiksIG47XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgbztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0sIG8pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBuID0gbmV3IEFycmF5KGkubGVuZ3RoKTsgbCA8IGkubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgIG5bbF0gPSBpW2xdO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KG8pIHx8IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaSkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpKTtcbiAgICAgICAgfShvKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIobywgaSkge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGkubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgbiA9IGlbbF07XG4gICAgICAgICAgbi5lbnVtZXJhYmxlID0gbi5lbnVtZXJhYmxlIHx8ICExLCBuLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIG4ua2V5LCBuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gbyhuKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG8pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAodGhpcy5yZW5kZXJlciA9IG4pLl9wSW5zdC5wdXNoKCksIHRoaXMuaWRlbnRpdHlNYXRyaXggPSBuZXcgdS5kZWZhdWx0Lk1hdHJpeCgpLCBuLnVNVk1hdHJpeCA9IG5ldyB1LmRlZmF1bHQuTWF0cml4KCksIHRoaXMuZ2VvbWV0cnkgPSBuZXcgdS5kZWZhdWx0Lkdlb21ldHJ5KCksIHRoaXMuZ2VvbWV0cnkuZ2lkID0gXCJfcDVfR2VvbWV0cnlCdWlsZGVyX1wiLmNvbmNhdChvLm5leHRHZW9tZXRyeUlkKSwgby5uZXh0R2VvbWV0cnlJZCsrLCB0aGlzLmhhc1RyYW5zZm9ybSA9ICExO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICByZXR1cm4gaSA9IG8sIChsID0gW3sga2V5OiBcInRyYW5zZm9ybVZlcnRpY2VzXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc1RyYW5zZm9ybSA/IG4ubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnJlbmRlcmVyLnVNVk1hdHJpeC5tdWx0aXBseVBvaW50KGMpO1xuICAgICAgICAgIH0pIDogbjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0cmFuc2Zvcm1Ob3JtYWxzXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc1RyYW5zZm9ybSA/IG4ubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnJlbmRlcmVyLnVOTWF0cml4Lm11bHRpcGx5VmVjMyhjKTtcbiAgICAgICAgICB9KSA6IG47XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkR2VvbWV0cnlcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBmb3IgKHZhciBhLCBjID0gdGhpcywgcCA9ICh0aGlzLmhhc1RyYW5zZm9ybSA9ICF0aGlzLnJlbmRlcmVyLnVNVk1hdHJpeC5tYXQ0LmV2ZXJ5KGZ1bmN0aW9uKFQsIF8pIHtcbiAgICAgICAgICAgIHJldHVybiBUID09PSBjLmlkZW50aXR5TWF0cml4Lm1hdDRbX107XG4gICAgICAgICAgfSksIHRoaXMuaGFzVHJhbnNmb3JtICYmIHRoaXMucmVuZGVyZXIudU5NYXRyaXguaW52ZXJzZVRyYW5zcG9zZSh0aGlzLnJlbmRlcmVyLnVNVk1hdHJpeCksIHRoaXMuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKSwgaiA9ICgoYSA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMpLnB1c2guYXBwbHkoYSwgZih0aGlzLnRyYW5zZm9ybVZlcnRpY2VzKG4udmVydGljZXMpKSksIChhID0gdGhpcy5nZW9tZXRyeS52ZXJ0ZXhOb3JtYWxzKS5wdXNoLmFwcGx5KGEsIGYodGhpcy50cmFuc2Zvcm1Ob3JtYWxzKG4udmVydGV4Tm9ybWFscykpKSwgKGEgPSB0aGlzLmdlb21ldHJ5LnV2cykucHVzaC5hcHBseShhLCBmKG4udXZzKSksIHRoaXMucmVuZGVyZXIuX2RvRmlsbCAmJiAoYSA9IHRoaXMuZ2VvbWV0cnkuZmFjZXMpLnB1c2guYXBwbHkoYSwgZihuLmZhY2VzLm1hcChmdW5jdGlvbihUKSB7XG4gICAgICAgICAgICByZXR1cm4gVC5tYXAoZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICByZXR1cm4gXyArIHA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkpLCB0aGlzLnJlbmRlcmVyLl9kb1N0cm9rZSAmJiAoYSA9IHRoaXMuZ2VvbWV0cnkuZWRnZXMpLnB1c2guYXBwbHkoYSwgZihuLmVkZ2VzLm1hcChmdW5jdGlvbihUKSB7XG4gICAgICAgICAgICByZXR1cm4gVC5tYXAoZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICByZXR1cm4gXyArIHA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkpLCBmKG4udmVydGV4Q29sb3JzKSk7IGoubGVuZ3RoIDwgNCAqIG4udmVydGljZXMubGVuZ3RoOyApXG4gICAgICAgICAgICBqLnB1c2guYXBwbHkoaiwgZih0aGlzLnJlbmRlcmVyLmN1ckZpbGxDb2xvcikpO1xuICAgICAgICAgIChhID0gdGhpcy5nZW9tZXRyeS52ZXJ0ZXhDb2xvcnMpLnB1c2guYXBwbHkoYSwgZihqKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkSW1tZWRpYXRlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMucmVuZGVyZXIuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeSwgYSA9IHRoaXMucmVuZGVyZXIuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUsIGMgPSBbXTtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5fZG9GaWxsKVxuICAgICAgICAgICAgaWYgKGEgPT09IGguVFJJQU5HTEVfU1RSSVAgfHwgYSA9PT0gaC5RVUFEX1NUUklQKVxuICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMjsgcCA8IG4udmVydGljZXMubGVuZ3RoOyBwKyspXG4gICAgICAgICAgICAgICAgcCAlIDIgPT0gMCA/IGMucHVzaChbcCwgcCAtIDEsIHAgLSAyXSkgOiBjLnB1c2goW3AsIHAgLSAyLCBwIC0gMV0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gaC5UUklBTkdMRV9GQU4pXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAyOyBqIDwgbi52ZXJ0aWNlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBjLnB1c2goWzAsIGogLSAxLCBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgbi52ZXJ0aWNlcy5sZW5ndGg7IFQgKz0gMylcbiAgICAgICAgICAgICAgICBjLnB1c2goW1QsIFQgKyAxLCBUICsgMl0pO1xuICAgICAgICAgIHRoaXMuYWRkR2VvbWV0cnkoT2JqZWN0LmFzc2lnbih7fSwgbiwgeyBmYWNlczogYyB9KSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWRkUmV0YWluZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB0aGlzLmFkZEdlb21ldHJ5KG4ubW9kZWwpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZpbmlzaFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuX3BJbnN0LnBvcCgpLCB0aGlzLmdlb21ldHJ5O1xuICAgICAgICB9IH1dKSAmJiByKGkucHJvdG90eXBlLCBsKSwgbztcbiAgICAgIH0oKTtcbiAgICAgIHMubmV4dEdlb21ldHJ5SWQgPSAwLCBDLmRlZmF1bHQgPSBzO1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnlcIjogMTU0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCI6IDE4MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOiAxODMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMzI1OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShyKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHM7XG4gICAgICAgIH0gOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHM7XG4gICAgICAgIH0pKHIpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnNpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnNpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB5ID0gKGYgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiBmLl9fZXNNb2R1bGUgPyBmIDogeyBkZWZhdWx0OiBmIH0sIHUgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmIChyICYmIHIuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgaWYgKHIgPT09IG51bGwgfHwgZyhyKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogciB9O1xuICAgICAgICB2YXIgcyA9IGgoKTtcbiAgICAgICAgaWYgKHMgJiYgcy5oYXMocikpXG4gICAgICAgICAgcmV0dXJuIHMuZ2V0KHIpO1xuICAgICAgICB2YXIgbywgaSA9IHt9LCBsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAobyBpbiByKSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG8pICYmICgobiA9IGwgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIG8pIDogbnVsbCkgJiYgKG4uZ2V0IHx8IG4uc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCBuKSA6IGlbb10gPSByW29dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5kZWZhdWx0ID0gciwgcyAmJiBzLnNldChyLCBpKSwgaTtcbiAgICAgIH0odChcIi4uL2NvcmUvY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSwgcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnKHIpIHtcbiAgICAgICAgcmV0dXJuIChnID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBtKHMpO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0ocyk7XG4gICAgICAgIH0pKHIpO1xuICAgICAgfVxuICAgICAgeS5kZWZhdWx0LnByb3RvdHlwZS5vcmJpdENvbnRyb2wgPSBmdW5jdGlvbihyLCBzLCBvLCBqKSB7XG4gICAgICAgIHZhciBsID0gdGhpcywgbiA9ICh0aGlzLl9hc3NlcnQzZChcIm9yYml0Q29udHJvbFwiKSwgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJvcmJpdENvbnRyb2xcIiwgYXJndW1lbnRzKSwgdGhpcy5fcmVuZGVyZXIuX2N1ckNhbWVyYSk7XG4gICAgICAgIHIgPT09IHZvaWQgMCAmJiAociA9IDEpLCBzID09PSB2b2lkIDAgJiYgKHMgPSByKSwgbyA9PT0gdm9pZCAwICYmIChvID0gMSksIGcoaikgIT09IFwib2JqZWN0XCIgJiYgKGogPSB7fSksIHRoaXMuY29udGV4dE1lbnVEaXNhYmxlZCAhPT0gITAgJiYgKHRoaXMuY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIHRoaXMuX3NldFByb3BlcnR5KFwiY29udGV4dE1lbnVEaXNhYmxlZFwiLCAhMCkpLCB0aGlzLndoZWVsRGVmYXVsdERpc2FibGVkICE9PSAhMCAmJiAodGhpcy5jYW52YXMub253aGVlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgdGhpcy5fc2V0UHJvcGVydHkoXCJ3aGVlbERlZmF1bHREaXNhYmxlZFwiLCAhMCkpO1xuICAgICAgICB2YXIgXyA9IGouZGlzYWJsZVRvdWNoQWN0aW9ucztcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbnNEaXNhYmxlZCA9PT0gITAgfHwgXyAhPT0gdm9pZCAwICYmICFfIHx8ICh0aGlzLmNhbnZhcy5zdHlsZVtcInRvdWNoLWFjdGlvblwiXSA9IFwibm9uZVwiLCB0aGlzLl9zZXRQcm9wZXJ0eShcInRvdWNoQWN0aW9uc0Rpc2FibGVkXCIsICEwKSk7XG4gICAgICAgIHZhciBhLCBjLCBwLCBfID0gai5mcmVlUm90YXRpb24sIGogPSBfICE9PSB2b2lkIDAgJiYgXywgVCA9IFtdLCBfID0gKHRoaXMudG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICBsLl9yZW5kZXJlci5wcmV2VG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICAgIFIuaWQgPT09IEwuaWQgJiYgKEwgPSB7IHg6IFIueCwgeTogUi55LCBweDogTC54LCBweTogTC55IH0sIFQucHVzaChMKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0aGlzLl9yZW5kZXJlci5wcmV2VG91Y2hlcyA9IHRoaXMudG91Y2hlcywgMCksIFMgPSAwLCBFID0gMCwgQSA9IDAsIHggPSAwLCBQID0gdGhpcy5oZWlnaHQgPCB0aGlzLndpZHRoID8gdGhpcy5oZWlnaHQgOiB0aGlzLndpZHRoLCBNID0gITE7XG4gICAgICAgIHJldHVybiAwIDwgVC5sZW5ndGggPyAoTSA9IDAgPCBUWzBdLnggJiYgVFswXS54IDwgdGhpcy53aWR0aCAmJiAwIDwgVFswXS55ICYmIFRbMF0ueSA8IHRoaXMuaGVpZ2h0LCBULmxlbmd0aCA9PT0gMSA/IChTID0gLXIgKiAoKGEgPSBUWzBdKS54IC0gYS5weCkgLyBQLCBFID0gcyAqIChhLnkgLSBhLnB5KSAvIFApIDogKGEgPSBUWzBdLCBjID0gVFsxXSwgXyA9IC0oTWF0aC5oeXBvdChhLnggLSBjLngsIGEueSAtIGMueSkgLSBNYXRoLmh5cG90KGEucHggLSBjLnB4LCBhLnB5IC0gYy5weSkpICogbyAqIDRlLTQsIEEgPSAwLjUgKiAoYS54ICsgYy54KSAtIDAuNSAqIChhLnB4ICsgYy5weCksIHggPSAwLjUgKiAoYS55ICsgYy55KSAtIDAuNSAqIChhLnB5ICsgYy5weSkpLCAwIDwgdGhpcy50b3VjaGVzLmxlbmd0aCA/IE0gJiYgKHRoaXMuX3JlbmRlcmVyLmV4ZWN1dGVSb3RhdGVBbmRNb3ZlID0gITAsIHRoaXMuX3JlbmRlcmVyLmV4ZWN1dGVab29tID0gITApIDogKHRoaXMuX3JlbmRlcmVyLmV4ZWN1dGVSb3RhdGVBbmRNb3ZlID0gITEsIHRoaXMuX3JlbmRlcmVyLmV4ZWN1dGVab29tID0gITEpKSA6IChNID0gMCA8IHRoaXMubW91c2VYICYmIHRoaXMubW91c2VYIDwgdGhpcy53aWR0aCAmJiAwIDwgdGhpcy5tb3VzZVkgJiYgdGhpcy5tb3VzZVkgPCB0aGlzLmhlaWdodCwgdGhpcy5fbW91c2VXaGVlbERlbHRhWSAhPT0gMCA/IChfID0gTWF0aC5zaWduKHRoaXMuX21vdXNlV2hlZWxEZWx0YVkpICogbywgXyAqPSAwLjAxLCB0aGlzLl9tb3VzZVdoZWVsRGVsdGFZID0gMCwgTSAmJiAodGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVpvb20gPSAhMCkpIDogdGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVpvb20gPSAhMSwgdGhpcy5tb3VzZUlzUHJlc3NlZCA/ICh0aGlzLm1vdXNlQnV0dG9uID09PSB0aGlzLkxFRlQgPyAoUyA9IC1yICogdGhpcy5tb3ZlZFggLyBQLCBFID0gcyAqIHRoaXMubW92ZWRZIC8gUCkgOiB0aGlzLm1vdXNlQnV0dG9uID09PSB0aGlzLlJJR0hUICYmIChBID0gdGhpcy5tb3ZlZFgsIHggPSB0aGlzLm1vdmVkWSAqIG4ueVNjYWxlKSwgTSAmJiAodGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVJvdGF0ZUFuZE1vdmUgPSAhMCkpIDogdGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVJvdGF0ZUFuZE1vdmUgPSAhMSksIF8gIT09IDAgJiYgdGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVpvb20gJiYgKHRoaXMuX3JlbmRlcmVyLnpvb21WZWxvY2l0eSArPSBfKSwgMWUtMyA8IE1hdGguYWJzKHRoaXMuX3JlbmRlcmVyLnpvb21WZWxvY2l0eSkgPyAoaiA/IG4uX29yYml0RnJlZSgwLCAwLCB0aGlzLl9yZW5kZXJlci56b29tVmVsb2NpdHkpIDogbi5fb3JiaXQoMCwgMCwgdGhpcy5fcmVuZGVyZXIuem9vbVZlbG9jaXR5KSwgbi5wcm9qTWF0cml4Lm1hdDRbMTVdICE9PSAwICYmIChuLnByb2pNYXRyaXgubWF0NFswXSAqPSBNYXRoLnBvdygxMCwgLXRoaXMuX3JlbmRlcmVyLnpvb21WZWxvY2l0eSksIG4ucHJvak1hdHJpeC5tYXQ0WzVdICo9IE1hdGgucG93KDEwLCAtdGhpcy5fcmVuZGVyZXIuem9vbVZlbG9jaXR5KSwgdGhpcy5fcmVuZGVyZXIudVBNYXRyaXgubWF0NFswXSA9IG4ucHJvak1hdHJpeC5tYXQ0WzBdLCB0aGlzLl9yZW5kZXJlci51UE1hdHJpeC5tYXQ0WzVdID0gbi5wcm9qTWF0cml4Lm1hdDRbNV0pLCB0aGlzLl9yZW5kZXJlci56b29tVmVsb2NpdHkgKj0gMC44NSkgOiB0aGlzLl9yZW5kZXJlci56b29tVmVsb2NpdHkgPSAwLCBTID09PSAwICYmIEUgPT09IDAgfHwgIXRoaXMuX3JlbmRlcmVyLmV4ZWN1dGVSb3RhdGVBbmRNb3ZlIHx8IHRoaXMuX3JlbmRlcmVyLnJvdGF0ZVZlbG9jaXR5LmFkZCgwLjYgKiBTLCAwLjYgKiBFKSwgMWUtNiA8IHRoaXMuX3JlbmRlcmVyLnJvdGF0ZVZlbG9jaXR5Lm1hZ1NxKCkgPyAoaiA/IG4uX29yYml0RnJlZSgtdGhpcy5fcmVuZGVyZXIucm90YXRlVmVsb2NpdHkueCwgdGhpcy5fcmVuZGVyZXIucm90YXRlVmVsb2NpdHkueSwgMCkgOiBuLl9vcmJpdCh0aGlzLl9yZW5kZXJlci5yb3RhdGVWZWxvY2l0eS54LCB0aGlzLl9yZW5kZXJlci5yb3RhdGVWZWxvY2l0eS55LCAwKSwgdGhpcy5fcmVuZGVyZXIucm90YXRlVmVsb2NpdHkubXVsdCgwLjg1KSkgOiB0aGlzLl9yZW5kZXJlci5yb3RhdGVWZWxvY2l0eS5zZXQoMCwgMCksIEEgPT09IDAgJiYgeCA9PT0gMCB8fCAhdGhpcy5fcmVuZGVyZXIuZXhlY3V0ZVJvdGF0ZUFuZE1vdmUgfHwgKGEgPSAyICogQSAvIHRoaXMud2lkdGgsIGMgPSAyICogLXggLyB0aGlzLmhlaWdodCwgdGhpcy5fcmVuZGVyZXIubW92ZVZlbG9jaXR5LmFkZCgwLjE1ICogYSwgMC4xNSAqIGMpKSwgMWUtNiA8IHRoaXMuX3JlbmRlcmVyLm1vdmVWZWxvY2l0eS5tYWdTcSgpID8gKG8gPSBuLl9nZXRMb2NhbEF4ZXMoKSwgciA9IG4uZXllWCAtIG4uY2VudGVyWCwgcyA9IG4uZXllWSAtIG4uY2VudGVyWSwgUCA9IG4uZXllWiAtIG4uY2VudGVyWiwgTSA9IE1hdGguc3FydChyICogciArIHMgKiBzICsgUCAqIFApLCBfID0gbmV3IHkuZGVmYXVsdC5WZWN0b3Iobi5jZW50ZXJYLCBuLmNlbnRlclksIG4uY2VudGVyWiksIF8gPSBuLmNhbWVyYU1hdHJpeC5tdWx0aXBseVBvaW50KF8pLCAoXyA9IHRoaXMuX3JlbmRlcmVyLnVQTWF0cml4Lm11bHRpcGx5QW5kTm9ybWFsaXplUG9pbnQoXykpLnggLT0gdGhpcy5fcmVuZGVyZXIubW92ZVZlbG9jaXR5LngsIF8ueSAtPSB0aGlzLl9yZW5kZXJlci5tb3ZlVmVsb2NpdHkueSwgRSA9IChTID0gdGhpcy5fcmVuZGVyZXIudVBNYXRyaXgubWF0NClbMTVdID09PSAwID8gKHAgPSAoU1s4XSArIF8ueCkgLyBTWzBdICogTSwgKFNbOV0gKyBfLnkpIC8gU1s1XSAqIE0pIDogKHAgPSAoXy54IC0gU1sxMl0pIC8gU1swXSwgKF8ueSAtIFNbMTNdKSAvIFNbNV0pLCBuLnNldFBvc2l0aW9uKG4uZXllWCArIHAgKiBvLnhbMF0gKyBFICogby55WzBdLCBuLmV5ZVkgKyBwICogby54WzFdICsgRSAqIG8ueVsxXSwgbi5leWVaICsgcCAqIG8ueFsyXSArIEUgKiBvLnlbMl0pLCB0aGlzLl9yZW5kZXJlci5tb3ZlVmVsb2NpdHkubXVsdCgwLjg1KSkgOiB0aGlzLl9yZW5kZXJlci5tb3ZlVmVsb2NpdHkuc2V0KDAsIDApLCB0aGlzO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5kZWJ1Z01vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJkZWJ1Z01vZGVcIik7XG4gICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KHIpLCBvID0gMDsgbyA8IHI7IG8rKylcbiAgICAgICAgICBzW29dID0gYXJndW1lbnRzW29dO1xuICAgICAgICB5LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImRlYnVnTW9kZVwiLCBzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3JlZ2lzdGVyZWRNZXRob2RzLnBvc3QubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZE1ldGhvZHMucG9zdFtpXS50b1N0cmluZygpICE9PSB0aGlzLl9ncmlkKCkudG9TdHJpbmcoKSAmJiB0aGlzLl9yZWdpc3RlcmVkTWV0aG9kcy5wb3N0W2ldLnRvU3RyaW5nKCkgIT09IHRoaXMuX2F4ZXNJY29uKCkudG9TdHJpbmcoKSB8fCB0aGlzLl9yZWdpc3RlcmVkTWV0aG9kcy5wb3N0LnNwbGljZShpLCAxKTtcbiAgICAgICAgc1swXSA9PT0gdS5HUklEID8gdGhpcy5yZWdpc3Rlck1ldGhvZChcInBvc3RcIiwgdGhpcy5fZ3JpZChzWzFdLCBzWzJdLCBzWzNdLCBzWzRdLCBzWzVdKSkgOiBzWzBdID09PSB1LkFYRVMgPyB0aGlzLnJlZ2lzdGVyTWV0aG9kKFwicG9zdFwiLCB0aGlzLl9heGVzSWNvbihzWzFdLCBzWzJdLCBzWzNdLCBzWzRdKSkgOiAodGhpcy5yZWdpc3Rlck1ldGhvZChcInBvc3RcIiwgdGhpcy5fZ3JpZChzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCBzWzRdKSksIHRoaXMucmVnaXN0ZXJNZXRob2QoXCJwb3N0XCIsIHRoaXMuX2F4ZXNJY29uKHNbNV0sIHNbNl0sIHNbN10sIHNbOF0pKSk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLm5vRGVidWdNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwibm9EZWJ1Z01vZGVcIik7XG4gICAgICAgIGZvciAodmFyIHIgPSB0aGlzLl9yZWdpc3RlcmVkTWV0aG9kcy5wb3N0Lmxlbmd0aCAtIDE7IDAgPD0gcjsgci0tKVxuICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRNZXRob2RzLnBvc3Rbcl0udG9TdHJpbmcoKSAhPT0gdGhpcy5fZ3JpZCgpLnRvU3RyaW5nKCkgJiYgdGhpcy5fcmVnaXN0ZXJlZE1ldGhvZHMucG9zdFtyXS50b1N0cmluZygpICE9PSB0aGlzLl9heGVzSWNvbigpLnRvU3RyaW5nKCkgfHwgdGhpcy5fcmVnaXN0ZXJlZE1ldGhvZHMucG9zdC5zcGxpY2UociwgMSk7XG4gICAgICB9LCB5LmRlZmF1bHQucHJvdG90eXBlLl9ncmlkID0gZnVuY3Rpb24ociwgcywgbywgaSwgbCkge1xuICAgICAgICByID09PSB2b2lkIDAgJiYgKHIgPSB0aGlzLndpZHRoIC8gMiksIHMgPT09IHZvaWQgMCAmJiAocyA9IE1hdGgucm91bmQociAvIDMwKSA8IDQgPyA0IDogTWF0aC5yb3VuZChyIC8gMzApKSwgbyA9PT0gdm9pZCAwICYmIChvID0gMCksIGkgPT09IHZvaWQgMCAmJiAoaSA9IDApLCBsID09PSB2b2lkIDAgJiYgKGwgPSAwKTtcbiAgICAgICAgdmFyIG4gPSByIC8gcywgYSA9IHIgLyAyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCksIHRoaXMuc3Ryb2tlKDI1NSAqIHRoaXMuX3JlbmRlcmVyLmN1clN0cm9rZUNvbG9yWzBdLCAyNTUgKiB0aGlzLl9yZW5kZXJlci5jdXJTdHJva2VDb2xvclsxXSwgMjU1ICogdGhpcy5fcmVuZGVyZXIuY3VyU3Ryb2tlQ29sb3JbMl0pLCB0aGlzLl9yZW5kZXJlci51TVZNYXRyaXguc2V0KHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEuY2FtZXJhTWF0cml4KTtcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8PSBzOyBjKyspXG4gICAgICAgICAgICB0aGlzLmJlZ2luU2hhcGUodGhpcy5MSU5FUyksIHRoaXMudmVydGV4KC1hICsgbywgaSwgYyAqIG4gLSBhICsgbCksIHRoaXMudmVydGV4KGEgKyBvLCBpLCBjICogbiAtIGEgKyBsKSwgdGhpcy5lbmRTaGFwZSgpO1xuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDw9IHM7IHArKylcbiAgICAgICAgICAgIHRoaXMuYmVnaW5TaGFwZSh0aGlzLkxJTkVTKSwgdGhpcy52ZXJ0ZXgocCAqIG4gLSBhICsgbywgaSwgLWEgKyBsKSwgdGhpcy52ZXJ0ZXgocCAqIG4gLSBhICsgbywgaSwgYSArIGwpLCB0aGlzLmVuZFNoYXBlKCk7XG4gICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHkuZGVmYXVsdC5wcm90b3R5cGUuX2F4ZXNJY29uID0gZnVuY3Rpb24ociwgcywgbywgaSkge1xuICAgICAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmIChyID0gNDAgPCB0aGlzLndpZHRoIC8gMjAgPyB0aGlzLndpZHRoIC8gMjAgOiA0MCksIHMgPT09IHZvaWQgMCAmJiAocyA9IC10aGlzLndpZHRoIC8gNCksIG8gPT09IHZvaWQgMCAmJiAobyA9IHMpLCBpID09PSB2b2lkIDAgJiYgKGkgPSBzKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCksIHRoaXMuX3JlbmRlcmVyLnVNVk1hdHJpeC5zZXQodGhpcy5fcmVuZGVyZXIuX2N1ckNhbWVyYS5jYW1lcmFNYXRyaXgpLCB0aGlzLnN0cm9rZVdlaWdodCgyKSwgdGhpcy5zdHJva2UoMjU1LCAwLCAwKSwgdGhpcy5iZWdpblNoYXBlKHRoaXMuTElORVMpLCB0aGlzLnZlcnRleChzLCBvLCBpKSwgdGhpcy52ZXJ0ZXgocyArIHIsIG8sIGkpLCB0aGlzLmVuZFNoYXBlKCksIHRoaXMuc3Ryb2tlKDAsIDI1NSwgMCksIHRoaXMuYmVnaW5TaGFwZSh0aGlzLkxJTkVTKSwgdGhpcy52ZXJ0ZXgocywgbywgaSksIHRoaXMudmVydGV4KHMsIG8gKyByLCBpKSwgdGhpcy5lbmRTaGFwZSgpLCB0aGlzLnN0cm9rZSgwLCAwLCAyNTUpLCB0aGlzLmJlZ2luU2hhcGUodGhpcy5MSU5FUyksIHRoaXMudmVydGV4KHMsIG8sIGkpLCB0aGlzLnZlcnRleChzLCBvLCBpICsgciksIHRoaXMuZW5kU2hhcGUoKSwgdGhpcy5wb3AoKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgZiA9IHkuZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IGY7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaFwiOiAxNjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCI6IDE3MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiOiAxNzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguc2lnblwiOiAxNzcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiOiAyNDIsIFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIjogMjQzIH1dLCAzMjY6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtID0gKHQgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH07XG4gICAgICBtLmRlZmF1bHQucHJvdG90eXBlLmFtYmllbnRMaWdodCA9IGZ1bmN0aW9uKHksIHUsIGgsIGcpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJhbWJpZW50TGlnaHRcIiksIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYW1iaWVudExpZ2h0XCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBmID0gdGhpcy5jb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuYW1iaWVudExpZ2h0Q29sb3JzLnB1c2goZi5fYXJyYXlbMF0sIGYuX2FycmF5WzFdLCBmLl9hcnJheVsyXSksIHRoaXMuX3JlbmRlcmVyLl9lbmFibGVMaWdodGluZyA9ICEwLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5zcGVjdWxhckNvbG9yID0gZnVuY3Rpb24oeSwgdSwgaCkge1xuICAgICAgICB0aGlzLl9hc3NlcnQzZChcInNwZWN1bGFyQ29sb3JcIiksIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwic3BlY3VsYXJDb2xvclwiLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuY29sb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnNwZWN1bGFyQ29sb3JzID0gW2cuX2FycmF5WzBdLCBnLl9hcnJheVsxXSwgZy5fYXJyYXlbMl1dLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5kaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24oeSwgbCwgaSwgZywgZiwgcikge1xuICAgICAgICB0aGlzLl9hc3NlcnQzZChcImRpcmVjdGlvbmFsTGlnaHRcIiksIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZGlyZWN0aW9uYWxMaWdodFwiLCBhcmd1bWVudHMpLCB5ID0geSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5Db2xvciA/IHkgOiB0aGlzLmNvbG9yKHksIGwsIGkpO1xuICAgICAgICB2YXIgcywgbywgbCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0sIGkgPSB0eXBlb2YgbCA9PSBcIm51bWJlclwiID8gKHMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDNdLCBvID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXSwgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSkgOiAocyA9IGwueCwgbyA9IGwueSwgbC56KSwgbCA9IE1hdGguc3FydChzICogcyArIG8gKiBvICsgaSAqIGkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbnMucHVzaChzIC8gbCwgbyAvIGwsIGkgLyBsKSwgdGhpcy5fcmVuZGVyZXIuZGlyZWN0aW9uYWxMaWdodERpZmZ1c2VDb2xvcnMucHVzaCh5Ll9hcnJheVswXSwgeS5fYXJyYXlbMV0sIHkuX2FycmF5WzJdKSwgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5fcmVuZGVyZXIuZGlyZWN0aW9uYWxMaWdodFNwZWN1bGFyQ29sb3JzLCB0aGlzLl9yZW5kZXJlci5zcGVjdWxhckNvbG9ycyksIHRoaXMuX3JlbmRlcmVyLl9lbmFibGVMaWdodGluZyA9ICEwLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5wb2ludExpZ2h0ID0gZnVuY3Rpb24oeSwgaSwgbCwgZywgZiwgcikge1xuICAgICAgICB0aGlzLl9hc3NlcnQzZChcInBvaW50TGlnaHRcIiksIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwicG9pbnRMaWdodFwiLCBhcmd1bWVudHMpLCB5ID0geSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5Db2xvciA/IHkgOiB0aGlzLmNvbG9yKHksIGksIGwpO1xuICAgICAgICB2YXIgcywgbywgaSA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0sIGwgPSB0eXBlb2YgaSA9PSBcIm51bWJlclwiID8gKHMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDNdLCBvID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXSwgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSkgOiAocyA9IGkueCwgbyA9IGkueSwgaS56KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnBvaW50TGlnaHRQb3NpdGlvbnMucHVzaChzLCBvLCBsKSwgdGhpcy5fcmVuZGVyZXIucG9pbnRMaWdodERpZmZ1c2VDb2xvcnMucHVzaCh5Ll9hcnJheVswXSwgeS5fYXJyYXlbMV0sIHkuX2FycmF5WzJdKSwgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5fcmVuZGVyZXIucG9pbnRMaWdodFNwZWN1bGFyQ29sb3JzLCB0aGlzLl9yZW5kZXJlci5zcGVjdWxhckNvbG9ycyksIHRoaXMuX3JlbmRlcmVyLl9lbmFibGVMaWdodGluZyA9ICEwLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5pbWFnZUxpZ2h0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hY3RpdmVJbWFnZUxpZ2h0ID0geSwgdGhpcy5fcmVuZGVyZXIuX2VuYWJsZUxpZ2h0aW5nID0gITA7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLnBhbm9yYW1hID0gZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLmZpbHRlcih0aGlzLl9yZW5kZXJlci5fZ2V0U3BoZXJlTWFwcGluZyh5KSk7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLmxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hc3NlcnQzZChcImxpZ2h0c1wiKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmNvbG9yKFwicmdiKDEyOCwxMjgsMTI4KVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1iaWVudExpZ2h0KHkpLCB0aGlzLmRpcmVjdGlvbmFsTGlnaHQoeSwgMCwgMCwgLTEpLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5saWdodEZhbGxvZmYgPSBmdW5jdGlvbih5LCB1LCBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3NlcnQzZChcImxpZ2h0RmFsbG9mZlwiKSwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsaWdodEZhbGxvZmZcIiwgYXJndW1lbnRzKSwgeSA8IDAgJiYgKHkgPSAwLCBjb25zb2xlLndhcm4oXCJWYWx1ZSBvZiBjb25zdGFudCBhcmd1bWVudCBpbiBsaWdodEZhbGxvZmYoKSBzaG91bGQgYmUgbmV2ZXIgYmUgbmVnYXRpdmUuIFNldCB0byAwLlwiKSksIHUgPCAwICYmICh1ID0gMCwgY29uc29sZS53YXJuKFwiVmFsdWUgb2YgbGluZWFyIGFyZ3VtZW50IGluIGxpZ2h0RmFsbG9mZigpIHNob3VsZCBiZSBuZXZlciBiZSBuZWdhdGl2ZS4gU2V0IHRvIDAuXCIpKSwgaCA8IDAgJiYgKGggPSAwLCBjb25zb2xlLndhcm4oXCJWYWx1ZSBvZiBxdWFkcmF0aWMgYXJndW1lbnQgaW4gbGlnaHRGYWxsb2ZmKCkgc2hvdWxkIGJlIG5ldmVyIGJlIG5lZ2F0aXZlLiBTZXQgdG8gMC5cIikpLCB5ID09PSAwICYmIHUgPT09IDAgJiYgaCA9PT0gMCAmJiAoeSA9IDEsIGNvbnNvbGUud2FybihcIkVpdGhlciBvbmUgb2YgdGhlIHRocmVlIGFyZ3VtZW50cyBpbiBsaWdodEZhbGxvZmYoKSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFNldCBjb25zdGFudCBhcmd1bWVudCB0byAxLlwiKSksIHRoaXMuX3JlbmRlcmVyLmNvbnN0YW50QXR0ZW51YXRpb24gPSB5LCB0aGlzLl9yZW5kZXJlci5saW5lYXJBdHRlbnVhdGlvbiA9IHUsIHRoaXMuX3JlbmRlcmVyLnF1YWRyYXRpY0F0dGVudWF0aW9uID0gaCwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuc3BvdExpZ2h0ID0gZnVuY3Rpb24oeSwgdSwgaCwgZywgZiwgciwgcywgbywgaSwgbCwgbikge1xuICAgICAgICB0aGlzLl9hc3NlcnQzZChcInNwb3RMaWdodFwiKSwgbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzcG90TGlnaHRcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGEsIGMsIHAsIGogPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBhID0gdGhpcy5jb2xvcih5LCB1LCBoKSwgYyA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKGcsIGYsIHIpLCBwID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IocywgbywgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB5IGluc3RhbmNlb2YgbS5kZWZhdWx0LkNvbG9yID8gKGEgPSB5LCBjID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IodSwgaCwgZyksIHAgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihmLCByLCBzKSwgbCA9IG8sIG4gPSBpKSA6IGcgaW5zdGFuY2VvZiBtLmRlZmF1bHQuVmVjdG9yID8gKGEgPSB0aGlzLmNvbG9yKHksIHUsIGgpLCBjID0gZywgcCA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKGYsIHIsIHMpLCBsID0gbywgbiA9IGkpIDogcyBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgPyAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihnLCBmLCByKSwgcCA9IHMsIGwgPSBvLCBuID0gaSkgOiAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihnLCBmLCByKSwgcCA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKHMsIG8sIGkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGwgPSAocCA9IHkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuQ29sb3IgPyAoYSA9IHksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3Rvcih1LCBoLCBnKSwgbmV3IG0uZGVmYXVsdC5WZWN0b3IoZiwgciwgcykpIDogZyBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgPyAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBnLCBuZXcgbS5kZWZhdWx0LlZlY3RvcihmLCByLCBzKSkgOiAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihnLCBmLCByKSwgcyksIG8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgeSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5Db2xvciAmJiB1IGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChhID0geSwgYyA9IHUsIHAgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihoLCBnLCBmKSwgbCA9IHIsIG4gPSBzKSA6IHkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuQ29sb3IgJiYgZiBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgPyAoYSA9IHksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3Rvcih1LCBoLCBnKSwgcCA9IGYsIGwgPSByLCBuID0gcykgOiBnIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciAmJiBmIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChhID0gdGhpcy5jb2xvcih5LCB1LCBoKSwgYyA9IGcsIHAgPSBmLCBsID0gciwgbiA9IHMpIDogcCA9IHkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuQ29sb3IgPyAoYSA9IHksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3Rvcih1LCBoLCBnKSwgbmV3IG0uZGVmYXVsdC5WZWN0b3IoZiwgciwgcykpIDogZyBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgPyAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBnLCBuZXcgbS5kZWZhdWx0LlZlY3RvcihmLCByLCBzKSkgOiAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihnLCBmLCByKSwgcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBnIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciAmJiBmIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChhID0gdGhpcy5jb2xvcih5LCB1LCBoKSwgYyA9IGcsIHAgPSBmLCBsID0gcikgOiB5IGluc3RhbmNlb2YgbS5kZWZhdWx0LkNvbG9yICYmIGYgaW5zdGFuY2VvZiBtLmRlZmF1bHQuVmVjdG9yID8gKGEgPSB5LCBjID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IodSwgaCwgZyksIHAgPSBmLCBsID0gcikgOiB5IGluc3RhbmNlb2YgbS5kZWZhdWx0LkNvbG9yICYmIHUgaW5zdGFuY2VvZiBtLmRlZmF1bHQuVmVjdG9yICYmIChhID0geSwgYyA9IHUsIHAgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihoLCBnLCBmKSwgbCA9IHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgeSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5Db2xvciAmJiB1IGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciAmJiBoIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChhID0geSwgYyA9IHUsIHAgPSBoLCBsID0gZywgbiA9IGYpIDogZyBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgJiYgZiBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgPyAoYSA9IHRoaXMuY29sb3IoeSwgdSwgaCksIGMgPSBnLCBwID0gZikgOiB5IGluc3RhbmNlb2YgbS5kZWZhdWx0LkNvbG9yICYmIGYgaW5zdGFuY2VvZiBtLmRlZmF1bHQuVmVjdG9yID8gKGEgPSB5LCBjID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IodSwgaCwgZyksIHAgPSBmKSA6IHkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuQ29sb3IgJiYgdSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5WZWN0b3IgJiYgKGEgPSB5LCBjID0gdSwgcCA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKGgsIGcsIGYpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGEgPSB5LCBjID0gdSwgcCA9IGgsIGwgPSBnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYSA9IHksIGMgPSB1LCBwID0gaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiU29ycnksIGlucHV0IGZvciBzcG90bGlnaHQoKSBpcyBub3QgaW4gcHJlc2NyaWJlZCBmb3JtYXQuIFRvbyBcIi5jb25jYXQoaiA8IDMgPyBcImZld1wiIDogXCJtYW55XCIsIFwiIGFyZ3VtZW50cyB3ZXJlIHByb3ZpZGVkXCIpKSwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuc3BvdExpZ2h0RGlmZnVzZUNvbG9ycy5wdXNoKGEuX2FycmF5WzBdLCBhLl9hcnJheVsxXSwgYS5fYXJyYXlbMl0pLCBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLl9yZW5kZXJlci5zcG90TGlnaHRTcGVjdWxhckNvbG9ycywgdGhpcy5fcmVuZGVyZXIuc3BlY3VsYXJDb2xvcnMpLCB0aGlzLl9yZW5kZXJlci5zcG90TGlnaHRQb3NpdGlvbnMucHVzaChjLngsIGMueSwgYy56KSwgcC5ub3JtYWxpemUoKSwgdGhpcy5fcmVuZGVyZXIuc3BvdExpZ2h0RGlyZWN0aW9ucy5wdXNoKHAueCwgcC55LCBwLnopLCBsID09PSB2b2lkIDAgJiYgKGwgPSBNYXRoLlBJIC8gMyksIG4gIT09IHZvaWQgMCAmJiBuIDwgMSA/IChuID0gMSwgY29uc29sZS53YXJuKFwiVmFsdWUgb2YgY29uY2VudHJhdGlvbiBuZWVkcyB0byBiZSBncmVhdGVyIHRoYW4gMS4gU2V0dGluZyBpdCB0byAxXCIpKSA6IG4gPT09IHZvaWQgMCAmJiAobiA9IDEwMCksIGwgPSB0aGlzLl9yZW5kZXJlci5fcEluc3QuX3RvUmFkaWFucyhsKSwgdGhpcy5fcmVuZGVyZXIuc3BvdExpZ2h0QW5nbGUucHVzaChNYXRoLmNvcyhsKSksIHRoaXMuX3JlbmRlcmVyLnNwb3RMaWdodENvbmMucHVzaChuKSwgdGhpcy5fcmVuZGVyZXIuX2VuYWJsZUxpZ2h0aW5nID0gITAsIHRoaXM7XG4gICAgICB9LCBtLmRlZmF1bHQucHJvdG90eXBlLm5vTGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwibm9MaWdodHNcIik7XG4gICAgICAgIGZvciAodmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoLCB1ID0gbmV3IEFycmF5KHkpLCBoID0gMDsgaCA8IHk7IGgrKylcbiAgICAgICAgICB1W2hdID0gYXJndW1lbnRzW2hdO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJub0xpZ2h0c1wiLCB1KSwgdGhpcy5fcmVuZGVyZXIuYWN0aXZlSW1hZ2VMaWdodCA9IG51bGwsIHRoaXMuX3JlbmRlcmVyLl9lbmFibGVMaWdodGluZyA9ICExLCB0aGlzLl9yZW5kZXJlci5hbWJpZW50TGlnaHRDb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5fcmVuZGVyZXIuc3BlY3VsYXJDb2xvcnMgPSBbMSwgMSwgMV0sIHRoaXMuX3JlbmRlcmVyLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25zLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLmRpcmVjdGlvbmFsTGlnaHREaWZmdXNlQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLmRpcmVjdGlvbmFsTGlnaHRTcGVjdWxhckNvbG9ycy5sZW5ndGggPSAwLCB0aGlzLl9yZW5kZXJlci5wb2ludExpZ2h0UG9zaXRpb25zLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLnBvaW50TGlnaHREaWZmdXNlQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLnBvaW50TGlnaHRTcGVjdWxhckNvbG9ycy5sZW5ndGggPSAwLCB0aGlzLl9yZW5kZXJlci5zcG90TGlnaHRQb3NpdGlvbnMubGVuZ3RoID0gMCwgdGhpcy5fcmVuZGVyZXIuc3BvdExpZ2h0RGlyZWN0aW9ucy5sZW5ndGggPSAwLCB0aGlzLl9yZW5kZXJlci5zcG90TGlnaHREaWZmdXNlQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLnNwb3RMaWdodFNwZWN1bGFyQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLnNwb3RMaWdodEFuZ2xlLmxlbmd0aCA9IDAsIHRoaXMuX3JlbmRlcmVyLnNwb3RMaWdodENvbmMubGVuZ3RoID0gMCwgdGhpcy5fcmVuZGVyZXIuY29uc3RhbnRBdHRlbnVhdGlvbiA9IDEsIHRoaXMuX3JlbmRlcmVyLmxpbmVhckF0dGVudWF0aW9uID0gMCwgdGhpcy5fcmVuZGVyZXIucXVhZHJhdGljQXR0ZW51YXRpb24gPSAwLCB0aGlzLl9yZW5kZXJlci5fdXNlU2hpbmluZXNzID0gMSwgdGhpcy5fcmVuZGVyZXIuX3VzZU1ldGFsbmVzcyA9IDAsIHRoaXM7XG4gICAgICB9LCB0ID0gbS5kZWZhdWx0LCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXJcIjogMTU2IH1dLCAzMjc6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHMpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgICAgICAgfSkocyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG4gICAgICB2YXIgeSA9IChyID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgci5fX2VzTW9kdWxlID8gciA6IHsgZGVmYXVsdDogciB9O1xuICAgICAgZnVuY3Rpb24gdShzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmV3IEFycmF5KG8ubGVuZ3RoKTsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIGxbaV0gPSBvW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KHMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChvKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICAgICAgfShzKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgocywgbywgaSwgbCwgbiwgYSwgYykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwID0gc1thXShjKSwgaiA9IHAudmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKFQpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCBpKFQpO1xuICAgICAgICB9XG4gICAgICAgIHAuZG9uZSA/IG8oaikgOiBQcm9taXNlLnJlc29sdmUoaikudGhlbihsLCBuKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGcocykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLCBpID0gYXJndW1lbnRzO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihsLCBuKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHMuYXBwbHkobywgaSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjKGopIHtcbiAgICAgICAgICAgICAgaChhLCBsLCBuLCBjLCBwLCBcIm5leHRcIiwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwKGopIHtcbiAgICAgICAgICAgICAgaChhLCBsLCBuLCBjLCBwLCBcInRocm93XCIsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyh2b2lkIDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihzKSB7XG4gICAgICAgIHJldHVybiAoZiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbShvKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKG8pO1xuICAgICAgICB9KShzKTtcbiAgICAgIH1cbiAgICAgIHQoXCIuL3A1Lkdlb21ldHJ5XCIpLCB5LmRlZmF1bHQucHJvdG90eXBlLmxvYWRNb2RlbCA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsb2FkTW9kZWxcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGksIGwsIG4gPSAhMSwgYSA9ICExLCBjID0gITEsIHAgPSBzLnNsaWNlKC00KSwgaiA9IChvICYmIGYobykgPT09IFwib2JqZWN0XCIgPyAobiA9IG8ubm9ybWFsaXplIHx8ICExLCBpID0gby5zdWNjZXNzQ2FsbGJhY2ssIGwgPSBvLmZhaWx1cmVDYWxsYmFjaywgcCA9IG8uZmlsZVR5cGUgfHwgcCwgYSA9IG8uZmxpcFUgfHwgITEsIGMgPSBvLmZsaXBWIHx8ICExKSA6IHR5cGVvZiBvID09IFwiYm9vbGVhblwiID8gKG4gPSBvLCBpID0gYXJndW1lbnRzWzJdLCBsID0gYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0gIT09IHZvaWQgMCAmJiAocCA9IGFyZ3VtZW50c1s0XSkpIDogKGkgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogdm9pZCAwLCBsID0gYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10gIT09IHZvaWQgMCAmJiAocCA9IGFyZ3VtZW50c1szXSkpLCBuZXcgeS5kZWZhdWx0Lkdlb21ldHJ5KCkpLCBUID0gKGouZ2lkID0gXCJcIi5jb25jYXQocywgXCJ8XCIpLmNvbmNhdChuKSwgdGhpcyk7XG4gICAgICAgIGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgcmV0dXJuIChfID0gZyhyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBFKEEpIHtcbiAgICAgICAgICAgIHZhciB4LCBQLCBNLCBSO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICAgICAgZm9yICg7IDsgKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoTC5wcmV2ID0gTC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoeCA9IFtdLCBQID0gMDsgUCA8IEEubGVuZ3RoOyBQKyspXG4gICAgICAgICAgICAgICAgICAgICAgKE0gPSBBW1BdLm1hdGNoKC9ebXRsbGliICguKykvKSkgJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgRiA9IFwiXCIsIFYgPSBNWzFdLCBHID0gcy5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBGID0gMSA8IEcubGVuZ3RoID8gKEcucG9wKCksIEcuam9pbihcIi9cIikgKyBcIi9cIiArIFYpIDogViwgeC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShGKS50aGVuKGZ1bmN0aW9uKFUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFUgPyAoVyA9IFQsIFggPSBGLCBuZXcgUHJvbWlzZShmdW5jdGlvbihuZSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBPID0gbnVsbCwgRCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFcubG9hZFN0cmluZ3MoWCwgZnVuY3Rpb24oQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgWSA9IDA7IFkgPCBCLmxlbmd0aDsgKytZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBKLCB0ZSA9IEJbWV0udHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlWzBdID09PSBcIm5ld210bFwiID8gKEogPSB0ZVsxXSwgRFtPID0gSl0gPSB7fSkgOiB0ZVswXSA9PT0gXCJLZFwiID8gRFtPXS5kaWZmdXNlQ29sb3IgPSBbcGFyc2VGbG9hdCh0ZVsxXSksIHBhcnNlRmxvYXQodGVbMl0pLCBwYXJzZUZsb2F0KHRlWzNdKV0gOiB0ZVswXSA9PT0gXCJLYVwiID8gRFtPXS5hbWJpZW50Q29sb3IgPSBbcGFyc2VGbG9hdCh0ZVsxXSksIHBhcnNlRmxvYXQodGVbMl0pLCBwYXJzZUZsb2F0KHRlWzNdKV0gOiB0ZVswXSA9PT0gXCJLc1wiID8gRFtPXS5zcGVjdWxhckNvbG9yID0gW3BhcnNlRmxvYXQodGVbMV0pLCBwYXJzZUZsb2F0KHRlWzJdKSwgcGFyc2VGbG9hdCh0ZVszXSldIDogdGVbMF0gPT09IFwibWFwX0tkXCIgJiYgKERbT10udGV4dHVyZVBhdGggPSB0ZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZShEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpIDogKGNvbnNvbGUud2FybihcIk1UTCBmaWxlIG5vdCBmb3VuZCBvciBlcnJvciBpbiBwYXJzaW5nOyBwcm9jZWVkaW5nIHdpdGhvdXQgbWF0ZXJpYWxzOiBcIi5jb25jYXQoRikpLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBXLCBYO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oVSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRXJyb3IgbG9hZGluZyBNVEwgZmlsZTogXCIuY29uY2F0KEYpLCBVKSwge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTC5wcmV2ID0gMiwgTC5uZXh0ID0gNSwgUHJvbWlzZS5hbGwoeCk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSID0gTC5zZW50LCBSID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KHUoUikpKSwgTC5hYnJ1cHQoXCJyZXR1cm5cIiwgUik7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTC5wcmV2ID0gMTAsIEwudDAgPSBMLmNhdGNoKDIpLCBMLmFicnVwdChcInJldHVyblwiLCB7fSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgRSwgbnVsbCwgW1syLCAxMF1dKTtcbiAgICAgICAgICB9KSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gUygpIHtcbiAgICAgICAgICByZXR1cm4gKFMgPSBnKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIEUoQSkge1xuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24oUCkge1xuICAgICAgICAgICAgICBmb3IgKDsgOyApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChQLnByZXYgPSBQLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAucHJldiA9IDAsIFAubmV4dCA9IDMsIGZldGNoKEEsIHsgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPSBQLnNlbnQsIFAuYWJydXB0KFwicmV0dXJuXCIsIHgub2spO1xuICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5wcmV2ID0gNywgUC50MCA9IFAuY2F0Y2goMCksIFAuYWJydXB0KFwicmV0dXJuXCIsICExKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBFLCBudWxsLCBbWzAsIDddXSk7XG4gICAgICAgICAgfSkpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwLm1hdGNoKC9cXC5zdGwkL2kpID8gdGhpcy5odHRwRG8ocywgXCJHRVRcIiwgXCJhcnJheUJ1ZmZlclwiLCBmdW5jdGlvbihFKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uKEEsIHgpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbihQKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIE0gPSBuZXcgRGF0YVZpZXcoUCksIFIgPSBbMTE1LCAxMTEsIDEwOCwgMTA1LCAxMDBdLCBMID0gMDsgTCA8IDU7IEwrKylcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24oRiwgViwgRykge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgVSA9IDAsIFcgPSBGLmxlbmd0aDsgVSA8IFc7IFUrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZbVV0gIT09IFYuZ2V0VWludDgoRyArIFUsICExKSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9KFIsIE0sIEwpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0oeCkpXG4gICAgICAgICAgICAgIChmdW5jdGlvbihQLCBNKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgUiwgTCwgRiwgViwgRywgVSwgVywgWCA9IG5ldyBEYXRhVmlldyhNKSwgbmUgPSBYLmdldFVpbnQzMig4MCwgITApLCBiID0gITEsIE8gPSAwOyBPIDwgNzA7IE8rKylcbiAgICAgICAgICAgICAgICAgIFguZ2V0VWludDMyKE8sICExKSA9PT0gMTEyOTI3MDM1MSAmJiBYLmdldFVpbnQ4KE8gKyA0KSA9PT0gODIgJiYgWC5nZXRVaW50OChPICsgNSkgPT09IDYxICYmIChiID0gITAsIFYgPSBbXSwgRyA9IFguZ2V0VWludDgoTyArIDYpIC8gMjU1LCBVID0gWC5nZXRVaW50OChPICsgNykgLyAyNTUsIFcgPSBYLmdldFVpbnQ4KE8gKyA4KSAvIDI1NSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgRCA9IDA7IEQgPCBuZTsgRCsrKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBCLCBZID0gODQgKyA1MCAqIEQsIEogPSBYLmdldEZsb2F0MzIoWSwgITApLCB0ZSA9IFguZ2V0RmxvYXQzMig0ICsgWSwgITApLCBjZSA9IFguZ2V0RmxvYXQzMig4ICsgWSwgITApLCByZSA9IChiICYmIChCID0gWC5nZXRVaW50MTYoNDggKyBZLCAhMCksIEYgPSAzMjc2OCAmIEIgPyAoUiA9IEcsIEwgPSBVLCBXKSA6IChSID0gKDMxICYgQikgLyAzMSwgTCA9IChCID4+IDUgJiAzMSkgLyAzMSwgKEIgPj4gMTAgJiAzMSkgLyAzMSkpLCBuZXcgeS5kZWZhdWx0LlZlY3RvcihKLCB0ZSwgY2UpKSwgdWUgPSAxOyB1ZSA8PSAzOyB1ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZSA9IFkgKyAxMiAqIHVlLCBsZSA9IG5ldyB5LmRlZmF1bHQuVmVjdG9yKFguZ2V0RmxvYXQzMihsZSwgITApLCBYLmdldEZsb2F0MzIoNCArIGxlLCAhMCksIFguZ2V0RmxvYXQzMig4ICsgbGUsICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIFAudmVydGljZXMucHVzaChsZSksIFAudmVydGV4Tm9ybWFscy5wdXNoKHJlKSwgYiAmJiBWLnB1c2goUiwgTCwgRik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBQLmZhY2VzLnB1c2goWzMgKiBELCAzICogRCArIDEsIDMgKiBEICsgMl0pLCBQLnV2cy5wdXNoKFswLCAwXSwgWzAsIDBdLCBbMCwgMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoQSwgeCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHggPSBuZXcgRGF0YVZpZXcoeCksICEoXCJUZXh0RGVjb2RlclwiIGluIHdpbmRvdykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlNvcnJ5LCBBU0NJSSBTVEwgbG9hZGluZyBvbmx5IHdvcmtzIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBUZXh0RGVjb2RlciAoaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD10ZXh0ZW5jb2RlcilcIik7XG4gICAgICAgICAgICAgIHggPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoeCkuc3BsaXQoYFxuYCksIGZ1bmN0aW9uKFAsIE0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBSLCBMLCBGID0gXCJcIiwgViA9IFtdLCBHID0gMDsgRyA8IE0ubGVuZ3RoOyArK0cpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIFUgPSBNW0ddLnRyaW0oKSwgVyA9IFUuc3BsaXQoXCIgXCIpLCBYID0gMDsgWCA8IFcubGVuZ3RoOyArK1gpXG4gICAgICAgICAgICAgICAgICAgIFdbWF0gPT09IFwiXCIgJiYgVy5zcGxpY2UoWCwgMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoVy5sZW5ndGggIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoRikge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXWzBdICE9PSBcInNvbGlkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFUpLCBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHN0YXRlIFwiJy5jb25jYXQoV1swXSwgJ1wiLCBzaG91bGQgYmUgXCJzb2xpZFwiJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRiA9IFwic29saWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzb2xpZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdbMF0gIT09IFwiZmFjZXRcIiB8fCBXWzFdICE9PSBcIm5vcm1hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihVKSwgY29uc29sZS5lcnJvcignSW52YWxpZCBzdGF0ZSBcIicuY29uY2F0KFdbMF0sICdcIiwgc2hvdWxkIGJlIFwiZmFjZXQgbm9ybWFsXCInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSID0gbmV3IHkuZGVmYXVsdC5WZWN0b3IocGFyc2VGbG9hdChXWzJdKSwgcGFyc2VGbG9hdChXWzNdKSwgcGFyc2VGbG9hdChXWzRdKSksIFAudmVydGV4Tm9ybWFscy5wdXNoKFIsIFIsIFIpLCBGID0gXCJmYWNldCBub3JtYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWNldCBub3JtYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXWzBdICE9PSBcIm91dGVyXCIgfHwgV1sxXSAhPT0gXCJsb29wXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFUpLCBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHN0YXRlIFwiJy5jb25jYXQoV1swXSwgJ1wiLCBzaG91bGQgYmUgXCJvdXRlciBsb29wXCInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBGID0gXCJ2ZXJ0ZXhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0ZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXWzBdID09PSBcInZlcnRleFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBMID0gbmV3IHkuZGVmYXVsdC5WZWN0b3IocGFyc2VGbG9hdChXWzFdKSwgcGFyc2VGbG9hdChXWzJdKSwgcGFyc2VGbG9hdChXWzNdKSksIFAudmVydGljZXMucHVzaChMKSwgUC51dnMucHVzaChbMCwgMF0pLCBWLnB1c2goUC52ZXJ0aWNlcy5pbmRleE9mKEwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoV1swXSAhPT0gXCJlbmRsb29wXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoVSksIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgc3RhdGUgXCInLmNvbmNhdChXWzBdLCAnXCIsIHNob3VsZCBiZSBcInZlcnRleFwiIG9yIFwiZW5kbG9vcFwiJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBQLmZhY2VzLnB1c2goViksIFYgPSBbXSwgRiA9IFwiZW5kbG9vcFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZGxvb3BcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXWzBdICE9PSBcImVuZGZhY2V0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFUpLCBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHN0YXRlIFwiJy5jb25jYXQoV1swXSwgJ1wiLCBzaG91bGQgYmUgXCJlbmRmYWNldFwiJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRiA9IFwiZW5kZmFjZXRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRmYWNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdbMF0gIT09IFwiZW5kc29saWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoV1swXSAhPT0gXCJmYWNldFwiIHx8IFdbMV0gIT09IFwibm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoVSksIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgc3RhdGUgXCInLmNvbmNhdChXWzBdLCAnXCIsIHNob3VsZCBiZSBcImVuZHNvbGlkXCIgb3IgXCJmYWNldCBub3JtYWxcIicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUiA9IG5ldyB5LmRlZmF1bHQuVmVjdG9yKHBhcnNlRmxvYXQoV1syXSksIHBhcnNlRmxvYXQoV1szXSksIHBhcnNlRmxvYXQoV1s0XSkpLCBQLnZlcnRleE5vcm1hbHMucHVzaChSLCBSLCBSKSwgRiA9IFwiZmFjZXQgbm9ybWFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBzdGF0ZSBcIicuY29uY2F0KEYsICdcIicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfShBLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KShqLCBFKSwgbiAmJiBqLm5vcm1hbGl6ZSgpLCBhICYmIGouZmxpcFUoKSwgYyAmJiBqLmZsaXBWKCksIFQuX2RlY3JlbWVudFByZWxvYWQoKSwgdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmIGkoaik7XG4gICAgICAgIH0sIGwpIDogcC5tYXRjaCgvXFwub2JqJC9pKSA/IHRoaXMubG9hZFN0cmluZ3MocywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIEUgPSBnKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIEEoeCkge1xuICAgICAgICAgICAgdmFyIFA7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgICBmb3IgKDsgOyApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChNLnByZXYgPSBNLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0ucHJldiA9IDAsIE0ubmV4dCA9IDMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0oeCk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIFAgPSBNLnNlbnQsIGZ1bmN0aW9uKFIsIEwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBGID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgViA9IHsgdjogW10sIHZ0OiBbXSwgdm46IFtdIH0sIEcgPSB7fSwgVSA9IG51bGwsIFcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBYID0gITEsIG5lID0gITEsIGIgPSAwOyBiIDwgTC5sZW5ndGg7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE8gPSBMW2JdLnRyaW0oKS5zcGxpdCgvXFxiXFxzKy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCBPLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT1swXSA9PT0gXCJ1c2VtdGxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVID0gT1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoT1swXSA9PT0gXCJ2XCIgfHwgT1swXSA9PT0gXCJ2blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEQgPSBuZXcgeS5kZWZhdWx0LlZlY3RvcihwYXJzZUZsb2F0KE9bMV0pLCBwYXJzZUZsb2F0KE9bMl0pLCBwYXJzZUZsb2F0KE9bM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW09bMF1dLnB1c2goRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoT1swXSA9PT0gXCJ2dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQgPSBbcGFyc2VGbG9hdChPWzFdKSwgMSAtIHBhcnNlRmxvYXQoT1syXSldLCBWW09bMF1dLnB1c2goRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9bMF0gPT09IFwiZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIEIgPSAzOyBCIDwgTy5sZW5ndGg7ICsrQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgWSA9IFtdLCBKID0gWzEsIEIgLSAxLCBCXSwgdGUgPSAwOyB0ZSA8IEoubGVuZ3RoOyArK3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNlLCByZSA9IE9bSlt0ZV1dLCB1ZSA9IHJlLnNwbGl0KFwiL1wiKSwgbGUgPSAwOyBsZSA8IHVlLmxlbmd0aDsgbGUrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZVtsZV0gPSBwYXJzZUludCh1ZVtsZV0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR1tyZV0gfHwgKEdbcmVdID0ge30pLCBHW3JlXVtVXSA9PT0gdm9pZCAwID8gKGNlID0gUi52ZXJ0aWNlcy5sZW5ndGgsIFIudmVydGljZXMucHVzaChWLnZbdWVbMF1dLmNvcHkoKSksIFIudXZzLnB1c2goVi52dFt1ZVsxXV0gPyBWLnZ0W3VlWzFdXS5zbGljZSgpIDogWzAsIDBdKSwgUi52ZXJ0ZXhOb3JtYWxzLnB1c2goVi52blt1ZVsyXV0gPyBWLnZuW3VlWzJdXS5jb3B5KCkgOiBuZXcgeS5kZWZhdWx0LlZlY3RvcigpKSwgR1tyZV1bVV0gPSBjZSwgWS5wdXNoKGNlKSwgVSAmJiBGW1VdICYmIEZbVV0uZGlmZnVzZUNvbG9yICYmIFcuYWRkKFYudlt1ZVswXV0pKSA6IFkucHVzaChHW3JlXVtVXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWVswXSAhPT0gWVsxXSAmJiBZWzBdICE9PSBZWzJdICYmIFlbMV0gIT09IFlbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSLmZhY2VzLnB1c2goWSksIFUgJiYgRltVXSAmJiBGW1VdLmRpZmZ1c2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFggPSBYID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgSyA9IEZbVV0uZGlmZnVzZUNvbG9yLCBhZSA9IDA7IGFlIDwgWS5sZW5ndGg7IGFlKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLnZlcnRleENvbG9ycy5wdXNoKEtbMF0pLCBSLnZlcnRleENvbG9ycy5wdXNoKEtbMV0pLCBSLnZlcnRleENvbG9ycy5wdXNoKEtbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFIudmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDAgJiYgUi5jb21wdXRlTm9ybWFscygpLCBYID09PSBuZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGNvbG9yaW5nIGlzIGluY29uc2lzdGVudC4gRWl0aGVyIGFsbCB2ZXJ0aWNlcyBzaG91bGQgaGF2ZSBjb2xvcnMgb3Igbm9uZSBzaG91bGQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KGosIHgsIFApLCBNLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNLnByZXYgPSA3LCBNLnQwID0gTS5jYXRjaCgwKSwgbCA/IGwoTS50MCkgOiB5LmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJFcnJvciBkdXJpbmcgcGFyc2luZzogXCIgKyBNLnQwLm1lc3NhZ2UpLCBNLmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNLnByZXYgPSAxMSwgbiAmJiBqLm5vcm1hbGl6ZSgpLCBhICYmIGouZmxpcFUoKSwgYyAmJiBqLmZsaXBWKCksIFQuX2RlY3JlbWVudFByZWxvYWQoKSwgdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmIGkoaiksIE0uZmluaXNoKDExKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBBLCBudWxsLCBbWzAsIDcsIDExLCAxOF1dKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgICAgIHJldHVybiBFLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpLCBsKSA6ICh5LmRlZmF1bHQuX2ZyaWVuZGx5RmlsZUxvYWRFcnJvcigzLCBzKSwgbCA/IGwoKSA6IHkuZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIlNvcnJ5LCB0aGUgZmlsZSB0eXBlIGlzIGludmFsaWQuIE9ubHkgT0JKIGFuZCBTVEwgZmlsZXMgYXJlIHN1cHBvcnRlZC5cIikpLCBqO1xuICAgICAgfSwgeS5kZWZhdWx0LnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJtb2RlbFwiKSwgeS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJtb2RlbFwiLCBhcmd1bWVudHMpLCAwIDwgcy52ZXJ0aWNlcy5sZW5ndGggJiYgKHRoaXMuX3JlbmRlcmVyLmdlb21ldHJ5SW5IYXNoKHMuZ2lkKSB8fCAocy5lZGdlcy5sZW5ndGggPT09IDAgJiYgcy5fbWFrZVRyaWFuZ2xlRWRnZXMoKSwgcy5fZWRnZXNUb1ZlcnRpY2VzKCksIHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUJ1ZmZlcnMocy5naWQsIHMpKSwgdGhpcy5fcmVuZGVyZXIuZHJhd0J1ZmZlcnMocy5naWQpKTtcbiAgICAgIH07XG4gICAgICB2YXIgciA9IHkuZGVmYXVsdDtcbiAgICAgIEMuZGVmYXVsdCA9IHI7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiLi9wNS5HZW9tZXRyeVwiOiAzMzIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiOiAxNTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIjogMTYxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZlwiOiAxNjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiOiAxNjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlXCI6IDE3MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnblwiOiAxODEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlXCI6IDE4OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc2V0XCI6IDE5NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoXCI6IDE5OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0XCI6IDIwMywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW1cIjogMjA2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MywgXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIjogMjU3IH1dLCAzMjg6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKHIpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgcztcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcyAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBzLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgcztcbiAgICAgICAgfSkocik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KHIpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBtKHMpO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0ocyk7XG4gICAgICAgIH0pKHIpO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAoZiA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIGYuX19lc01vZHVsZSA/IGYgOiB7IGRlZmF1bHQ6IGYgfSwgaCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKHIgJiYgci5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBpZiAociA9PT0gbnVsbCB8fCB5KHIpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiByIH07XG4gICAgICAgIHZhciBzID0gZygpO1xuICAgICAgICBpZiAocyAmJiBzLmhhcyhyKSlcbiAgICAgICAgICByZXR1cm4gcy5nZXQocik7XG4gICAgICAgIHZhciBvLCBpID0ge30sIGwgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChvIGluIHIpIHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgbykgJiYgKChuID0gbCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgbykgOiBudWxsKSAmJiAobi5nZXQgfHwgbi5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIG4pIDogaVtvXSA9IHJbb10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpLmRlZmF1bHQgPSByLCBzICYmIHMuc2V0KHIsIGkpLCBpO1xuICAgICAgfSh0KFwiLi4vY29yZS9jb25zdGFudHNcIikpO1xuICAgICAgZnVuY3Rpb24gZygpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCByKTtcbiAgICAgIH1cbiAgICAgIHQoXCIuL3A1LlRleHR1cmVcIiksIHUuZGVmYXVsdC5wcm90b3R5cGUubG9hZFNoYWRlciA9IGZ1bmN0aW9uKHIsIHMsIG8sIGkpIHtcbiAgICAgICAgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsb2FkU2hhZGVyXCIsIGFyZ3VtZW50cyksIGkgPSBpIHx8IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgICAgYS5fZGVjcmVtZW50UHJlbG9hZCgpLCBvICYmIG8obik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBuZXcgdS5kZWZhdWx0LlNoYWRlcigpLCBhID0gdGhpcywgYyA9ICExLCBwID0gITE7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTdHJpbmdzKHIsIGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICBuLl92ZXJ0U3JjID0gai5qb2luKGBcbmApLCBwID0gITAsIGMgJiYgbCgpO1xuICAgICAgICB9LCBpKSwgdGhpcy5sb2FkU3RyaW5ncyhzLCBmdW5jdGlvbihqKSB7XG4gICAgICAgICAgbi5fZnJhZ1NyYyA9IGouam9pbihgXG5gKSwgYyA9ICEwLCBwICYmIGwoKTtcbiAgICAgICAgfSwgaSksIG47XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmNyZWF0ZVNoYWRlciA9IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgICAgcmV0dXJuIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY3JlYXRlU2hhZGVyXCIsIGFyZ3VtZW50cyksIG5ldyB1LmRlZmF1bHQuU2hhZGVyKHRoaXMuX3JlbmRlcmVyLCByLCBzKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUuY3JlYXRlRmlsdGVyU2hhZGVyID0gZnVuY3Rpb24ocikge1xuICAgICAgICB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcImNyZWF0ZUZpbHRlclNoYWRlclwiLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcyA9IHIuaW5jbHVkZXMoXCIjdmVyc2lvbiAzMDAgZXNcIikgPyBgI3ZlcnNpb24gMzAwIGVzXG4gICAgdW5pZm9ybSBtYXQ0IHVNb2RlbFZpZXdNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaW4gdmVjMyBhUG9zaXRpb247XG4gICAgaW4gdmVjMiBhVGV4Q29vcmQ7XG4gICAgb3V0IHZlYzIgdlRleENvb3JkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gdHJhbnNmZXJyaW5nIHRleGNvb3JkcyBmb3IgdGhlIGZyYWcgc2hhZGVyXG4gICAgICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG5cbiAgICAgIC8vIGNvcHkgcG9zaXRpb24gd2l0aCBhIGZvdXJ0aCBjb29yZGluYXRlIGZvciBwcm9qZWN0aW9uICgxLjAgaXMgbm9ybWFsKVxuICAgICAgdmVjNCBwb3NpdGlvblZlYzQgPSB2ZWM0KGFQb3NpdGlvbiwgMS4wKTtcblxuICAgICAgLy8gcHJvamVjdCB0byAzRCBzcGFjZVxuICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVNb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvblZlYzQ7XG4gICAgfVxuICBgIDogYFxuICAgIHVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xuICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcblxuICAgIGF0dHJpYnV0ZSB2ZWMzIGFQb3NpdGlvbjtcbiAgICAvLyB0ZXhjb29yZHMgb25seSBjb21lIGZyb20gcDUgdG8gdmVydGV4IHNoYWRlclxuICAgIC8vIHNvIHBhc3MgdGV4Y29vcmRzIG9uIHRvIHRoZSBmcmFnbWVudCBzaGFkZXIgaW4gYSB2YXJ5aW5nIHZhcmlhYmxlXG4gICAgYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAvLyB0cmFuc2ZlcnJpbmcgdGV4Y29vcmRzIGZvciB0aGUgZnJhZyBzaGFkZXJcbiAgICAgIHZUZXhDb29yZCA9IGFUZXhDb29yZDtcblxuICAgICAgLy8gY29weSBwb3NpdGlvbiB3aXRoIGEgZm91cnRoIGNvb3JkaW5hdGUgZm9yIHByb2plY3Rpb24gKDEuMCBpcyBub3JtYWwpXG4gICAgICB2ZWM0IHBvc2l0aW9uVmVjNCA9IHZlYzQoYVBvc2l0aW9uLCAxLjApO1xuXG4gICAgICAvLyBwcm9qZWN0IHRvIDNEIHNwYWNlXG4gICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdU1vZGVsVmlld01hdHJpeCAqIHBvc2l0aW9uVmVjNDtcbiAgICB9XG4gIGAsIHMgPSBuZXcgdS5kZWZhdWx0LlNoYWRlcih0aGlzLl9yZW5kZXJlciwgcywgcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5HTCA/IHMuZW5zdXJlQ29tcGlsZWRPbkNvbnRleHQodGhpcykgOiBzLmVuc3VyZUNvbXBpbGVkT25Db250ZXh0KHRoaXMuX3JlbmRlcmVyLmdldEZpbHRlckdyYXBoaWNzTGF5ZXIoKSksIHM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnNoYWRlciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwic2hhZGVyXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNoYWRlclwiLCBhcmd1bWVudHMpLCByLmVuc3VyZUNvbXBpbGVkT25Db250ZXh0KHRoaXMpLCByLmlzU3Ryb2tlU2hhZGVyKCkgPyB0aGlzLl9yZW5kZXJlci51c2VyU3Ryb2tlU2hhZGVyID0gciA6ICh0aGlzLl9yZW5kZXJlci51c2VyRmlsbFNoYWRlciA9IHIsIHRoaXMuX3JlbmRlcmVyLl91c2VOb3JtYWxNYXRlcmlhbCA9ICExKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5wcm90b3R5cGUucmVzZXRTaGFkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnVzZXJGaWxsU2hhZGVyID0gdGhpcy5fcmVuZGVyZXIudXNlclN0cm9rZVNoYWRlciA9IG51bGwsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3NlcnQzZChcInRleHR1cmVcIiksIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwidGV4dHVyZVwiLCBhcmd1bWVudHMpLCByLmdpZlByb3BlcnRpZXMgJiYgci5fYW5pbWF0ZUdpZih0aGlzKSwgdGhpcy5fcmVuZGVyZXIuZHJhd01vZGUgPSBoLlRFWFRVUkUsIHRoaXMuX3JlbmRlcmVyLl91c2VOb3JtYWxNYXRlcmlhbCA9ICExLCB0aGlzLl9yZW5kZXJlci5fdGV4ID0gciwgdGhpcy5fcmVuZGVyZXIuX3NldFByb3BlcnR5KFwiX2RvRmlsbFwiLCAhMCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnRleHR1cmVNb2RlID0gZnVuY3Rpb24ocikge1xuICAgICAgICByICE9PSBoLklNQUdFICYmIHIgIT09IGguTk9STUFMID8gY29uc29sZS53YXJuKFwiWW91IHRyaWVkIHRvIHNldCBcIi5jb25jYXQociwgXCIgdGV4dHVyZU1vZGUgb25seSBzdXBwb3J0cyBJTUFHRSAmIE5PUk1BTCBcIikpIDogdGhpcy5fcmVuZGVyZXIudGV4dHVyZU1vZGUgPSByO1xuICAgICAgfSwgdS5kZWZhdWx0LnByb3RvdHlwZS50ZXh0dXJlV3JhcCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgdmFyIHMgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHIsIG8gPSAodGhpcy5fcmVuZGVyZXIudGV4dHVyZVdyYXBYID0gciwgdGhpcy5fcmVuZGVyZXIudGV4dHVyZVdyYXBZID0gcywgITApLCBpID0gITEsIGwgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgbiwgYSA9IHRoaXMuX3JlbmRlcmVyLnRleHR1cmVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShvID0gKG4gPSBhLm5leHQoKSkuZG9uZSk7IG8gPSAhMClcbiAgICAgICAgICAgIG4udmFsdWUuc2V0V3JhcE1vZGUociwgcyk7XG4gICAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgICBpID0gITAsIGwgPSBjO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvIHx8IGEucmV0dXJuID09IG51bGwgfHwgYS5yZXR1cm4oKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgIHRocm93IGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLm5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwibm9ybWFsTWF0ZXJpYWxcIik7XG4gICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KHIpLCBvID0gMDsgbyA8IHI7IG8rKylcbiAgICAgICAgICBzW29dID0gYXJndW1lbnRzW29dO1xuICAgICAgICByZXR1cm4gdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJub3JtYWxNYXRlcmlhbFwiLCBzKSwgdGhpcy5fcmVuZGVyZXIuZHJhd01vZGUgPSBoLkZJTEwsIHRoaXMuX3JlbmRlcmVyLl91c2VTcGVjdWxhck1hdGVyaWFsID0gITEsIHRoaXMuX3JlbmRlcmVyLl91c2VFbWlzc2l2ZU1hdGVyaWFsID0gITEsIHRoaXMuX3JlbmRlcmVyLl91c2VOb3JtYWxNYXRlcmlhbCA9ICEwLCB0aGlzLl9yZW5kZXJlci5jdXJGaWxsQ29sb3IgPSBbMSwgMSwgMSwgMV0sIHRoaXMuX3JlbmRlcmVyLl9zZXRQcm9wZXJ0eShcIl9kb0ZpbGxcIiwgITApLCB0aGlzLm5vU3Ryb2tlKCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmFtYmllbnRNYXRlcmlhbCA9IGZ1bmN0aW9uKHIsIHMsIG8pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJhbWJpZW50TWF0ZXJpYWxcIiksIHUuZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiYW1iaWVudE1hdGVyaWFsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBpID0gdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX2hhc1NldEFtYmllbnQgPSAhMCwgdGhpcy5fcmVuZGVyZXIuY3VyQW1iaWVudENvbG9yID0gaS5fYXJyYXksIHRoaXMuX3JlbmRlcmVyLl91c2VOb3JtYWxNYXRlcmlhbCA9ICExLCB0aGlzLl9yZW5kZXJlci5fZW5hYmxlTGlnaHRpbmcgPSAhMCwgdGhpcy5fcmVuZGVyZXIuX3NldFByb3BlcnR5KFwiX2RvRmlsbFwiLCAhMCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLmVtaXNzaXZlTWF0ZXJpYWwgPSBmdW5jdGlvbihyLCBzLCBvLCBpKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwiZW1pc3NpdmVNYXRlcmlhbFwiKSwgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJlbWlzc2l2ZU1hdGVyaWFsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBsID0gdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuY3VyRW1pc3NpdmVDb2xvciA9IGwuX2FycmF5LCB0aGlzLl9yZW5kZXJlci5fdXNlRW1pc3NpdmVNYXRlcmlhbCA9ICEwLCB0aGlzLl9yZW5kZXJlci5fdXNlTm9ybWFsTWF0ZXJpYWwgPSAhMSwgdGhpcy5fcmVuZGVyZXIuX2VuYWJsZUxpZ2h0aW5nID0gITAsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnNwZWN1bGFyTWF0ZXJpYWwgPSBmdW5jdGlvbihyLCBzLCBvLCBpKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwic3BlY3VsYXJNYXRlcmlhbFwiKSwgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJzcGVjdWxhck1hdGVyaWFsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBsID0gdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuY3VyU3BlY3VsYXJDb2xvciA9IGwuX2FycmF5LCB0aGlzLl9yZW5kZXJlci5fdXNlU3BlY3VsYXJNYXRlcmlhbCA9ICEwLCB0aGlzLl9yZW5kZXJlci5fdXNlTm9ybWFsTWF0ZXJpYWwgPSAhMSwgdGhpcy5fcmVuZGVyZXIuX2VuYWJsZUxpZ2h0aW5nID0gITAsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLnNoaW5pbmVzcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwic2hpbmluZXNzXCIpLCB1LmRlZmF1bHQuX3ZhbGlkYXRlUGFyYW1ldGVycyhcInNoaW5pbmVzc1wiLCBhcmd1bWVudHMpLCB0aGlzLl9yZW5kZXJlci5fdXNlU2hpbmluZXNzID0gciA9IHIgPCAxID8gMSA6IHIsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQucHJvdG90eXBlLm1ldGFsbmVzcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydDNkKFwibWV0YWxuZXNzXCIpLCByID0gMSAtIE1hdGguZXhwKC1yIC8gMTAwKSwgdGhpcy5fcmVuZGVyZXIuX3VzZU1ldGFsbmVzcyA9IHIsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2FwcGx5Q29sb3JCbGVuZCA9IGZ1bmN0aW9uKHIsIGwpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLkdMLCBpID0gdGhpcy5kcmF3TW9kZSA9PT0gaC5URVhUVVJFLCBsID0gbCB8fCB0aGlzLnVzZXJGaWxsU2hhZGVyIHx8IHRoaXMudXNlclN0cm9rZVNoYWRlciB8fCB0aGlzLnVzZXJQb2ludFNoYWRlciB8fCBpIHx8IHRoaXMuY3VyQmxlbmRNb2RlICE9PSBoLkJMRU5EIHx8IHJbci5sZW5ndGggLSAxXSA8IDEgfHwgdGhpcy5faXNFcmFzaW5nO1xuICAgICAgICByZXR1cm4gbCAhPT0gdGhpcy5faXNCbGVuZGluZyAmJiAobCB8fCB0aGlzLmN1ckJsZW5kTW9kZSAhPT0gaC5CTEVORCAmJiB0aGlzLmN1ckJsZW5kTW9kZSAhPT0gaC5BREQgPyBvLmVuYWJsZShvLkJMRU5EKSA6IG8uZGlzYWJsZShvLkJMRU5EKSwgby5kZXB0aE1hc2soITApLCB0aGlzLl9pc0JsZW5kaW5nID0gbCksIHRoaXMuX2FwcGx5QmxlbmRNb2RlKCksIHI7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2FwcGx5QmxlbmRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRCbGVuZE1vZGUgIT09IHRoaXMuY3VyQmxlbmRNb2RlKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLkdMO1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5jdXJCbGVuZE1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgaC5CTEVORDpcbiAgICAgICAgICAgICAgci5ibGVuZEVxdWF0aW9uKHIuRlVOQ19BREQpLCByLmJsZW5kRnVuYyhyLk9ORSwgci5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGguQUREOlxuICAgICAgICAgICAgICByLmJsZW5kRXF1YXRpb24oci5GVU5DX0FERCksIHIuYmxlbmRGdW5jKHIuT05FLCByLk9ORSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLlJFTU9WRTpcbiAgICAgICAgICAgICAgci5ibGVuZEVxdWF0aW9uKHIuRlVOQ19BREQpLCByLmJsZW5kRnVuYyhyLlpFUk8sIHIuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLk1VTFRJUExZOlxuICAgICAgICAgICAgICByLmJsZW5kRXF1YXRpb24oci5GVU5DX0FERCksIHIuYmxlbmRGdW5jKHIuRFNUX0NPTE9SLCByLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgaC5TQ1JFRU46XG4gICAgICAgICAgICAgIHIuYmxlbmRFcXVhdGlvbihyLkZVTkNfQUREKSwgci5ibGVuZEZ1bmMoci5PTkUsIHIuT05FX01JTlVTX1NSQ19DT0xPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLkVYQ0xVU0lPTjpcbiAgICAgICAgICAgICAgci5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoci5GVU5DX0FERCwgci5GVU5DX0FERCksIHIuYmxlbmRGdW5jU2VwYXJhdGUoci5PTkVfTUlOVVNfRFNUX0NPTE9SLCByLk9ORV9NSU5VU19TUkNfQ09MT1IsIHIuT05FLCByLk9ORSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLlJFUExBQ0U6XG4gICAgICAgICAgICAgIHIuYmxlbmRFcXVhdGlvbihyLkZVTkNfQUREKSwgci5ibGVuZEZ1bmMoci5PTkUsIHIuWkVSTyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLlNVQlRSQUNUOlxuICAgICAgICAgICAgICByLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShyLkZVTkNfUkVWRVJTRV9TVUJUUkFDVCwgci5GVU5DX0FERCksIHIuYmxlbmRGdW5jU2VwYXJhdGUoci5PTkUsIHIuT05FLCByLk9ORSwgci5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGguREFSS0VTVDpcbiAgICAgICAgICAgICAgdGhpcy5ibGVuZEV4dCA/IChyLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSh0aGlzLmJsZW5kRXh0Lk1JTiB8fCB0aGlzLmJsZW5kRXh0Lk1JTl9FWFQsIHIuRlVOQ19BREQpLCByLmJsZW5kRnVuY1NlcGFyYXRlKHIuT05FLCByLk9ORSwgci5PTkUsIHIuT05FKSkgOiBjb25zb2xlLndhcm4oXCJibGVuZE1vZGUoREFSS0VTVCkgZG9lcyBub3Qgd29yayBpbiB5b3VyIGJyb3dzZXIgaW4gV0VCR0wgbW9kZS5cIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBoLkxJR0hURVNUOlxuICAgICAgICAgICAgICB0aGlzLmJsZW5kRXh0ID8gKHIuYmxlbmRFcXVhdGlvblNlcGFyYXRlKHRoaXMuYmxlbmRFeHQuTUFYIHx8IHRoaXMuYmxlbmRFeHQuTUFYX0VYVCwgci5GVU5DX0FERCksIHIuYmxlbmRGdW5jU2VwYXJhdGUoci5PTkUsIHIuT05FLCByLk9ORSwgci5PTkUpKSA6IGNvbnNvbGUud2FybihcImJsZW5kTW9kZShMSUdIVEVTVCkgZG9lcyBub3Qgd29yayBpbiB5b3VyIGJyb3dzZXIgaW4gV0VCR0wgbW9kZS5cIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk9vcHMhIFNvbWVob3cgUmVuZGVyZXJHTCBzZXQgY3VyQmxlbmRNb2RlIHRvIGFuIHVuc3VwcG9ydGVkIG1vZGUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pc0VyYXNpbmcgfHwgKHRoaXMuX2NhY2hlZEJsZW5kTW9kZSA9IHRoaXMuY3VyQmxlbmRNb2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBmID0gdS5kZWZhdWx0O1xuICAgICAgQy5kZWZhdWx0ID0gZjtcbiAgICB9LCB7IFwiLi4vY29yZS9jb25zdGFudHNcIjogMjY5LCBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiLi9wNS5UZXh0dXJlXCI6IDMzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIjogMTYyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW5cIjogMTY1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiOiAxOTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMyOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3RcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN1YlwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIHkodSwgaCkge1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGgubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGhbZ107XG4gICAgICAgICAgZi5lbnVtZXJhYmxlID0gZi5lbnVtZXJhYmxlIHx8ICExLCBmLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gZiAmJiAoZi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIGYua2V5LCBmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbS5kZWZhdWx0LnByb3RvdHlwZS5jYW1lcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwiY2FtZXJhXCIpO1xuICAgICAgICBmb3IgKHZhciBoID0gYXJndW1lbnRzLmxlbmd0aCwgZyA9IG5ldyBBcnJheShoKSwgZiA9IDA7IGYgPCBoOyBmKyspXG4gICAgICAgICAgZ1tmXSA9IGFyZ3VtZW50c1tmXTtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiY2FtZXJhXCIsIGcpLCAodSA9IHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEpLmNhbWVyYS5hcHBseSh1LCBnKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUucGVyc3BlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwicGVyc3BlY3RpdmVcIik7XG4gICAgICAgIGZvciAodmFyIGggPSBhcmd1bWVudHMubGVuZ3RoLCBnID0gbmV3IEFycmF5KGgpLCBmID0gMDsgZiA8IGg7IGYrKylcbiAgICAgICAgICBnW2ZdID0gYXJndW1lbnRzW2ZdO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJwZXJzcGVjdGl2ZVwiLCBnKSwgKHUgPSB0aGlzLl9yZW5kZXJlci5fY3VyQ2FtZXJhKS5wZXJzcGVjdGl2ZS5hcHBseSh1LCBnKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUubGluZVBlcnNwZWN0aXZlID0gZnVuY3Rpb24odSkge1xuICAgICAgICBpZiAobS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJsaW5lUGVyc3BlY3RpdmVcIiwgYXJndW1lbnRzKSwgISh0aGlzLl9yZW5kZXJlciBpbnN0YW5jZW9mIG0uZGVmYXVsdC5SZW5kZXJlckdMKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsaW5lUGVyc3BlY3RpdmUoKSBtdXN0IGJlIGNhbGxlZCBpbiBXZWJHTCBtb2RlLlwiKTtcbiAgICAgICAgaWYgKHUgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX2N1ckNhbWVyYS51c2VMaW5lUGVyc3BlY3RpdmU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEudXNlTGluZVBlcnNwZWN0aXZlID0gdTtcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUub3J0aG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHRoaXMuX2Fzc2VydDNkKFwib3J0aG9cIik7XG4gICAgICAgIGZvciAodmFyIGggPSBhcmd1bWVudHMubGVuZ3RoLCBnID0gbmV3IEFycmF5KGgpLCBmID0gMDsgZiA8IGg7IGYrKylcbiAgICAgICAgICBnW2ZdID0gYXJndW1lbnRzW2ZdO1xuICAgICAgICByZXR1cm4gbS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJvcnRob1wiLCBnKSwgKHUgPSB0aGlzLl9yZW5kZXJlci5fY3VyQ2FtZXJhKS5vcnRoby5hcHBseSh1LCBnKSwgdGhpcztcbiAgICAgIH0sIG0uZGVmYXVsdC5wcm90b3R5cGUuZnJ1c3R1bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJmcnVzdHVtXCIpO1xuICAgICAgICBmb3IgKHZhciBoID0gYXJndW1lbnRzLmxlbmd0aCwgZyA9IG5ldyBBcnJheShoKSwgZiA9IDA7IGYgPCBoOyBmKyspXG4gICAgICAgICAgZ1tmXSA9IGFyZ3VtZW50c1tmXTtcbiAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fdmFsaWRhdGVQYXJhbWV0ZXJzKFwiZnJ1c3R1bVwiLCBnKSwgKHUgPSB0aGlzLl9yZW5kZXJlci5fY3VyQ2FtZXJhKS5mcnVzdHVtLmFwcGx5KHUsIGcpLCB0aGlzO1xuICAgICAgfSwgbS5kZWZhdWx0LnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0M2QoXCJjcmVhdGVDYW1lcmFcIik7XG4gICAgICAgIHZhciB1ID0gbmV3IG0uZGVmYXVsdC5DYW1lcmEodGhpcy5fcmVuZGVyZXIpO1xuICAgICAgICByZXR1cm4gdS5fY29tcHV0ZUNhbWVyYURlZmF1bHRTZXR0aW5ncygpLCB1Ll9zZXREZWZhdWx0Q2FtZXJhKCksIHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEgPSB1O1xuICAgICAgfSwgbS5kZWZhdWx0LkNhbWVyYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB1KGYpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gZiwgdGhpcy5jYW1lcmFUeXBlID0gXCJkZWZhdWx0XCIsIHRoaXMudXNlTGluZVBlcnNwZWN0aXZlID0gITAsIHRoaXMuY2FtZXJhTWF0cml4ID0gbmV3IG0uZGVmYXVsdC5NYXRyaXgoKSwgdGhpcy5wcm9qTWF0cml4ID0gbmV3IG0uZGVmYXVsdC5NYXRyaXgoKSwgdGhpcy55U2NhbGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoLCBnO1xuICAgICAgICByZXR1cm4gaCA9IHUsIChnID0gW3sga2V5OiBcInBlcnNwZWN0aXZlXCIsIHZhbHVlOiBmdW5jdGlvbihpLCByLCBzLCBvKSB7XG4gICAgICAgICAgdGhpcy5jYW1lcmFUeXBlID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggPyBcImN1c3RvbVwiIDogXCJkZWZhdWx0XCIsIGkgPT09IHZvaWQgMCA/IChpID0gdGhpcy5kZWZhdWx0Q2FtZXJhRk9WLCB0aGlzLmNhbWVyYUZPViA9IGkpIDogdGhpcy5jYW1lcmFGT1YgPSB0aGlzLl9yZW5kZXJlci5fcEluc3QuX3RvUmFkaWFucyhpKSwgciA9PT0gdm9pZCAwICYmIChyID0gdGhpcy5kZWZhdWx0QXNwZWN0UmF0aW8pLCBzID09PSB2b2lkIDAgJiYgKHMgPSB0aGlzLmRlZmF1bHRDYW1lcmFOZWFyKSwgbyA9PT0gdm9pZCAwICYmIChvID0gdGhpcy5kZWZhdWx0Q2FtZXJhRmFyKSwgcyA8PSAxZS00ICYmIChzID0gMC4wMSwgY29uc29sZS5sb2coXCJBdm9pZCBwZXJzcGVjdGl2ZSBuZWFyIHBsYW5lIHZhbHVlcyBjbG9zZSB0byBvciBiZWxvdyAwLiBTZXR0aW5nIHZhbHVlIHRvIDAuMDEuXCIpKSwgbyA8IHMgJiYgY29uc29sZS5sb2coXCJQZXJzcGVjdGl2ZSBmYXIgcGxhbmUgdmFsdWUgaXMgbGVzcyB0aGFuIG5lYXIgcGxhbmUgdmFsdWUuIE5vdGhpbmcgd2lsbCBiZSBzaG93bi5cIiksIHRoaXMuYXNwZWN0UmF0aW8gPSByLCB0aGlzLmNhbWVyYU5lYXIgPSBzLCB0aGlzLmNhbWVyYUZhciA9IG8sIHRoaXMucHJvak1hdHJpeCA9IG0uZGVmYXVsdC5NYXRyaXguaWRlbnRpdHkoKTtcbiAgICAgICAgICB2YXIgaSA9IDEgLyBNYXRoLnRhbih0aGlzLmNhbWVyYUZPViAvIDIpLCBsID0gMSAvICh0aGlzLmNhbWVyYU5lYXIgLSB0aGlzLmNhbWVyYUZhcik7XG4gICAgICAgICAgdGhpcy5wcm9qTWF0cml4LnNldChpIC8gciwgMCwgMCwgMCwgMCwgLWkgKiB0aGlzLnlTY2FsZSwgMCwgMCwgMCwgMCwgKG8gKyBzKSAqIGwsIC0xLCAwLCAwLCAyICogbyAqIHMgKiBsLCAwKSwgdGhpcy5faXNBY3RpdmUoKSAmJiB0aGlzLl9yZW5kZXJlci51UE1hdHJpeC5zZXQodGhpcy5wcm9qTWF0cml4KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJvcnRob1wiLCB2YWx1ZTogZnVuY3Rpb24oXywgVCwgcywgbywgaSwgbCkge1xuICAgICAgICAgIF8gPT09IHZvaWQgMCAmJiAoXyA9IC10aGlzLl9yZW5kZXJlci53aWR0aCAvIDIpLCBUID09PSB2b2lkIDAgJiYgKFQgPSArdGhpcy5fcmVuZGVyZXIud2lkdGggLyAyKSwgcyA9PT0gdm9pZCAwICYmIChzID0gLXRoaXMuX3JlbmRlcmVyLmhlaWdodCAvIDIpLCBvID09PSB2b2lkIDAgJiYgKG8gPSArdGhpcy5fcmVuZGVyZXIuaGVpZ2h0IC8gMiksIGkgPT09IHZvaWQgMCAmJiAoaSA9IDApLCBsID09PSB2b2lkIDAgJiYgKGwgPSBNYXRoLm1heCh0aGlzLl9yZW5kZXJlci53aWR0aCwgdGhpcy5fcmVuZGVyZXIuaGVpZ2h0KSArIDgwMCksIHRoaXMuY2FtZXJhTmVhciA9IGk7XG4gICAgICAgICAgdmFyIFMgPSBUIC0gXywgbiA9IG8gLSBzLCBhID0gKHRoaXMuY2FtZXJhRmFyID0gbCkgLSBpLCBjID0gMiAvIFMsIHAgPSAyIC8gbiAqIHRoaXMueVNjYWxlLCBqID0gLTIgLyBhLCBUID0gLShUICsgXykgLyBTLCBfID0gLShvICsgcykgLyBuLCBTID0gLShsICsgaSkgLyBhO1xuICAgICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG0uZGVmYXVsdC5NYXRyaXguaWRlbnRpdHkoKSwgdGhpcy5wcm9qTWF0cml4LnNldChjLCAwLCAwLCAwLCAwLCAtcCwgMCwgMCwgMCwgMCwgaiwgMCwgVCwgXywgUywgMSksIHRoaXMuX2lzQWN0aXZlKCkgJiYgdGhpcy5fcmVuZGVyZXIudVBNYXRyaXguc2V0KHRoaXMucHJvak1hdHJpeCksIHRoaXMuY2FtZXJhVHlwZSA9IFwiY3VzdG9tXCI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZnJ1c3R1bVwiLCB2YWx1ZTogZnVuY3Rpb24oXywgVCwgcywgbywgaSwgbCkge1xuICAgICAgICAgIF8gPT09IHZvaWQgMCAmJiAoXyA9IDAuMDUgKiAtdGhpcy5fcmVuZGVyZXIud2lkdGgpLCBUID09PSB2b2lkIDAgJiYgKFQgPSAwLjA1ICogK3RoaXMuX3JlbmRlcmVyLndpZHRoKSwgcyA9PT0gdm9pZCAwICYmIChzID0gMC4wNSAqICt0aGlzLl9yZW5kZXJlci5oZWlnaHQpLCBvID09PSB2b2lkIDAgJiYgKG8gPSAwLjA1ICogLXRoaXMuX3JlbmRlcmVyLmhlaWdodCksIGkgPT09IHZvaWQgMCAmJiAoaSA9IHRoaXMuZGVmYXVsdENhbWVyYU5lYXIpLCBsID09PSB2b2lkIDAgJiYgKGwgPSB0aGlzLmRlZmF1bHRDYW1lcmFGYXIpLCB0aGlzLmNhbWVyYU5lYXIgPSBpO1xuICAgICAgICAgIHZhciBTID0gVCAtIF8sIG4gPSBvIC0gcywgYSA9ICh0aGlzLmNhbWVyYUZhciA9IGwpIC0gaSwgYyA9IDIgKiBpIC8gUywgcCA9IDIgKiBpIC8gbiAqIHRoaXMueVNjYWxlLCBqID0gLTIgKiBsICogaSAvIGEsIFQgPSAoVCArIF8pIC8gUywgXyA9IChvICsgcykgLyBuLCBTID0gLShsICsgaSkgLyBhO1xuICAgICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG0uZGVmYXVsdC5NYXRyaXguaWRlbnRpdHkoKSwgdGhpcy5wcm9qTWF0cml4LnNldChjLCAwLCAwLCAwLCAwLCAtcCwgMCwgMCwgVCwgXywgUywgLTEsIDAsIDAsIGosIDApLCB0aGlzLl9pc0FjdGl2ZSgpICYmIHRoaXMuX3JlbmRlcmVyLnVQTWF0cml4LnNldCh0aGlzLnByb2pNYXRyaXgpLCB0aGlzLmNhbWVyYVR5cGUgPSBcImN1c3RvbVwiO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9yb3RhdGVWaWV3XCIsIHZhbHVlOiBmdW5jdGlvbihjLCByLCBzLCBvKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmNlbnRlclgsIGwgPSB0aGlzLmNlbnRlclksIG4gPSB0aGlzLmNlbnRlclosIGEgPSAoaSAtPSB0aGlzLmV5ZVgsIGwgLT0gdGhpcy5leWVZLCBuIC09IHRoaXMuZXllWiwgbS5kZWZhdWx0Lk1hdHJpeC5pZGVudGl0eSh0aGlzLl9yZW5kZXJlci5fcEluc3QpKSwgYyA9IChhLnJvdGF0ZSh0aGlzLl9yZW5kZXJlci5fcEluc3QuX3RvUmFkaWFucyhjKSwgciwgcywgbyksIFtpICogYS5tYXQ0WzBdICsgbCAqIGEubWF0NFs0XSArIG4gKiBhLm1hdDRbOF0sIGkgKiBhLm1hdDRbMV0gKyBsICogYS5tYXQ0WzVdICsgbiAqIGEubWF0NFs5XSwgaSAqIGEubWF0NFsyXSArIGwgKiBhLm1hdDRbNl0gKyBuICogYS5tYXQ0WzEwXV0pO1xuICAgICAgICAgIGNbMF0gKz0gdGhpcy5leWVYLCBjWzFdICs9IHRoaXMuZXllWSwgY1syXSArPSB0aGlzLmV5ZVosIHRoaXMuY2FtZXJhKHRoaXMuZXllWCwgdGhpcy5leWVZLCB0aGlzLmV5ZVosIGNbMF0sIGNbMV0sIGNbMl0sIHRoaXMudXBYLCB0aGlzLnVwWSwgdGhpcy51cFopO1xuICAgICAgICB9IH0sIHsga2V5OiBcInBhblwiLCB2YWx1ZTogZnVuY3Rpb24oZikge1xuICAgICAgICAgIHZhciByID0gdGhpcy5fZ2V0TG9jYWxBeGVzKCk7XG4gICAgICAgICAgdGhpcy5fcm90YXRlVmlldyhmLCByLnlbMF0sIHIueVsxXSwgci55WzJdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0aWx0XCIsIHZhbHVlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9nZXRMb2NhbEF4ZXMoKTtcbiAgICAgICAgICB0aGlzLl9yb3RhdGVWaWV3KGYsIHIueFswXSwgci54WzFdLCByLnhbMl0pO1xuICAgICAgICB9IH0sIHsga2V5OiBcImxvb2tBdFwiLCB2YWx1ZTogZnVuY3Rpb24oZiwgciwgcykge1xuICAgICAgICAgIHRoaXMuY2FtZXJhKHRoaXMuZXllWCwgdGhpcy5leWVZLCB0aGlzLmV5ZVosIGYsIHIsIHMsIHRoaXMudXBYLCB0aGlzLnVwWSwgdGhpcy51cFopO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNhbWVyYVwiLCB2YWx1ZTogZnVuY3Rpb24oZiwgciwgcywgbywgaSwgbCwgbiwgYSwgYykge1xuICAgICAgICAgIHJldHVybiBmID09PSB2b2lkIDAgJiYgKGYgPSB0aGlzLmRlZmF1bHRFeWVYLCByID0gdGhpcy5kZWZhdWx0RXllWSwgcyA9IHRoaXMuZGVmYXVsdEV5ZVosIG8gPSBmLCBpID0gciwgYSA9IDEsIGMgPSBuID0gbCA9IDApLCB0aGlzLmV5ZVggPSBmLCB0aGlzLmV5ZVkgPSByLCB0aGlzLmV5ZVogPSBzLCBvICE9PSB2b2lkIDAgJiYgKHRoaXMuY2VudGVyWCA9IG8sIHRoaXMuY2VudGVyWSA9IGksIHRoaXMuY2VudGVyWiA9IGwpLCBuICE9PSB2b2lkIDAgJiYgKHRoaXMudXBYID0gbiwgdGhpcy51cFkgPSBhLCB0aGlzLnVwWiA9IGMpLCBvID0gdGhpcy5fZ2V0TG9jYWxBeGVzKCksIHRoaXMuY2FtZXJhTWF0cml4LnNldChvLnhbMF0sIG8ueVswXSwgby56WzBdLCAwLCBvLnhbMV0sIG8ueVsxXSwgby56WzFdLCAwLCBvLnhbMl0sIG8ueVsyXSwgby56WzJdLCAwLCAwLCAwLCAwLCAxKSwgaSA9IC1mLCB0aGlzLmNhbWVyYU1hdHJpeC50cmFuc2xhdGUoW2ksIC1yLCAtc10pLCB0aGlzLl9pc0FjdGl2ZSgpICYmIHRoaXMuX3JlbmRlcmVyLnVNVk1hdHJpeC5zZXQodGhpcy5jYW1lcmFNYXRyaXgpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm1vdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKG8sIGksIHMpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXMuX2dldExvY2FsQXhlcygpLCBvID0gW2wueFswXSAqIG8sIGwueFsxXSAqIG8sIGwueFsyXSAqIG9dLCBpID0gW2wueVswXSAqIGksIGwueVsxXSAqIGksIGwueVsyXSAqIGldLCBsID0gW2wuelswXSAqIHMsIGwuelsxXSAqIHMsIGwuelsyXSAqIHNdO1xuICAgICAgICAgIHRoaXMuY2FtZXJhKHRoaXMuZXllWCArIG9bMF0gKyBpWzBdICsgbFswXSwgdGhpcy5leWVZICsgb1sxXSArIGlbMV0gKyBsWzFdLCB0aGlzLmV5ZVogKyBvWzJdICsgaVsyXSArIGxbMl0sIHRoaXMuY2VudGVyWCArIG9bMF0gKyBpWzBdICsgbFswXSwgdGhpcy5jZW50ZXJZICsgb1sxXSArIGlbMV0gKyBsWzFdLCB0aGlzLmNlbnRlclogKyBvWzJdICsgaVsyXSArIGxbMl0sIHRoaXMudXBYLCB0aGlzLnVwWSwgdGhpcy51cFopO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFBvc2l0aW9uXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgICAgdmFyIG8gPSBmIC0gdGhpcy5leWVYLCBpID0gciAtIHRoaXMuZXllWSwgbCA9IHMgLSB0aGlzLmV5ZVo7XG4gICAgICAgICAgdGhpcy5jYW1lcmEoZiwgciwgcywgdGhpcy5jZW50ZXJYICsgbywgdGhpcy5jZW50ZXJZICsgaSwgdGhpcy5jZW50ZXJaICsgbCwgdGhpcy51cFgsIHRoaXMudXBZLCB0aGlzLnVwWik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0XCIsIHZhbHVlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDAsIHMgPSBbXCJleWVYXCIsIFwiZXllWVwiLCBcImV5ZVpcIiwgXCJjZW50ZXJYXCIsIFwiY2VudGVyWVwiLCBcImNlbnRlclpcIiwgXCJ1cFhcIiwgXCJ1cFlcIiwgXCJ1cFpcIiwgXCJjYW1lcmFGT1ZcIiwgXCJhc3BlY3RSYXRpb1wiLCBcImNhbWVyYU5lYXJcIiwgXCJjYW1lcmFGYXJcIiwgXCJjYW1lcmFUeXBlXCIsIFwieVNjYWxlXCJdOyByIDwgcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBzW3JdO1xuICAgICAgICAgICAgdGhpc1tvXSA9IGZbb107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2FtZXJhTWF0cml4ID0gZi5jYW1lcmFNYXRyaXguY29weSgpLCB0aGlzLnByb2pNYXRyaXggPSBmLnByb2pNYXRyaXguY29weSgpLCB0aGlzLl9pc0FjdGl2ZSgpICYmICh0aGlzLl9yZW5kZXJlci51TVZNYXRyaXgubWF0NCA9IHRoaXMuY2FtZXJhTWF0cml4Lm1hdDQuc2xpY2UoKSwgdGhpcy5fcmVuZGVyZXIudVBNYXRyaXgubWF0NCA9IHRoaXMucHJvak1hdHJpeC5tYXQ0LnNsaWNlKCkpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNsZXJwXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByLCBzKSB7XG4gICAgICAgICAgdmFyIG8sIGksIGwsIG4sIGEsIGMsIHAsIGosIFQsIF8sIFMsIEUsIEEsIHgsIFAsIE0sIFIsIEw7XG4gICAgICAgICAgcyA9PT0gMCA/IHRoaXMuc2V0KGYpIDogcyA9PT0gMSA/IHRoaXMuc2V0KHIpIDogKHRoaXMucHJvak1hdHJpeC5tYXQ0WzE1XSAhPT0gMCAmJiAodGhpcy5wcm9qTWF0cml4Lm1hdDRbMF0gPSBmLnByb2pNYXRyaXgubWF0NFswXSAqIE1hdGgucG93KHIucHJvak1hdHJpeC5tYXQ0WzBdIC8gZi5wcm9qTWF0cml4Lm1hdDRbMF0sIHMpLCB0aGlzLnByb2pNYXRyaXgubWF0NFs1XSA9IGYucHJvak1hdHJpeC5tYXQ0WzVdICogTWF0aC5wb3coci5wcm9qTWF0cml4Lm1hdDRbNV0gLyBmLnByb2pNYXRyaXgubWF0NFs1XSwgcyksIHRoaXMuX2lzQWN0aXZlKCkgJiYgKHRoaXMuX3JlbmRlcmVyLnVQTWF0cml4Lm1hdDQgPSB0aGlzLnByb2pNYXRyaXgubWF0NC5zbGljZSgpKSksIG4gPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihmLmV5ZVgsIGYuZXllWSwgZi5leWVaKSwgYSA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKHIuZXllWCwgci5leWVZLCByLmV5ZVopLCBNID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IoZi5jZW50ZXJYLCBmLmNlbnRlclksIGYuY2VudGVyWiksIEwgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcihyLmNlbnRlclgsIHIuY2VudGVyWSwgci5jZW50ZXJaKSwgbCA9IG0uZGVmYXVsdC5WZWN0b3IuZGlzdChuLCBNKSwgbyA9IG0uZGVmYXVsdC5WZWN0b3IuZGlzdChhLCBMKSwgbyA9IGwgKiBNYXRoLnBvdyhvIC8gbCwgcyksIGwgPSBtLmRlZmF1bHQuVmVjdG9yLnN1YihuLCBhKSwgaSA9IDEsIDFlLTYgPCAoUiA9ICh4ID0gbi5jb3B5KCkuc3ViKGEpLnN1YihNKS5hZGQoTCkpLm1hZ1NxKCkpICYmIChpID0gbS5kZWZhdWx0LlZlY3Rvci5kb3QobCwgeCkgLyBSLCBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaSwgMSkpKSwgbCA9IG0uZGVmYXVsdC5WZWN0b3IubGVycChtLmRlZmF1bHQuVmVjdG9yLmxlcnAobiwgTSwgaSksIG0uZGVmYXVsdC5WZWN0b3IubGVycChhLCBMLCBpKSwgcyksIHggPSBmLmNhbWVyYU1hdHJpeC5jcmVhdGVTdWJNYXRyaXgzeDMoKSwgUiA9IHIuY2FtZXJhTWF0cml4LmNyZWF0ZVN1Yk1hdHJpeDN4MygpLCBuID0geC5yb3coMiksIE0gPSBSLnJvdygyKSwgYSA9IHgucm93KDEpLCBMID0gUi5yb3coMSksIGYgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcigpLCByID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IoKSwgYyA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKCksIHAgPSBuZXcgbS5kZWZhdWx0LlZlY3RvcigpLCAxIC0gKGogPSAwLjUgKiAoKHggPSAoUiA9IFIubXVsdDN4Myh4LmNvcHkoKS50cmFuc3Bvc2UzeDMoKSkpLmRpYWdvbmFsKCkpWzBdICsgeFsxXSArIHhbMl0gLSAxKSkgPCAxZS03ID8gKGYuc2V0KG0uZGVmYXVsdC5WZWN0b3IubGVycChuLCBNLCBzKSkubm9ybWFsaXplKCksIGMuc2V0KGYpLm11bHQoaSAqIG8pLmFkZChsKSwgcC5zZXQoZikubXVsdCgoaSAtIDEpICogbykuYWRkKGwpLCByLnNldChtLmRlZmF1bHQuVmVjdG9yLmxlcnAoYSwgTCwgcykpLm5vcm1hbGl6ZSgpKSA6IChNID0gMSAvICgxIC0gaiksIEwgPSBNYXRoLm1heCh4WzBdLCB4WzFdLCB4WzJdKSwgRSA9IFIubWF0M1sxXSArIFIubWF0M1szXSwgQSA9IFIubWF0M1syXSArIFIubWF0M1s2XSwgUCA9IFIubWF0M1s1XSArIFIubWF0M1s3XSwgTCA9IEwgPT09IHhbMF0gPyAoXyA9IDAuNSAqIEUgKiAoTSAvPSBUID0gTWF0aC5zcXJ0KCh4WzBdIC0gaikgKiBNKSksIFMgPSAwLjUgKiBBICogTSwgMC41ICogKFIubWF0M1s3XSAtIFIubWF0M1s1XSkgLyBUKSA6IEwgPT09IHhbMV0gPyAoUyA9IDAuNSAqIFAgKiAoTSAvPSBfID0gTWF0aC5zcXJ0KCh4WzFdIC0gaikgKiBNKSksIFQgPSAwLjUgKiBFICogTSwgMC41ICogKFIubWF0M1syXSAtIFIubWF0M1s2XSkgLyBfKSA6IChUID0gMC41ICogQSAqIChNIC89IFMgPSBNYXRoLnNxcnQoKHhbMl0gLSBqKSAqIE0pKSwgXyA9IDAuNSAqIFAgKiBNLCAwLjUgKiAoUi5tYXQzWzNdIC0gUi5tYXQzWzFdKSAvIFMpLCBFID0gcyAqIE1hdGguYXRhbjIoTCwgaiksIEEgPSBNYXRoLmNvcyhFKSwgeCA9IE1hdGguc2luKEUpLCAoTCA9IG5ldyBtLmRlZmF1bHQuTWF0cml4KFwibWF0M1wiLCBbQSArIChQID0gMSAtIEEpICogVCAqIFQsIFAgKiAoTSA9IFQgKiBfKSArIHggKiBTLCBQICogKFIgPSBTICogVCkgLSB4ICogXywgUCAqIE0gLSB4ICogUywgQSArIFAgKiBfICogXywgUCAqIChzID0gXyAqIFMpICsgeCAqIFQsIFAgKiBSICsgeCAqIF8sIFAgKiBzIC0geCAqIFQsIEEgKyBQICogUyAqIFNdKSkubXVsdGlwbHlWZWMzKG4sIGYpLCBjLnNldChmKS5tdWx0KGkgKiBvKS5hZGQobCksIHAuc2V0KGYpLm11bHQoKGkgLSAxKSAqIG8pLmFkZChsKSwgTC5tdWx0aXBseVZlYzMoYSwgcikpLCB0aGlzLmNhbWVyYShjLngsIGMueSwgYy56LCBwLngsIHAueSwgcC56LCByLngsIHIueSwgci56KSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2NvbXB1dGVDYW1lcmFEZWZhdWx0U2V0dGluZ3NcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEFzcGVjdFJhdGlvID0gdGhpcy5fcmVuZGVyZXIud2lkdGggLyB0aGlzLl9yZW5kZXJlci5oZWlnaHQsIHRoaXMuZGVmYXVsdEV5ZVggPSAwLCB0aGlzLmRlZmF1bHRFeWVZID0gMCwgdGhpcy5kZWZhdWx0RXllWiA9IDgwMCwgdGhpcy5kZWZhdWx0Q2FtZXJhRk9WID0gMiAqIE1hdGguYXRhbih0aGlzLl9yZW5kZXJlci5oZWlnaHQgLyAyIC8gdGhpcy5kZWZhdWx0RXllWiksIHRoaXMuZGVmYXVsdENlbnRlclggPSAwLCB0aGlzLmRlZmF1bHRDZW50ZXJZID0gMCwgdGhpcy5kZWZhdWx0Q2VudGVyWiA9IDAsIHRoaXMuZGVmYXVsdENhbWVyYU5lYXIgPSAwLjEgKiB0aGlzLmRlZmF1bHRFeWVaLCB0aGlzLmRlZmF1bHRDYW1lcmFGYXIgPSAxMCAqIHRoaXMuZGVmYXVsdEV5ZVo7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NldERlZmF1bHRDYW1lcmFcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2FtZXJhRk9WID0gdGhpcy5kZWZhdWx0Q2FtZXJhRk9WLCB0aGlzLmFzcGVjdFJhdGlvID0gdGhpcy5kZWZhdWx0QXNwZWN0UmF0aW8sIHRoaXMuZXllWCA9IHRoaXMuZGVmYXVsdEV5ZVgsIHRoaXMuZXllWSA9IHRoaXMuZGVmYXVsdEV5ZVksIHRoaXMuZXllWiA9IHRoaXMuZGVmYXVsdEV5ZVosIHRoaXMuY2VudGVyWCA9IHRoaXMuZGVmYXVsdENlbnRlclgsIHRoaXMuY2VudGVyWSA9IHRoaXMuZGVmYXVsdENlbnRlclksIHRoaXMuY2VudGVyWiA9IHRoaXMuZGVmYXVsdENlbnRlclosIHRoaXMudXBYID0gMCwgdGhpcy51cFkgPSAxLCB0aGlzLnVwWiA9IDAsIHRoaXMuY2FtZXJhTmVhciA9IHRoaXMuZGVmYXVsdENhbWVyYU5lYXIsIHRoaXMuY2FtZXJhRmFyID0gdGhpcy5kZWZhdWx0Q2FtZXJhRmFyLCB0aGlzLnBlcnNwZWN0aXZlKCksIHRoaXMuY2FtZXJhKCksIHRoaXMuY2FtZXJhVHlwZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9yZXNpemVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2FtZXJhVHlwZSA9PT0gXCJkZWZhdWx0XCIgJiYgKHRoaXMuX2NvbXB1dGVDYW1lcmFEZWZhdWx0U2V0dGluZ3MoKSwgdGhpcy5jYW1lcmFGT1YgPSB0aGlzLmRlZmF1bHRDYW1lcmFGT1YsIHRoaXMuYXNwZWN0UmF0aW8gPSB0aGlzLmRlZmF1bHRBc3BlY3RSYXRpbywgdGhpcy5wZXJzcGVjdGl2ZSgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjb3B5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZiA9IG5ldyBtLmRlZmF1bHQuQ2FtZXJhKHRoaXMuX3JlbmRlcmVyKTtcbiAgICAgICAgICByZXR1cm4gZi5jYW1lcmFGT1YgPSB0aGlzLmNhbWVyYUZPViwgZi5hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW8sIGYuZXllWCA9IHRoaXMuZXllWCwgZi5leWVZID0gdGhpcy5leWVZLCBmLmV5ZVogPSB0aGlzLmV5ZVosIGYuY2VudGVyWCA9IHRoaXMuY2VudGVyWCwgZi5jZW50ZXJZID0gdGhpcy5jZW50ZXJZLCBmLmNlbnRlclogPSB0aGlzLmNlbnRlclosIGYudXBYID0gdGhpcy51cFgsIGYudXBZID0gdGhpcy51cFksIGYudXBaID0gdGhpcy51cFosIGYuY2FtZXJhTmVhciA9IHRoaXMuY2FtZXJhTmVhciwgZi5jYW1lcmFGYXIgPSB0aGlzLmNhbWVyYUZhciwgZi5jYW1lcmFUeXBlID0gdGhpcy5jYW1lcmFUeXBlLCBmLmNhbWVyYU1hdHJpeCA9IHRoaXMuY2FtZXJhTWF0cml4LmNvcHkoKSwgZi5wcm9qTWF0cml4ID0gdGhpcy5wcm9qTWF0cml4LmNvcHkoKSwgZi55U2NhbGUgPSB0aGlzLnlTY2FsZSwgZjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0TG9jYWxBeGVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMuZXllWCAtIHRoaXMuY2VudGVyWCwgciA9IHRoaXMuZXllWSAtIHRoaXMuY2VudGVyWSwgcyA9IHRoaXMuZXllWiAtIHRoaXMuY2VudGVyWiwgbiA9IE1hdGguc3FydChmICogZiArIHIgKiByICsgcyAqIHMpLCBuID0gKG4gIT09IDAgJiYgKGYgLz0gbiwgciAvPSBuLCBzIC89IG4pLCB0aGlzLnVwWCksIG8gPSAoYSA9IHRoaXMudXBZKSAqIHMgLSAoYyA9IHRoaXMudXBaKSAqIHIsIGkgPSAtbiAqIHMgKyBjICogZiwgbCA9IG4gKiByIC0gYSAqIGYsIG4gPSByICogbCAtIHMgKiBpLCBhID0gLWYgKiBsICsgcyAqIG8sIGMgPSBmICogaSAtIHIgKiBvLCBwID0gTWF0aC5zcXJ0KG8gKiBvICsgaSAqIGkgKyBsICogbCksIHAgPSAocCAhPT0gMCAmJiAobyAvPSBwLCBpIC89IHAsIGwgLz0gcCksIE1hdGguc3FydChuICogbiArIGEgKiBhICsgYyAqIGMpKTtcbiAgICAgICAgICByZXR1cm4gcCAhPT0gMCAmJiAobiAvPSBwLCBhIC89IHAsIGMgLz0gcCksIHsgeDogW28sIGksIGxdLCB5OiBbbiwgYSwgY10sIHo6IFtmLCByLCBzXSB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9vcmJpdFwiLCB2YWx1ZTogZnVuY3Rpb24oZiwgcCwgYykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5leWVYIC0gdGhpcy5jZW50ZXJYLCBsID0gdGhpcy5leWVZIC0gdGhpcy5jZW50ZXJZLCBuID0gdGhpcy5leWVaIC0gdGhpcy5jZW50ZXJaLCBvID0gTWF0aC5oeXBvdChpLCBsLCBuKSwgaSA9IG5ldyBtLmRlZmF1bHQuVmVjdG9yKGksIGwsIG4pLm5vcm1hbGl6ZSgpLCBsID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IodGhpcy51cFgsIHRoaXMudXBZLCB0aGlzLnVwWikubm9ybWFsaXplKCksIG4gPSBtLmRlZmF1bHQuVmVjdG9yLmNyb3NzKGwsIGkpLm5vcm1hbGl6ZSgpLCBhID0gbS5kZWZhdWx0LlZlY3Rvci5jcm9zcyhuLCBsKSwgYyA9ICgobyA9IChvICo9IE1hdGgucG93KDEwLCBjKSkgPCB0aGlzLmNhbWVyYU5lYXIgPyB0aGlzLmNhbWVyYU5lYXIgOiBvKSA+IHRoaXMuY2FtZXJhRmFyICYmIChvID0gdGhpcy5jYW1lcmFGYXIpLCBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIG0uZGVmYXVsdC5WZWN0b3IuZG90KGksIGwpKSkpICsgcCksIHAgPSBmO1xuICAgICAgICAgIChjIDw9IDAgfHwgYyA+PSBNYXRoLlBJKSAmJiAodGhpcy51cFggKj0gLTEsIHRoaXMudXBZICo9IC0xLCB0aGlzLnVwWiAqPSAtMSksIGwubXVsdChNYXRoLmNvcyhjKSksIGEubXVsdChNYXRoLmNvcyhwKSAqIE1hdGguc2luKGMpKSwgbi5tdWx0KE1hdGguc2luKHApICogTWF0aC5zaW4oYykpLCBpLnNldChsKS5hZGQoYSkuYWRkKG4pLCB0aGlzLmV5ZVggPSBvICogaS54ICsgdGhpcy5jZW50ZXJYLCB0aGlzLmV5ZVkgPSBvICogaS55ICsgdGhpcy5jZW50ZXJZLCB0aGlzLmV5ZVogPSBvICogaS56ICsgdGhpcy5jZW50ZXJaLCB0aGlzLmNhbWVyYSh0aGlzLmV5ZVgsIHRoaXMuZXllWSwgdGhpcy5leWVaLCB0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgdGhpcy5jZW50ZXJaLCB0aGlzLnVwWCwgdGhpcy51cFksIHRoaXMudXBaKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfb3JiaXRGcmVlXCIsIHZhbHVlOiBmdW5jdGlvbihjLCBwLCBUKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmV5ZVggLSB0aGlzLmNlbnRlclgsIGwgPSB0aGlzLmV5ZVkgLSB0aGlzLmNlbnRlclksIG4gPSB0aGlzLmV5ZVogLSB0aGlzLmNlbnRlclosIG8gPSBNYXRoLmh5cG90KGksIGwsIG4pLCBpID0gbmV3IG0uZGVmYXVsdC5WZWN0b3IoaSwgbCwgbikubm9ybWFsaXplKCksIGwgPSBuZXcgbS5kZWZhdWx0LlZlY3Rvcih0aGlzLnVwWCwgdGhpcy51cFksIHRoaXMudXBaKSwgbiA9IG0uZGVmYXVsdC5WZWN0b3IuY3Jvc3MobCwgaSkubm9ybWFsaXplKCksIGEgPSBtLmRlZmF1bHQuVmVjdG9yLmNyb3NzKGksIG4pLCBfID0gTWF0aC5hdGFuMihwLCBjKSwgXyA9IChhLm11bHQoTWF0aC5zaW4oXykpLCBuLm11bHQoTWF0aC5jb3MoXykpLmFkZChhKSwgTWF0aC5zcXJ0KGMgKiBjICsgcCAqIHApKSwgYSA9IG0uZGVmYXVsdC5WZWN0b3IuY3Jvc3MoaSwgbiksIGMgPSAoKG8gPSAobyAqPSBNYXRoLnBvdygxMCwgVCkpIDwgdGhpcy5jYW1lcmFOZWFyID8gdGhpcy5jYW1lcmFOZWFyIDogbykgPiB0aGlzLmNhbWVyYUZhciAmJiAobyA9IHRoaXMuY2FtZXJhRmFyKSwgTWF0aC5jb3MoXykpLCBwID0gTWF0aC5zaW4oXyksIFQgPSBsLmRvdChpKSwgXyA9IGwuZG90KG4pLCBqID0gVCAqIGMgKyBfICogcCwgVCA9IC1UICogcCArIF8gKiBjLCBfID0gbC5kb3QoYSk7XG4gICAgICAgICAgbC54ID0gaiAqIGkueCArIFQgKiBuLnggKyBfICogYS54LCBsLnkgPSBqICogaS55ICsgVCAqIG4ueSArIF8gKiBhLnksIGwueiA9IGogKiBpLnogKyBUICogbi56ICsgXyAqIGEueiwgbi5tdWx0KC1wKSwgaS5tdWx0KGMpLmFkZChuKS5tdWx0KG8pLCB0aGlzLmNhbWVyYShpLnggKyB0aGlzLmNlbnRlclgsIGkueSArIHRoaXMuY2VudGVyWSwgaS56ICsgdGhpcy5jZW50ZXJaLCB0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgdGhpcy5jZW50ZXJaLCBsLngsIGwueSwgbC56KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfaXNBY3RpdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzID09PSB0aGlzLl9yZW5kZXJlci5fY3VyQ2FtZXJhO1xuICAgICAgICB9IH1dKSAmJiB5KGgucHJvdG90eXBlLCBnKSwgdTtcbiAgICAgIH0oKSwgbS5kZWZhdWx0LnByb3RvdHlwZS5zZXRDYW1lcmEgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEgPSB1LCB0aGlzLl9yZW5kZXJlci51UE1hdHJpeC5zZXQodS5wcm9qTWF0cml4KTtcbiAgICAgIH0sIHQgPSBtLmRlZmF1bHQuQ2FtZXJhLCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3RcIjogMTc1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCI6IDIwNSB9XSwgMzMwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmxvZzJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGgubG9nMlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMCwgdCA9ICh0ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHsgZGVmYXVsdDogdCB9O1xuICAgICAgZnVuY3Rpb24gbSh5LCB1KSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgdS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBnID0gdVtoXTtcbiAgICAgICAgICBnLmVudW1lcmFibGUgPSBnLmVudW1lcmFibGUgfHwgITEsIGcuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBnICYmIChnLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoeSwgZy5rZXksIGcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0LmRlZmF1bHQuRGF0YUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICAgICAgdmFyIGcgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IDEyOCwgZiA9IHRoaXMsIHIgPSB5O1xuICAgICAgICAgIGlmICghKGYgaW5zdGFuY2VvZiByKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSAwLCB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGcpLCB0aGlzLmluaXRpYWxMZW5ndGggPSBnO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1LCBoO1xuICAgICAgICByZXR1cm4gdSA9IHksIChoID0gW3sga2V5OiBcImRhdGFBcnJheVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3ViQXJyYXkoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNsZWFyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVzY2FsZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPCB0aGlzLmRhdGEubGVuZ3RoIC8gMiAmJiAoZyA9IDEgPDwgTWF0aC5jZWlsKE1hdGgubG9nMih0aGlzLmxlbmd0aCkpLCAoZyA9IG5ldyBGbG9hdDMyQXJyYXkoZykpLnNldCh0aGlzLmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpLCAwKSwgdGhpcy5kYXRhID0gZyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmluaXRpYWxMZW5ndGgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInB1c2hcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGcgPSBhcmd1bWVudHMubGVuZ3RoLCBmID0gbmV3IEFycmF5KGcpLCByID0gMDsgciA8IGc7IHIrKylcbiAgICAgICAgICAgIGZbcl0gPSBhcmd1bWVudHNbcl07XG4gICAgICAgICAgdGhpcy5lbnN1cmVMZW5ndGgodGhpcy5sZW5ndGggKyBmLmxlbmd0aCksIHRoaXMuZGF0YS5zZXQoZiwgdGhpcy5sZW5ndGgpLCB0aGlzLmxlbmd0aCArPSBmLmxlbmd0aDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzbGljZVwiLCB2YWx1ZTogZnVuY3Rpb24oZywgZikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2UoZywgTWF0aC5taW4oZiwgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzdWJBcnJheVwiLCB2YWx1ZTogZnVuY3Rpb24oZywgZikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3ViYXJyYXkoZywgTWF0aC5taW4oZiwgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlbnN1cmVMZW5ndGhcIiwgdmFsdWU6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICBmb3IgKDsgdGhpcy5kYXRhLmxlbmd0aCA8IGc7ICkge1xuICAgICAgICAgICAgdmFyIGYgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGYuc2V0KHRoaXMuZGF0YSwgMCksIHRoaXMuZGF0YSA9IGY7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dKSAmJiBtKHUucHJvdG90eXBlLCBoKSwgeTtcbiAgICAgIH0oKSwgdCA9IHQuZGVmYXVsdC5EYXRhQXJyYXksIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIjogMTY4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmxvZzJcIjogMTc2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIjogMjEwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiOiAyMTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIjogMjEyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIjogMjEzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCI6IDIxNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiOiAyMTQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXlcIjogMjE2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiOiAyMTgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCI6IDIxOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIjogMjIwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiOiAyMjMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIjogMjI0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCI6IDIyNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCI6IDIyNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCI6IDIyOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCI6IDIyNywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiOiAyMjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiOiAyMzAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCI6IDIzMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiOiAyMzIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIjogMjMzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiOiAyMzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIjogMjM1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIjogMjM2IH1dLCAzMzE6IFtmdW5jdGlvbihFLCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKEEpIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgeDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4geCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB4LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgeCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgeDtcbiAgICAgICAgfSkoQSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KEEpIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiBtKHgpO1xuICAgICAgICB9IDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiB4ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHguY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB4ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0oeCk7XG4gICAgICAgIH0pKEEpO1xuICAgICAgfVxuICAgICAgRShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1jbGFtcGVkLWFycmF5XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZlwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlc1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWNsYW1wZWQtYXJyYXlcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCBFKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIEUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgRShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKFMgPSBFKFwiLi4vY29yZS9tYWluXCIpKSAmJiBTLl9fZXNNb2R1bGUgPyBTIDogeyBkZWZhdWx0OiBTIH0sIGggPSBmdW5jdGlvbihBKSB7XG4gICAgICAgIGlmIChBICYmIEEuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgaWYgKEEgPT09IG51bGwgfHwgeShBKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgQSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogQSB9O1xuICAgICAgICB2YXIgeCA9IHIoKTtcbiAgICAgICAgaWYgKHggJiYgeC5oYXMoQSkpXG4gICAgICAgICAgcmV0dXJuIHguZ2V0KEEpO1xuICAgICAgICB2YXIgUCwgTSA9IHt9LCBSID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAoUCBpbiBBKSB7XG4gICAgICAgICAgdmFyIEw7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsIFApICYmICgoTCA9IFIgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEEsIFApIDogbnVsbCkgJiYgKEwuZ2V0IHx8IEwuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNLCBQLCBMKSA6IE1bUF0gPSBBW1BdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTS5kZWZhdWx0ID0gQSwgeCAmJiB4LnNldChBLCBNKSwgTTtcbiAgICAgIH0oRShcIi4uL2NvcmUvY29uc3RhbnRzXCIpKSwgZyA9IEUoXCIuL3A1LlRleHR1cmVcIiksIGYgPSBFKFwiLi9wNS5SZW5kZXJlckdMXCIpO1xuICAgICAgZnVuY3Rpb24gcigpIHtcbiAgICAgICAgdmFyIEE7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKEEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9LCBBKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHMoQSwgeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oUCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFApKVxuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0oQSkgfHwgZnVuY3Rpb24oUCwgTSkge1xuICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KFApIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikge1xuICAgICAgICAgICAgdmFyIFIgPSBbXSwgTCA9ICEwLCBGID0gITEsIFYgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBHLCBVID0gUFtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoTCA9IChHID0gVS5uZXh0KCkpLmRvbmUpICYmIChSLnB1c2goRy52YWx1ZSksICFNIHx8IFIubGVuZ3RoICE9PSBNKTsgTCA9ICEwKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFcpIHtcbiAgICAgICAgICAgICAgRiA9ICEwLCBWID0gVztcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgTCB8fCBVLnJldHVybiA9PSBudWxsIHx8IFUucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKEYpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBWO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUjtcbiAgICAgICAgICB9XG4gICAgICAgIH0oQSwgeCkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8oQSwgeCwgUCkge1xuICAgICAgICByZXR1cm4geCBpbiBBID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsIHgsIHsgdmFsdWU6IFAsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBBW3hdID0gUCwgQTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoQSwgeCkge1xuICAgICAgICBpZiAoIShBIGluc3RhbmNlb2YgeCkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwoQSwgeCkge1xuICAgICAgICBmb3IgKHZhciBQID0gMDsgUCA8IHgubGVuZ3RoOyBQKyspIHtcbiAgICAgICAgICB2YXIgTSA9IHhbUF07XG4gICAgICAgICAgTS5lbnVtZXJhYmxlID0gTS5lbnVtZXJhYmxlIHx8ICExLCBNLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gTSAmJiAoTS53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsIE0ua2V5LCBNKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbihBLCB4LCBQKSB7XG4gICAgICAgIHggJiYgbChBLnByb3RvdHlwZSwgeCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhKEEsIHgsIFApIHtcbiAgICAgICAgcmV0dXJuIChhID0gdHlwZW9mIFJlZmxlY3QgPCBcInVcIiAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0IDogZnVuY3Rpb24oRiwgUiwgTCkge1xuICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oViwgRykge1xuICAgICAgICAgICAgZm9yICg7ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoViwgRykgJiYgKFYgPSBqKFYpKSAhPT0gbnVsbDsgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gVjtcbiAgICAgICAgICB9KEYsIFIpO1xuICAgICAgICAgIGlmIChGKVxuICAgICAgICAgICAgcmV0dXJuIChGID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihGLCBSKSkuZ2V0ID8gRi5nZXQuY2FsbChMKSA6IEYudmFsdWU7XG4gICAgICAgIH0pKEEsIHgsIFAgfHwgQSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKEEsIHgpIHtcbiAgICAgICAgcmV0dXJuIChjID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKFAsIE0pIHtcbiAgICAgICAgICByZXR1cm4gUC5fX3Byb3RvX18gPSBNLCBQO1xuICAgICAgICB9KShBLCB4KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHAoQSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHgsIFAgPSBqKEEpLCBQID0gKHggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KSksIDE7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSgpID8gKHggPSBqKHRoaXMpLmNvbnN0cnVjdG9yLCBSZWZsZWN0LmNvbnN0cnVjdChQLCBhcmd1bWVudHMsIHgpKSA6IFAuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcyk7XG4gICAgICAgICAgaWYgKCF4IHx8IHkoeCkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHggIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoUCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBqKEEpIHtcbiAgICAgICAgcmV0dXJuIChqID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiB4Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgICAgIH0pKEEpO1xuICAgICAgfVxuICAgICAgdmFyIFQgPSBmdW5jdGlvbihBKSB7XG4gICAgICAgIHZhciB4ID0gTTtcbiAgICAgICAgaWYgKHR5cGVvZiBBICE9IFwiZnVuY3Rpb25cIiAmJiBBICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgeC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEEgJiYgQS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHgsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBBICYmIGMoeCwgQSk7XG4gICAgICAgIHZhciBQID0gcChNKTtcbiAgICAgICAgZnVuY3Rpb24gTShSKSB7XG4gICAgICAgICAgdmFyIEw7XG4gICAgICAgICAgcmV0dXJuIGkodGhpcywgTSksIChMID0gUC5jYWxsKHRoaXMsIFIudGFyZ2V0Ll9yZW5kZXJlcikpLmZibyA9IFIsIEwueVNjYWxlID0gLTEsIEw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4oTSwgW3sga2V5OiBcIl9jb21wdXRlQ2FtZXJhRGVmYXVsdFNldHRpbmdzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhKGooTS5wcm90b3R5cGUpLCBcIl9jb21wdXRlQ2FtZXJhRGVmYXVsdFNldHRpbmdzXCIsIHRoaXMpLmNhbGwodGhpcyksIHRoaXMuZGVmYXVsdEFzcGVjdFJhdGlvID0gdGhpcy5mYm8ud2lkdGggLyB0aGlzLmZiby5oZWlnaHQsIHRoaXMuZGVmYXVsdENhbWVyYUZPViA9IDIgKiBNYXRoLmF0YW4odGhpcy5mYm8uaGVpZ2h0IC8gMiAvIHRoaXMuZGVmYXVsdEV5ZVopO1xuICAgICAgICB9IH1dKSwgTTtcbiAgICAgIH0odS5kZWZhdWx0LkNhbWVyYSksIF8gPSAodS5kZWZhdWx0LkZyYW1lYnVmZmVyQ2FtZXJhID0gVCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEEoeCwgUCkge1xuICAgICAgICAgIGkodGhpcywgQSksIHRoaXMuZnJhbWVidWZmZXIgPSB4LCB0aGlzLnByb3BlcnR5ID0gUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbihBLCBbeyBrZXk6IFwicmF3VGV4dHVyZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVidWZmZXJbdGhpcy5wcm9wZXJ0eV07XG4gICAgICAgIH0gfSwgeyBrZXk6IFwid2lkdGhcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCAqIHRoaXMuZnJhbWVidWZmZXIuZGVuc2l0eTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJoZWlnaHRcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgKiB0aGlzLmZyYW1lYnVmZmVyLmRlbnNpdHk7XG4gICAgICAgIH0gfV0pLCBBO1xuICAgICAgfSgpKSwgUyA9ICh1LmRlZmF1bHQuRnJhbWVidWZmZXJUZXh0dXJlID0gXywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEEoeCkge1xuICAgICAgICAgIHZhciBQID0gdGhpcywgTSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIFIgPSAoaSh0aGlzLCBBKSwgdGhpcy50YXJnZXQgPSB4LCB0aGlzLnRhcmdldC5fcmVuZGVyZXIuZnJhbWVidWZmZXJzLmFkZCh0aGlzKSwgdGhpcy5faXNDbGlwQXBwbGllZCA9ICExLCB0aGlzLnBpeGVscyA9IFtdLCB0aGlzLmZvcm1hdCA9IE0uZm9ybWF0IHx8IGguVU5TSUdORURfQllURSwgdGhpcy5jaGFubmVscyA9IE0uY2hhbm5lbHMgfHwgKHguX3JlbmRlcmVyLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLmFscGhhID8gaC5SR0JBIDogaC5SR0IpLCB0aGlzLnVzZURlcHRoID0gTS5kZXB0aCA9PT0gdm9pZCAwIHx8IE0uZGVwdGgsIHRoaXMuZGVwdGhGb3JtYXQgPSBNLmRlcHRoRm9ybWF0IHx8IGguRkxPQVQsIHRoaXMudGV4dHVyZUZpbHRlcmluZyA9IE0udGV4dHVyZUZpbHRlcmluZyB8fCBoLkxJTkVBUiwgTS5hbnRpYWxpYXMgPT09IHZvaWQgMCA/IHRoaXMuYW50aWFsaWFzU2FtcGxlcyA9IHguX3JlbmRlcmVyLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLmFudGlhbGlhcyA/IDIgOiAwIDogdHlwZW9mIE0uYW50aWFsaWFzID09IFwibnVtYmVyXCIgPyB0aGlzLmFudGlhbGlhc1NhbXBsZXMgPSBNLmFudGlhbGlhcyA6IHRoaXMuYW50aWFsaWFzU2FtcGxlcyA9IE0uYW50aWFsaWFzID8gMiA6IDAsIHRoaXMuYW50aWFsaWFzID0gMCA8IHRoaXMuYW50aWFsaWFzU2FtcGxlcywgdGhpcy5hbnRpYWxpYXMgJiYgeC53ZWJnbFZlcnNpb24gIT09IGguV0VCR0wyICYmIChjb25zb2xlLndhcm4oXCJBbnRpYWxpYXNpbmcgaXMgdW5zdXBwb3J0ZWQgaW4gYSBXZWJHTCAxIGNvbnRleHRcIiksIHRoaXMuYW50aWFsaWFzID0gITEpLCB0aGlzLmRlbnNpdHkgPSBNLmRlbnNpdHkgfHwgeC5waXhlbERlbnNpdHkoKSwgeC5fcmVuZGVyZXIuR0wpO1xuICAgICAgICAgIGlmICh0aGlzLmdsID0gUiwgTS53aWR0aCAmJiBNLmhlaWdodCA/IChMID0geC5fcmVuZGVyZXIuX2FkanVzdERpbWVuc2lvbnMoTS53aWR0aCwgTS5oZWlnaHQpLCB0aGlzLndpZHRoID0gTC5hZGp1c3RlZFdpZHRoLCB0aGlzLmhlaWdodCA9IEwuYWRqdXN0ZWRIZWlnaHQsIHRoaXMuX2F1dG9TaXplZCA9ICExKSA6IChNLndpZHRoID09PSB2b2lkIDAgIT0gKE0uaGVpZ2h0ID09PSB2b2lkIDApICYmIGNvbnNvbGUud2FybihcIlBsZWFzZSBzdXBwbHkgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGZvciBhIGZyYW1lYnVmZmVyIHRvIGdpdmUgaXQgYSBzaXplLiBPbmx5IG9uZSB3YXMgZ2l2ZW4sIHNvIHRoZSBmcmFtZWJ1ZmZlciB3aWxsIG1hdGNoIHRoZSBzaXplIG9mIGl0cyBjYW52YXMuXCIpLCB0aGlzLndpZHRoID0geC53aWR0aCwgdGhpcy5oZWlnaHQgPSB4LmhlaWdodCwgdGhpcy5fYXV0b1NpemVkID0gITApLCB0aGlzLl9jaGVja0lmRm9ybWF0c0F2YWlsYWJsZSgpLCBNLnN0ZW5jaWwgJiYgIXRoaXMudXNlRGVwdGggJiYgY29uc29sZS53YXJuKFwiQSBzdGVuY2lsIGJ1ZmZlciBjYW4gb25seSBiZSB1c2VkIGlmIGFsc28gdXNpbmcgZGVwdGguIFNpbmNlIHRoZSBmcmFtZWJ1ZmZlciBoYXMgbm8gZGVwdGggYnVmZmVyLCB0aGUgc3RlbmNpbCBidWZmZXIgd2lsbCBiZSBpZ25vcmVkLlwiKSwgdGhpcy51c2VTdGVuY2lsID0gdGhpcy51c2VEZXB0aCAmJiAoTS5zdGVuY2lsID09PSB2b2lkIDAgfHwgTS5zdGVuY2lsKSwgdGhpcy5mcmFtZWJ1ZmZlciA9IFIuY3JlYXRlRnJhbWVidWZmZXIoKSwgIXRoaXMuZnJhbWVidWZmZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGEgZnJhbWVidWZmZXJcIik7XG4gICAgICAgICAgaWYgKHRoaXMuYW50aWFsaWFzICYmICh0aGlzLmFhRnJhbWVidWZmZXIgPSBSLmNyZWF0ZUZyYW1lYnVmZmVyKCksICF0aGlzLmFhRnJhbWVidWZmZXIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBhIGZyYW1lYnVmZmVyIGZvciBhbnRpYWxpYXNpbmdcIik7XG4gICAgICAgICAgdGhpcy5fcmVjcmVhdGVUZXh0dXJlcygpO1xuICAgICAgICAgIHZhciBMID0gdGhpcy50YXJnZXQuX3JlbmRlcmVyLl9jdXJDYW1lcmE7XG4gICAgICAgICAgdGhpcy5kZWZhdWx0Q2FtZXJhID0gdGhpcy5jcmVhdGVDYW1lcmEoKSwgdGhpcy5maWx0ZXJDYW1lcmEgPSB0aGlzLmNyZWF0ZUNhbWVyYSgpLCB0aGlzLnRhcmdldC5fcmVuZGVyZXIuX2N1ckNhbWVyYSA9IEwsIHRoaXMuZHJhdyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQLnRhcmdldC5jbGVhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuKEEsIFt7IGtleTogXCJyZXNpemVcIiwgdmFsdWU6IGZ1bmN0aW9uKHgsIFApIHtcbiAgICAgICAgICB0aGlzLl9hdXRvU2l6ZWQgPSAhMTtcbiAgICAgICAgICB2YXIgTSA9IHRoaXMudGFyZ2V0Ll9yZW5kZXJlci5fYWRqdXN0RGltZW5zaW9ucyh4LCBQKTtcbiAgICAgICAgICB4ID0gTS5hZGp1c3RlZFdpZHRoLCBQID0gTS5hZGp1c3RlZEhlaWdodCwgdGhpcy53aWR0aCA9IHgsIHRoaXMuaGVpZ2h0ID0gUCwgdGhpcy5faGFuZGxlUmVzaXplKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicGl4ZWxEZW5zaXR5XCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgaWYgKCF4KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVuc2l0eTtcbiAgICAgICAgICB0aGlzLl9hdXRvU2l6ZWQgPSAhMSwgdGhpcy5kZW5zaXR5ID0geCwgdGhpcy5faGFuZGxlUmVzaXplKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYXV0b1NpemVkXCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgaWYgKHggPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvU2l6ZWQ7XG4gICAgICAgICAgdGhpcy5fYXV0b1NpemVkID0geCwgdGhpcy5faGFuZGxlUmVzaXplKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2NoZWNrSWZGb3JtYXRzQXZhaWxhYmxlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2wsIHggPSAodGhpcy51c2VEZXB0aCAmJiB0aGlzLnRhcmdldC53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wgJiYgIXguZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSAmJiAoY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNyZWF0ZSBkZXB0aCB0ZXh0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gYSBmcmFtZWJ1ZmZlciB3aXRob3V0IGRlcHRoLlwiKSwgdGhpcy51c2VEZXB0aCA9ICExKSwgdGhpcy51c2VEZXB0aCAmJiB0aGlzLnRhcmdldC53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wgJiYgdGhpcy5kZXB0aEZvcm1hdCA9PT0gaC5GTE9BVCAmJiAoY29uc29sZS53YXJuKFwiRkxPQVQgZGVwdGggZm9ybWF0IGlzIHVuYXZhaWxhYmxlIGluIFdlYkdMIDEuIERlZmF1bHRpbmcgdG8gVU5TSUdORURfSU5ULlwiKSwgdGhpcy5kZXB0aEZvcm1hdCA9IGguVU5TSUdORURfSU5UKSwgW2guVU5TSUdORURfQllURSwgaC5GTE9BVCwgaC5IQUxGX0ZMT0FUXS5pbmNsdWRlcyh0aGlzLmZvcm1hdCkgfHwgKGNvbnNvbGUud2FybihcIlVua25vd24gRnJhbWVidWZmZXIgZm9ybWF0LiBQbGVhc2UgdXNlIFVOU0lHTkVEX0JZVEUsIEZMT0FULCBvciBIQUxGX0ZMT0FULiBEZWZhdWx0aW5nIHRvIFVOU0lHTkVEX0JZVEUuXCIpLCB0aGlzLmZvcm1hdCA9IGguVU5TSUdORURfQllURSksIHRoaXMudXNlRGVwdGggJiYgIVtoLlVOU0lHTkVEX0lOVCwgaC5GTE9BVF0uaW5jbHVkZXModGhpcy5kZXB0aEZvcm1hdCkgJiYgKGNvbnNvbGUud2FybihcIlVua25vd24gRnJhbWVidWZmZXIgZGVwdGggZm9ybWF0LiBQbGVhc2UgdXNlIFVOU0lHTkVEX0lOVCBvciBGTE9BVC4gRGVmYXVsdGluZyB0byBGTE9BVC5cIiksIHRoaXMuZGVwdGhGb3JtYXQgPSBoLkZMT0FUKSwgKDAsIGcuY2hlY2tXZWJHTENhcGFiaWxpdGllcykodGhpcy50YXJnZXQuX3JlbmRlcmVyKSk7XG4gICAgICAgICAgeC5mbG9hdCB8fCB0aGlzLmZvcm1hdCAhPT0gaC5GTE9BVCB8fCAoY29uc29sZS53YXJuKFwiVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHRleHR1cmVzLiBGYWxsaW5nIGJhY2sgdG8gVU5TSUdORURfQllURS5cIiksIHRoaXMuZm9ybWF0ID0gaC5VTlNJR05FRF9CWVRFKSwgdGhpcy51c2VEZXB0aCAmJiAheC5mbG9hdCAmJiB0aGlzLmRlcHRoRm9ybWF0ID09PSBoLkZMT0FUICYmIChjb25zb2xlLndhcm4oXCJUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgZGVwdGggdGV4dHVyZXMuIEZhbGxpbmcgYmFjayB0byBVTlNJR05FRF9JTlQuXCIpLCB0aGlzLmRlcHRoRm9ybWF0ID0gaC5VTlNJR05FRF9JTlQpLCB4LmhhbGZGbG9hdCB8fCB0aGlzLmZvcm1hdCAhPT0gaC5IQUxGX0ZMT0FUIHx8IChjb25zb2xlLndhcm4oXCJUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgSEFMRl9GTE9BVCB0ZXh0dXJlcy4gRmFsbGluZyBiYWNrIHRvIFVOU0lHTkVEX0JZVEUuXCIpLCB0aGlzLmZvcm1hdCA9IGguVU5TSUdORURfQllURSksIHRoaXMuY2hhbm5lbHMgPT09IGguUkdCICYmIFtoLkZMT0FULCBoLkhBTEZfRkxPQVRdLmluY2x1ZGVzKHRoaXMuZm9ybWF0KSAmJiAoY29uc29sZS53YXJuKFwiRkxPQVQgYW5kIEhBTEZfRkxPQVQgZm9ybWF0cyBkbyBub3Qgd29yayBjcm9zcy1wbGF0Zm9ybSB3aXRoIG9ubHkgUkdCIGNoYW5uZWxzLiBGYWxsaW5nIGJhY2sgdG8gUkdCQS5cIiksIHRoaXMuY2hhbm5lbHMgPSBoLlJHQkEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9yZWNyZWF0ZVRleHR1cmVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2wsIFAgPSAodGhpcy5fdXBkYXRlU2l6ZSgpLCB4LmdldFBhcmFtZXRlcih4LlRFWFRVUkVfQklORElOR18yRCkpLCBNID0geC5nZXRQYXJhbWV0ZXIoeC5GUkFNRUJVRkZFUl9CSU5ESU5HKSwgUiA9IHguY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgY29sb3IgdGV4dHVyZVwiKTtcbiAgICAgICAgICB4LmJpbmRUZXh0dXJlKHguVEVYVFVSRV8yRCwgUik7XG4gICAgICAgICAgdmFyIEwgPSB0aGlzLl9nbENvbG9yRm9ybWF0KCk7XG4gICAgICAgICAgaWYgKHgudGV4SW1hZ2UyRCh4LlRFWFRVUkVfMkQsIDAsIEwuaW50ZXJuYWxGb3JtYXQsIHRoaXMud2lkdGggKiB0aGlzLmRlbnNpdHksIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5LCAwLCBMLmZvcm1hdCwgTC50eXBlLCBudWxsKSwgdGhpcy5jb2xvclRleHR1cmUgPSBSLCB4LmJpbmRGcmFtZWJ1ZmZlcih4LkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKSwgeC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh4LkZSQU1FQlVGRkVSLCB4LkNPTE9SX0FUVEFDSE1FTlQwLCB4LlRFWFRVUkVfMkQsIFIsIDApLCB0aGlzLnVzZURlcHRoKSB7XG4gICAgICAgICAgICB2YXIgUiA9IHguY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGRlcHRoIHRleHR1cmVcIik7XG4gICAgICAgICAgICB2YXIgRiA9IHRoaXMuX2dsRGVwdGhGb3JtYXQoKTtcbiAgICAgICAgICAgIHguYmluZFRleHR1cmUoeC5URVhUVVJFXzJELCBSKSwgeC50ZXhJbWFnZTJEKHguVEVYVFVSRV8yRCwgMCwgRi5pbnRlcm5hbEZvcm1hdCwgdGhpcy53aWR0aCAqIHRoaXMuZGVuc2l0eSwgdGhpcy5oZWlnaHQgKiB0aGlzLmRlbnNpdHksIDAsIEYuZm9ybWF0LCBGLnR5cGUsIG51bGwpLCB4LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHguRlJBTUVCVUZGRVIsIHRoaXMudXNlU3RlbmNpbCA/IHguREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogeC5ERVBUSF9BVFRBQ0hNRU5ULCB4LlRFWFRVUkVfMkQsIFIsIDApLCB0aGlzLmRlcHRoVGV4dHVyZSA9IFI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYW50aWFsaWFzICYmICh0aGlzLmNvbG9yUmVuZGVyYnVmZmVyID0geC5jcmVhdGVSZW5kZXJidWZmZXIoKSwgeC5iaW5kUmVuZGVyYnVmZmVyKHguUkVOREVSQlVGRkVSLCB0aGlzLmNvbG9yUmVuZGVyYnVmZmVyKSwgeC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoeC5SRU5ERVJCVUZGRVIsIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYW50aWFsaWFzU2FtcGxlcywgeC5nZXRQYXJhbWV0ZXIoeC5NQVhfU0FNUExFUykpKSwgTC5pbnRlcm5hbEZvcm1hdCwgdGhpcy53aWR0aCAqIHRoaXMuZGVuc2l0eSwgdGhpcy5oZWlnaHQgKiB0aGlzLmRlbnNpdHkpLCB0aGlzLnVzZURlcHRoICYmIChGID0gdGhpcy5fZ2xEZXB0aEZvcm1hdCgpLCB0aGlzLmRlcHRoUmVuZGVyYnVmZmVyID0geC5jcmVhdGVSZW5kZXJidWZmZXIoKSwgeC5iaW5kUmVuZGVyYnVmZmVyKHguUkVOREVSQlVGRkVSLCB0aGlzLmRlcHRoUmVuZGVyYnVmZmVyKSwgeC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoeC5SRU5ERVJCVUZGRVIsIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYW50aWFsaWFzU2FtcGxlcywgeC5nZXRQYXJhbWV0ZXIoeC5NQVhfU0FNUExFUykpKSwgRi5pbnRlcm5hbEZvcm1hdCwgdGhpcy53aWR0aCAqIHRoaXMuZGVuc2l0eSwgdGhpcy5oZWlnaHQgKiB0aGlzLmRlbnNpdHkpKSwgeC5iaW5kRnJhbWVidWZmZXIoeC5GUkFNRUJVRkZFUiwgdGhpcy5hYUZyYW1lYnVmZmVyKSwgeC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih4LkZSQU1FQlVGRkVSLCB4LkNPTE9SX0FUVEFDSE1FTlQwLCB4LlJFTkRFUkJVRkZFUiwgdGhpcy5jb2xvclJlbmRlcmJ1ZmZlciksIHRoaXMudXNlRGVwdGggJiYgeC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih4LkZSQU1FQlVGRkVSLCB0aGlzLnVzZVN0ZW5jaWwgPyB4LkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IHguREVQVEhfQVRUQUNITUVOVCwgeC5SRU5ERVJCVUZGRVIsIHRoaXMuZGVwdGhSZW5kZXJidWZmZXIpKSwgdGhpcy51c2VEZXB0aCAmJiAodGhpcy5kZXB0aCA9IG5ldyBfKHRoaXMsIFwiZGVwdGhUZXh0dXJlXCIpLCBSID0geC5ORUFSRVNULCB0aGlzLmRlcHRoUDVUZXh0dXJlID0gbmV3IHUuZGVmYXVsdC5UZXh0dXJlKHRoaXMudGFyZ2V0Ll9yZW5kZXJlciwgdGhpcy5kZXB0aCwgeyBtaW5GaWx0ZXI6IFIsIG1hZ0ZpbHRlcjogUiB9KSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLnRleHR1cmVzLnNldCh0aGlzLmRlcHRoLCB0aGlzLmRlcHRoUDVUZXh0dXJlKSksIHRoaXMuY29sb3IgPSBuZXcgXyh0aGlzLCBcImNvbG9yVGV4dHVyZVwiKSwgTCA9IHRoaXMudGV4dHVyZUZpbHRlcmluZyA9PT0gaC5MSU5FQVIgPyB4LkxJTkVBUiA6IHguTkVBUkVTVCwgdGhpcy5jb2xvclA1VGV4dHVyZSA9IG5ldyB1LmRlZmF1bHQuVGV4dHVyZSh0aGlzLnRhcmdldC5fcmVuZGVyZXIsIHRoaXMuY29sb3IsIHsgbWluRmlsdGVyOiBMLCBtYWdGaWx0ZXI6IEwgfSksIHRoaXMudGFyZ2V0Ll9yZW5kZXJlci50ZXh0dXJlcy5zZXQodGhpcy5jb2xvciwgdGhpcy5jb2xvclA1VGV4dHVyZSksIHguYmluZFRleHR1cmUoeC5URVhUVVJFXzJELCBQKSwgeC5iaW5kRnJhbWVidWZmZXIoeC5GUkFNRUJVRkZFUiwgTSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dsQ29sb3JGb3JtYXRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB4LCBQLCBNID0gdGhpcy5nbCwgUiA9IHRoaXMuZm9ybWF0ID09PSBoLkZMT0FUID8gTS5GTE9BVCA6IHRoaXMuZm9ybWF0ID09PSBoLkhBTEZfRkxPQVQgPyB0aGlzLnRhcmdldC53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wyID8gTS5IQUxGX0ZMT0FUIDogTS5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLkhBTEZfRkxPQVRfT0VTIDogTS5VTlNJR05FRF9CWVRFLCBMID0gdGhpcy5jaGFubmVscyA9PT0gaC5SR0JBID8gTS5SR0JBIDogTS5SR0I7XG4gICAgICAgICAgcmV0dXJuIHsgaW50ZXJuYWxGb3JtYXQ6IHRoaXMudGFyZ2V0LndlYmdsVmVyc2lvbiA9PT0gaC5XRUJHTDIgPyAobyhQID0ge30sIE0uRkxPQVQsIG8oe30sIE0uUkdCQSwgTS5SR0JBMzJGKSksIG8oUCwgTS5IQUxGX0ZMT0FULCBvKHt9LCBNLlJHQkEsIE0uUkdCQTE2RikpLCBvKFAsIE0uVU5TSUdORURfQllURSwgKG8oeCA9IHt9LCBNLlJHQkEsIE0uUkdCQTgpLCBvKHgsIE0uUkdCLCBNLlJHQjgpLCB4KSksIFBbUl1bTF0pIDogdGhpcy5mb3JtYXQgPT09IGguSEFMRl9GTE9BVCA/IE0uUkdCQSA6IEwsIGZvcm1hdDogTCwgdHlwZTogUiB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nbERlcHRoRm9ybWF0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgTSA9IHRoaXMuZ2wsIHggPSB0aGlzLnVzZVN0ZW5jaWwgPyB0aGlzLmRlcHRoRm9ybWF0ID09PSBoLkZMT0FUID8gTS5GTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgOiB0aGlzLnRhcmdldC53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wyID8gTS5VTlNJR05FRF9JTlRfMjRfOCA6IE0uZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKS5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCA6IHRoaXMuZGVwdGhGb3JtYXQgPT09IGguRkxPQVQgPyBNLkZMT0FUIDogTS5VTlNJR05FRF9JTlQsIFAgPSB0aGlzLnVzZVN0ZW5jaWwgPyBNLkRFUFRIX1NURU5DSUwgOiBNLkRFUFRIX0NPTVBPTkVOVCwgTSA9IHRoaXMudXNlU3RlbmNpbCA/IHRoaXMuZGVwdGhGb3JtYXQgPT09IGguRkxPQVQgPyBNLkRFUFRIMzJGX1NURU5DSUw4IDogdGhpcy50YXJnZXQud2ViZ2xWZXJzaW9uID09PSBoLldFQkdMMiA/IE0uREVQVEgyNF9TVEVOQ0lMOCA6IE0uREVQVEhfU1RFTkNJTCA6IHRoaXMudGFyZ2V0LndlYmdsVmVyc2lvbiA9PT0gaC5XRUJHTDIgPyB0aGlzLmRlcHRoRm9ybWF0ID09PSBoLkZMT0FUID8gTS5ERVBUSF9DT01QT05FTlQzMkYgOiBNLkRFUFRIX0NPTVBPTkVOVDI0IDogTS5ERVBUSF9DT01QT05FTlQ7XG4gICAgICAgICAgcmV0dXJuIHsgaW50ZXJuYWxGb3JtYXQ6IE0sIGZvcm1hdDogUCwgdHlwZTogeCB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcIl91cGRhdGVTaXplXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9hdXRvU2l6ZWQgJiYgKHRoaXMud2lkdGggPSB0aGlzLnRhcmdldC53aWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLnRhcmdldC5oZWlnaHQsIHRoaXMuZGVuc2l0eSA9IHRoaXMudGFyZ2V0LnBpeGVsRGVuc2l0eSgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfY2FudmFzU2l6ZUNoYW5nZWRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2F1dG9TaXplZCAmJiB0aGlzLl9oYW5kbGVSZXNpemUoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfaGFuZGxlUmVzaXplXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgUiA9IHRoaXMuY29sb3IsIHggPSB0aGlzLmRlcHRoLCBQID0gdGhpcy5jb2xvclJlbmRlcmJ1ZmZlciwgTSA9IHRoaXMuZGVwdGhSZW5kZXJidWZmZXIsIFIgPSAodGhpcy5fZGVsZXRlVGV4dHVyZShSKSwgeCAmJiB0aGlzLl9kZWxldGVUZXh0dXJlKHgpLCB0aGlzLmdsKTtcbiAgICAgICAgICBQICYmIFIuZGVsZXRlUmVuZGVyYnVmZmVyKFApLCBNICYmIFIuZGVsZXRlUmVuZGVyYnVmZmVyKE0pLCB0aGlzLl9yZWNyZWF0ZVRleHR1cmVzKCksIHRoaXMuZGVmYXVsdENhbWVyYS5fcmVzaXplKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY3JlYXRlQ2FtZXJhXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IG5ldyBUKHRoaXMpO1xuICAgICAgICAgIHJldHVybiB4Ll9jb21wdXRlQ2FtZXJhRGVmYXVsdFNldHRpbmdzKCksIHguX3NldERlZmF1bHRDYW1lcmEoKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLl9jdXJDYW1lcmEgPSB4O1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9kZWxldGVUZXh0dXJlXCIsIHZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHgucmF3VGV4dHVyZSgpKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLnRleHR1cmVzLmRlbGV0ZSh4KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1vdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5nbDtcbiAgICAgICAgICB0aGlzLl9kZWxldGVUZXh0dXJlKHRoaXMuY29sb3IpLCB0aGlzLmRlcHRoICYmIHRoaXMuX2RlbGV0ZVRleHR1cmUodGhpcy5kZXB0aCksIHguZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksIHRoaXMuYWFGcmFtZWJ1ZmZlciAmJiB4LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuYWFGcmFtZWJ1ZmZlciksIHRoaXMuZGVwdGhSZW5kZXJidWZmZXIgJiYgeC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5kZXB0aFJlbmRlcmJ1ZmZlciksIHRoaXMuY29sb3JSZW5kZXJidWZmZXIgJiYgeC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5jb2xvclJlbmRlcmJ1ZmZlciksIHRoaXMudGFyZ2V0Ll9yZW5kZXJlci5mcmFtZWJ1ZmZlcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImJlZ2luXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnByZXZGcmFtZWJ1ZmZlciA9IHRoaXMudGFyZ2V0Ll9yZW5kZXJlci5hY3RpdmVGcmFtZWJ1ZmZlcigpLCB0aGlzLnByZXZGcmFtZWJ1ZmZlciAmJiB0aGlzLnByZXZGcmFtZWJ1ZmZlci5fYmVmb3JlRW5kKCksIHRoaXMudGFyZ2V0Ll9yZW5kZXJlci5hY3RpdmVGcmFtZWJ1ZmZlcnMucHVzaCh0aGlzKSwgdGhpcy5fYmVmb3JlQmVnaW4oKSwgdGhpcy50YXJnZXQucHVzaCgpLCB0aGlzLnRhcmdldC5zZXRDYW1lcmEodGhpcy5kZWZhdWx0Q2FtZXJhKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLnVNVk1hdHJpeC5zZXQodGhpcy50YXJnZXQuX3JlbmRlcmVyLl9jdXJDYW1lcmEuY2FtZXJhTWF0cml4KSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLl9hcHBseVN0ZW5jaWxUZXN0SWZDbGlwcGluZygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9mcmFtZWJ1ZmZlclRvQmluZFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYW50aWFsaWFzID8gdGhpcy5hYUZyYW1lYnVmZmVyIDogdGhpcy5mcmFtZWJ1ZmZlcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfYmVmb3JlQmVnaW5cIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5nbDtcbiAgICAgICAgICB4LmJpbmRGcmFtZWJ1ZmZlcih4LkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZWJ1ZmZlclRvQmluZCgpKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLnZpZXdwb3J0KHRoaXMud2lkdGggKiB0aGlzLmRlbnNpdHksIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfYmVmb3JlRW5kXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5hbnRpYWxpYXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5nbCwgUCA9ICh4LmJpbmRGcmFtZWJ1ZmZlcih4LlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuYWFGcmFtZWJ1ZmZlciksIHguYmluZEZyYW1lYnVmZmVyKHguRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlciksIFtbeC5DT0xPUl9CVUZGRVJfQklULCB0aGlzLmNvbG9yUDVUZXh0dXJlLmdsTWFnRmlsdGVyXV0pO1xuICAgICAgICAgICAgdGhpcy51c2VEZXB0aCAmJiBQLnB1c2goW3guREVQVEhfQlVGRkVSX0JJVCwgdGhpcy5kZXB0aFA1VGV4dHVyZS5nbE1hZ0ZpbHRlcl0pO1xuICAgICAgICAgICAgZm9yICh2YXIgTSA9IDAsIFIgPSBQOyBNIDwgUi5sZW5ndGg7IE0rKykge1xuICAgICAgICAgICAgICB2YXIgRiA9IHMoUltNXSwgMiksIEwgPSBGWzBdLCBGID0gRlsxXTtcbiAgICAgICAgICAgICAgeC5ibGl0RnJhbWVidWZmZXIoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMuZGVuc2l0eSwgdGhpcy5oZWlnaHQgKiB0aGlzLmRlbnNpdHksIDAsIDAsIHRoaXMud2lkdGggKiB0aGlzLmRlbnNpdHksIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5LCBMLCBGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZW5kXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2w7XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LnBvcCgpLCB0aGlzLnRhcmdldC5fcmVuZGVyZXIuYWN0aXZlRnJhbWVidWZmZXJzLnBvcCgpICE9PSB0aGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgY2FsbGVkIGVuZCgpIHdoaWxlIGFub3RoZXIgRnJhbWVidWZmZXIgaXMgYWN0aXZlLlwiKTtcbiAgICAgICAgICB0aGlzLl9iZWZvcmVFbmQoKSwgdGhpcy5wcmV2RnJhbWVidWZmZXIgPyB0aGlzLnByZXZGcmFtZWJ1ZmZlci5fYmVmb3JlQmVnaW4oKSA6ICh4LmJpbmRGcmFtZWJ1ZmZlcih4LkZSQU1FQlVGRkVSLCBudWxsKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLnZpZXdwb3J0KHRoaXMudGFyZ2V0Ll9yZW5kZXJlci5fb3JpZ1ZpZXdwb3J0LndpZHRoLCB0aGlzLnRhcmdldC5fcmVuZGVyZXIuX29yaWdWaWV3cG9ydC5oZWlnaHQpKSwgdGhpcy50YXJnZXQuX3JlbmRlcmVyLl9hcHBseVN0ZW5jaWxUZXN0SWZDbGlwcGluZygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRyYXdcIiwgdmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKCksIHgoKSwgdGhpcy5lbmQoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJsb2FkUGl4ZWxzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2wsIFAgPSB0aGlzLnRhcmdldC5fcmVuZGVyZXIuYWN0aXZlRnJhbWVidWZmZXIoKSwgTSA9ICh4LmJpbmRGcmFtZWJ1ZmZlcih4LkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKSwgdGhpcy5fZ2xDb2xvckZvcm1hdCgpKTtcbiAgICAgICAgICB0aGlzLnBpeGVscyA9ICgwLCBmLnJlYWRQaXhlbHNXZWJHTCkodGhpcy5waXhlbHMsIHgsIHRoaXMuZnJhbWVidWZmZXIsIDAsIDAsIHRoaXMud2lkdGggKiB0aGlzLmRlbnNpdHksIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5LCBNLmZvcm1hdCwgTS50eXBlKSwgUCA/IHguYmluZEZyYW1lYnVmZmVyKHguRlJBTUVCVUZGRVIsIFAuX2ZyYW1lYnVmZmVyVG9CaW5kKCkpIDogeC5iaW5kRnJhbWVidWZmZXIoeC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbih4LCBQLCBNLCBSKSB7XG4gICAgICAgICAgdS5kZWZhdWx0Ll92YWxpZGF0ZVBhcmFtZXRlcnMoXCJwNS5GcmFtZWJ1ZmZlci5nZXRcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgTCA9IHRoaXMuX2dsQ29sb3JGb3JtYXQoKTtcbiAgICAgICAgICBpZiAoeCA9PT0gdm9pZCAwICYmIFAgPT09IHZvaWQgMClcbiAgICAgICAgICAgIFAgPSB4ID0gMCwgTSA9IHRoaXMud2lkdGgsIFIgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICBlbHNlIGlmIChNID09PSB2b2lkIDAgJiYgUiA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuICh4IDwgMCB8fCBQIDwgMCB8fCB4ID49IHRoaXMud2lkdGggfHwgUCA+PSB0aGlzLmhlaWdodCkgJiYgKGNvbnNvbGUud2FybihcIlRoZSB4IGFuZCB5IHZhbHVlcyBwYXNzZWQgdG8gcDUuRnJhbWVidWZmZXIuZ2V0IGFyZSBvdXRzaWRlIG9mIGl0cyByYW5nZSBhbmQgd2lsbCBiZSBjbGFtcGVkLlwiKSwgeCA9IHRoaXMudGFyZ2V0LmNvbnN0cmFpbih4LCAwLCB0aGlzLndpZHRoIC0gMSksIFAgPSB0aGlzLnRhcmdldC5jb25zdHJhaW4oUCwgMCwgdGhpcy5oZWlnaHQgLSAxKSksICgwLCBmLnJlYWRQaXhlbFdlYkdMKSh0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyLCB4ICogdGhpcy5kZW5zaXR5LCBQICogdGhpcy5kZW5zaXR5LCBMLmZvcm1hdCwgTC50eXBlKTtcbiAgICAgICAgICB4ID0gdGhpcy50YXJnZXQuY29uc3RyYWluKHgsIDAsIHRoaXMud2lkdGggLSAxKSwgUCA9IHRoaXMudGFyZ2V0LmNvbnN0cmFpbihQLCAwLCB0aGlzLmhlaWdodCAtIDEpLCBNID0gdGhpcy50YXJnZXQuY29uc3RyYWluKE0sIDEsIHRoaXMud2lkdGggLSB4KSwgUiA9IHRoaXMudGFyZ2V0LmNvbnN0cmFpbihSLCAxLCB0aGlzLmhlaWdodCAtIFApO1xuICAgICAgICAgIGZvciAodmFyIEYgPSAoMCwgZi5yZWFkUGl4ZWxzV2ViR0wpKHZvaWQgMCwgdGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlciwgeCAqIHRoaXMuZGVuc2l0eSwgUCAqIHRoaXMuZGVuc2l0eSwgTSAqIHRoaXMuZGVuc2l0eSwgUiAqIHRoaXMuZGVuc2l0eSwgTC5mb3JtYXQsIEwudHlwZSksIFYgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoTSAqIFIgKiB0aGlzLmRlbnNpdHkgKiB0aGlzLmRlbnNpdHkgKiA0KSwgRyA9IChWLmZpbGwoMjU1KSwgTC50eXBlID09PSB0aGlzLmdsLlJHQiA/IDMgOiA0KSwgVSA9IDA7IFUgPCBSICogdGhpcy5kZW5zaXR5OyBVKyspXG4gICAgICAgICAgICBmb3IgKHZhciBXID0gMDsgVyA8IE0gKiB0aGlzLmRlbnNpdHk7IFcrKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgWCA9IDA7IFggPCA0OyBYKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmUsIGIgPSA0ICogKFUgKiBNICogdGhpcy5kZW5zaXR5ICsgVykgKyBYO1xuICAgICAgICAgICAgICAgIFggPCBHICYmIChuZSA9IEcgPT0gNCA/IGIgOiAoVSAqIE0gKiB0aGlzLmRlbnNpdHkgKyBXKSAqIEcgKyBYLCBWW2JdID0gRltuZV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHggPSBuZXcgdS5kZWZhdWx0LkltYWdlKE0gKiB0aGlzLmRlbnNpdHksIFIgKiB0aGlzLmRlbnNpdHkpLCB4LmltYWdlRGF0YSA9IHguY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5jcmVhdGVJbWFnZURhdGEoeC53aWR0aCwgeC5oZWlnaHQpLCB4LmltYWdlRGF0YS5kYXRhLnNldChWKSwgeC5waXhlbHMgPSB4LmltYWdlRGF0YS5kYXRhLCB4LnVwZGF0ZVBpeGVscygpLCB0aGlzLmRlbnNpdHkgIT09IDEgJiYgeC5yZXNpemUoTSwgUiksIHg7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXBkYXRlUGl4ZWxzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2wsIFAgPSAodGhpcy5jb2xvclA1VGV4dHVyZS5iaW5kVGV4dHVyZSgpLCB0aGlzLl9nbENvbG9yRm9ybWF0KCkpLCBNID0gUC5mb3JtYXQgPT09IHguUkdCQSA/IDQgOiAzLCBNID0gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5ICogdGhpcy5kZW5zaXR5ICogTSwgUiA9IFAudHlwZSA9PT0geC5VTlNJR05FRF9CWVRFID8gVWludDhBcnJheSA6IEZsb2F0MzJBcnJheTtcbiAgICAgICAgICBpZiAoISh0aGlzLnBpeGVscyBpbnN0YW5jZW9mIFIpIHx8IHRoaXMucGl4ZWxzLmxlbmd0aCAhPT0gTSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwaXhlbHMgYXJyYXkgaGFzIG5vdCBiZWVuIHNldCBjb3JyZWN0bHkuIFBsZWFzZSBjYWxsIGxvYWRQaXhlbHMoKSBiZWZvcmUgdXBkYXRlUGl4ZWxzKCkuXCIpO1xuICAgICAgICAgIHgudGV4SW1hZ2UyRCh4LlRFWFRVUkVfMkQsIDAsIFAuaW50ZXJuYWxGb3JtYXQsIHRoaXMud2lkdGggKiB0aGlzLmRlbnNpdHksIHRoaXMuaGVpZ2h0ICogdGhpcy5kZW5zaXR5LCAwLCBQLmZvcm1hdCwgUC50eXBlLCB0aGlzLnBpeGVscyksIHRoaXMuY29sb3JQNVRleHR1cmUudW5iaW5kVGV4dHVyZSgpLCBSID0gdGhpcy50YXJnZXQuX3JlbmRlcmVyLmFjdGl2ZUZyYW1lYnVmZmVyKCksIHRoaXMuYW50aWFsaWFzID8gKHRoaXMuYmVnaW4oKSwgdGhpcy50YXJnZXQucHVzaCgpLCB0aGlzLnRhcmdldC5pbWFnZU1vZGUodGhpcy50YXJnZXQuQ0VOVEVSKSwgdGhpcy50YXJnZXQucmVzZXRNYXRyaXgoKSwgdGhpcy50YXJnZXQubm9TdHJva2UoKSwgdGhpcy50YXJnZXQuY2xlYXIoKSwgdGhpcy50YXJnZXQuaW1hZ2UodGhpcywgMCwgMCksIHRoaXMudGFyZ2V0LnBvcCgpLCB0aGlzLnVzZURlcHRoICYmICh4LmNsZWFyRGVwdGgoMSksIHguY2xlYXIoeC5ERVBUSF9CVUZGRVJfQklUKSksIHRoaXMuZW5kKCkpIDogKHguYmluZEZyYW1lYnVmZmVyKHguRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpLCB0aGlzLnVzZURlcHRoICYmICh4LmNsZWFyRGVwdGgoMSksIHguY2xlYXIoeC5ERVBUSF9CVUZGRVJfQklUKSksIFIgPyB4LmJpbmRGcmFtZWJ1ZmZlcih4LkZSQU1FQlVGRkVSLCBSLl9mcmFtZWJ1ZmZlclRvQmluZCgpKSA6IHguYmluZEZyYW1lYnVmZmVyKHguRlJBTUVCVUZGRVIsIG51bGwpKTtcbiAgICAgICAgfSB9XSksIEE7XG4gICAgICB9KCkpLCBFID0gdS5kZWZhdWx0LkZyYW1lYnVmZmVyID0gUztcbiAgICAgIEMuZGVmYXVsdCA9IEU7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vcDUuUmVuZGVyZXJHTFwiOiAzMzcsIFwiLi9wNS5UZXh0dXJlXCI6IDMzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiOiAxNTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCI6IDE2MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjogMTg1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIjogMTg5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiOiAxOTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIjogMTk2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheVwiOiAyMTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCI6IDIxOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIjogMjE5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiOiAyMjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCI6IDIyMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiOiAyMjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIjogMjI1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIjogMjI2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIjogMjI4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIjogMjI3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCI6IDIyOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCI6IDIzMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIjogMjMxLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCI6IDIzMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiOiAyMzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCI6IDIzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiOiAyMzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiOiAyMzYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCI6IDIzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtY2xhbXBlZC1hcnJheVwiOiAyNDAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMzMjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0obykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBpO1xuICAgICAgICB9KShvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkobykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIG0oaSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgaS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGkgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShpKTtcbiAgICAgICAgfSkobyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3RvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdWJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS51bnNjb3BhYmxlcy5mbGF0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdWJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IChzID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgcy5fX2VzTW9kdWxlID8gcyA6IHsgZGVmYXVsdDogcyB9LCBoID0gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAobyAmJiBvLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIGlmIChvID09PSBudWxsIHx8IHkobykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IG8gfTtcbiAgICAgICAgdmFyIGkgPSBnKCk7XG4gICAgICAgIGlmIChpICYmIGkuaGFzKG8pKVxuICAgICAgICAgIHJldHVybiBpLmdldChvKTtcbiAgICAgICAgdmFyIGwsIG4gPSB7fSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGwgaW4gbykge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBsKSAmJiAoKGMgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBsKSA6IG51bGwpICYmIChjLmdldCB8fCBjLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgbCwgYykgOiBuW2xdID0gb1tsXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZGVmYXVsdCA9IG8sIGkgJiYgaS5zZXQobywgbiksIG47XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgbztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0sIG8pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBuID0gbmV3IEFycmF5KGkubGVuZ3RoKTsgbCA8IGkubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgIG5bbF0gPSBpW2xdO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KG8pIHx8IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaSkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpKTtcbiAgICAgICAgfShvKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIobywgaSkge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGkubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgbiA9IGlbbF07XG4gICAgICAgICAgbi5lbnVtZXJhYmxlID0gbi5lbnVtZXJhYmxlIHx8ICExLCBuLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIG4ua2V5LCBuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdS5kZWZhdWx0Lkdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIG8obiwgYSwgYykge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBvKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdLCB0aGlzLmJvdW5kaW5nQm94Q2FjaGUgPSBudWxsLCB0aGlzLmxpbmVWZXJ0aWNlcyA9IG5ldyB1LmRlZmF1bHQuRGF0YUFycmF5KCksIHRoaXMubGluZVRhbmdlbnRzSW4gPSBuZXcgdS5kZWZhdWx0LkRhdGFBcnJheSgpLCB0aGlzLmxpbmVUYW5nZW50c091dCA9IG5ldyB1LmRlZmF1bHQuRGF0YUFycmF5KCksIHRoaXMubGluZVNpZGVzID0gbmV3IHUuZGVmYXVsdC5EYXRhQXJyYXkoKSwgdGhpcy52ZXJ0ZXhOb3JtYWxzID0gW10sIHRoaXMuZmFjZXMgPSBbXSwgdGhpcy51dnMgPSBbXSwgdGhpcy5lZGdlcyA9IFtdLCB0aGlzLnZlcnRleENvbG9ycyA9IFtdLCB0aGlzLnZlcnRleFN0cm9rZUNvbG9ycyA9IFtdLCB0aGlzLmxpbmVWZXJ0ZXhDb2xvcnMgPSBuZXcgdS5kZWZhdWx0LkRhdGFBcnJheSgpLCB0aGlzLmRldGFpbFggPSBuICE9PSB2b2lkIDAgPyBuIDogMSwgdGhpcy5kZXRhaWxZID0gYSAhPT0gdm9pZCAwID8gYSA6IDEsIHRoaXMuZGlydHlGbGFncyA9IHt9LCB0aGlzLl9oYXNGaWxsVHJhbnNwYXJlbmN5ID0gdm9pZCAwLCB0aGlzLl9oYXNTdHJva2VUcmFuc3BhcmVuY3kgPSB2b2lkIDAsIGMgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBjLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIHJldHVybiBpID0gbywgKGwgPSBbeyBrZXk6IFwiY2FsY3VsYXRlQm91bmRpbmdCb3hcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5ib3VuZGluZ0JveENhY2hlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSksIGEgPSBuZXcgdS5kZWZhdWx0LlZlY3RvcihOdW1iZXIuTUlOX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFKSwgYyA9IDA7IGMgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gdGhpcy52ZXJ0aWNlc1tjXTtcbiAgICAgICAgICAgICAgbi54ID0gTWF0aC5taW4obi54LCBwLngpLCBuLnkgPSBNYXRoLm1pbihuLnksIHAueSksIG4ueiA9IE1hdGgubWluKG4ueiwgcC56KSwgYS54ID0gTWF0aC5tYXgoYS54LCBwLngpLCBhLnkgPSBNYXRoLm1heChhLnksIHAueSksIGEueiA9IE1hdGgubWF4KGEueiwgcC56KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoYS54IC0gbi54LCBhLnkgLSBuLnksIGEueiAtIG4ueiksIFQgPSBuZXcgdS5kZWZhdWx0LlZlY3Rvcigobi54ICsgYS54KSAvIDIsIChuLnkgKyBhLnkpIC8gMiwgKG4ueiArIGEueikgLyAyKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hDYWNoZSA9IHsgbWluOiBuLCBtYXg6IGEsIHNpemU6IGosIG9mZnNldDogVCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveENhY2hlO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlc2V0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9oYXNGaWxsVHJhbnNwYXJlbmN5ID0gdm9pZCAwLCB0aGlzLl9oYXNTdHJva2VUcmFuc3BhcmVuY3kgPSB2b2lkIDAsIHRoaXMubGluZVZlcnRpY2VzLmNsZWFyKCksIHRoaXMubGluZVRhbmdlbnRzSW4uY2xlYXIoKSwgdGhpcy5saW5lVGFuZ2VudHNPdXQuY2xlYXIoKSwgdGhpcy5saW5lU2lkZXMuY2xlYXIoKSwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPSAwLCB0aGlzLmVkZ2VzLmxlbmd0aCA9IDAsIHRoaXMudmVydGV4Q29sb3JzLmxlbmd0aCA9IDAsIHRoaXMudmVydGV4U3Ryb2tlQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMubGluZVZlcnRleENvbG9ycy5jbGVhcigpLCB0aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoID0gMCwgdGhpcy51dnMubGVuZ3RoID0gMCwgdGhpcy5kaXJ0eUZsYWdzID0ge307XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaGFzRmlsbFRyYW5zcGFyZW5jeVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0ZpbGxUcmFuc3BhcmVuY3kgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5faGFzRmlsbFRyYW5zcGFyZW5jeSA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLnZlcnRleENvbG9ycy5sZW5ndGg7IG4gKz0gNClcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4Q29sb3JzW24gKyAzXSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNGaWxsVHJhbnNwYXJlbmN5ID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZpbGxUcmFuc3BhcmVuY3k7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaGFzU3Ryb2tlVHJhbnNwYXJlbmN5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5faGFzU3Ryb2tlVHJhbnNwYXJlbmN5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1N0cm9rZVRyYW5zcGFyZW5jeSA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLmxpbmVWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBuICs9IDQpXG4gICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVWZXJ0ZXhDb2xvcnNbbiArIDNdIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1N0cm9rZVRyYW5zcGFyZW5jeSA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNTdHJva2VUcmFuc3BhcmVuY3k7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJDb2xvcnNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZlcnRleENvbG9ycyA9IFtdLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZsaXBVXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnV2cyA9IHRoaXMudXZzLmZsYXQoKS5tYXAoZnVuY3Rpb24obiwgYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgJSAyID09IDAgPyAxIC0gbiA6IG47XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZmxpcFZcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXZzID0gdGhpcy51dnMuZmxhdCgpLm1hcChmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAlIDIgPT0gMCA/IG4gOiAxIC0gbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJjb21wdXRlRmFjZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZmFjZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBuLCBhLCBjLCBwID0gdGhpcy5kZXRhaWxYICsgMSwgaiA9IDA7IGogPCB0aGlzLmRldGFpbFk7IGorKylcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgdGhpcy5kZXRhaWxYOyBUKyspXG4gICAgICAgICAgICAgIGEgPSAoaiArIDEpICogcCArIFQgKyAxLCB0aGlzLmZhY2VzLnB1c2goW2ogKiBwICsgVCwgbiA9IGogKiBwICsgVCArIDEsIGMgPSAoaiArIDEpICogcCArIFRdKSwgdGhpcy5mYWNlcy5wdXNoKFtjLCBuLCBhXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEZhY2VOb3JtYWxcIiwgdmFsdWU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZmFjZXNbYV0sIGMgPSB0aGlzLnZlcnRpY2VzW2FbMF1dLCBqID0gdGhpcy52ZXJ0aWNlc1thWzFdXSwgYSA9IHRoaXMudmVydGljZXNbYVsyXV0sIGogPSB1LmRlZmF1bHQuVmVjdG9yLnN1YihqLCBjKSwgYSA9IHUuZGVmYXVsdC5WZWN0b3Iuc3ViKGEsIGMpLCBjID0gdS5kZWZhdWx0LlZlY3Rvci5jcm9zcyhqLCBhKSwgcCA9IHUuZGVmYXVsdC5WZWN0b3IubWFnKGMpLCBqID0gcCAvICh1LmRlZmF1bHQuVmVjdG9yLm1hZyhqKSAqIHUuZGVmYXVsdC5WZWN0b3IubWFnKGEpKTtcbiAgICAgICAgICByZXR1cm4gaiA9PT0gMCB8fCBpc05hTihqKSA/IChjb25zb2xlLndhcm4oXCJwNS5HZW9tZXRyeS5wcm90b3R5cGUuX2dldEZhY2VOb3JtYWw6XCIsIFwiZmFjZSBoYXMgY29saW5lYXIgc2lkZXMgb3IgYSByZXBlYXRlZCB2ZXJ0ZXhcIiksIGMpIDogKDEgPCBqICYmIChqID0gMSksIGMubXVsdChNYXRoLmFzaW4oaikgLyBwKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY29tcHV0ZU5vcm1hbHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuLCBhID0gdGhpcywgYyA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogaC5GTEFULCBwID0gKDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30pLnJvdW5kVG9QcmVjaXNpb24sIGogPSB0aGlzLnZlcnRleE5vcm1hbHMsIFQgPSB0aGlzLnZlcnRpY2VzLCBfID0gdGhpcy5mYWNlcztcbiAgICAgICAgICBpZiAoYyA9PT0gaC5TTU9PVEgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFMgPSB7fSwgRSA9IFtdLCBBID0gTWF0aC5wb3coMTAsIHAgPT09IHZvaWQgMCA/IDMgOiBwKSwgeCA9IGZ1bmN0aW9uKEYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoRiAqIEEpIC8gQTtcbiAgICAgICAgICAgIH0sIFAgPSBmdW5jdGlvbihGKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4KEYueCksIFwiLFwiKS5jb25jYXQoeChGLnkpLCBcIixcIikuY29uY2F0KHgoRi56KSk7XG4gICAgICAgICAgICB9LCBNID0gMDsgTSA8IFQubGVuZ3RoOyBNKyspIHtcbiAgICAgICAgICAgICAgdmFyIFIgPSBUW01dLCBMID0gUChSKTtcbiAgICAgICAgICAgICAgU1tMXSA9PT0gdm9pZCAwICYmIChTW0xdID0gRS5sZW5ndGgsIEUucHVzaChSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmZvckVhY2goZnVuY3Rpb24oRikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBWID0gMDsgViA8IDM7ICsrVikge1xuICAgICAgICAgICAgICAgIHZhciBHID0gRltWXSwgRyA9IFRbR10sIEcgPSBQKEcpO1xuICAgICAgICAgICAgICAgIEZbVl0gPSBTW0ddO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgdGhpcy5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKEYpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgViA9IDA7IFYgPCAyOyArK1YpIHtcbiAgICAgICAgICAgICAgICB2YXIgRyA9IEZbVl0sIEcgPSBUW0ddLCBHID0gUChHKTtcbiAgICAgICAgICAgICAgICBGW1ZdID0gU1tHXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHRoaXMudmVydGljZXMgPSBUID0gRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChuID0gai5sZW5ndGggPSAwOyBuIDwgVC5sZW5ndGg7ICsrbilcbiAgICAgICAgICAgIGoucHVzaChuZXcgdS5kZWZhdWx0LlZlY3RvcigpKTtcbiAgICAgICAgICBmb3IgKF8uZm9yRWFjaChmdW5jdGlvbihGLCBWKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBHID0gYS5fZ2V0RmFjZU5vcm1hbChWKSwgVSA9IDA7IFUgPCAzOyArK1UpIHtcbiAgICAgICAgICAgICAgdmFyIFcgPSBGW1VdO1xuICAgICAgICAgICAgICBqW1ddLmFkZChHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgbiA9IDA7IG4gPCBULmxlbmd0aDsgKytuKVxuICAgICAgICAgICAgaltuXS5ub3JtYWxpemUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJhdmVyYWdlTm9ybWFsc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPD0gdGhpcy5kZXRhaWxZOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5kZXRhaWxYICsgMSwgYyA9IHUuZGVmYXVsdC5WZWN0b3IuYWRkKHRoaXMudmVydGV4Tm9ybWFsc1tuICogYV0sIHRoaXMudmVydGV4Tm9ybWFsc1tuICogYSArIHRoaXMuZGV0YWlsWF0pLCBjID0gdS5kZWZhdWx0LlZlY3Rvci5kaXYoYywgMik7XG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbbiAqIGFdID0gYywgdGhpcy52ZXJ0ZXhOb3JtYWxzW24gKiBhICsgdGhpcy5kZXRhaWxYXSA9IGM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImF2ZXJhZ2VQb2xlTm9ybWFsc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IG5ldyB1LmRlZmF1bHQuVmVjdG9yKDAsIDAsIDApLCBhID0gMDsgYSA8IHRoaXMuZGV0YWlsWDsgYSsrKVxuICAgICAgICAgICAgbi5hZGQodGhpcy52ZXJ0ZXhOb3JtYWxzW2FdKTtcbiAgICAgICAgICBmb3IgKHZhciBuID0gdS5kZWZhdWx0LlZlY3Rvci5kaXYobiwgdGhpcy5kZXRhaWxYKSwgYyA9IDA7IGMgPCB0aGlzLmRldGFpbFg7IGMrKylcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1tjXSA9IG47XG4gICAgICAgICAgbiA9IG5ldyB1LmRlZmF1bHQuVmVjdG9yKDAsIDAsIDApO1xuICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7IHAgPiB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgLSB0aGlzLmRldGFpbFg7IHAtLSlcbiAgICAgICAgICAgIG4uYWRkKHRoaXMudmVydGV4Tm9ybWFsc1twXSk7XG4gICAgICAgICAgbiA9IHUuZGVmYXVsdC5WZWN0b3IuZGl2KG4sIHRoaXMuZGV0YWlsWCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTsgaiA+IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSAtIHRoaXMuZGV0YWlsWDsgai0tKVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW2pdID0gbjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfbWFrZVRyaWFuZ2xlRWRnZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIG4gPSB0aGlzLmVkZ2VzLmxlbmd0aCA9IDA7IG4gPCB0aGlzLmZhY2VzLmxlbmd0aDsgbisrKVxuICAgICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKFt0aGlzLmZhY2VzW25dWzBdLCB0aGlzLmZhY2VzW25dWzFdXSksIHRoaXMuZWRnZXMucHVzaChbdGhpcy5mYWNlc1tuXVsxXSwgdGhpcy5mYWNlc1tuXVsyXV0pLCB0aGlzLmVkZ2VzLnB1c2goW3RoaXMuZmFjZXNbbl1bMl0sIHRoaXMuZmFjZXNbbl1bMF1dKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZWRnZXNUb1ZlcnRpY2VzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmxpbmVWZXJ0aWNlcy5jbGVhcigpLCB0aGlzLmxpbmVUYW5nZW50c0luLmNsZWFyKCksIHRoaXMubGluZVRhbmdlbnRzT3V0LmNsZWFyKCksIHRoaXMubGluZVNpZGVzLmNsZWFyKCk7XG4gICAgICAgICAgZm9yICh2YXIgbiwgYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBwID0gMDsgcCA8IHRoaXMuZWRnZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciBqLCBUID0gdGhpcy5lZGdlc1twIC0gMV0sIF8gPSB0aGlzLmVkZ2VzW3BdLCBTID0gdGhpcy52ZXJ0aWNlc1tfWzBdXSwgRSA9IHRoaXMudmVydGljZXNbX1sxXV0sIEEgPSAwIDwgdGhpcy52ZXJ0ZXhTdHJva2VDb2xvcnMubGVuZ3RoID8gdGhpcy52ZXJ0ZXhTdHJva2VDb2xvcnMuc2xpY2UoNCAqIF9bMF0sIDQgKiAoX1swXSArIDEpKSA6IFswLCAwLCAwLCAwXSwgeCA9IDAgPCB0aGlzLnZlcnRleFN0cm9rZUNvbG9ycy5sZW5ndGggPyB0aGlzLnZlcnRleFN0cm9rZUNvbG9ycy5zbGljZSg0ICogX1sxXSwgNCAqIChfWzFdICsgMSkpIDogWzAsIDAsIDAsIDBdLCBQID0gRS5jb3B5KCkuc3ViKFMpLm5vcm1hbGl6ZSgpLCBNID0gMCA8IFAubWFnU3EoKTtcbiAgICAgICAgICAgIE0gJiYgdGhpcy5fYWRkU2VnbWVudChTLCBFLCBBLCB4LCBQKSwgMCA8IHAgJiYgVFsxXSA9PT0gX1swXSA/IGMuaGFzKF9bMF0pIHx8IChjLmFkZChfWzBdKSwgYS5kZWxldGUoX1swXSksIG4gJiYgTSAmJiBQLmRvdChuKSA8IDEgLSAxZS04ICYmIHRoaXMuX2FkZEpvaW4oUywgbiwgUCwgQSkpIDogKE0gJiYgIWMuaGFzKF9bMF0pICYmICgoaiA9IGEuZ2V0KF9bMF0pKSA/ICh0aGlzLl9hZGRKb2luKFMsIGouZGlyLCBQLCBBKSwgYS5kZWxldGUoX1swXSksIGMuYWRkKF9bMF0pKSA6IGEuc2V0KF9bMF0sIHsgcG9pbnQ6IFMsIGRpcjogUC5jb3B5KCkubXVsdCgtMSksIGNvbG9yOiBBIH0pKSwgbiAmJiAhYy5oYXMoVFsxXSkgJiYgKChqID0gYS5nZXQoVFsxXSkpID8gKHRoaXMuX2FkZEpvaW4odGhpcy52ZXJ0aWNlc1tUWzFdXSwgbiwgai5kaXIuY29weSgpLm11bHQoLTEpLCBBKSwgYS5kZWxldGUoVFsxXSksIGMuYWRkKFRbMV0pKSA6IGEuc2V0KFRbMV0sIHsgcG9pbnQ6IHRoaXMudmVydGljZXNbVFsxXV0sIGRpcjogbiwgY29sb3I6IEEgfSksIG4gPSB2b2lkIDApKSwgcCAhPT0gdGhpcy5lZGdlcy5sZW5ndGggLSAxIHx8IGMuaGFzKF9bMV0pIHx8ICgoUyA9IGEuZ2V0KF9bMV0pKSA/ICh0aGlzLl9hZGRKb2luKEUsIFAsIFMuZGlyLmNvcHkoKS5tdWx0KC0xKSwgeCksIGEuZGVsZXRlKF9bMV0pLCBjLmFkZChfWzFdKSkgOiBhLnNldChfWzFdLCB7IHBvaW50OiBFLCBkaXI6IFAsIGNvbG9yOiB4IH0pKSwgTSAmJiAobiA9IFApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgUiA9ICEwLCBMID0gITEsIEYgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIFYsIEcgPSBhLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShSID0gKFYgPSBHLm5leHQoKSkuZG9uZSk7IFIgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgVSA9IFYudmFsdWUsIFcgPSBVLnBvaW50LCBYID0gVS5kaXIsIG5lID0gVS5jb2xvcjtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkQ2FwKFcsIFgsIG5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChiKSB7XG4gICAgICAgICAgICBMID0gITAsIEYgPSBiO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSIHx8IEcucmV0dXJuID09IG51bGwgfHwgRy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChMKVxuICAgICAgICAgICAgICAgIHRocm93IEY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hZGRTZWdtZW50XCIsIHZhbHVlOiBmdW5jdGlvbihULCBfLCBjLCBwLCBqKSB7XG4gICAgICAgICAgdmFyIFQgPSBULmFycmF5KCksIF8gPSBfLmFycmF5KCksIFMgPSBqLmFycmF5KCk7XG4gICAgICAgICAgdGhpcy5saW5lU2lkZXMucHVzaCgxLCAxLCAtMSwgMSwgLTEsIC0xKTtcbiAgICAgICAgICBmb3IgKHZhciBFID0gMCwgQSA9IFt0aGlzLmxpbmVUYW5nZW50c0luLCB0aGlzLmxpbmVUYW5nZW50c091dF07IEUgPCBBLmxlbmd0aDsgRSsrKVxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IEFbRV0sIFAgPSAwOyBQIDwgNjsgUCsrKVxuICAgICAgICAgICAgICB4LnB1c2guYXBwbHkoeCwgZihTKSk7XG4gICAgICAgICAgcmV0dXJuIChqID0gdGhpcy5saW5lVmVydGljZXMpLnB1c2guYXBwbHkoaiwgZihUKS5jb25jYXQoZihfKSwgZihUKSwgZihfKSwgZihfKSwgZihUKSkpLCAoaiA9IHRoaXMubGluZVZlcnRleENvbG9ycykucHVzaC5hcHBseShqLCBmKGMpLmNvbmNhdChmKHApLCBmKGMpLCBmKHApLCBmKHApLCBmKGMpKSksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2FkZENhcFwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSwgYykge1xuICAgICAgICAgIGZvciAodmFyIHAsIGogPSBuLmFycmF5KCksIFQgPSBhLmFycmF5KCksIF8gPSBbMCwgMCwgMF0sIFMgPSAwOyBTIDwgNjsgUysrKVxuICAgICAgICAgICAgKHAgPSB0aGlzLmxpbmVWZXJ0aWNlcykucHVzaC5hcHBseShwLCBmKGopKSwgKHAgPSB0aGlzLmxpbmVUYW5nZW50c0luKS5wdXNoLmFwcGx5KHAsIGYoVCkpLCAocCA9IHRoaXMubGluZVRhbmdlbnRzT3V0KS5wdXNoLmFwcGx5KHAsIF8pLCAocCA9IHRoaXMubGluZVZlcnRleENvbG9ycykucHVzaC5hcHBseShwLCBmKGMpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saW5lU2lkZXMucHVzaCgtMSwgMiwgLTIsIDEsIDIsIC0xKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfYWRkSm9pblwiLCB2YWx1ZTogZnVuY3Rpb24obiwgYSwgYywgcCkge1xuICAgICAgICAgIGZvciAodmFyIGosIFQgPSBuLmFycmF5KCksIF8gPSBhLmFycmF5KCksIFMgPSBjLmFycmF5KCksIEUgPSAwOyBFIDwgMTI7IEUrKylcbiAgICAgICAgICAgIChqID0gdGhpcy5saW5lVmVydGljZXMpLnB1c2guYXBwbHkoaiwgZihUKSksIChqID0gdGhpcy5saW5lVGFuZ2VudHNJbikucHVzaC5hcHBseShqLCBmKF8pKSwgKGogPSB0aGlzLmxpbmVUYW5nZW50c091dCkucHVzaC5hcHBseShqLCBmKFMpKSwgKGogPSB0aGlzLmxpbmVWZXJ0ZXhDb2xvcnMpLnB1c2guYXBwbHkoaiwgZihwKSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGluZVNpZGVzLnB1c2goLTEsIC0zLCAtMiwgLTEsIDAsIC0zKSwgdGhpcy5saW5lU2lkZXMucHVzaCgzLCAxLCAyLCAzLCAwLCAxKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJub3JtYWxpemVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgwIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSB0aGlzLnZlcnRpY2VzWzBdLmNvcHkoKSwgYSA9IHRoaXMudmVydGljZXNbMF0uY29weSgpLCBjID0gMDsgYyA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBjKyspXG4gICAgICAgICAgICAgIG4ueCA9IE1hdGgubWF4KG4ueCwgdGhpcy52ZXJ0aWNlc1tjXS54KSwgYS54ID0gTWF0aC5taW4oYS54LCB0aGlzLnZlcnRpY2VzW2NdLngpLCBuLnkgPSBNYXRoLm1heChuLnksIHRoaXMudmVydGljZXNbY10ueSksIGEueSA9IE1hdGgubWluKGEueSwgdGhpcy52ZXJ0aWNlc1tjXS55KSwgbi56ID0gTWF0aC5tYXgobi56LCB0aGlzLnZlcnRpY2VzW2NdLnopLCBhLnogPSBNYXRoLm1pbihhLnosIHRoaXMudmVydGljZXNbY10ueik7XG4gICAgICAgICAgICBmb3IgKHZhciBwID0gdS5kZWZhdWx0LlZlY3Rvci5sZXJwKG4sIGEsIDAuNSksIGogPSB1LmRlZmF1bHQuVmVjdG9yLnN1YihuLCBhKSwgVCA9IDIwMCAvIE1hdGgubWF4KE1hdGgubWF4KGoueCwgai55KSwgai56KSwgXyA9IDA7IF8gPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgXysrKVxuICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW19dLnN1YihwKSwgdGhpcy52ZXJ0aWNlc1tfXS5tdWx0KFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSB9XSkgJiYgcihpLnByb3RvdHlwZSwgbCksIG87XG4gICAgICB9KCk7XG4gICAgICB2YXIgcyA9IHUuZGVmYXVsdC5HZW9tZXRyeTtcbiAgICAgIEMuZGVmYXVsdCA9IHM7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIjogMTUyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0XCI6IDE1OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2hcIjogMTYwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXRcIjogMTcyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5tYXBcIjogMTc0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3JcIjogMTc4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIjogMTk0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCI6IDIwNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoXCI6IDI0MiwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMzMzogW2Z1bmN0aW9uKGcsIEgsIEMpIHtcbiAgICAgIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIiksIGcoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiKSwgZyhcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCIpLCBnKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIG0gPSAoZyA9IGcoXCIuLi9jb3JlL21haW5cIikpICYmIGcuX19lc01vZHVsZSA/IGcgOiB7IGRlZmF1bHQ6IGcgfTtcbiAgICAgIGZ1bmN0aW9uIHkoZiwgcikge1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHIubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgbyA9IHJbc107XG4gICAgICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIG8ua2V5LCBvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHUgPSBBcnJheSwgaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZik7XG4gICAgICB9LCBnID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgPCBcInVcIiAmJiAodSA9IEZsb2F0MzJBcnJheSwgaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZikgfHwgZiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTtcbiAgICAgIH0pLCBtLmRlZmF1bHQuTWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLCBsID0gZjtcbiAgICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIGwpXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAmJiAoKGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHZvaWQgMCA6IGFyZ3VtZW50c1tpXSkgaW5zdGFuY2VvZiBtLmRlZmF1bHQgJiYgKHRoaXMucDUgPSAobCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxKSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBsID8gdm9pZCAwIDogYXJndW1lbnRzW2xdKSwgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgPT09IFwibWF0M1wiID8gdGhpcy5tYXQzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pID8gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdIDogbmV3IHUoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKSA6IHRoaXMubWF0NCA9IEFycmF5LmlzQXJyYXkoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSA6IG5ldyB1KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksIHRoaXM7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciwgcywgbztcbiAgICAgICAgcmV0dXJuIHIgPSBmLCBvID0gW3sga2V5OiBcImlkZW50aXR5XCIsIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBtLmRlZmF1bHQuTWF0cml4KGkpO1xuICAgICAgICB9IH1dLCAocyA9IFt7IGtleTogXCJzZXRcIiwgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICB2YXIgbCA9IGFyZ3VtZW50cztcbiAgICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIG0uZGVmYXVsdC5NYXRyaXggPyBsID0gaS5tYXQ0IDogaChpKSAmJiAobCA9IGkpLCBsLmxlbmd0aCAhPT0gMTYpXG4gICAgICAgICAgICBtLmRlZmF1bHQuX2ZyaWVuZGx5RXJyb3IoXCJFeHBlY3RlZCAxNiB2YWx1ZXMgYnV0IHJlY2VpdmVkIFwiLmNvbmNhdChsLmxlbmd0aCwgXCIuXCIpLCBcInA1Lk1hdHJpeC5zZXRcIik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAxNjsgbisrKVxuICAgICAgICAgICAgICB0aGlzLm1hdDRbbl0gPSBsW25dO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBtLmRlZmF1bHQuTWF0cml4KHRoaXMubWF0NCwgdGhpcy5wNSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY29weVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWF0MyAhPT0gdm9pZCAwID8gKChpID0gbmV3IG0uZGVmYXVsdC5NYXRyaXgoXCJtYXQzXCIsIHRoaXMucDUpKS5tYXQzWzBdID0gdGhpcy5tYXQzWzBdLCBpLm1hdDNbMV0gPSB0aGlzLm1hdDNbMV0sIGkubWF0M1syXSA9IHRoaXMubWF0M1syXSwgaS5tYXQzWzNdID0gdGhpcy5tYXQzWzNdLCBpLm1hdDNbNF0gPSB0aGlzLm1hdDNbNF0sIGkubWF0M1s1XSA9IHRoaXMubWF0M1s1XSwgaS5tYXQzWzZdID0gdGhpcy5tYXQzWzZdLCBpLm1hdDNbN10gPSB0aGlzLm1hdDNbN10sIGkubWF0M1s4XSA9IHRoaXMubWF0M1s4XSkgOiAoKGkgPSBuZXcgbS5kZWZhdWx0Lk1hdHJpeCh0aGlzLnA1KSkubWF0NFswXSA9IHRoaXMubWF0NFswXSwgaS5tYXQ0WzFdID0gdGhpcy5tYXQ0WzFdLCBpLm1hdDRbMl0gPSB0aGlzLm1hdDRbMl0sIGkubWF0NFszXSA9IHRoaXMubWF0NFszXSwgaS5tYXQ0WzRdID0gdGhpcy5tYXQ0WzRdLCBpLm1hdDRbNV0gPSB0aGlzLm1hdDRbNV0sIGkubWF0NFs2XSA9IHRoaXMubWF0NFs2XSwgaS5tYXQ0WzddID0gdGhpcy5tYXQ0WzddLCBpLm1hdDRbOF0gPSB0aGlzLm1hdDRbOF0sIGkubWF0NFs5XSA9IHRoaXMubWF0NFs5XSwgaS5tYXQ0WzEwXSA9IHRoaXMubWF0NFsxMF0sIGkubWF0NFsxMV0gPSB0aGlzLm1hdDRbMTFdLCBpLm1hdDRbMTJdID0gdGhpcy5tYXQ0WzEyXSwgaS5tYXQ0WzEzXSA9IHRoaXMubWF0NFsxM10sIGkubWF0NFsxNF0gPSB0aGlzLm1hdDRbMTRdLCBpLm1hdDRbMTVdID0gdGhpcy5tYXQ0WzE1XSksIGk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidHJhbnNwb3NlXCIsIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgdmFyIGwsIG4sIGEsIGMsIHAsIGo7XG4gICAgICAgICAgcmV0dXJuIGkgaW5zdGFuY2VvZiBtLmRlZmF1bHQuTWF0cml4ID8gKGwgPSBpLm1hdDRbMV0sIG4gPSBpLm1hdDRbMl0sIGEgPSBpLm1hdDRbM10sIGMgPSBpLm1hdDRbNl0sIHAgPSBpLm1hdDRbN10sIGogPSBpLm1hdDRbMTFdLCB0aGlzLm1hdDRbMF0gPSBpLm1hdDRbMF0sIHRoaXMubWF0NFsxXSA9IGkubWF0NFs0XSwgdGhpcy5tYXQ0WzJdID0gaS5tYXQ0WzhdLCB0aGlzLm1hdDRbM10gPSBpLm1hdDRbMTJdLCB0aGlzLm1hdDRbNF0gPSBsLCB0aGlzLm1hdDRbNV0gPSBpLm1hdDRbNV0sIHRoaXMubWF0NFs2XSA9IGkubWF0NFs5XSwgdGhpcy5tYXQ0WzddID0gaS5tYXQ0WzEzXSwgdGhpcy5tYXQ0WzhdID0gbiwgdGhpcy5tYXQ0WzldID0gYywgdGhpcy5tYXQ0WzEwXSA9IGkubWF0NFsxMF0sIHRoaXMubWF0NFsxMV0gPSBpLm1hdDRbMTRdLCB0aGlzLm1hdDRbMTJdID0gYSwgdGhpcy5tYXQ0WzEzXSA9IHAsIHRoaXMubWF0NFsxNF0gPSBqLCB0aGlzLm1hdDRbMTVdID0gaS5tYXQ0WzE1XSkgOiBoKGkpICYmIChsID0gaVsxXSwgbiA9IGlbMl0sIGEgPSBpWzNdLCBjID0gaVs2XSwgcCA9IGlbN10sIGogPSBpWzExXSwgdGhpcy5tYXQ0WzBdID0gaVswXSwgdGhpcy5tYXQ0WzFdID0gaVs0XSwgdGhpcy5tYXQ0WzJdID0gaVs4XSwgdGhpcy5tYXQ0WzNdID0gaVsxMl0sIHRoaXMubWF0NFs0XSA9IGwsIHRoaXMubWF0NFs1XSA9IGlbNV0sIHRoaXMubWF0NFs2XSA9IGlbOV0sIHRoaXMubWF0NFs3XSA9IGlbMTNdLCB0aGlzLm1hdDRbOF0gPSBuLCB0aGlzLm1hdDRbOV0gPSBjLCB0aGlzLm1hdDRbMTBdID0gaVsxMF0sIHRoaXMubWF0NFsxMV0gPSBpWzE0XSwgdGhpcy5tYXQ0WzEyXSA9IGEsIHRoaXMubWF0NFsxM10gPSBwLCB0aGlzLm1hdDRbMTRdID0gaiwgdGhpcy5tYXQ0WzE1XSA9IGlbMTVdKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJpbnZlcnRcIiwgdmFsdWU6IGZ1bmN0aW9uKEYpIHtcbiAgICAgICAgICBGIGluc3RhbmNlb2YgbS5kZWZhdWx0Lk1hdHJpeCA/IChsID0gRi5tYXQ0WzBdLCBuID0gRi5tYXQ0WzFdLCBhID0gRi5tYXQ0WzJdLCBjID0gRi5tYXQ0WzNdLCBwID0gRi5tYXQ0WzRdLCBqID0gRi5tYXQ0WzVdLCBUID0gRi5tYXQ0WzZdLCBfID0gRi5tYXQ0WzddLCBTID0gRi5tYXQ0WzhdLCBFID0gRi5tYXQ0WzldLCBBID0gRi5tYXQ0WzEwXSwgeCA9IEYubWF0NFsxMV0sIFAgPSBGLm1hdDRbMTJdLCBNID0gRi5tYXQ0WzEzXSwgUiA9IEYubWF0NFsxNF0sIEwgPSBGLm1hdDRbMTVdKSA6IGgoRikgJiYgKGwgPSBGWzBdLCBuID0gRlsxXSwgYSA9IEZbMl0sIGMgPSBGWzNdLCBwID0gRls0XSwgaiA9IEZbNV0sIFQgPSBGWzZdLCBfID0gRls3XSwgUyA9IEZbOF0sIEUgPSBGWzldLCBBID0gRlsxMF0sIHggPSBGWzExXSwgUCA9IEZbMTJdLCBNID0gRlsxM10sIFIgPSBGWzE0XSwgTCA9IEZbMTVdKTtcbiAgICAgICAgICB2YXIgbCwgbiwgYSwgYywgcCwgaiwgVCwgXywgUywgRSwgQSwgeCwgUCwgTSwgUiwgTCwgRiA9IGwgKiBqIC0gbiAqIHAsIFYgPSBsICogVCAtIGEgKiBwLCBHID0gbCAqIF8gLSBjICogcCwgVSA9IG4gKiBUIC0gYSAqIGosIFcgPSBuICogXyAtIGMgKiBqLCBYID0gYSAqIF8gLSBjICogVCwgbmUgPSBTICogTSAtIEUgKiBQLCBiID0gUyAqIFIgLSBBICogUCwgTyA9IFMgKiBMIC0geCAqIFAsIEQgPSBFICogUiAtIEEgKiBNLCBCID0gRSAqIEwgLSB4ICogTSwgWSA9IEEgKiBMIC0geCAqIFIsIEogPSBGICogWSAtIFYgKiBCICsgRyAqIEQgKyBVICogTyAtIFcgKiBiICsgWCAqIG5lO1xuICAgICAgICAgIHJldHVybiBKID8gKHRoaXMubWF0NFswXSA9IChqICogWSAtIFQgKiBCICsgXyAqIEQpICogKEogPSAxIC8gSiksIHRoaXMubWF0NFsxXSA9IChhICogQiAtIG4gKiBZIC0gYyAqIEQpICogSiwgdGhpcy5tYXQ0WzJdID0gKE0gKiBYIC0gUiAqIFcgKyBMICogVSkgKiBKLCB0aGlzLm1hdDRbM10gPSAoQSAqIFcgLSBFICogWCAtIHggKiBVKSAqIEosIHRoaXMubWF0NFs0XSA9IChUICogTyAtIHAgKiBZIC0gXyAqIGIpICogSiwgdGhpcy5tYXQ0WzVdID0gKGwgKiBZIC0gYSAqIE8gKyBjICogYikgKiBKLCB0aGlzLm1hdDRbNl0gPSAoUiAqIEcgLSBQICogWCAtIEwgKiBWKSAqIEosIHRoaXMubWF0NFs3XSA9IChTICogWCAtIEEgKiBHICsgeCAqIFYpICogSiwgdGhpcy5tYXQ0WzhdID0gKHAgKiBCIC0gaiAqIE8gKyBfICogbmUpICogSiwgdGhpcy5tYXQ0WzldID0gKG4gKiBPIC0gbCAqIEIgLSBjICogbmUpICogSiwgdGhpcy5tYXQ0WzEwXSA9IChQICogVyAtIE0gKiBHICsgTCAqIEYpICogSiwgdGhpcy5tYXQ0WzExXSA9IChFICogRyAtIFMgKiBXIC0geCAqIEYpICogSiwgdGhpcy5tYXQ0WzEyXSA9IChqICogYiAtIHAgKiBEIC0gVCAqIG5lKSAqIEosIHRoaXMubWF0NFsxM10gPSAobCAqIEQgLSBuICogYiArIGEgKiBuZSkgKiBKLCB0aGlzLm1hdDRbMTRdID0gKE0gKiBWIC0gUCAqIFUgLSBSICogRikgKiBKLCB0aGlzLm1hdDRbMTVdID0gKFMgKiBVIC0gRSAqIFYgKyBBICogRikgKiBKLCB0aGlzKSA6IG51bGw7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaW52ZXJ0M3gzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMubWF0M1swXSwgbCA9IHRoaXMubWF0M1sxXSwgbiA9IHRoaXMubWF0M1syXSwgYSA9IHRoaXMubWF0M1szXSwgYyA9IHRoaXMubWF0M1s0XSwgcCA9IHRoaXMubWF0M1s1XSwgaiA9IHRoaXMubWF0M1s2XSwgVCA9IHRoaXMubWF0M1s3XSwgXyA9IHRoaXMubWF0M1s4XSwgUyA9IF8gKiBjIC0gcCAqIFQsIEUgPSAtXyAqIGEgKyBwICogaiwgQSA9IFQgKiBhIC0gYyAqIGosIHggPSBpICogUyArIGwgKiBFICsgbiAqIEE7XG4gICAgICAgICAgcmV0dXJuIHggPyAodGhpcy5tYXQzWzBdID0gUyAqICh4ID0gMSAvIHgpLCB0aGlzLm1hdDNbMV0gPSAoLV8gKiBsICsgbiAqIFQpICogeCwgdGhpcy5tYXQzWzJdID0gKHAgKiBsIC0gbiAqIGMpICogeCwgdGhpcy5tYXQzWzNdID0gRSAqIHgsIHRoaXMubWF0M1s0XSA9IChfICogaSAtIG4gKiBqKSAqIHgsIHRoaXMubWF0M1s1XSA9ICgtcCAqIGkgKyBuICogYSkgKiB4LCB0aGlzLm1hdDNbNl0gPSBBICogeCwgdGhpcy5tYXQzWzddID0gKC1UICogaSArIGwgKiBqKSAqIHgsIHRoaXMubWF0M1s4XSA9IChjICogaSAtIGwgKiBhKSAqIHgsIHRoaXMpIDogbnVsbDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJ0cmFuc3Bvc2UzeDNcIiwgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICB2YXIgbCA9IChpID0gaSA9PT0gdm9pZCAwID8gdGhpcy5tYXQzIDogaSlbMV0sIG4gPSBpWzJdLCBhID0gaVs1XTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXQzWzBdID0gaVswXSwgdGhpcy5tYXQzWzFdID0gaVszXSwgdGhpcy5tYXQzWzJdID0gaVs2XSwgdGhpcy5tYXQzWzNdID0gbCwgdGhpcy5tYXQzWzRdID0gaVs0XSwgdGhpcy5tYXQzWzVdID0gaVs3XSwgdGhpcy5tYXQzWzZdID0gbiwgdGhpcy5tYXQzWzddID0gYSwgdGhpcy5tYXQzWzhdID0gaVs4XSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJpbnZlcnNlVHJhbnNwb3NlXCIsIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKGkgPSBpLm1hdDQsIHRoaXMubWF0MyA9PT0gdm9pZCAwID8gbS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwic29ycnksIHRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyB3aXRoIG1hdDNcIikgOiAodGhpcy5tYXQzWzBdID0gaVswXSwgdGhpcy5tYXQzWzFdID0gaVsxXSwgdGhpcy5tYXQzWzJdID0gaVsyXSwgdGhpcy5tYXQzWzNdID0gaVs0XSwgdGhpcy5tYXQzWzRdID0gaVs1XSwgdGhpcy5tYXQzWzVdID0gaVs2XSwgdGhpcy5tYXQzWzZdID0gaVs4XSwgdGhpcy5tYXQzWzddID0gaVs5XSwgdGhpcy5tYXQzWzhdID0gaVsxMF0pLCBpID0gdGhpcy5pbnZlcnQzeDMoKSwgaSlcbiAgICAgICAgICAgIGkudHJhbnNwb3NlM3gzKHRoaXMubWF0Myk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCA5OyBsKyspXG4gICAgICAgICAgICAgIHRoaXMubWF0M1tsXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZGV0ZXJtaW5hbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5tYXQ0WzBdICogdGhpcy5tYXQ0WzVdIC0gdGhpcy5tYXQ0WzFdICogdGhpcy5tYXQ0WzRdLCBsID0gdGhpcy5tYXQ0WzBdICogdGhpcy5tYXQ0WzZdIC0gdGhpcy5tYXQ0WzJdICogdGhpcy5tYXQ0WzRdLCBuID0gdGhpcy5tYXQ0WzBdICogdGhpcy5tYXQ0WzddIC0gdGhpcy5tYXQ0WzNdICogdGhpcy5tYXQ0WzRdLCBhID0gdGhpcy5tYXQ0WzFdICogdGhpcy5tYXQ0WzZdIC0gdGhpcy5tYXQ0WzJdICogdGhpcy5tYXQ0WzVdLCBjID0gdGhpcy5tYXQ0WzFdICogdGhpcy5tYXQ0WzddIC0gdGhpcy5tYXQ0WzNdICogdGhpcy5tYXQ0WzVdLCBwID0gdGhpcy5tYXQ0WzJdICogdGhpcy5tYXQ0WzddIC0gdGhpcy5tYXQ0WzNdICogdGhpcy5tYXQ0WzZdLCBqID0gdGhpcy5tYXQ0WzhdICogdGhpcy5tYXQ0WzEzXSAtIHRoaXMubWF0NFs5XSAqIHRoaXMubWF0NFsxMl0sIFQgPSB0aGlzLm1hdDRbOF0gKiB0aGlzLm1hdDRbMTRdIC0gdGhpcy5tYXQ0WzEwXSAqIHRoaXMubWF0NFsxMl0sIF8gPSB0aGlzLm1hdDRbOF0gKiB0aGlzLm1hdDRbMTVdIC0gdGhpcy5tYXQ0WzExXSAqIHRoaXMubWF0NFsxMl0sIFMgPSB0aGlzLm1hdDRbOV0gKiB0aGlzLm1hdDRbMTRdIC0gdGhpcy5tYXQ0WzEwXSAqIHRoaXMubWF0NFsxM10sIEUgPSB0aGlzLm1hdDRbOV0gKiB0aGlzLm1hdDRbMTVdIC0gdGhpcy5tYXQ0WzExXSAqIHRoaXMubWF0NFsxM107XG4gICAgICAgICAgcmV0dXJuIGkgKiAodGhpcy5tYXQ0WzEwXSAqIHRoaXMubWF0NFsxNV0gLSB0aGlzLm1hdDRbMTFdICogdGhpcy5tYXQ0WzE0XSkgLSBsICogRSArIG4gKiBTICsgYSAqIF8gLSBjICogVCArIHAgKiBqO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm11bHRcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgbDtcbiAgICAgICAgICBpZiAobiA9PT0gdGhpcyB8fCBuID09PSB0aGlzLm1hdDQpXG4gICAgICAgICAgICBsID0gdGhpcy5jb3B5KCkubWF0NDtcbiAgICAgICAgICBlbHNlIGlmIChuIGluc3RhbmNlb2YgbS5kZWZhdWx0Lk1hdHJpeClcbiAgICAgICAgICAgIGwgPSBuLm1hdDQ7XG4gICAgICAgICAgZWxzZSBpZiAoaChuKSlcbiAgICAgICAgICAgIGwgPSBuO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDE2KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsID0gYXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbiA9IHRoaXMubWF0NFswXSwgYSA9IHRoaXMubWF0NFsxXSwgYyA9IHRoaXMubWF0NFsyXSwgcCA9IHRoaXMubWF0NFszXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXQ0WzBdID0gbiAqIGxbMF0gKyBhICogbFs0XSArIGMgKiBsWzhdICsgcCAqIGxbMTJdLCB0aGlzLm1hdDRbMV0gPSBuICogbFsxXSArIGEgKiBsWzVdICsgYyAqIGxbOV0gKyBwICogbFsxM10sIHRoaXMubWF0NFsyXSA9IG4gKiBsWzJdICsgYSAqIGxbNl0gKyBjICogbFsxMF0gKyBwICogbFsxNF0sIHRoaXMubWF0NFszXSA9IG4gKiBsWzNdICsgYSAqIGxbN10gKyBjICogbFsxMV0gKyBwICogbFsxNV0sIG4gPSB0aGlzLm1hdDRbNF0sIGEgPSB0aGlzLm1hdDRbNV0sIGMgPSB0aGlzLm1hdDRbNl0sIHAgPSB0aGlzLm1hdDRbN10sIHRoaXMubWF0NFs0XSA9IG4gKiBsWzBdICsgYSAqIGxbNF0gKyBjICogbFs4XSArIHAgKiBsWzEyXSwgdGhpcy5tYXQ0WzVdID0gbiAqIGxbMV0gKyBhICogbFs1XSArIGMgKiBsWzldICsgcCAqIGxbMTNdLCB0aGlzLm1hdDRbNl0gPSBuICogbFsyXSArIGEgKiBsWzZdICsgYyAqIGxbMTBdICsgcCAqIGxbMTRdLCB0aGlzLm1hdDRbN10gPSBuICogbFszXSArIGEgKiBsWzddICsgYyAqIGxbMTFdICsgcCAqIGxbMTVdLCBuID0gdGhpcy5tYXQ0WzhdLCBhID0gdGhpcy5tYXQ0WzldLCBjID0gdGhpcy5tYXQ0WzEwXSwgcCA9IHRoaXMubWF0NFsxMV0sIHRoaXMubWF0NFs4XSA9IG4gKiBsWzBdICsgYSAqIGxbNF0gKyBjICogbFs4XSArIHAgKiBsWzEyXSwgdGhpcy5tYXQ0WzldID0gbiAqIGxbMV0gKyBhICogbFs1XSArIGMgKiBsWzldICsgcCAqIGxbMTNdLCB0aGlzLm1hdDRbMTBdID0gbiAqIGxbMl0gKyBhICogbFs2XSArIGMgKiBsWzEwXSArIHAgKiBsWzE0XSwgdGhpcy5tYXQ0WzExXSA9IG4gKiBsWzNdICsgYSAqIGxbN10gKyBjICogbFsxMV0gKyBwICogbFsxNV0sIG4gPSB0aGlzLm1hdDRbMTJdLCBhID0gdGhpcy5tYXQ0WzEzXSwgYyA9IHRoaXMubWF0NFsxNF0sIHAgPSB0aGlzLm1hdDRbMTVdLCB0aGlzLm1hdDRbMTJdID0gbiAqIGxbMF0gKyBhICogbFs0XSArIGMgKiBsWzhdICsgcCAqIGxbMTJdLCB0aGlzLm1hdDRbMTNdID0gbiAqIGxbMV0gKyBhICogbFs1XSArIGMgKiBsWzldICsgcCAqIGxbMTNdLCB0aGlzLm1hdDRbMTRdID0gbiAqIGxbMl0gKyBhICogbFs2XSArIGMgKiBsWzEwXSArIHAgKiBsWzE0XSwgdGhpcy5tYXQ0WzE1XSA9IG4gKiBsWzNdICsgYSAqIGxbN10gKyBjICogbFsxMV0gKyBwICogbFsxNV0sIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYXBwbHlcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgbDtcbiAgICAgICAgICBpZiAobiA9PT0gdGhpcyB8fCBuID09PSB0aGlzLm1hdDQpXG4gICAgICAgICAgICBsID0gdGhpcy5jb3B5KCkubWF0NDtcbiAgICAgICAgICBlbHNlIGlmIChuIGluc3RhbmNlb2YgbS5kZWZhdWx0Lk1hdHJpeClcbiAgICAgICAgICAgIGwgPSBuLm1hdDQ7XG4gICAgICAgICAgZWxzZSBpZiAoaChuKSlcbiAgICAgICAgICAgIGwgPSBuO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDE2KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsID0gYXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbiA9IHRoaXMubWF0NCwgYSA9IG5bMF0sIGMgPSBuWzRdLCBwID0gbls4XSwgaiA9IG5bMTJdLCBhID0gKG5bMF0gPSBsWzBdICogYSArIGxbMV0gKiBjICsgbFsyXSAqIHAgKyBsWzNdICogaiwgbls0XSA9IGxbNF0gKiBhICsgbFs1XSAqIGMgKyBsWzZdICogcCArIGxbN10gKiBqLCBuWzhdID0gbFs4XSAqIGEgKyBsWzldICogYyArIGxbMTBdICogcCArIGxbMTFdICogaiwgblsxMl0gPSBsWzEyXSAqIGEgKyBsWzEzXSAqIGMgKyBsWzE0XSAqIHAgKyBsWzE1XSAqIGosIG5bMV0pLCBjID0gbls1XSwgcCA9IG5bOV0sIGogPSBuWzEzXSwgYSA9IChuWzFdID0gbFswXSAqIGEgKyBsWzFdICogYyArIGxbMl0gKiBwICsgbFszXSAqIGosIG5bNV0gPSBsWzRdICogYSArIGxbNV0gKiBjICsgbFs2XSAqIHAgKyBsWzddICogaiwgbls5XSA9IGxbOF0gKiBhICsgbFs5XSAqIGMgKyBsWzEwXSAqIHAgKyBsWzExXSAqIGosIG5bMTNdID0gbFsxMl0gKiBhICsgbFsxM10gKiBjICsgbFsxNF0gKiBwICsgbFsxNV0gKiBqLCBuWzJdKSwgYyA9IG5bNl0sIHAgPSBuWzEwXSwgaiA9IG5bMTRdLCBhID0gKG5bMl0gPSBsWzBdICogYSArIGxbMV0gKiBjICsgbFsyXSAqIHAgKyBsWzNdICogaiwgbls2XSA9IGxbNF0gKiBhICsgbFs1XSAqIGMgKyBsWzZdICogcCArIGxbN10gKiBqLCBuWzEwXSA9IGxbOF0gKiBhICsgbFs5XSAqIGMgKyBsWzEwXSAqIHAgKyBsWzExXSAqIGosIG5bMTRdID0gbFsxMl0gKiBhICsgbFsxM10gKiBjICsgbFsxNF0gKiBwICsgbFsxNV0gKiBqLCBuWzNdKSwgYyA9IG5bN10sIHAgPSBuWzExXSwgaiA9IG5bMTVdO1xuICAgICAgICAgIHJldHVybiBuWzNdID0gbFswXSAqIGEgKyBsWzFdICogYyArIGxbMl0gKiBwICsgbFszXSAqIGosIG5bN10gPSBsWzRdICogYSArIGxbNV0gKiBjICsgbFs2XSAqIHAgKyBsWzddICogaiwgblsxMV0gPSBsWzhdICogYSArIGxbOV0gKiBjICsgbFsxMF0gKiBwICsgbFsxMV0gKiBqLCBuWzE1XSA9IGxbMTJdICogYSArIGxbMTNdICogYyArIGxbMTRdICogcCArIGxbMTVdICogaiwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJzY2FsZVwiLCB2YWx1ZTogZnVuY3Rpb24oaSwgbCwgbikge1xuICAgICAgICAgIHJldHVybiBpIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChsID0gaS55LCBuID0gaS56LCBpID0gaS54KSA6IGkgaW5zdGFuY2VvZiBBcnJheSAmJiAobCA9IGlbMV0sIG4gPSBpWzJdLCBpID0gaVswXSksIHRoaXMubWF0NFswXSAqPSBpLCB0aGlzLm1hdDRbMV0gKj0gaSwgdGhpcy5tYXQ0WzJdICo9IGksIHRoaXMubWF0NFszXSAqPSBpLCB0aGlzLm1hdDRbNF0gKj0gbCwgdGhpcy5tYXQ0WzVdICo9IGwsIHRoaXMubWF0NFs2XSAqPSBsLCB0aGlzLm1hdDRbN10gKj0gbCwgdGhpcy5tYXQ0WzhdICo9IG4sIHRoaXMubWF0NFs5XSAqPSBuLCB0aGlzLm1hdDRbMTBdICo9IG4sIHRoaXMubWF0NFsxMV0gKj0gbiwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJyb3RhdGVcIiwgdmFsdWU6IGZ1bmN0aW9uKEYsIEIsIEQsIGEpIHtcbiAgICAgICAgICBCIGluc3RhbmNlb2YgbS5kZWZhdWx0LlZlY3RvciA/IChEID0gQi55LCBhID0gQi56LCBCID0gQi54KSA6IEIgaW5zdGFuY2VvZiBBcnJheSAmJiAoRCA9IEJbMV0sIGEgPSBCWzJdLCBCID0gQlswXSk7XG4gICAgICAgICAgdmFyIGMgPSBNYXRoLnNxcnQoQiAqIEIgKyBEICogRCArIGEgKiBhKSwgYyA9IChCICo9IDEgLyBjLCBEICo9IDEgLyBjLCBhICo9IDEgLyBjLCB0aGlzLm1hdDRbMF0pLCBwID0gdGhpcy5tYXQ0WzFdLCBqID0gdGhpcy5tYXQ0WzJdLCBUID0gdGhpcy5tYXQ0WzNdLCBfID0gdGhpcy5tYXQ0WzRdLCBTID0gdGhpcy5tYXQ0WzVdLCBFID0gdGhpcy5tYXQ0WzZdLCBBID0gdGhpcy5tYXQ0WzddLCB4ID0gdGhpcy5tYXQ0WzhdLCBQID0gdGhpcy5tYXQ0WzldLCBNID0gdGhpcy5tYXQ0WzEwXSwgUiA9IHRoaXMubWF0NFsxMV0sIEwgPSBNYXRoLnNpbihGKSwgRiA9IE1hdGguY29zKEYpLCBWID0gMSAtIEYsIEcgPSBCICogQiAqIFYgKyBGLCBVID0gRCAqIEIgKiBWICsgYSAqIEwsIFcgPSBhICogQiAqIFYgLSBEICogTCwgWCA9IEIgKiBEICogViAtIGEgKiBMLCBuZSA9IEQgKiBEICogViArIEYsIGIgPSBhICogRCAqIFYgKyBCICogTCwgTyA9IEIgKiBhICogViArIEQgKiBMLCBEID0gRCAqIGEgKiBWIC0gQiAqIEwsIEIgPSBhICogYSAqIFYgKyBGO1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hdDRbMF0gPSBjICogRyArIF8gKiBVICsgeCAqIFcsIHRoaXMubWF0NFsxXSA9IHAgKiBHICsgUyAqIFUgKyBQICogVywgdGhpcy5tYXQ0WzJdID0gaiAqIEcgKyBFICogVSArIE0gKiBXLCB0aGlzLm1hdDRbM10gPSBUICogRyArIEEgKiBVICsgUiAqIFcsIHRoaXMubWF0NFs0XSA9IGMgKiBYICsgXyAqIG5lICsgeCAqIGIsIHRoaXMubWF0NFs1XSA9IHAgKiBYICsgUyAqIG5lICsgUCAqIGIsIHRoaXMubWF0NFs2XSA9IGogKiBYICsgRSAqIG5lICsgTSAqIGIsIHRoaXMubWF0NFs3XSA9IFQgKiBYICsgQSAqIG5lICsgUiAqIGIsIHRoaXMubWF0NFs4XSA9IGMgKiBPICsgXyAqIEQgKyB4ICogQiwgdGhpcy5tYXQ0WzldID0gcCAqIE8gKyBTICogRCArIFAgKiBCLCB0aGlzLm1hdDRbMTBdID0gaiAqIE8gKyBFICogRCArIE0gKiBCLCB0aGlzLm1hdDRbMTFdID0gVCAqIE8gKyBBICogRCArIFIgKiBCLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInRyYW5zbGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHZhciBsID0gYVswXSwgbiA9IGFbMV0sIGEgPSBhWzJdIHx8IDA7XG4gICAgICAgICAgdGhpcy5tYXQ0WzEyXSArPSB0aGlzLm1hdDRbMF0gKiBsICsgdGhpcy5tYXQ0WzRdICogbiArIHRoaXMubWF0NFs4XSAqIGEsIHRoaXMubWF0NFsxM10gKz0gdGhpcy5tYXQ0WzFdICogbCArIHRoaXMubWF0NFs1XSAqIG4gKyB0aGlzLm1hdDRbOV0gKiBhLCB0aGlzLm1hdDRbMTRdICs9IHRoaXMubWF0NFsyXSAqIGwgKyB0aGlzLm1hdDRbNl0gKiBuICsgdGhpcy5tYXQ0WzEwXSAqIGEsIHRoaXMubWF0NFsxNV0gKz0gdGhpcy5tYXQ0WzNdICogbCArIHRoaXMubWF0NFs3XSAqIG4gKyB0aGlzLm1hdDRbMTFdICogYTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyb3RhdGVYXCIsIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgdGhpcy5yb3RhdGUoaSwgMSwgMCwgMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicm90YXRlWVwiLCB2YWx1ZTogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHRoaXMucm90YXRlKGksIDAsIDEsIDApO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJvdGF0ZVpcIiwgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICB0aGlzLnJvdGF0ZShpLCAwLCAwLCAxKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwZXJzcGVjdGl2ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYywgbCwgbiwgYSkge1xuICAgICAgICAgIHZhciBjID0gMSAvIE1hdGgudGFuKGMgLyAyKSwgcCA9IDEgLyAobiAtIGEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hdDRbMF0gPSBjIC8gbCwgdGhpcy5tYXQ0WzFdID0gMCwgdGhpcy5tYXQ0WzJdID0gMCwgdGhpcy5tYXQ0WzNdID0gMCwgdGhpcy5tYXQ0WzRdID0gMCwgdGhpcy5tYXQ0WzVdID0gYywgdGhpcy5tYXQ0WzZdID0gMCwgdGhpcy5tYXQ0WzddID0gMCwgdGhpcy5tYXQ0WzhdID0gMCwgdGhpcy5tYXQ0WzldID0gMCwgdGhpcy5tYXQ0WzEwXSA9IChhICsgbikgKiBwLCB0aGlzLm1hdDRbMTFdID0gLTEsIHRoaXMubWF0NFsxMl0gPSAwLCB0aGlzLm1hdDRbMTNdID0gMCwgdGhpcy5tYXQ0WzE0XSA9IDIgKiBhICogbiAqIHAsIHRoaXMubWF0NFsxNV0gPSAwLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm9ydGhvXCIsIHZhbHVlOiBmdW5jdGlvbihpLCBsLCBuLCBhLCBjLCBwKSB7XG4gICAgICAgICAgdmFyIGogPSAxIC8gKGkgLSBsKSwgVCA9IDEgLyAobiAtIGEpLCBfID0gMSAvIChjIC0gcCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWF0NFswXSA9IC0yICogaiwgdGhpcy5tYXQ0WzFdID0gMCwgdGhpcy5tYXQ0WzJdID0gMCwgdGhpcy5tYXQ0WzNdID0gMCwgdGhpcy5tYXQ0WzRdID0gMCwgdGhpcy5tYXQ0WzVdID0gLTIgKiBULCB0aGlzLm1hdDRbNl0gPSAwLCB0aGlzLm1hdDRbN10gPSAwLCB0aGlzLm1hdDRbOF0gPSAwLCB0aGlzLm1hdDRbOV0gPSAwLCB0aGlzLm1hdDRbMTBdID0gMiAqIF8sIHRoaXMubWF0NFsxMV0gPSAwLCB0aGlzLm1hdDRbMTJdID0gKGkgKyBsKSAqIGosIHRoaXMubWF0NFsxM10gPSAoYSArIG4pICogVCwgdGhpcy5tYXQ0WzE0XSA9IChwICsgYykgKiBfLCB0aGlzLm1hdDRbMTVdID0gMSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJtdWx0aXBseVZlYzRcIiwgdmFsdWU6IGZ1bmN0aW9uKGksIGwsIG4sIGEpIHtcbiAgICAgICAgICB2YXIgYyA9IG5ldyBBcnJheSg0KSwgcCA9IHRoaXMubWF0NDtcbiAgICAgICAgICByZXR1cm4gY1swXSA9IHBbMF0gKiBpICsgcFs0XSAqIGwgKyBwWzhdICogbiArIHBbMTJdICogYSwgY1sxXSA9IHBbMV0gKiBpICsgcFs1XSAqIGwgKyBwWzldICogbiArIHBbMTNdICogYSwgY1syXSA9IHBbMl0gKiBpICsgcFs2XSAqIGwgKyBwWzEwXSAqIG4gKyBwWzE0XSAqIGEsIGNbM10gPSBwWzNdICogaSArIHBbN10gKiBsICsgcFsxMV0gKiBuICsgcFsxNV0gKiBhLCBjO1xuICAgICAgICB9IH0sIHsga2V5OiBcIm11bHRpcGx5UG9pbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYSA9IG4ueCwgbCA9IG4ueSwgbiA9IG4ueiwgYSA9IHRoaXMubXVsdGlwbHlWZWM0KGEsIGwsIG4sIDEpO1xuICAgICAgICAgIHJldHVybiBuZXcgbS5kZWZhdWx0LlZlY3RvcihhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtdWx0aXBseUFuZE5vcm1hbGl6ZVBvaW50XCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGEgPSBuLngsIGwgPSBuLnksIG4gPSBuLnosIGEgPSB0aGlzLm11bHRpcGx5VmVjNChhLCBsLCBuLCAxKTtcbiAgICAgICAgICByZXR1cm4gYVswXSAvPSBhWzNdLCBhWzFdIC89IGFbM10sIGFbMl0gLz0gYVszXSwgbmV3IG0uZGVmYXVsdC5WZWN0b3IoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibXVsdGlwbHlEaXJlY3Rpb25cIiwgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYSA9IG4ueCwgbCA9IG4ueSwgbiA9IG4ueiwgYSA9IHRoaXMubXVsdGlwbHlWZWM0KGEsIGwsIG4sIDApO1xuICAgICAgICAgIHJldHVybiBuZXcgbS5kZWZhdWx0LlZlY3RvcihhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtdWx0M3gzXCIsIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgaWYgKG4gPT09IHRoaXMgfHwgbiA9PT0gdGhpcy5tYXQzKVxuICAgICAgICAgICAgbCA9IHRoaXMuY29weSgpLm1hdDM7XG4gICAgICAgICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG0uZGVmYXVsdC5NYXRyaXgpXG4gICAgICAgICAgICBsID0gbi5tYXQzO1xuICAgICAgICAgIGVsc2UgaWYgKGgobikpXG4gICAgICAgICAgICBsID0gbjtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA5KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsID0gYXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbiA9IHRoaXMubWF0M1swXSwgYSA9IHRoaXMubWF0M1sxXSwgYyA9IHRoaXMubWF0M1syXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXQzWzBdID0gbiAqIGxbMF0gKyBhICogbFszXSArIGMgKiBsWzZdLCB0aGlzLm1hdDNbMV0gPSBuICogbFsxXSArIGEgKiBsWzRdICsgYyAqIGxbN10sIHRoaXMubWF0M1syXSA9IG4gKiBsWzJdICsgYSAqIGxbNV0gKyBjICogbFs4XSwgbiA9IHRoaXMubWF0M1szXSwgYSA9IHRoaXMubWF0M1s0XSwgYyA9IHRoaXMubWF0M1s1XSwgdGhpcy5tYXQzWzNdID0gbiAqIGxbMF0gKyBhICogbFszXSArIGMgKiBsWzZdLCB0aGlzLm1hdDNbNF0gPSBuICogbFsxXSArIGEgKiBsWzRdICsgYyAqIGxbN10sIHRoaXMubWF0M1s1XSA9IG4gKiBsWzJdICsgYSAqIGxbNV0gKyBjICogbFs4XSwgbiA9IHRoaXMubWF0M1s2XSwgYSA9IHRoaXMubWF0M1s3XSwgYyA9IHRoaXMubWF0M1s4XSwgdGhpcy5tYXQzWzZdID0gbiAqIGxbMF0gKyBhICogbFszXSArIGMgKiBsWzZdLCB0aGlzLm1hdDNbN10gPSBuICogbFsxXSArIGEgKiBsWzRdICsgYyAqIGxbN10sIHRoaXMubWF0M1s4XSA9IG4gKiBsWzJdICsgYSAqIGxbNV0gKyBjICogbFs4XSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJjb2x1bW5cIiwgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG0uZGVmYXVsdC5WZWN0b3IodGhpcy5tYXQzWzMgKiBpXSwgdGhpcy5tYXQzWzMgKiBpICsgMV0sIHRoaXMubWF0M1szICogaSArIDJdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyb3dcIiwgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG0uZGVmYXVsdC5WZWN0b3IodGhpcy5tYXQzW2ldLCB0aGlzLm1hdDNbaSArIDNdLCB0aGlzLm1hdDNbaSArIDZdKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkaWFnb25hbFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWF0MyAhPT0gdm9pZCAwID8gW3RoaXMubWF0M1swXSwgdGhpcy5tYXQzWzRdLCB0aGlzLm1hdDNbOF1dIDogW3RoaXMubWF0NFswXSwgdGhpcy5tYXQ0WzVdLCB0aGlzLm1hdDRbMTBdLCB0aGlzLm1hdDRbMTVdXTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtdWx0aXBseVZlYzNcIiwgdmFsdWU6IGZ1bmN0aW9uKGksIGwpIHtcbiAgICAgICAgICByZXR1cm4gKGwgPSBsID09PSB2b2lkIDAgPyBpLmNvcHkoKSA6IGwpLnggPSB0aGlzLnJvdygwKS5kb3QoaSksIGwueSA9IHRoaXMucm93KDEpLmRvdChpKSwgbC56ID0gdGhpcy5yb3coMikuZG90KGkpLCBsO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNyZWF0ZVN1Yk1hdHJpeDN4M1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgbS5kZWZhdWx0Lk1hdHJpeChcIm1hdDNcIik7XG4gICAgICAgICAgcmV0dXJuIGkubWF0M1swXSA9IHRoaXMubWF0NFswXSwgaS5tYXQzWzFdID0gdGhpcy5tYXQ0WzFdLCBpLm1hdDNbMl0gPSB0aGlzLm1hdDRbMl0sIGkubWF0M1szXSA9IHRoaXMubWF0NFs0XSwgaS5tYXQzWzRdID0gdGhpcy5tYXQ0WzVdLCBpLm1hdDNbNV0gPSB0aGlzLm1hdDRbNl0sIGkubWF0M1s2XSA9IHRoaXMubWF0NFs4XSwgaS5tYXQzWzddID0gdGhpcy5tYXQ0WzldLCBpLm1hdDNbOF0gPSB0aGlzLm1hdDRbMTBdLCBpO1xuICAgICAgICB9IH1dKSAmJiB5KHIucHJvdG90eXBlLCBzKSwgbyAmJiB5KHIsIG8pLCBmO1xuICAgICAgfSgpLCBtLmRlZmF1bHQuTWF0cml4KTtcbiAgICAgIEMuZGVmYXVsdCA9IGc7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiOiAxODcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCI6IDIxMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIjogMjExLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCI6IDIxMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCI6IDIxMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiOiAyMTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIjogMjE0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCI6IDIxNiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIjogMjE4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiOiAyMTksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCI6IDIyMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIjogMjIzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCI6IDIyNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiOiAyMjUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiOiAyMjYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiOiAyMjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiOiAyMjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIjogMjI5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIjogMjMwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiOiAyMzEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIjogMjMyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCI6IDIzMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIjogMjM0LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCI6IDIzNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCI6IDIzNiB9XSwgMzM0OiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLmRlZmF1bHQgPSB2b2lkIDAsIHQgPSAodCA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHQuX19lc01vZHVsZSA/IHQgOiB7IGRlZmF1bHQ6IHQgfTtcbiAgICAgIGZ1bmN0aW9uIG0oeSwgdSkge1xuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHUubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgZyA9IHVbaF07XG4gICAgICAgICAgZy5lbnVtZXJhYmxlID0gZy5lbnVtZXJhYmxlIHx8ICExLCBnLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gZyAmJiAoZy53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHksIGcua2V5LCBnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdC5kZWZhdWx0LlJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB5KGcsIGYsIHIsIHMsIG8sIGkpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IGcsIHRoaXMuc3JjID0gZiwgdGhpcy5kc3QgPSByLCB0aGlzLmF0dHIgPSBzLCB0aGlzLl9yZW5kZXJlciA9IG8sIHRoaXMubWFwID0gaTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSwgaDtcbiAgICAgICAgcmV0dXJuIHUgPSB5LCAoaCA9IFt7IGtleTogXCJfcHJlcGFyZUJ1ZmZlclwiLCB2YWx1ZTogZnVuY3Rpb24oZywgZikge1xuICAgICAgICAgIHZhciByLCBzLCBvLCBuID0gZi5hdHRyaWJ1dGVzLCBpID0gdGhpcy5fcmVuZGVyZXIuR0wsIGwgPSBnLm1vZGVsIHx8IGcsIG4gPSBuW3RoaXMuYXR0cl07XG4gICAgICAgICAgbiAmJiAociA9IGdbdGhpcy5kc3RdLCAwIDwgKHMgPSBsW3RoaXMuc3JjXSkubGVuZ3RoID8gKChvID0gIXIpICYmIChnW3RoaXMuZHN0XSA9IHIgPSBpLmNyZWF0ZUJ1ZmZlcigpKSwgaS5iaW5kQnVmZmVyKGkuQVJSQVlfQlVGRkVSLCByKSwgIW8gJiYgbC5kaXJ0eUZsYWdzW3RoaXMuc3JjXSA9PT0gITEgfHwgKG8gPSAoZyA9IHRoaXMubWFwKSA/IGcocykgOiBzLCB0aGlzLl9yZW5kZXJlci5fYmluZEJ1ZmZlcihyLCBpLkFSUkFZX0JVRkZFUiwgbyksIGwuZGlydHlGbGFnc1t0aGlzLnNyY10gPSAhMSksIGYuZW5hYmxlQXR0cmliKG4sIHRoaXMuc2l6ZSkpIDogKGcgPSBuLmxvY2F0aW9uKSAhPT0gLTEgJiYgdGhpcy5fcmVuZGVyZXIucmVnaXN0ZXJFbmFibGVkLmhhcyhnKSAmJiAoaS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoZyksIHRoaXMuX3JlbmRlcmVyLnJlZ2lzdGVyRW5hYmxlZC5kZWxldGUoZykpKTtcbiAgICAgICAgfSB9XSkgJiYgbSh1LnByb3RvdHlwZSwgaCksIHk7XG4gICAgICB9KCksIHQgPSB0LmRlZmF1bHQuUmVuZGVyQnVmZmVyLCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3IH1dLCAzMzU6IFtmdW5jdGlvbih0LCBILCBDKSB7XG4gICAgICBmdW5jdGlvbiBtKG8pIHtcbiAgICAgICAgcmV0dXJuIChtID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgaTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBpLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgaSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgaTtcbiAgICAgICAgfSkobyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KG8pIHtcbiAgICAgICAgcmV0dXJuICh5ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbShTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBtKGkpO1xuICAgICAgICB9IDogZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGkuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBpICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IG0oaSk7XG4gICAgICAgIH0pKG8pO1xuICAgICAgfVxuICAgICAgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb21cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAocyA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIHMuX19lc01vZHVsZSA/IHMgOiB7IGRlZmF1bHQ6IHMgfSwgaCA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKG8gJiYgby5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICBpZiAobyA9PT0gbnVsbCB8fCB5KG8pICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBvIH07XG4gICAgICAgIHZhciBpID0gZygpO1xuICAgICAgICBpZiAoaSAmJiBpLmhhcyhvKSlcbiAgICAgICAgICByZXR1cm4gaS5nZXQobyk7XG4gICAgICAgIHZhciBsLCBuID0ge30sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChsIGluIG8pIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgbCkgJiYgKChjID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgbCkgOiBudWxsKSAmJiAoYy5nZXQgfHwgYy5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGwsIGMpIDogbltsXSA9IG9bbF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLmRlZmF1bHQgPSBvLCBpICYmIGkuc2V0KG8sIG4pLCBuO1xuICAgICAgfSh0KFwiLi4vY29yZS9jb25zdGFudHNcIikpO1xuICAgICAgZnVuY3Rpb24gZygpIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9LCBvKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYobykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMCwgbiA9IG5ldyBBcnJheShpLmxlbmd0aCk7IGwgPCBpLmxlbmd0aDsgbCsrKVxuICAgICAgICAgICAgICBuW2xdID0gaVtsXTtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfShvKSB8fCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaSkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaSk7XG4gICAgICAgIH0obykgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgICAgICB9KCk7XG4gICAgICB9XG4gICAgICB0KFwiLi9wNS5SZW5kZXJCdWZmZXJcIiksIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5iZWdpblNoYXBlID0gZnVuY3Rpb24obykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSA9IG8gIT09IHZvaWQgMCA/IG8gOiBoLlRFU1MsIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS5yZXNldCgpLCB0aGlzLmltbWVkaWF0ZU1vZGUuY29udG91ckluZGljZXMgPSBbXSwgdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgciA9IHsgdmVydGljZXM6IDEsIHZlcnRleE5vcm1hbHM6IDEsIHZlcnRleENvbG9yczogNCwgdmVydGV4U3Ryb2tlQ29sb3JzOiA0LCB1dnM6IDIgfSwgcyA9ICh1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuYmVnaW5Db250b3VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlICE9PSBoLlRFU1MpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgbW9kZSBjYW4gb25seSB1c2UgY29udG91cnMgd2l0aCBiZWdpblNoYXBlKFRFU1MpLlwiKTtcbiAgICAgICAgdGhpcy5pbW1lZGlhdGVNb2RlLmNvbnRvdXJJbmRpY2VzLnB1c2godGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUudmVydGV4ID0gZnVuY3Rpb24obywgaSkge1xuICAgICAgICBpZiAodGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSA9PT0gaC5RVUFEUyAmJiB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICUgNiA9PSAzKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gcikge1xuICAgICAgICAgICAgdmFyIG4gPSByW2xdLCBsID0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5W2xdO1xuICAgICAgICAgICAgbC5wdXNoLmFwcGx5KGwsIGYobC5zbGljZShsLmxlbmd0aCAtIDMgKiBuLCBsLmxlbmd0aCAtIDIgKiBuKSkuY29uY2F0KGYobC5zbGljZShsLmxlbmd0aCAtIG4sIGwubGVuZ3RoKSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBhLCBjLCBwID0gYSA9IGMgPSAwLCBqID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBwID0gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNCA/IChhID0gYXJndW1lbnRzWzJdLCBjID0gYXJndW1lbnRzWzNdKSA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDUgJiYgKHAgPSBhcmd1bWVudHNbMl0sIGEgPSBhcmd1bWVudHNbM10sIGMgPSBhcmd1bWVudHNbNF0pLCBuZXcgdS5kZWZhdWx0LlZlY3RvcihvLCBpLCBwKSksIGogPSAodGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLnB1c2goaiksIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0ZXhOb3JtYWxzLnB1c2godGhpcy5fY3VycmVudE5vcm1hbCksIHRoaXMuY3VyRmlsbENvbG9yIHx8IFswLjUsIDAuNSwgMC41LCAxXSksIGogPSAodGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleENvbG9ycy5wdXNoKGpbMF0sIGpbMV0sIGpbMl0sIGpbM10pLCB0aGlzLmN1clN0cm9rZUNvbG9yIHx8IFswLjUsIDAuNSwgMC41LCAxXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGV4U3Ryb2tlQ29sb3JzLnB1c2goalswXSwgalsxXSwgalsyXSwgalszXSksIHRoaXMudGV4dHVyZU1vZGUgIT09IGguSU1BR0UgfHwgdGhpcy5pc1Byb2Nlc3NpbmdWZXJ0aWNlcyB8fCAodGhpcy5fdGV4ICE9PSBudWxsID8gMCA8IHRoaXMuX3RleC53aWR0aCAmJiAwIDwgdGhpcy5fdGV4LmhlaWdodCAmJiAoYSAvPSB0aGlzLl90ZXgud2lkdGgsIGMgLz0gdGhpcy5fdGV4LmhlaWdodCkgOiB0aGlzLnVzZXJGaWxsU2hhZGVyID09PSB2b2lkIDAgJiYgdGhpcy51c2VyU3Ryb2tlU2hhZGVyID09PSB2b2lkIDAgJiYgdGhpcy51c2VyUG9pbnRTaGFkZXIgPT09IHZvaWQgMCAmJiB0aGlzLl90ZXggPT09IG51bGwgJiYgNCA8PSBhcmd1bWVudHMubGVuZ3RoICYmIGNvbnNvbGUud2FybihcIllvdSBtdXN0IGZpcnN0IGNhbGwgdGV4dHVyZSgpIGJlZm9yZSB1c2luZyB2ZXJ0ZXgoKSB3aXRoIGltYWdlIGJhc2VkIHUgYW5kIHYgY29vcmRpbmF0ZXNcIikpLCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudXZzLnB1c2goYSwgYyksIHRoaXMuaW1tZWRpYXRlTW9kZS5fYmV6aWVyVmVydGV4WzBdID0gbywgdGhpcy5pbW1lZGlhdGVNb2RlLl9iZXppZXJWZXJ0ZXhbMV0gPSBpLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2JlemllclZlcnRleFsyXSA9IHAsIHRoaXMuaW1tZWRpYXRlTW9kZS5fcXVhZHJhdGljVmVydGV4WzBdID0gbywgdGhpcy5pbW1lZGlhdGVNb2RlLl9xdWFkcmF0aWNWZXJ0ZXhbMV0gPSBpLCB0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleFsyXSA9IHAsIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24obywgaSwgbCkge1xuICAgICAgICByZXR1cm4gbyBpbnN0YW5jZW9mIHUuZGVmYXVsdC5WZWN0b3IgPyB0aGlzLl9jdXJyZW50Tm9ybWFsID0gbyA6IHRoaXMuX2N1cnJlbnROb3JtYWwgPSBuZXcgdS5kZWZhdWx0LlZlY3RvcihvLCBpLCBsKSwgdGhpcztcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5lbmRTaGFwZSA9IGZ1bmN0aW9uKG8sIGksIGwsIG4sIGEsIGMpIHtcbiAgICAgICAgdmFyIHAsIGogPSA2IDwgYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbNl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s2XSA6IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlID09PSBoLlBPSU5UUyA/IHRoaXMuX2RyYXdQb2ludHModGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLCB0aGlzLmltbWVkaWF0ZU1vZGUuYnVmZmVycy5wb2ludCkgOiAodGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlID09PSBoLlRFU1MgJiYgKHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUsIGguVFJJQU5HTEVTKSwgdGhpcy5pc1Byb2Nlc3NpbmdWZXJ0aWNlcyA9ICEwLCB0aGlzLl9wcm9jZXNzVmVydGljZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcCA9IHRoaXMuaXNQcm9jZXNzaW5nVmVydGljZXMgPSAhMSwgdGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSAhPT0gaC5MSU5FX1NUUklQICYmIHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgIT09IGguTElORVMgfHwgKHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgPSBoLlRSSUFOR0xFX0ZBTiwgcCA9ICEwKSwgdGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSA9PT0gaC5RVUFEUyA/IHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgPSBoLlRSSUFOR0xFUyA6IHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgPT09IGguUVVBRF9TVFJJUCAmJiAodGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSA9IGguVFJJQU5HTEVfU1RSSVApLCB0aGlzLl9kb0ZpbGwgJiYgIXAgJiYgIXRoaXMuZ2VvbWV0cnlCdWlsZGVyICYmIDMgPD0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAmJiB0aGlzLl9kcmF3SW1tZWRpYXRlRmlsbChqKSwgdGhpcy5fZG9TdHJva2UgJiYgIXRoaXMuZ2VvbWV0cnlCdWlsZGVyICYmIDEgPD0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LmxpbmVWZXJ0aWNlcy5sZW5ndGggJiYgdGhpcy5fZHJhd0ltbWVkaWF0ZVN0cm9rZSgpLCB0aGlzLmdlb21ldHJ5QnVpbGRlciAmJiB0aGlzLmdlb21ldHJ5QnVpbGRlci5hZGRJbW1lZGlhdGUoKSwgdGhpcy5pc0JlemllciA9ICExLCB0aGlzLmlzUXVhZHJhdGljID0gITEsIHRoaXMuaXNDdXJ2ZSA9ICExLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2JlemllclZlcnRleC5sZW5ndGggPSAwLCB0aGlzLmltbWVkaWF0ZU1vZGUuX3F1YWRyYXRpY1ZlcnRleC5sZW5ndGggPSAwLCB0aGlzLmltbWVkaWF0ZU1vZGUuX2N1cnZlVmVydGV4Lmxlbmd0aCA9IDApLCB0aGlzO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9wcm9jZXNzVmVydGljZXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICE9PSAwICYmIChpID0gdGhpcy5fZG9TdHJva2UsIG8gPSBvID09PSBoLkNMT1NFLCBpICYmICh0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkuZWRnZXMgPSB0aGlzLl9jYWxjdWxhdGVFZGdlcyh0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlLCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMsIG8pLCB0aGlzLmdlb21ldHJ5QnVpbGRlciB8fCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkuX2VkZ2VzVG9WZXJ0aWNlcygpKSwgaSA9IHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgPT09IGguVEVTUywgbyA9IDAgPCB0aGlzLmltbWVkaWF0ZU1vZGUuY29udG91ckluZGljZXMubGVuZ3RoLCB0aGlzLl9kb0ZpbGwgJiYgKHRoaXMuaXNCZXppZXIgfHwgdGhpcy5pc1F1YWRyYXRpYyB8fCB0aGlzLmlzQ3VydmUgfHwgaSB8fCBvKSAmJiB0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlICE9PSBoLkxJTkVTICYmIHRoaXMuX3Rlc3NlbGF0ZVNoYXBlKCkpO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9jYWxjdWxhdGVFZGdlcyA9IGZ1bmN0aW9uKG8sIGksIGwpIHtcbiAgICAgICAgdmFyIG4gPSBbXSwgYSA9IDAsIGMgPSB0aGlzLmltbWVkaWF0ZU1vZGUuY29udG91ckluZGljZXMuc2xpY2UoKSwgcCA9IDA7XG4gICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgIGNhc2UgaC5UUklBTkdMRV9TVFJJUDpcbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBpLmxlbmd0aCAtIDI7IGErKylcbiAgICAgICAgICAgICAgbi5wdXNoKFthLCBhICsgMV0pLCBuLnB1c2goW2EsIGEgKyAyXSk7XG4gICAgICAgICAgICBuLnB1c2goW2EsIGEgKyAxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGguVFJJQU5HTEVfRkFOOlxuICAgICAgICAgICAgZm9yIChhID0gMTsgYSA8IGkubGVuZ3RoIC0gMTsgYSsrKVxuICAgICAgICAgICAgICBuLnB1c2goWzAsIGFdKSwgbi5wdXNoKFthLCBhICsgMV0pO1xuICAgICAgICAgICAgbi5wdXNoKFswLCBpLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaC5UUklBTkdMRVM6XG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaS5sZW5ndGggLSAyOyBhICs9IDMpXG4gICAgICAgICAgICAgIG4ucHVzaChbYSwgYSArIDFdKSwgbi5wdXNoKFthICsgMSwgYSArIDJdKSwgbi5wdXNoKFthICsgMiwgYV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBoLkxJTkVTOlxuICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IGkubGVuZ3RoIC0gMTsgYSArPSAyKVxuICAgICAgICAgICAgICBuLnB1c2goW2EsIGEgKyAxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGguUVVBRFM6XG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaS5sZW5ndGggLSA1OyBhICs9IDYpXG4gICAgICAgICAgICAgIG4ucHVzaChbYSwgYSArIDFdKSwgbi5wdXNoKFthICsgMSwgYSArIDJdKSwgbi5wdXNoKFthICsgMywgYSArIDVdKSwgbi5wdXNoKFthICsgNCwgYSArIDVdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaC5RVUFEX1NUUklQOlxuICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IGkubGVuZ3RoIC0gMjsgYSArPSAyKVxuICAgICAgICAgICAgICBuLnB1c2goW2EsIGEgKyAxXSksIG4ucHVzaChbYSwgYSArIDJdKSwgbi5wdXNoKFthICsgMSwgYSArIDNdKTtcbiAgICAgICAgICAgIG4ucHVzaChbYSwgYSArIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKylcbiAgICAgICAgICAgICAgYSArIDEgPCBpLmxlbmd0aCAmJiBhICsgMSAhPT0gY1swXSA/IG4ucHVzaChbYSwgYSArIDFdKSA6ICgobCB8fCBwKSAmJiBuLnB1c2goW2EsIHBdKSwgMCA8IGMubGVuZ3RoICYmIChwID0gYy5zaGlmdCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8gIT09IGguVEVTUyAmJiBsICYmIG4ucHVzaChbaS5sZW5ndGggLSAxLCAwXSksIG47XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX3Rlc3NlbGF0ZVNoYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSB0aGlzLCBpID0gKHRoaXMuaW1tZWRpYXRlTW9kZS5zaGFwZU1vZGUgPSBoLlRSSUFOR0xFUywgW1tdXSksIGwgPSAwOyBsIDwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgbCsrKVxuICAgICAgICAgIDAgPCB0aGlzLmltbWVkaWF0ZU1vZGUuY29udG91ckluZGljZXMubGVuZ3RoICYmIHRoaXMuaW1tZWRpYXRlTW9kZS5jb250b3VySW5kaWNlc1swXSA9PT0gbCAmJiAodGhpcy5pbW1lZGlhdGVNb2RlLmNvbnRvdXJJbmRpY2VzLnNoaWZ0KCksIGkucHVzaChbXSkpLCBpW2kubGVuZ3RoIC0gMV0ucHVzaCh0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXNbbF0ueCwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzW2xdLnksIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0aWNlc1tsXS56LCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudXZzWzIgKiBsXSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnV2c1syICogbCArIDFdLCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGV4Q29sb3JzWzQgKiBsXSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleENvbG9yc1s0ICogbCArIDFdLCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGV4Q29sb3JzWzQgKiBsICsgMl0sIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0ZXhDb2xvcnNbNCAqIGwgKyAzXSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleE5vcm1hbHNbbF0ueCwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleE5vcm1hbHNbbF0ueSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleE5vcm1hbHNbbF0ueik7XG4gICAgICAgIGZvciAodmFyIG4sIGEgPSB0aGlzLl90cmlhbmd1bGF0ZShpKSwgYyA9IHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0aWNlcywgcCA9ICh0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMgPSBbXSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleE5vcm1hbHMgPSBbXSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnV2cyA9IFtdLCBbXSksIGogPSAwLCBUID0gYS5sZW5ndGg7IGogPCBUOyBqICs9IHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS50ZXNzeVZlcnRleFNpemUpXG4gICAgICAgICAgcC5wdXNoLmFwcGx5KHAsIGYoYS5zbGljZShqICsgNSwgaiArIDkpKSksIHRoaXMubm9ybWFsLmFwcGx5KHRoaXMsIGYoYS5zbGljZShqICsgOSwgaiArIDEyKSkpLCB0aGlzLnZlcnRleC5hcHBseSh0aGlzLCBmKGEuc2xpY2UoaiwgaiArIDUpKSk7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlCdWlsZGVyICYmIChuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LmVkZ2VzID0gdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LmVkZ2VzLm1hcChmdW5jdGlvbihfKSB7XG4gICAgICAgICAgcmV0dXJuIF8ubWFwKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIGlmICghbi5oYXMoUykpIHtcbiAgICAgICAgICAgICAgdmFyIEUgPSBjW1NdLCBBID0gby5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmZpbmRJbmRleChmdW5jdGlvbihWKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEUueCA9PT0gVi54ICYmIEUueSA9PT0gVi55ICYmIEUueiA9PT0gVi56O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKEEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDEgLyAwLCBQID0gMCwgTSA9IDA7IE0gPCBvLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBNKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBMID0gby5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzW01dLCBGID0gRS54IC0gTC54LCBSID0gRS55IC0gTC55LCBMID0gRS56IC0gTC56LCBGID0gRiAqIEYgKyBSICogUiArIEwgKiBMO1xuICAgICAgICAgICAgICAgICAgRiA8IHggJiYgKHggPSBGLCBQID0gTSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEEgPSBQO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG4uc2V0KFMsIEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG4uZ2V0KFMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSksIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS52ZXJ0ZXhDb2xvcnMgPSBwO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9kcmF3SW1tZWRpYXRlRmlsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbywgaSA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogMSwgbCA9IHRoaXMuR0wsIG4gPSAodGhpcy5fdXNlVmVydGV4Q29sb3IgPSAwIDwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRleENvbG9ycy5sZW5ndGgsIG8gPSB0aGlzLl9nZXRJbW1lZGlhdGVGaWxsU2hhZGVyKCksIHRoaXMuX3NldEZpbGxVbmlmb3JtcyhvKSwgITApLCBhID0gITEsIGMgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgcCwgaiA9IHRoaXMuaW1tZWRpYXRlTW9kZS5idWZmZXJzLmZpbGxbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKG4gPSAocCA9IGoubmV4dCgpKS5kb25lKTsgbiA9ICEwKVxuICAgICAgICAgICAgcC52YWx1ZS5fcHJlcGFyZUJ1ZmZlcih0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnksIG8pO1xuICAgICAgICB9IGNhdGNoIChUKSB7XG4gICAgICAgICAgYSA9ICEwLCBjID0gVDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbiB8fCBqLnJldHVybiA9PSBudWxsIHx8IGoucmV0dXJuKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgICB0aHJvdyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5kaXNhYmxlUmVtYWluaW5nQXR0cmlidXRlcygpLCB0aGlzLl9hcHBseUNvbG9yQmxlbmQodGhpcy5jdXJGaWxsQ29sb3IsIHRoaXMuaW1tZWRpYXRlTW9kZS5nZW9tZXRyeS5oYXNGaWxsVHJhbnNwYXJlbmN5KCkpLCBpID09PSAxKVxuICAgICAgICAgIGwuZHJhd0FycmF5cyh0aGlzLmltbWVkaWF0ZU1vZGUuc2hhcGVNb2RlLCAwLCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsLmRyYXdBcnJheXNJbnN0YW5jZWQodGhpcy5pbW1lZGlhdGVNb2RlLnNoYXBlTW9kZSwgMCwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCwgaSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfjLggcDUuanMgc2F5czogSW5zdGFuY2luZyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIgbW9kZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIG8udW5iaW5kU2hhZGVyKCk7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2RyYXdJbW1lZGlhdGVTdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLkdMLCBpID0gKHRoaXMuX3VzZUxpbmVDb2xvciA9IDAgPCB0aGlzLmltbWVkaWF0ZU1vZGUuZ2VvbWV0cnkudmVydGV4U3Ryb2tlQ29sb3JzLmxlbmd0aCwgdGhpcy5fZ2V0SW1tZWRpYXRlU3Ryb2tlU2hhZGVyKCkpLCBsID0gKHRoaXMuX3NldFN0cm9rZVVuaWZvcm1zKGkpLCAhMCksIG4gPSAhMSwgYSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBjLCBwID0gdGhpcy5pbW1lZGlhdGVNb2RlLmJ1ZmZlcnMuc3Ryb2tlW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShsID0gKGMgPSBwLm5leHQoKSkuZG9uZSk7IGwgPSAhMClcbiAgICAgICAgICAgIGMudmFsdWUuX3ByZXBhcmVCdWZmZXIodGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LCBpKTtcbiAgICAgICAgfSBjYXRjaCAoaikge1xuICAgICAgICAgIG4gPSAhMCwgYSA9IGo7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGwgfHwgcC5yZXR1cm4gPT0gbnVsbCB8fCBwLnJldHVybigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgICAgdGhyb3cgYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaS5kaXNhYmxlUmVtYWluaW5nQXR0cmlidXRlcygpLCB0aGlzLl9hcHBseUNvbG9yQmxlbmQodGhpcy5jdXJTdHJva2VDb2xvciwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5Lmhhc0ZpbGxUcmFuc3BhcmVuY3koKSksIG8uZHJhd0FycmF5cyhvLlRSSUFOR0xFUywgMCwgdGhpcy5pbW1lZGlhdGVNb2RlLmdlb21ldHJ5LmxpbmVWZXJ0aWNlcy5sZW5ndGggLyAzKSwgaS51bmJpbmRTaGFkZXIoKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMKTtcbiAgICAgIEMuZGVmYXVsdCA9IHM7XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vcDUuUmVuZGVyQnVmZmVyXCI6IDMzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCI6IDE1MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiOiAxNTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQtaW5kZXhcIjogMTU3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIjogMTY3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiOiAxNzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZ1wiOiAxOTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiOiAxOTcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiOiAyMDksIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiOiAyMDcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvclwiOiAyMDgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMzNjogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0ocikge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBzO1xuICAgICAgICB9IDogZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHMuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBzICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBzO1xuICAgICAgICB9KShyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkocikge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIG0ocyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHMgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHMgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShzKTtcbiAgICAgICAgfSkocik7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDE2LWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQzMi1hcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQxNi1hcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MzItYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQy5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgdmFyIHUgPSAoZiA9IHQoXCIuLi9jb3JlL21haW5cIikpICYmIGYuX19lc01vZHVsZSA/IGYgOiB7IGRlZmF1bHQ6IGYgfSwgaCA9ICh0KFwiLi9wNS5SZW5kZXJlckdMXCIpLCB0KFwiLi9wNS5SZW5kZXJCdWZmZXJcIiksIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKHIgJiYgci5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBpZiAociA9PT0gbnVsbCB8fCB5KHIpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiByIH07XG4gICAgICAgIHZhciBzID0gZygpO1xuICAgICAgICBpZiAocyAmJiBzLmhhcyhyKSlcbiAgICAgICAgICByZXR1cm4gcy5nZXQocik7XG4gICAgICAgIHZhciBvLCBpID0ge30sIGwgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgZm9yIChvIGluIHIpIHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgbykgJiYgKChuID0gbCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgbykgOiBudWxsKSAmJiAobi5nZXQgfHwgbi5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIG4pIDogaVtvXSA9IHJbb10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpLmRlZmF1bHQgPSByLCBzICYmIHMuc2V0KHIsIGkpLCBpO1xuICAgICAgfSh0KFwiLi4vY29yZS9jb25zdGFudHNcIikpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSwgcik7XG4gICAgICB9XG4gICAgICB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuZnJlZUdlb21ldHJ5ID0gZnVuY3Rpb24ocikge1xuICAgICAgICByLmdpZCA/IHRoaXMuX2ZyZWVCdWZmZXJzKHIuZ2lkKSA6IGNvbnNvbGUud2FybihcIlRoZSBtb2RlbCB5b3UgcGFzc2VkIHRvIGZyZWVHZW9tZXRyeSBkb2VzIG5vdCBoYXZlIGFuIGlkIVwiKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5faW5pdEJ1ZmZlckRlZmF1bHRzID0gZnVuY3Rpb24ocikge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZWVCdWZmZXJzKHIpLCAxZTMgPCBPYmplY3Qua2V5cyh0aGlzLnJldGFpbmVkTW9kZS5nZW9tZXRyeSkubGVuZ3RoICYmIChzID0gT2JqZWN0LmtleXModGhpcy5yZXRhaW5lZE1vZGUuZ2VvbWV0cnkpWzBdLCB0aGlzLl9mcmVlQnVmZmVycyhzKSksIHRoaXMucmV0YWluZWRNb2RlLmdlb21ldHJ5W3JdID0ge307XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2ZyZWVCdWZmZXJzID0gZnVuY3Rpb24ocikge1xuICAgICAgICB2YXIgcywgbyA9IHRoaXMucmV0YWluZWRNb2RlLmdlb21ldHJ5W3JdO1xuICAgICAgICBmdW5jdGlvbiBpKGwpIHtcbiAgICAgICAgICB2YXIgbiA9ICEwLCBhID0gITEsIGMgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHAsIGogPSBsW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShuID0gKHAgPSBqLm5leHQoKSkuZG9uZSk7IG4gPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgVCA9IHAudmFsdWU7XG4gICAgICAgICAgICAgIG9bVC5kc3RdICYmIChzLmRlbGV0ZUJ1ZmZlcihvW1QuZHN0XSksIG9bVC5kc3RdID0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgYSA9ICEwLCBjID0gXztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbiB8fCBqLnJldHVybiA9PSBudWxsIHx8IGoucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvICYmIChkZWxldGUgdGhpcy5yZXRhaW5lZE1vZGUuZ2VvbWV0cnlbcl0sIHMgPSB0aGlzLkdMLCBvLmluZGV4QnVmZmVyICYmIHMuZGVsZXRlQnVmZmVyKG8uaW5kZXhCdWZmZXIpLCBpKHRoaXMucmV0YWluZWRNb2RlLmJ1ZmZlcnMuc3Ryb2tlKSwgaSh0aGlzLnJldGFpbmVkTW9kZS5idWZmZXJzLmZpbGwpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5jcmVhdGVCdWZmZXJzID0gZnVuY3Rpb24oYSwgcykge1xuICAgICAgICB2YXIgbywgaSwgbCwgbiA9IHRoaXMuR0wsIGEgPSB0aGlzLl9pbml0QnVmZmVyRGVmYXVsdHMoYSksIGMgPSAoYS5tb2RlbCA9IHMsIGEuaW5kZXhCdWZmZXIpO1xuICAgICAgICByZXR1cm4gcy5mYWNlcy5sZW5ndGggPyAoYyA9IGMgfHwgKGEuaW5kZXhCdWZmZXIgPSBuLmNyZWF0ZUJ1ZmZlcigpKSwgbCA9IChpID0gKG8gPSB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2ZsYXR0ZW4ocy5mYWNlcykpLnNvbWUoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiA2NTUzNSA8IHA7XG4gICAgICAgIH0pKSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXksIHRoaXMuX2JpbmRCdWZmZXIoYywgbi5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbywgbCksIGEuaW5kZXhCdWZmZXJUeXBlID0gaSA/IG4uVU5TSUdORURfSU5UIDogbi5VTlNJR05FRF9TSE9SVCwgYS52ZXJ0ZXhDb3VudCA9IDMgKiBzLmZhY2VzLmxlbmd0aCkgOiAoYyAmJiAobi5kZWxldGVCdWZmZXIoYyksIGEuaW5kZXhCdWZmZXIgPSBudWxsKSwgYS52ZXJ0ZXhDb3VudCA9IHMudmVydGljZXMgPyBzLnZlcnRpY2VzLmxlbmd0aCA6IDApLCBhLmxpbmVWZXJ0ZXhDb3VudCA9IHMubGluZVZlcnRpY2VzID8gcy5saW5lVmVydGljZXMubGVuZ3RoIC8gMyA6IDAsIGE7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5HTCwgbyA9IHRoaXMucmV0YWluZWRNb2RlLmdlb21ldHJ5W3JdO1xuICAgICAgICBpZiAoIXRoaXMuZ2VvbWV0cnlCdWlsZGVyICYmIHRoaXMuX2RvRmlsbCAmJiAwIDwgdGhpcy5yZXRhaW5lZE1vZGUuZ2VvbWV0cnlbcl0udmVydGV4Q291bnQpIHtcbiAgICAgICAgICB0aGlzLl91c2VWZXJ0ZXhDb2xvciA9IDAgPCBvLm1vZGVsLnZlcnRleENvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9nZXRSZXRhaW5lZEZpbGxTaGFkZXIoKSwgbCA9ICh0aGlzLl9zZXRGaWxsVW5pZm9ybXMoaSksICEwKSwgbiA9ICExLCBhID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjLCBwID0gdGhpcy5yZXRhaW5lZE1vZGUuYnVmZmVycy5maWxsW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShsID0gKGMgPSBwLm5leHQoKSkuZG9uZSk7IGwgPSAhMClcbiAgICAgICAgICAgICAgYy52YWx1ZS5fcHJlcGFyZUJ1ZmZlcihvLCBpKTtcbiAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICBuID0gITAsIGEgPSBFO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsIHx8IHAucmV0dXJuID09IG51bGwgfHwgcC5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgIHRocm93IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGkuZGlzYWJsZVJlbWFpbmluZ0F0dHJpYnV0ZXMoKSwgby5pbmRleEJ1ZmZlciAmJiB0aGlzLl9iaW5kQnVmZmVyKG8uaW5kZXhCdWZmZXIsIHMuRUxFTUVOVF9BUlJBWV9CVUZGRVIpLCB0aGlzLl9hcHBseUNvbG9yQmxlbmQodGhpcy5jdXJGaWxsQ29sb3IsIG8ubW9kZWwuaGFzRmlsbFRyYW5zcGFyZW5jeSgpKSwgdGhpcy5fZHJhd0VsZW1lbnRzKHMuVFJJQU5HTEVTLCByKSwgaS51bmJpbmRTaGFkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2VvbWV0cnlCdWlsZGVyICYmIHRoaXMuX2RvU3Ryb2tlICYmIDAgPCBvLmxpbmVWZXJ0ZXhDb3VudCkge1xuICAgICAgICAgIHRoaXMuX3VzZUxpbmVDb2xvciA9IDAgPCBvLm1vZGVsLnZlcnRleFN0cm9rZUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGogPSB0aGlzLl9nZXRSZXRhaW5lZFN0cm9rZVNoYWRlcigpLCBUID0gKHRoaXMuX3NldFN0cm9rZVVuaWZvcm1zKGopLCAhMCksIG4gPSAhMSwgYSA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgXywgUyA9IHRoaXMucmV0YWluZWRNb2RlLmJ1ZmZlcnMuc3Ryb2tlW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShUID0gKF8gPSBTLm5leHQoKSkuZG9uZSk7IFQgPSAhMClcbiAgICAgICAgICAgICAgXy52YWx1ZS5fcHJlcGFyZUJ1ZmZlcihvLCBqKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBuID0gITAsIGEgPSB4O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBUIHx8IFMucmV0dXJuID09IG51bGwgfHwgUy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgIHRocm93IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGouZGlzYWJsZVJlbWFpbmluZ0F0dHJpYnV0ZXMoKSwgdGhpcy5fYXBwbHlDb2xvckJsZW5kKHRoaXMuY3VyU3Ryb2tlQ29sb3IsIG8ubW9kZWwuaGFzU3Ryb2tlVHJhbnNwYXJlbmN5KCkpLCB0aGlzLl9kcmF3QXJyYXlzKHMuVFJJQU5HTEVTLCByKSwgai51bmJpbmRTaGFkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUJ1aWxkZXIgJiYgdGhpcy5nZW9tZXRyeUJ1aWxkZXIuYWRkUmV0YWluZWQobyksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuZHJhd0J1ZmZlcnNTY2FsZWQgPSBmdW5jdGlvbihyLCBzLCBvLCBpKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy51TVZNYXRyaXguY29weSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudU1WTWF0cml4LnNjYWxlKHMsIG8sIGkpLCB0aGlzLmRyYXdCdWZmZXJzKHIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMudU1WTWF0cml4ID0gbDtcbiAgICAgICAgfVxuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9kcmF3QXJyYXlzID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICByZXR1cm4gdGhpcy5HTC5kcmF3QXJyYXlzKHIsIDAsIHRoaXMucmV0YWluZWRNb2RlLmdlb21ldHJ5W3NdLmxpbmVWZXJ0ZXhDb3VudCksIHRoaXM7XG4gICAgICB9LCB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUuX2RyYXdFbGVtZW50cyA9IGZ1bmN0aW9uKHIsIG8pIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLnJldGFpbmVkTW9kZS5nZW9tZXRyeVtvXSwgaSA9IHRoaXMuR0w7XG4gICAgICAgIGlmIChvLmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BJbnN0LndlYmdsVmVyc2lvbiAhPT0gaC5XRUJHTDIgJiYgby5pbmRleEJ1ZmZlclR5cGUgPT09IGkuVU5TSUdORURfSU5UICYmICFpLmdldEV4dGVuc2lvbihcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVuZGVyIGEgM2QgbW9kZWwgd2l0aCA+IDY1NTM1IHRyaWFuZ2xlcy4gWW91ciB3ZWIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBXZWJHTCBFeHRlbnNpb24gT0VTX2VsZW1lbnRfaW5kZXhfdWludC5cIik7XG4gICAgICAgICAgaS5kcmF3RWxlbWVudHMoaS5UUklBTkdMRVMsIG8udmVydGV4Q291bnQsIG8uaW5kZXhCdWZmZXJUeXBlLCAwKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaS5kcmF3QXJyYXlzKHIgfHwgaS5UUklBTkdMRVMsIDAsIG8udmVydGV4Q291bnQpO1xuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9kcmF3UG9pbnRzID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuR0wsIGkgPSB0aGlzLl9nZXRJbW1lZGlhdGVQb2ludFNoYWRlcigpO1xuICAgICAgICB0aGlzLl9zZXRQb2ludFVuaWZvcm1zKGkpLCB0aGlzLl9iaW5kQnVmZmVyKHMsIG8uQVJSQVlfQlVGRkVSLCB0aGlzLl92VG9OQXJyYXkociksIEZsb2F0MzJBcnJheSwgby5TVEFUSUNfRFJBVyksIGkuZW5hYmxlQXR0cmliKGkuYXR0cmlidXRlcy5hUG9zaXRpb24sIDMpLCB0aGlzLl9hcHBseUNvbG9yQmxlbmQodGhpcy5jdXJTdHJva2VDb2xvciksIG8uZHJhd0FycmF5cyhvLlBvaW50cywgMCwgci5sZW5ndGgpLCBpLnVuYmluZFNoYWRlcigpO1xuICAgICAgfTtcbiAgICAgIHZhciBmID0gdS5kZWZhdWx0LlJlbmRlcmVyR0w7XG4gICAgICBDLmRlZmF1bHQgPSBmO1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuL3A1LlJlbmRlckJ1ZmZlclwiOiAzMzQsIFwiLi9wNS5SZW5kZXJlckdMXCI6IDMzNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbFwiOiAxNTUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCI6IDE2NCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiOiAxNjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5c1wiOiAxODYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIjogMTg3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheVwiOiAyMTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCI6IDIxOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIjogMjE5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiOiAyMjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCI6IDIyMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiOiAyMjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIjogMjI1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIjogMjI2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIjogMjI4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIjogMjI3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCI6IDIyOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCI6IDIzMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIjogMjMxLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCI6IDIzMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiOiAyMzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCI6IDIzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiOiAyMzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiOiAyMzYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQxNi1hcnJheVwiOiAyMzcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQzMi1hcnJheVwiOiAyMzgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCI6IDI0MSwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMzNzogW2Z1bmN0aW9uKE0sIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oVSkge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihXKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBXO1xuICAgICAgICB9IDogZnVuY3Rpb24oVykge1xuICAgICAgICAgIHJldHVybiBXICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFcuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBXICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBXO1xuICAgICAgICB9KShVKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoVSkge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihXKSB7XG4gICAgICAgICAgcmV0dXJuIG0oVyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihXKSB7XG4gICAgICAgICAgcmV0dXJuIFcgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgVy5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIFcgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShXKTtcbiAgICAgICAgfSkoVSk7XG4gICAgICB9XG4gICAgICBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb3B5LXdpdGhpblwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5ldmVyeVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZsYXRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmxhdC1tYXBcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlc1wiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXBcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS51bnNjb3BhYmxlcy5mbGF0XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXQtbWFwXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnNldFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXlcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQ2NC1hcnJheVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbnQxNi1hcnJheVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MTYtYXJyYXlcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlc1wiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvclwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmdcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvcHktd2l0aGluXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmxhdFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0LW1hcFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb21lXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkudW5zY29wYWJsZXMuZmxhdC1tYXBcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMubWFwXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0NjQtYXJyYXlcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW50MTYtYXJyYXlcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDE2LWFycmF5XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQzMi1hcnJheVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIiksIE0oXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiKSwgTShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCIpLCBNKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiKSwgTShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBDLnJlYWRQaXhlbHNXZWJHTCA9IFYsIEMucmVhZFBpeGVsV2ViR0wgPSBHLCBDLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICB2YXIgdSA9IG8oTShcIi4uL2NvcmUvbWFpblwiKSksIGggPSBmdW5jdGlvbihVKSB7XG4gICAgICAgIGlmIChVICYmIFUuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gVTtcbiAgICAgICAgaWYgKFUgPT09IG51bGwgfHwgeShVKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgVSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogVSB9O1xuICAgICAgICB2YXIgVyA9IHMoKTtcbiAgICAgICAgaWYgKFcgJiYgVy5oYXMoVSkpXG4gICAgICAgICAgcmV0dXJuIFcuZ2V0KFUpO1xuICAgICAgICB2YXIgWCwgbmUgPSB7fSwgYiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKFggaW4gVSkge1xuICAgICAgICAgIHZhciBPO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChVLCBYKSAmJiAoKE8gPSBiID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihVLCBYKSA6IG51bGwpICYmIChPLmdldCB8fCBPLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmUsIFgsIE8pIDogbmVbWF0gPSBVW1hdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmUuZGVmYXVsdCA9IFUsIFcgJiYgVy5zZXQoVSwgbmUpLCBuZTtcbiAgICAgIH0oTShcIi4uL2NvcmUvY29uc3RhbnRzXCIpKSwgZyA9IG8oTShcIi4vR2VvbWV0cnlCdWlsZGVyXCIpKSwgZiA9IG8oTShcImxpYnRlc3NcIikpLCByID0gKE0oXCIuL3A1LlNoYWRlclwiKSwgTShcIi4vcDUuQ2FtZXJhXCIpLCBNKFwiLi4vY29yZS9wNS5SZW5kZXJlclwiKSwgTShcIi4vcDUuTWF0cml4XCIpLCBNKFwiLi9wNS5GcmFtZWJ1ZmZlclwiKSwgTShcInBhdGhcIiksIE0oXCIuL3A1LlRleHR1cmVcIikpO1xuICAgICAgZnVuY3Rpb24gcygpIHtcbiAgICAgICAgdmFyIFU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgV2Vha01hcCAhPSBcImZ1bmN0aW9uXCIgPyBudWxsIDogKFUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBVO1xuICAgICAgICB9LCBVKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8oVSkge1xuICAgICAgICByZXR1cm4gVSAmJiBVLl9fZXNNb2R1bGUgPyBVIDogeyBkZWZhdWx0OiBVIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpKFUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShXKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgWCA9IDAsIG5lID0gbmV3IEFycmF5KFcubGVuZ3RoKTsgWCA8IFcubGVuZ3RoOyBYKyspXG4gICAgICAgICAgICAgIG5lW1hdID0gV1tYXTtcbiAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oVSkgfHwgZnVuY3Rpb24oVykge1xuICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KFcpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChXKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIilcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKFcpO1xuICAgICAgICB9KFUpIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbChVLCBXKSB7XG4gICAgICAgIGZvciAodmFyIFggPSAwOyBYIDwgVy5sZW5ndGg7IFgrKykge1xuICAgICAgICAgIHZhciBuZSA9IFdbWF07XG4gICAgICAgICAgbmUuZW51bWVyYWJsZSA9IG5lLmVudW1lcmFibGUgfHwgITEsIG5lLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbmUgJiYgKG5lLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoVSwgbmUua2V5LCBuZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG4oVSwgVywgWCkge1xuICAgICAgICByZXR1cm4gKG4gPSB0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQgOiBmdW5jdGlvbihELCBiLCBPKSB7XG4gICAgICAgICAgdmFyIEQgPSBmdW5jdGlvbihCLCBZKSB7XG4gICAgICAgICAgICBmb3IgKDsgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChCLCBZKSAmJiAoQiA9IGooQikpICE9PSBudWxsOyApXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICAgIH0oRCwgYik7XG4gICAgICAgICAgaWYgKEQpXG4gICAgICAgICAgICByZXR1cm4gKEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEQsIGIpKS5nZXQgPyBELmdldC5jYWxsKE8pIDogRC52YWx1ZTtcbiAgICAgICAgfSkoVSwgVywgWCB8fCBVKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGEoVSwgVykge1xuICAgICAgICByZXR1cm4gKGEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oWCwgbmUpIHtcbiAgICAgICAgICByZXR1cm4gWC5fX3Byb3RvX18gPSBuZSwgWDtcbiAgICAgICAgfSkoVSwgVyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKFUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBXLCBYLCBuZSA9IGooVSk7XG4gICAgICAgICAgcmV0dXJuIFcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KSksIDE7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSgpID8gKFcgPSBqKHRoaXMpLmNvbnN0cnVjdG9yLCBSZWZsZWN0LmNvbnN0cnVjdChuZSwgYXJndW1lbnRzLCBXKSkgOiBuZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBuZSA9IHRoaXMsICEoWCA9IFcpIHx8IHkoWCkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFggIT0gXCJmdW5jdGlvblwiID8gcChuZSkgOiBYO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcChVKSB7XG4gICAgICAgIGlmIChVID09PSB2b2lkIDApXG4gICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gVTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGooVSkge1xuICAgICAgICByZXR1cm4gKGogPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbihXKSB7XG4gICAgICAgICAgcmV0dXJuIFcuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXKTtcbiAgICAgICAgfSkoVSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUKFUsIFcsIFgpIHtcbiAgICAgICAgVyBpbiBVID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KFUsIFcsIHsgdmFsdWU6IFgsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBVW1ddID0gWDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF8oVSwgVykge1xuICAgICAgICBQICs9IFwiI2RlZmluZSBTVFJPS0VfQ0FQX1wiLmNvbmNhdChVLCBcIiBcIikuY29uY2F0KFcsIGBcbmApLCBBW2hbVV1dID0gVztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFMoVSwgVykge1xuICAgICAgICBQICs9IFwiI2RlZmluZSBTVFJPS0VfSk9JTl9cIi5jb25jYXQoVSwgXCIgXCIpLmNvbmNhdChXLCBgXG5gKSwgeFtoW1VdXSA9IFc7XG4gICAgICB9XG4gICAgICB2YXIgRSwgQSA9IHt9LCB4ID0ge30sIFAgPSBcIlwiLCBNID0gKF8oXCJST1VORFwiLCAwKSwgXyhcIlBST0pFQ1RcIiwgMSksIF8oXCJTUVVBUkVcIiwgMiksIFMoXCJST1VORFwiLCAwKSwgUyhcIk1JVEVSXCIsIDEpLCBTKFwiQkVWRUxcIiwgMiksIGAjZGVmaW5lIFBJIDMuMTQxNTkyXG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5cbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcblxudW5pZm9ybSBib29sIHVVc2VMaWdodGluZztcblxudW5pZm9ybSBpbnQgdUFtYmllbnRMaWdodENvdW50O1xudW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3JbNV07XG51bmlmb3JtIG1hdDMgdUNhbWVyYVJvdGF0aW9uO1xudW5pZm9ybSBpbnQgdURpcmVjdGlvbmFsTGlnaHRDb3VudDtcbnVuaWZvcm0gdmVjMyB1TGlnaHRpbmdEaXJlY3Rpb25bNV07XG51bmlmb3JtIHZlYzMgdURpcmVjdGlvbmFsRGlmZnVzZUNvbG9yc1s1XTtcbnVuaWZvcm0gdmVjMyB1RGlyZWN0aW9uYWxTcGVjdWxhckNvbG9yc1s1XTtcblxudW5pZm9ybSBpbnQgdVBvaW50TGlnaHRDb3VudDtcbnVuaWZvcm0gdmVjMyB1UG9pbnRMaWdodExvY2F0aW9uWzVdO1xudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0RGlmZnVzZUNvbG9yc1s1XTtcdFxudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0U3BlY3VsYXJDb2xvcnNbNV07XG5cbnVuaWZvcm0gaW50IHVTcG90TGlnaHRDb3VudDtcbnVuaWZvcm0gZmxvYXQgdVNwb3RMaWdodEFuZ2xlWzVdO1xudW5pZm9ybSBmbG9hdCB1U3BvdExpZ2h0Q29uY1s1XTtcbnVuaWZvcm0gdmVjMyB1U3BvdExpZ2h0RGlmZnVzZUNvbG9yc1s1XTtcbnVuaWZvcm0gdmVjMyB1U3BvdExpZ2h0U3BlY3VsYXJDb2xvcnNbNV07XG51bmlmb3JtIHZlYzMgdVNwb3RMaWdodExvY2F0aW9uWzVdO1xudW5pZm9ybSB2ZWMzIHVTcG90TGlnaHREaXJlY3Rpb25bNV07XG5cbnVuaWZvcm0gYm9vbCB1U3BlY3VsYXI7XG51bmlmb3JtIGZsb2F0IHVTaGluaW5lc3M7XG51bmlmb3JtIGZsb2F0IG1ldGFsbGljO1xuXG51bmlmb3JtIGZsb2F0IHVDb25zdGFudEF0dGVudWF0aW9uO1xudW5pZm9ybSBmbG9hdCB1TGluZWFyQXR0ZW51YXRpb247XG51bmlmb3JtIGZsb2F0IHVRdWFkcmF0aWNBdHRlbnVhdGlvbjtcblxuLy8gc2V0dGluZyBmcm9tICBfc2V0SW1hZ2VMaWdodFVuaWZvcm1zKClcbi8vIGJvb2xlYW4gdG8gaW5pdGlhdGUgdGhlIGNhbGN1bGF0ZUltYWdlRGlmZnVzZSBhbmQgY2FsY3VsYXRlSW1hZ2VTcGVjdWxhclxudW5pZm9ybSBib29sIHVVc2VJbWFnZUxpZ2h0O1xuLy8gdGV4dHVyZSBmb3IgdXNlIGluIGNhbGN1bGF0ZUltYWdlRGlmZnVzZVxudW5pZm9ybSBzYW1wbGVyMkQgZW52aXJvbm1lbnRNYXBEaWZmdXNlZDtcbi8vIHRleHR1cmUgZm9yIHVzZSBpbiBjYWxjdWxhdGVJbWFnZVNwZWN1bGFyXG51bmlmb3JtIHNhbXBsZXIyRCBlbnZpcm9ubWVudE1hcFNwZWN1bGFyO1xuLy8gcm91Z2huZXNzIGZvciB1c2UgaW4gY2FsY3VsYXRlSW1hZ2VTcGVjdWxhclxudW5pZm9ybSBmbG9hdCBsZXZlbE9mRGV0YWlsO1xuXG5jb25zdCBmbG9hdCBzcGVjdWxhckZhY3RvciA9IDIuMDtcbmNvbnN0IGZsb2F0IGRpZmZ1c2VGYWN0b3IgPSAwLjczO1xuXG5zdHJ1Y3QgTGlnaHRSZXN1bHQge1xuICBmbG9hdCBzcGVjdWxhcjtcbiAgZmxvYXQgZGlmZnVzZTtcbn07XG5cbmZsb2F0IF9waG9uZ1NwZWN1bGFyKFxuICB2ZWMzIGxpZ2h0RGlyZWN0aW9uLFxuICB2ZWMzIHZpZXdEaXJlY3Rpb24sXG4gIHZlYzMgc3VyZmFjZU5vcm1hbCxcbiAgZmxvYXQgc2hpbmluZXNzKSB7XG5cbiAgdmVjMyBSID0gcmVmbGVjdChsaWdodERpcmVjdGlvbiwgc3VyZmFjZU5vcm1hbCk7XG4gIHJldHVybiBwb3cobWF4KDAuMCwgZG90KFIsIHZpZXdEaXJlY3Rpb24pKSwgc2hpbmluZXNzKTtcbn1cblxuZmxvYXQgX2xhbWJlcnREaWZmdXNlKHZlYzMgbGlnaHREaXJlY3Rpb24sIHZlYzMgc3VyZmFjZU5vcm1hbCkge1xuICByZXR1cm4gbWF4KDAuMCwgZG90KC1saWdodERpcmVjdGlvbiwgc3VyZmFjZU5vcm1hbCkpO1xufVxuXG5MaWdodFJlc3VsdCBfbGlnaHQodmVjMyB2aWV3RGlyZWN0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodFZlY3Rvcikge1xuXG4gIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUobGlnaHRWZWN0b3IpO1xuXG4gIC8vY29tcHV0ZSBvdXIgZGlmZnVzZSAmIHNwZWN1bGFyIHRlcm1zXG4gIExpZ2h0UmVzdWx0IGxyO1xuICBmbG9hdCBzcGVjdWxhckludGVuc2l0eSA9IG1peCgxLjAsIDAuNCwgbWV0YWxsaWMpO1xuICBmbG9hdCBkaWZmdXNlSW50ZW5zaXR5ID0gbWl4KDEuMCwgMC4xLCBtZXRhbGxpYyk7XG4gIGlmICh1U3BlY3VsYXIpXG4gICAgbHIuc3BlY3VsYXIgPSAoX3Bob25nU3BlY3VsYXIobGlnaHREaXIsIHZpZXdEaXJlY3Rpb24sIG5vcm1hbCwgdVNoaW5pbmVzcykpICogc3BlY3VsYXJJbnRlbnNpdHk7XG4gICAgbHIuZGlmZnVzZSA9IF9sYW1iZXJ0RGlmZnVzZShsaWdodERpciwgbm9ybWFsKSAqIGRpZmZ1c2VJbnRlbnNpdHk7XG4gIHJldHVybiBscjtcbn1cblxuLy8gY29udmVydHMgdGhlIHJhbmdlIG9mIFwidmFsdWVcIiBmcm9tIFttaW4xIHRvIG1heDFdIHRvIFttaW4yIHRvIG1heDJdXG5mbG9hdCBtYXAoZmxvYXQgdmFsdWUsIGZsb2F0IG1pbjEsIGZsb2F0IG1heDEsIGZsb2F0IG1pbjIsIGZsb2F0IG1heDIpIHtcbiAgcmV0dXJuIG1pbjIgKyAodmFsdWUgLSBtaW4xKSAqIChtYXgyIC0gbWluMikgLyAobWF4MSAtIG1pbjEpO1xufVxuXG52ZWMyIG1hcFRleHR1cmVUb05vcm1hbCggdmVjMyB2ICl7XG4gIC8vIHggPSByIHNpbihwaGkpIGNvcyh0aGV0YSkgICBcbiAgLy8geSA9IHIgY29zKHBoaSkgIFxuICAvLyB6ID0gciBzaW4ocGhpKSBzaW4odGhldGEpXG4gIGZsb2F0IHBoaSA9IGFjb3MoIHYueSApO1xuICAvLyBpZiBwaGkgaXMgMCwgdGhlbiB0aGVyZSBhcmUgbm8geCwgeiBjb21wb25lbnRzXG4gIGZsb2F0IHRoZXRhID0gMC4wO1xuICAvLyBlbHNlIFxuICB0aGV0YSA9IGFjb3Modi54IC8gc2luKHBoaSkpO1xuICBmbG9hdCBzaW5UaGV0YSA9IHYueiAvIHNpbihwaGkpO1xuICBpZiAoc2luVGhldGEgPCAwLjApIHtcbiAgICAvLyBUdXJuIGl0IGludG8gLXRoZXRhLCBidXQgaW4gdGhlIDAtMlBJIHJhbmdlXG4gICAgdGhldGEgPSAyLjAgKiBQSSAtIHRoZXRhO1xuICB9XG4gIHRoZXRhID0gdGhldGEgLyAoMi4wICogMy4xNDE1OSk7XG4gIHBoaSA9IHBoaSAvIDMuMTQxNTkgO1xuICBcbiAgdmVjMiBhbmdsZXMgPSB2ZWMyKCBmcmFjdCh0aGV0YSArIDAuMjUpLCAxLjAgLSBwaGkgKTtcbiAgcmV0dXJuIGFuZ2xlcztcbn1cblxuXG52ZWMzIGNhbGN1bGF0ZUltYWdlRGlmZnVzZSggdmVjMyB2Tm9ybWFsLCB2ZWMzIHZWaWV3UG9zaXRpb24gKXtcbiAgLy8gbWFrZSAyIHNlcGVyYXRlIGJ1aWxkcyBcbiAgdmVjMyB3b3JsZENhbWVyYVBvc2l0aW9uID0gIHZlYzMoMC4wLCAwLjAsIDAuMCk7ICAvLyBoYXJkY29kZWQgd29ybGQgY2FtZXJhIHBvc2l0aW9uXG4gIHZlYzMgd29ybGROb3JtYWwgPSBub3JtYWxpemUodk5vcm1hbCAqIHVDYW1lcmFSb3RhdGlvbik7XG4gIHZlYzIgbmV3VGV4Q29vciA9IG1hcFRleHR1cmVUb05vcm1hbCggd29ybGROb3JtYWwgKTtcbiAgdmVjNCB0ZXh0dXJlID0gVEVYVFVSRSggZW52aXJvbm1lbnRNYXBEaWZmdXNlZCwgbmV3VGV4Q29vciApO1xuICAvLyB0aGlzIGlzIHRvIG1ha2UgdGhlIGRhcmtlciBzZWN0aW9ucyBtb3JlIGRhcmtcbiAgLy8gcG5nIGFuZCBqcGcgdXN1YWxseSBmbGF0dGVuIHRoZSBicmlnaHRuZXNzIHNvIGl0IGlzIHRvIHJldmVyc2UgdGhhdFxuICByZXR1cm4gbWl4KHNtb290aHN0ZXAodmVjMygwLjApLCB2ZWMzKDEuMCksIHRleHR1cmUueHl6KSwgdmVjMygwLjApLCBtZXRhbGxpYyk7XG59XG5cbnZlYzMgY2FsY3VsYXRlSW1hZ2VTcGVjdWxhciggdmVjMyB2Tm9ybWFsLCB2ZWMzIHZWaWV3UG9zaXRpb24gKXtcbiAgdmVjMyB3b3JsZENhbWVyYVBvc2l0aW9uID0gIHZlYzMoMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgd29ybGROb3JtYWwgPSBub3JtYWxpemUodk5vcm1hbCk7XG4gIHZlYzMgbGlnaHREaXJlY3Rpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gLSB3b3JsZENhbWVyYVBvc2l0aW9uICk7XG4gIHZlYzMgUiA9IHJlZmxlY3QobGlnaHREaXJlY3Rpb24sIHdvcmxkTm9ybWFsKSAqIHVDYW1lcmFSb3RhdGlvbjtcbiAgdmVjMiBuZXdUZXhDb29yID0gbWFwVGV4dHVyZVRvTm9ybWFsKCBSICk7XG4jaWZkZWYgV0VCR0wyXG4gIHZlYzQgb3V0Q29sb3IgPSB0ZXh0dXJlTG9kKGVudmlyb25tZW50TWFwU3BlY3VsYXIsIG5ld1RleENvb3IsIGxldmVsT2ZEZXRhaWwpO1xuI2Vsc2VcbiAgdmVjNCBvdXRDb2xvciA9IFRFWFRVUkUoZW52aXJvbm1lbnRNYXBTcGVjdWxhciwgbmV3VGV4Q29vcik7XG4jZW5kaWZcbiAgLy8gdGhpcyBpcyB0byBtYWtlIHRoZSBkYXJrZXIgc2VjdGlvbnMgbW9yZSBkYXJrXG4gIC8vIHBuZyBhbmQganBnIHVzdWFsbHkgZmxhdHRlbiB0aGUgYnJpZ2h0bmVzcyBzbyBpdCBpcyB0byByZXZlcnNlIHRoYXRcbiAgcmV0dXJuIG1peChcbiAgICBwb3cob3V0Q29sb3IueHl6LCB2ZWMzKDEwKSksXG4gICAgcG93KG91dENvbG9yLnh5eiwgdmVjMygxLjIpKSxcbiAgICBtZXRhbGxpYyBcbiAgKTtcbn1cblxudm9pZCB0b3RhbExpZ2h0KFxuICB2ZWMzIG1vZGVsUG9zaXRpb24sXG4gIHZlYzMgbm9ybWFsLFxuICBvdXQgdmVjMyB0b3RhbERpZmZ1c2UsXG4gIG91dCB2ZWMzIHRvdGFsU3BlY3VsYXJcbikge1xuXG4gIHRvdGFsU3BlY3VsYXIgPSB2ZWMzKDAuMCk7XG5cbiAgaWYgKCF1VXNlTGlnaHRpbmcpIHtcbiAgICB0b3RhbERpZmZ1c2UgPSB2ZWMzKDEuMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdG90YWxEaWZmdXNlID0gdmVjMygwLjApO1xuXG4gIHZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbGl6ZSgtbW9kZWxQb3NpdGlvbik7XG5cbiAgZm9yIChpbnQgaiA9IDA7IGogPCA1OyBqKyspIHtcbiAgICBpZiAoaiA8IHVEaXJlY3Rpb25hbExpZ2h0Q291bnQpIHtcbiAgICAgIHZlYzMgbGlnaHRWZWN0b3IgPSAodVZpZXdNYXRyaXggKiB2ZWM0KHVMaWdodGluZ0RpcmVjdGlvbltqXSwgMC4wKSkueHl6O1xuICAgICAgdmVjMyBsaWdodENvbG9yID0gdURpcmVjdGlvbmFsRGlmZnVzZUNvbG9yc1tqXTtcbiAgICAgIHZlYzMgc3BlY3VsYXJDb2xvciA9IHVEaXJlY3Rpb25hbFNwZWN1bGFyQ29sb3JzW2pdO1xuICAgICAgTGlnaHRSZXN1bHQgcmVzdWx0ID0gX2xpZ2h0KHZpZXdEaXJlY3Rpb24sIG5vcm1hbCwgbGlnaHRWZWN0b3IpO1xuICAgICAgdG90YWxEaWZmdXNlICs9IHJlc3VsdC5kaWZmdXNlICogbGlnaHRDb2xvcjtcbiAgICAgIHRvdGFsU3BlY3VsYXIgKz0gcmVzdWx0LnNwZWN1bGFyICogbGlnaHRDb2xvciAqIHNwZWN1bGFyQ29sb3I7XG4gICAgfVxuXG4gICAgaWYgKGogPCB1UG9pbnRMaWdodENvdW50KSB7XG4gICAgICB2ZWMzIGxpZ2h0UG9zaXRpb24gPSAodVZpZXdNYXRyaXggKiB2ZWM0KHVQb2ludExpZ2h0TG9jYXRpb25bal0sIDEuMCkpLnh5ejtcbiAgICAgIHZlYzMgbGlnaHRWZWN0b3IgPSBtb2RlbFBvc2l0aW9uIC0gbGlnaHRQb3NpdGlvbjtcbiAgICAgIC8vY2FsY3VsYXRlIGF0dGVudWF0aW9uXG4gICAgICBmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKGxpZ2h0VmVjdG9yKTtcbiAgICAgIGZsb2F0IGxpZ2h0RmFsbG9mZiA9IDEuMCAvICh1Q29uc3RhbnRBdHRlbnVhdGlvbiArIGxpZ2h0RGlzdGFuY2UgKiB1TGluZWFyQXR0ZW51YXRpb24gKyAobGlnaHREaXN0YW5jZSAqIGxpZ2h0RGlzdGFuY2UpICogdVF1YWRyYXRpY0F0dGVudWF0aW9uKTtcbiAgICAgIHZlYzMgbGlnaHRDb2xvciA9IGxpZ2h0RmFsbG9mZiAqIHVQb2ludExpZ2h0RGlmZnVzZUNvbG9yc1tqXTtcbiAgICAgIHZlYzMgc3BlY3VsYXJDb2xvciA9IGxpZ2h0RmFsbG9mZiAqIHVQb2ludExpZ2h0U3BlY3VsYXJDb2xvcnNbal07XG5cbiAgICAgIExpZ2h0UmVzdWx0IHJlc3VsdCA9IF9saWdodCh2aWV3RGlyZWN0aW9uLCBub3JtYWwsIGxpZ2h0VmVjdG9yKTtcbiAgICAgIHRvdGFsRGlmZnVzZSArPSByZXN1bHQuZGlmZnVzZSAqIGxpZ2h0Q29sb3I7XG4gICAgICB0b3RhbFNwZWN1bGFyICs9IHJlc3VsdC5zcGVjdWxhciAqIGxpZ2h0Q29sb3IgKiBzcGVjdWxhckNvbG9yO1xuICAgIH1cblxuICAgIGlmKGogPCB1U3BvdExpZ2h0Q291bnQpIHtcbiAgICAgIHZlYzMgbGlnaHRQb3NpdGlvbiA9ICh1Vmlld01hdHJpeCAqIHZlYzQodVNwb3RMaWdodExvY2F0aW9uW2pdLCAxLjApKS54eXo7XG4gICAgICB2ZWMzIGxpZ2h0VmVjdG9yID0gbW9kZWxQb3NpdGlvbiAtIGxpZ2h0UG9zaXRpb247XG4gICAgXG4gICAgICBmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKGxpZ2h0VmVjdG9yKTtcbiAgICAgIGZsb2F0IGxpZ2h0RmFsbG9mZiA9IDEuMCAvICh1Q29uc3RhbnRBdHRlbnVhdGlvbiArIGxpZ2h0RGlzdGFuY2UgKiB1TGluZWFyQXR0ZW51YXRpb24gKyAobGlnaHREaXN0YW5jZSAqIGxpZ2h0RGlzdGFuY2UpICogdVF1YWRyYXRpY0F0dGVudWF0aW9uKTtcblxuICAgICAgdmVjMyBsaWdodERpcmVjdGlvbiA9ICh1Vmlld01hdHJpeCAqIHZlYzQodVNwb3RMaWdodERpcmVjdGlvbltqXSwgMC4wKSkueHl6O1xuICAgICAgZmxvYXQgc3BvdERvdCA9IGRvdChub3JtYWxpemUobGlnaHRWZWN0b3IpLCBub3JtYWxpemUobGlnaHREaXJlY3Rpb24pKTtcbiAgICAgIGZsb2F0IHNwb3RGYWxsb2ZmO1xuICAgICAgaWYoc3BvdERvdCA8IHVTcG90TGlnaHRBbmdsZVtqXSkge1xuICAgICAgICBzcG90RmFsbG9mZiA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzcG90RmFsbG9mZiA9IHBvdyhzcG90RG90LCB1U3BvdExpZ2h0Q29uY1tqXSk7XG4gICAgICB9XG4gICAgICBsaWdodEZhbGxvZmYgKj0gc3BvdEZhbGxvZmY7XG5cbiAgICAgIHZlYzMgbGlnaHRDb2xvciA9IHVTcG90TGlnaHREaWZmdXNlQ29sb3JzW2pdO1xuICAgICAgdmVjMyBzcGVjdWxhckNvbG9yID0gdVNwb3RMaWdodFNwZWN1bGFyQ29sb3JzW2pdO1xuICAgICBcbiAgICAgIExpZ2h0UmVzdWx0IHJlc3VsdCA9IF9saWdodCh2aWV3RGlyZWN0aW9uLCBub3JtYWwsIGxpZ2h0VmVjdG9yKTtcbiAgICAgIFxuICAgICAgdG90YWxEaWZmdXNlICs9IHJlc3VsdC5kaWZmdXNlICogbGlnaHRDb2xvciAqIGxpZ2h0RmFsbG9mZjtcbiAgICAgIHRvdGFsU3BlY3VsYXIgKz0gcmVzdWx0LnNwZWN1bGFyICogbGlnaHRDb2xvciAqIHNwZWN1bGFyQ29sb3IgKiBsaWdodEZhbGxvZmY7XG4gICAgfVxuICB9XG5cbiAgaWYoIHVVc2VJbWFnZUxpZ2h0ICl7XG4gICAgdG90YWxEaWZmdXNlICs9IGNhbGN1bGF0ZUltYWdlRGlmZnVzZShub3JtYWwsIG1vZGVsUG9zaXRpb24pO1xuICAgIHRvdGFsU3BlY3VsYXIgKz0gY2FsY3VsYXRlSW1hZ2VTcGVjdWxhcihub3JtYWwsIG1vZGVsUG9zaXRpb24pO1xuICB9XG5cbiAgdG90YWxEaWZmdXNlICo9IGRpZmZ1c2VGYWN0b3I7XG4gIHRvdGFsU3BlY3VsYXIgKj0gc3BlY3VsYXJGYWN0b3I7XG59XG5gKSwgUiA9IHsgc3BoZXJlTWFwcGluZ0ZyYWc6IGAjZGVmaW5lIFBJIDMuMTQxNTkyXG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gbWF0MyB1TmV3Tm9ybWFsTWF0cml4O1xudW5pZm9ybSBmbG9hdCB1Rm92WTtcbnVuaWZvcm0gZmxvYXQgdUFzcGVjdDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbiAgXG52b2lkIG1haW4oKSB7XG4gICAgZmxvYXQgdUZvdlggPSB1Rm92WSAqIHVBc3BlY3Q7IFxuICAgIHZlYzQgbmV3VGV4Q29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXhDb29yZCk7XG4gICAgZmxvYXQgYW5nbGVZID0gbWl4KHVGb3ZZLzIuMCwgIC11Rm92WS8yLjAsIHZUZXhDb29yZC55KTtcbiAgICBmbG9hdCBhbmdsZVggPSBtaXgodUZvdlgvMi4wLCAtdUZvdlgvMi4wLCB2VGV4Q29vcmQueCk7XG4gICAgdmVjMyByb3RhdGVkTm9ybWFsID0gdmVjMyggYW5nbGVYLCBhbmdsZVksIDEuMCApO1xuICAgIHJvdGF0ZWROb3JtYWwgPSB1TmV3Tm9ybWFsTWF0cml4ICogbm9ybWFsaXplKHJvdGF0ZWROb3JtYWwpO1xuICAgIHZlYzIgc3V2O1xuICAgIHN1di55ID0gMC41ICsgMC41ICogKC1yb3RhdGVkTm9ybWFsLnkpO1xuICAgIHN1di54ID0gYXRhbihyb3RhdGVkTm9ybWFsLnosIHJvdGF0ZWROb3JtYWwueCkgLyAoMi4wICogUEkpICsgMC41O1xuICAgIG5ld1RleENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBzdXYueHkpO1xuICAgIGdsX0ZyYWdDb2xvciA9IG5ld1RleENvbG9yO1xufVxuYCwgaW1tZWRpYXRlVmVydDogYElOIHZlYzMgYVBvc2l0aW9uO1xuSU4gdmVjNCBhVmVydGV4Q29sb3I7XG5cbnVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBmbG9hdCB1UmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdVBvaW50U2l6ZTtcblxuT1VUIHZlYzQgdkNvbG9yO1xudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCBwb3NpdGlvblZlYzQgPSB2ZWM0KGFQb3NpdGlvbiwgMS4wKTtcbiAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVNb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvblZlYzQ7XG4gIHZDb2xvciA9IGFWZXJ0ZXhDb2xvcjtcbiAgZ2xfUG9pbnRTaXplID0gdVBvaW50U2l6ZTtcbn1cbmAsIHZlcnRleENvbG9yVmVydDogYElOIHZlYzMgYVBvc2l0aW9uO1xuSU4gdmVjNCBhVmVydGV4Q29sb3I7XG5cbnVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuXG5PVVQgdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzQgcG9zaXRpb25WZWM0ID0gdmVjNChhUG9zaXRpb24sIDEuMCk7XG4gIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1TW9kZWxWaWV3TWF0cml4ICogcG9zaXRpb25WZWM0O1xuICB2Q29sb3IgPSBhVmVydGV4Q29sb3I7XG59XG5gLCB2ZXJ0ZXhDb2xvckZyYWc6IGBJTiB2ZWM0IHZDb2xvcjtcbnZvaWQgbWFpbih2b2lkKSB7XG4gIE9VVF9DT0xPUiA9IHZlYzQodkNvbG9yLnJnYiwgMS4pICogdkNvbG9yLmE7XG59XG5gLCBub3JtYWxWZXJ0OiBgSU4gdmVjMyBhUG9zaXRpb247XG5JTiB2ZWMzIGFOb3JtYWw7XG5JTiB2ZWMyIGFUZXhDb29yZDtcbklOIHZlYzQgYVZlcnRleENvbG9yO1xuXG51bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB1Tm9ybWFsTWF0cml4O1xuXG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG51bmlmb3JtIGJvb2wgdVVzZVZlcnRleENvbG9yO1xuXG5PVVQgdmVjMyB2VmVydGV4Tm9ybWFsO1xuT1VUIGhpZ2hwIHZlYzIgdlZlcnRUZXhDb29yZDtcbk9VVCB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCBwb3NpdGlvblZlYzQgPSB2ZWM0KGFQb3NpdGlvbiwgMS4wKTtcbiAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVNb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvblZlYzQ7XG4gIHZWZXJ0ZXhOb3JtYWwgPSBub3JtYWxpemUodmVjMyggdU5vcm1hbE1hdHJpeCAqIGFOb3JtYWwgKSk7XG4gIHZWZXJ0VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG4gIHZDb2xvciA9ICh1VXNlVmVydGV4Q29sb3IgPyBhVmVydGV4Q29sb3IgOiB1TWF0ZXJpYWxDb2xvcik7XG59XG5gLCBub3JtYWxGcmFnOiBgSU4gdmVjMyB2VmVydGV4Tm9ybWFsO1xudm9pZCBtYWluKHZvaWQpIHtcbiAgT1VUX0NPTE9SID0gdmVjNCh2VmVydGV4Tm9ybWFsLCAxLjApO1xufVxuYCwgYmFzaWNGcmFnOiBgSU4gdmVjNCB2Q29sb3I7XG52b2lkIG1haW4odm9pZCkge1xuICBPVVRfQ09MT1IgPSB2ZWM0KHZDb2xvci5yZ2IsIDEuKSAqIHZDb2xvci5hO1xufVxuYCwgbGlnaHRWZXJ0OiBNICsgYC8vIGluY2x1ZGUgbGlnaHRpbmcuZ2xnbFxuXG5JTiB2ZWMzIGFQb3NpdGlvbjtcbklOIHZlYzMgYU5vcm1hbDtcbklOIHZlYzIgYVRleENvb3JkO1xuSU4gdmVjNCBhVmVydGV4Q29sb3I7XG5cbnVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XG5cbnVuaWZvcm0gYm9vbCB1VXNlVmVydGV4Q29sb3I7XG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG5cbk9VVCBoaWdocCB2ZWMyIHZWZXJ0VGV4Q29vcmQ7XG5PVVQgdmVjMyB2RGlmZnVzZUNvbG9yO1xuT1VUIHZlYzMgdlNwZWN1bGFyQ29sb3I7XG5PVVQgdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgdmVjNCB2aWV3TW9kZWxQb3NpdGlvbiA9IHVNb2RlbFZpZXdNYXRyaXggKiB2ZWM0KGFQb3NpdGlvbiwgMS4wKTtcbiAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNb2RlbFBvc2l0aW9uO1xuXG4gIHZlYzMgdmVydGV4Tm9ybWFsID0gbm9ybWFsaXplKHVOb3JtYWxNYXRyaXggKiBhTm9ybWFsKTtcbiAgdlZlcnRUZXhDb29yZCA9IGFUZXhDb29yZDtcblxuICB0b3RhbExpZ2h0KHZpZXdNb2RlbFBvc2l0aW9uLnh5eiwgdmVydGV4Tm9ybWFsLCB2RGlmZnVzZUNvbG9yLCB2U3BlY3VsYXJDb2xvcik7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBpZiAoaSA8IHVBbWJpZW50TGlnaHRDb3VudCkge1xuICAgICAgdkRpZmZ1c2VDb2xvciArPSB1QW1iaWVudENvbG9yW2ldO1xuICAgIH1cbiAgfVxuICBcbiAgdkNvbG9yID0gKHVVc2VWZXJ0ZXhDb2xvciA/IGFWZXJ0ZXhDb2xvciA6IHVNYXRlcmlhbENvbG9yKTtcbn1cbmAsIGxpZ2h0VGV4dHVyZUZyYWc6IGB1bmlmb3JtIHZlYzQgdVRpbnQ7XG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gYm9vbCBpc1RleHR1cmU7XG51bmlmb3JtIGJvb2wgdUVtaXNzaXZlO1xuXG5JTiBoaWdocCB2ZWMyIHZWZXJ0VGV4Q29vcmQ7XG5JTiB2ZWMzIHZEaWZmdXNlQ29sb3I7XG5JTiB2ZWMzIHZTcGVjdWxhckNvbG9yO1xuSU4gdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGlmKHVFbWlzc2l2ZSAmJiAhaXNUZXh0dXJlKSB7XG4gICAgT1VUX0NPTE9SID0gdkNvbG9yO1xuICB9XG4gIGVsc2Uge1xuICAgIHZlYzQgYmFzZUNvbG9yID0gaXNUZXh0dXJlXG4gICAgICAvLyBUZXh0dXJlcyBjb21lIGluIHdpdGggcHJlbXVsdGlwbGllZCBhbHBoYS4gVG8gYXBwbHkgdGludCBhbmQgc3RpbGwgaGF2ZVxuICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYSBvdXRwdXQsIHdlIG5lZWQgdG8gbXVsdGlwbHkgdGhlIFJHQiBjaGFubmVscyBieSB0aGVcbiAgICAgIC8vIHRpbnQgUkdCLCBhbmQgYWxsIGNoYW5uZWxzIGJ5IHRoZSB0aW50IGFscGhhLlxuICAgICAgPyBURVhUVVJFKHVTYW1wbGVyLCB2VmVydFRleENvb3JkKSAqIHZlYzQodVRpbnQucmdiLzI1NS4sIDEuKSAqICh1VGludC5hLzI1NS4pXG4gICAgICAvLyBDb2xvcnMgY29tZSBpbiB3aXRoIHVubXVsdGlwbGllZCBhbHBoYSwgc28gd2UgbmVlZCB0byBtdWx0aXBseSB0aGUgUkdCXG4gICAgICAvLyBjaGFubmVscyBieSBhbHBoYSB0byBjb252ZXJ0IGl0IHRvIHByZW11bHRpcGxpZWQgYWxwaGEuXG4gICAgICA6IHZlYzQodkNvbG9yLnJnYiAqIHZDb2xvci5hLCB2Q29sb3IuYSk7XG4gICAgT1VUX0NPTE9SID0gdmVjNChiYXNlQ29sb3IucmdiICogdkRpZmZ1c2VDb2xvciArIHZTcGVjdWxhckNvbG9yLCBiYXNlQ29sb3IuYSk7XG4gIH1cbn1cbmAsIHBob25nVmVydDogYHByZWNpc2lvbiBoaWdocCBpbnQ7XG5cbklOIHZlYzMgYVBvc2l0aW9uO1xuSU4gdmVjMyBhTm9ybWFsO1xuSU4gdmVjMiBhVGV4Q29vcmQ7XG5JTiB2ZWM0IGFWZXJ0ZXhDb2xvcjtcblxudW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3JbNV07XG5cbnVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XG51bmlmb3JtIGludCB1QW1iaWVudExpZ2h0Q291bnQ7XG5cbnVuaWZvcm0gYm9vbCB1VXNlVmVydGV4Q29sb3I7XG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG5cbk9VVCB2ZWMzIHZOb3JtYWw7XG5PVVQgdmVjMiB2VGV4Q29vcmQ7XG5PVVQgdmVjMyB2Vmlld1Bvc2l0aW9uO1xuT1VUIHZlYzMgdkFtYmllbnRDb2xvcjtcbk9VVCB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICB2ZWM0IHZpZXdNb2RlbFBvc2l0aW9uID0gdU1vZGVsVmlld01hdHJpeCAqIHZlYzQoYVBvc2l0aW9uLCAxLjApO1xuXG4gIC8vIFBhc3MgdmFyeWluZ3MgdG8gZnJhZ21lbnQgc2hhZGVyXG4gIHZWaWV3UG9zaXRpb24gPSB2aWV3TW9kZWxQb3NpdGlvbi54eXo7XG4gIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2aWV3TW9kZWxQb3NpdGlvbjsgIFxuXG4gIHZOb3JtYWwgPSB1Tm9ybWFsTWF0cml4ICogYU5vcm1hbDtcbiAgdlRleENvb3JkID0gYVRleENvb3JkO1xuXG4gIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGEgdW5pZm9ybVxuICB2QW1iaWVudENvbG9yID0gdmVjMygwLjApO1xuICBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIGlmIChpIDwgdUFtYmllbnRMaWdodENvdW50KSB7XG4gICAgICB2QW1iaWVudENvbG9yICs9IHVBbWJpZW50Q29sb3JbaV07XG4gICAgfVxuICB9XG4gIFxuICB2Q29sb3IgPSAodVVzZVZlcnRleENvbG9yID8gYVZlcnRleENvbG9yIDogdU1hdGVyaWFsQ29sb3IpO1xufVxuYCwgcGhvbmdGcmFnOiBNICsgYC8vIGluY2x1ZGUgbGlnaHRpbmcuZ2xzbFxucHJlY2lzaW9uIGhpZ2hwIGludDtcblxudW5pZm9ybSBib29sIHVIYXNTZXRBbWJpZW50O1xudW5pZm9ybSB2ZWM0IHVTcGVjdWxhck1hdENvbG9yO1xudW5pZm9ybSB2ZWM0IHVBbWJpZW50TWF0Q29sb3I7XG51bmlmb3JtIHZlYzQgdUVtaXNzaXZlTWF0Q29sb3I7XG5cbnVuaWZvcm0gdmVjNCB1VGludDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBib29sIGlzVGV4dHVyZTtcblxuSU4gdmVjMyB2Tm9ybWFsO1xuSU4gdmVjMiB2VGV4Q29vcmQ7XG5JTiB2ZWMzIHZWaWV3UG9zaXRpb247XG5JTiB2ZWMzIHZBbWJpZW50Q29sb3I7XG5JTiB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICB2ZWMzIGRpZmZ1c2U7XG4gIHZlYzMgc3BlY3VsYXI7XG4gIHRvdGFsTGlnaHQodlZpZXdQb3NpdGlvbiwgbm9ybWFsaXplKHZOb3JtYWwpLCBkaWZmdXNlLCBzcGVjdWxhcik7XG5cbiAgLy8gQ2FsY3VsYXRpbmcgZmluYWwgY29sb3IgYXMgcmVzdWx0IG9mIGFsbCBsaWdodHMgKHBsdXMgZW1pc3NpdmUgdGVybSkuXG5cbiAgdmVjNCBiYXNlQ29sb3IgPSBpc1RleHR1cmVcbiAgICAvLyBUZXh0dXJlcyBjb21lIGluIHdpdGggcHJlbXVsdGlwbGllZCBhbHBoYS4gVG8gYXBwbHkgdGludCBhbmQgc3RpbGwgaGF2ZVxuICAgIC8vIHByZW11bHRpcGxpZWQgYWxwaGEgb3V0cHV0LCB3ZSBuZWVkIHRvIG11bHRpcGx5IHRoZSBSR0IgY2hhbm5lbHMgYnkgdGhlXG4gICAgLy8gdGludCBSR0IsIGFuZCBhbGwgY2hhbm5lbHMgYnkgdGhlIHRpbnQgYWxwaGEuXG4gICAgPyBURVhUVVJFKHVTYW1wbGVyLCB2VGV4Q29vcmQpICogdmVjNCh1VGludC5yZ2IvMjU1LiwgMS4pICogKHVUaW50LmEvMjU1LilcbiAgICAvLyBDb2xvcnMgY29tZSBpbiB3aXRoIHVubXVsdGlwbGllZCBhbHBoYSwgc28gd2UgbmVlZCB0byBtdWx0aXBseSB0aGUgUkdCXG4gICAgLy8gY2hhbm5lbHMgYnkgYWxwaGEgdG8gY29udmVydCBpdCB0byBwcmVtdWx0aXBsaWVkIGFscGhhLlxuICAgIDogdmVjNCh2Q29sb3IucmdiICogdkNvbG9yLmEsIHZDb2xvci5hKTtcbiAgT1VUX0NPTE9SID0gdmVjNChkaWZmdXNlICogYmFzZUNvbG9yLnJnYiArIFxuICAgICAgICAgICAgICAgICAgICB2QW1iaWVudENvbG9yICogKFxuICAgICAgICAgICAgICAgICAgICAgIHVIYXNTZXRBbWJpZW50ID8gdUFtYmllbnRNYXRDb2xvci5yZ2IgOiBiYXNlQ29sb3IucmdiXG4gICAgICAgICAgICAgICAgICAgICkgKyBcbiAgICAgICAgICAgICAgICAgICAgc3BlY3VsYXIgKiB1U3BlY3VsYXJNYXRDb2xvci5yZ2IgKyBcbiAgICAgICAgICAgICAgICAgICAgdUVtaXNzaXZlTWF0Q29sb3IucmdiLCBiYXNlQ29sb3IuYSk7XG59XG5gLCBmb250VmVydDogYElOIHZlYzMgYVBvc2l0aW9uO1xuSU4gdmVjMiBhVGV4Q29vcmQ7XG51bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcblxudW5pZm9ybSB2ZWM0IHVHbHlwaFJlY3Q7XG51bmlmb3JtIGZsb2F0IHVHbHlwaE9mZnNldDtcblxuT1VUIHZlYzIgdlRleENvb3JkO1xuT1VUIGZsb2F0IHc7XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjNCBwb3NpdGlvblZlYzQgPSB2ZWM0KGFQb3NpdGlvbiwgMS4wKTtcblxuICAvLyBzY2FsZSBieSB0aGUgc2l6ZSBvZiB0aGUgZ2x5cGgncyByZWN0YW5nbGVcbiAgcG9zaXRpb25WZWM0Lnh5ICo9IHVHbHlwaFJlY3QuencgLSB1R2x5cGhSZWN0Lnh5O1xuXG4gIC8vIEV4cGFuZCBnbHlwaCBib3VuZGluZyBib3hlcyBieSAxcHggb24gZWFjaCBzaWRlIHRvIGdpdmUgYSBiaXQgb2Ygcm9vbVxuICAvLyBmb3IgYW50aWFsaWFzaW5nXG4gIHZlYzMgbmV3T3JpZ2luID0gKHVNb2RlbFZpZXdNYXRyaXggKiB2ZWM0KDAuLCAwLiwgMC4sIDEuKSkueHl6O1xuICB2ZWMzIG5ld0RYID0gKHVNb2RlbFZpZXdNYXRyaXggKiB2ZWM0KDEuLCAwLiwgMC4sIDEuKSkueHl6O1xuICB2ZWMzIG5ld0RZID0gKHVNb2RlbFZpZXdNYXRyaXggKiB2ZWM0KDAuLCAxLiwgMC4sIDEuKSkueHl6O1xuICB2ZWMyIHBpeGVsU2NhbGUgPSB2ZWMyKFxuICAgIDEuIC8gbGVuZ3RoKG5ld09yaWdpbiAtIG5ld0RYKSxcbiAgICAxLiAvIGxlbmd0aChuZXdPcmlnaW4gLSBuZXdEWSlcbiAgKTtcbiAgdmVjMiBvZmZzZXQgPSBwaXhlbFNjYWxlICogbm9ybWFsaXplKGFUZXhDb29yZCAtIHZlYzIoMC41LCAwLjUpKSAqIHZlYzIoMS4sIC0xLik7XG4gIHZlYzIgdGV4dHVyZU9mZnNldCA9IG9mZnNldCAqICgxLiAvIHZlYzIoXG4gICAgdUdseXBoUmVjdC56IC0gdUdseXBoUmVjdC54LFxuICAgIHVHbHlwaFJlY3QudyAtIHVHbHlwaFJlY3QueVxuICApKTtcblxuICAvLyBtb3ZlIHRvIHRoZSBjb3JuZXIgb2YgdGhlIGdseXBoXG4gIHBvc2l0aW9uVmVjNC54eSArPSB1R2x5cGhSZWN0Lnh5O1xuXG4gIC8vIG1vdmUgdG8gdGhlIGxldHRlcidzIGxpbmUgb2Zmc2V0XG4gIHBvc2l0aW9uVmVjNC54ICs9IHVHbHlwaE9mZnNldDtcblxuICBwb3NpdGlvblZlYzQueHkgKz0gb2Zmc2V0O1xuICBcbiAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVNb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvblZlYzQ7XG4gIHZUZXhDb29yZCA9IGFUZXhDb29yZCArIHRleHR1cmVPZmZzZXQ7XG4gIHcgPSBnbF9Qb3NpdGlvbi53O1xufVxuYCwgZm9udEZyYWc6IGAjaWZuZGVmIFdFQkdMMlxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcbiNlbmRpZlxuXG4jaWYgMFxuICAvLyBzaW11bGF0ZSBpbnRlZ2VyIG1hdGggdXNpbmcgZmxvYXRzXG5cdCNkZWZpbmUgaW50IGZsb2F0XG5cdCNkZWZpbmUgaXZlYzIgdmVjMlxuXHQjZGVmaW5lIElOVCh4KSBmbG9hdCh4KVxuXG5cdGludCBpZmxvb3IoZmxvYXQgdikgeyByZXR1cm4gZmxvb3Iodik7IH1cblx0aXZlYzIgaWZsb29yKHZlYzIgdikgeyByZXR1cm4gZmxvb3Iodik7IH1cblxuI2Vsc2VcbiAgLy8gdXNlIG5hdGl2ZSBpbnRlZ2VyIG1hdGhcblx0cHJlY2lzaW9uIGhpZ2hwIGludDtcblx0I2RlZmluZSBJTlQoeCkgeFxuXG5cdGludCBpZmxvb3IoZmxvYXQgdikgeyByZXR1cm4gaW50KHYpOyB9XG5cdGludCBpZmxvb3IoaW50IHYpIHsgcmV0dXJuIHY7IH1cblx0aXZlYzIgaWZsb29yKHZlYzIgdikgeyByZXR1cm4gaXZlYzIodik7IH1cblxuI2VuZGlmXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyU3Ryb2tlcztcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyUm93U3Ryb2tlcztcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyUm93cztcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyQ29sU3Ryb2tlcztcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyQ29scztcblxudW5pZm9ybSBpdmVjMiB1U3Ryb2tlSW1hZ2VTaXplO1xudW5pZm9ybSBpdmVjMiB1Q2VsbHNJbWFnZVNpemU7XG51bmlmb3JtIGl2ZWMyIHVHcmlkSW1hZ2VTaXplO1xuXG51bmlmb3JtIGl2ZWMyIHVHcmlkT2Zmc2V0O1xudW5pZm9ybSBpdmVjMiB1R3JpZFNpemU7XG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG5cbklOIHZlYzIgdlRleENvb3JkO1xuXG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnNcbmludCBST1VORChmbG9hdCB2KSB7IHJldHVybiBpZmxvb3IodiArIDAuNSk7IH1cbml2ZWMyIFJPVU5EKHZlYzIgdikgeyByZXR1cm4gaWZsb29yKHYgKyAwLjUpOyB9XG5mbG9hdCBzYXR1cmF0ZShmbG9hdCB2KSB7IHJldHVybiBjbGFtcCh2LCAwLjAsIDEuMCk7IH1cbnZlYzIgc2F0dXJhdGUodmVjMiB2KSB7IHJldHVybiBjbGFtcCh2LCAwLjAsIDEuMCk7IH1cblxuaW50IG11bChmbG9hdCB2MSwgaW50IHYyKSB7XG4gIHJldHVybiBpZmxvb3IodjEgKiBmbG9hdCh2MikpO1xufVxuXG5pdmVjMiBtdWwodmVjMiB2MSwgaXZlYzIgdjIpIHtcbiAgcmV0dXJuIGlmbG9vcih2MSAqIHZlYzIodjIpICsgMC41KTtcbn1cblxuLy8gdW5wYWNrIGEgMTYtYml0IGludGVnZXIgZnJvbSBhIGZsb2F0IHZlYzJcbmludCBnZXRJbnQxNih2ZWMyIHYpIHtcbiAgaXZlYzIgaXYgPSBST1VORCh2ICogMjU1LjApO1xuICByZXR1cm4gaXYueCAqIElOVCgxMjgpICsgaXYueTtcbn1cblxudmVjMiBwaXhlbFNjYWxlO1xudmVjMiBjb3ZlcmFnZSA9IHZlYzIoMC4wKTtcbnZlYzIgd2VpZ2h0ID0gdmVjMigwLjUpO1xuY29uc3QgZmxvYXQgbWluRGlzdGFuY2UgPSAxLjAvODE5Mi4wO1xuY29uc3QgZmxvYXQgaGFyZG5lc3MgPSAxLjA1OyAvLyBhbW91bnQgb2YgYW50aWFsaWFzXG5cbi8vIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZXMgaW4gYSBnbHlwaFxuY29uc3QgaW50IE4gPSBJTlQoMjUwKTtcblxuLy8gcmV0cmlldmVzIGFuIGluZGV4ZWQgcGl4ZWwgZnJvbSBhIHNhbXBsZXJcbnZlYzQgZ2V0VGV4ZWwoc2FtcGxlcjJEIHNhbXBsZXIsIGludCBwb3MsIGl2ZWMyIHNpemUpIHtcbiAgaW50IHdpZHRoID0gc2l6ZS54O1xuICBpbnQgeSA9IGlmbG9vcihwb3MgLyB3aWR0aCk7XG4gIGludCB4ID0gcG9zIC0geSAqIHdpZHRoOyAgLy8gcG9zICUgd2lkdGhcblxuICByZXR1cm4gVEVYVFVSRShzYW1wbGVyLCAodmVjMih4LCB5KSArIDAuNSkgLyB2ZWMyKHNpemUpKTtcbn1cblxudm9pZCBjYWx1bGF0ZUNyb3NzaW5ncyh2ZWMyIHAwLCB2ZWMyIHAxLCB2ZWMyIHAyLCBvdXQgdmVjMiBDMSwgb3V0IHZlYzIgQzIpIHtcblxuICAvLyBnZXQgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcXVhZHJhdGljIGluIHRcbiAgdmVjMiBhID0gcDAgLSBwMSAqIDIuMCArIHAyO1xuICB2ZWMyIGIgPSBwMCAtIHAxO1xuICB2ZWMyIGMgPSBwMCAtIHZUZXhDb29yZDtcblxuICAvLyBmb3VuZCBvdXQgd2hpY2ggdmFsdWVzIG9mICd0JyBpdCBjcm9zc2VzIHRoZSBheGVzXG4gIHZlYzIgc3VyZCA9IHNxcnQobWF4KHZlYzIoMC4wKSwgYiAqIGIgLSBhICogYykpO1xuICB2ZWMyIHQxID0gKChiIC0gc3VyZCkgLyBhKS55eDtcbiAgdmVjMiB0MiA9ICgoYiArIHN1cmQpIC8gYSkueXg7XG5cbiAgLy8gYXBwcm94aW1hdGUgc3RyYWlnaHQgbGluZXMgdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzXG4gIGlmIChhYnMoYS55KSA8IDAuMDAxKVxuICAgIHQxLnggPSB0Mi54ID0gYy55IC8gKDIuMCAqIGIueSk7XG5cbiAgaWYgKGFicyhhLngpIDwgMC4wMDEpXG4gICAgdDEueSA9IHQyLnkgPSBjLnggLyAoMi4wICogYi54KTtcblxuICAvLyBwbHVnIGludG8gcXVhZHJhdGljIGZvcm11bGEgdG8gZmluZCB0aGUgY29ycmRpbmF0ZXMgb2YgdGhlIGNyb3NzaW5nc1xuICBDMSA9ICgoYSAqIHQxIC0gYiAqIDIuMCkgKiB0MSArIGMpICogcGl4ZWxTY2FsZTtcbiAgQzIgPSAoKGEgKiB0MiAtIGIgKiAyLjApICogdDIgKyBjKSAqIHBpeGVsU2NhbGU7XG59XG5cbnZvaWQgY292ZXJhZ2VYKHZlYzIgcDAsIHZlYzIgcDEsIHZlYzIgcDIpIHtcblxuICB2ZWMyIEMxLCBDMjtcbiAgY2FsdWxhdGVDcm9zc2luZ3MocDAsIHAxLCBwMiwgQzEsIEMyKTtcblxuICAvLyBkZXRlcm1pbmUgb24gd2hpY2ggc2lkZSBvZiB0aGUgeC1heGlzIHRoZSBwb2ludHMgbGllXG4gIGJvb2wgeTAgPSBwMC55ID4gdlRleENvb3JkLnk7XG4gIGJvb2wgeTEgPSBwMS55ID4gdlRleENvb3JkLnk7XG4gIGJvb2wgeTIgPSBwMi55ID4gdlRleENvb3JkLnk7XG5cbiAgLy8gY291bGQgd2ViIGJlIHVuZGVyIHRoZSBjdXJ2ZSAoYWZ0ZXIgdDEpP1xuICBpZiAoeTEgPyAheTIgOiB5MCkge1xuICAgIC8vIGFkZCB0aGUgY292ZXJhZ2UgZm9yIHQxXG4gICAgY292ZXJhZ2UueCArPSBzYXR1cmF0ZShDMS54ICsgMC41KTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGFudGktYWxpYXNpbmcgZm9yIHQxXG4gICAgd2VpZ2h0LnggPSBtaW4od2VpZ2h0LngsIGFicyhDMS54KSk7XG4gIH1cblxuICAvLyBhcmUgd2Ugb3V0c2lkZSB0aGUgY3VydmUgKGFmdGVyIHQyKT9cbiAgaWYgKHkxID8gIXkwIDogeTIpIHtcbiAgICAvLyBzdWJ0cmFjdCB0aGUgY292ZXJhZ2UgZm9yIHQyXG4gICAgY292ZXJhZ2UueCAtPSBzYXR1cmF0ZShDMi54ICsgMC41KTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGFudGktYWxpYXNpbmcgZm9yIHQyXG4gICAgd2VpZ2h0LnggPSBtaW4od2VpZ2h0LngsIGFicyhDMi54KSk7XG4gIH1cbn1cblxuLy8gdGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyBjb3ZlcmFnZVgsIGJ1dCB3aXRoIHRoZSBheGVzIHN3YXBwZWRcbnZvaWQgY292ZXJhZ2VZKHZlYzIgcDAsIHZlYzIgcDEsIHZlYzIgcDIpIHtcblxuICB2ZWMyIEMxLCBDMjtcbiAgY2FsdWxhdGVDcm9zc2luZ3MocDAsIHAxLCBwMiwgQzEsIEMyKTtcblxuICBib29sIHgwID0gcDAueCA+IHZUZXhDb29yZC54O1xuICBib29sIHgxID0gcDEueCA+IHZUZXhDb29yZC54O1xuICBib29sIHgyID0gcDIueCA+IHZUZXhDb29yZC54O1xuXG4gIGlmICh4MSA/ICF4MiA6IHgwKSB7XG4gICAgY292ZXJhZ2UueSAtPSBzYXR1cmF0ZShDMS55ICsgMC41KTtcbiAgICB3ZWlnaHQueSA9IG1pbih3ZWlnaHQueSwgYWJzKEMxLnkpKTtcbiAgfVxuXG4gIGlmICh4MSA/ICF4MCA6IHgyKSB7XG4gICAgY292ZXJhZ2UueSArPSBzYXR1cmF0ZShDMi55ICsgMC41KTtcbiAgICB3ZWlnaHQueSA9IG1pbih3ZWlnaHQueSwgYWJzKEMyLnkpKTtcbiAgfVxufVxuXG52b2lkIG1haW4oKSB7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBwaXhlbCBzY2FsZSBiYXNlZCBvbiBzY3JlZW4tY29vcmRpbmF0ZXNcbiAgcGl4ZWxTY2FsZSA9IGhhcmRuZXNzIC8gZndpZHRoKHZUZXhDb29yZCk7XG5cbiAgLy8gd2hpY2ggZ3JpZCBjZWxsIGlzIHRoaXMgcGl4ZWwgaW4/XG4gIGl2ZWMyIGdyaWRDb29yZCA9IGlmbG9vcih2VGV4Q29vcmQgKiB2ZWMyKHVHcmlkU2l6ZSkpO1xuXG4gIC8vIGludGVyc2VjdCBjdXJ2ZXMgaW4gdGhpcyByb3dcbiAge1xuICAgIC8vIHRoZSBpbmRleCBpbnRvIHRoZSByb3cgaW5mbyBiaXRtYXBcbiAgICBpbnQgcm93SW5kZXggPSBncmlkQ29vcmQueSArIHVHcmlkT2Zmc2V0Lnk7XG4gICAgLy8gZmV0Y2ggdGhlIGluZm8gdGV4ZWxcbiAgICB2ZWM0IHJvd0luZm8gPSBnZXRUZXhlbCh1U2FtcGxlclJvd3MsIHJvd0luZGV4LCB1R3JpZEltYWdlU2l6ZSk7XG4gICAgLy8gdW5wYWNrIHRoZSByb3dJbmZvXG4gICAgaW50IHJvd1N0cm9rZUluZGV4ID0gZ2V0SW50MTYocm93SW5mby54eSk7XG4gICAgaW50IHJvd1N0cm9rZUNvdW50ID0gZ2V0SW50MTYocm93SW5mby56dyk7XG5cbiAgICBmb3IgKGludCBpUm93U3Ryb2tlID0gSU5UKDApOyBpUm93U3Ryb2tlIDwgTjsgaVJvd1N0cm9rZSsrKSB7XG4gICAgICBpZiAoaVJvd1N0cm9rZSA+PSByb3dTdHJva2VDb3VudClcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIGVhY2ggc3Ryb2tlIGlzIG1hZGUgdXAgb2YgMyBwb2ludHM6IHRoZSBzdGFydCBhbmQgY29udHJvbCBwb2ludFxuICAgICAgLy8gYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjdXJ2ZS5cbiAgICAgIC8vIGZldGNoIHRoZSBpbmRpY2VzIG9mIHRoaXMgcGFpciBvZiBzdHJva2VzOlxuICAgICAgdmVjNCBzdHJva2VJbmRpY2VzID0gZ2V0VGV4ZWwodVNhbXBsZXJSb3dTdHJva2VzLCByb3dTdHJva2VJbmRleCsrLCB1Q2VsbHNJbWFnZVNpemUpO1xuXG4gICAgICAvLyB1bnBhY2sgdGhlIHN0cm9rZSBpbmRleFxuICAgICAgaW50IHN0cm9rZVBvcyA9IGdldEludDE2KHN0cm9rZUluZGljZXMueHkpO1xuXG4gICAgICAvLyBmZXRjaCB0aGUgdHdvIHN0cm9rZXNcbiAgICAgIHZlYzQgc3Ryb2tlMCA9IGdldFRleGVsKHVTYW1wbGVyU3Ryb2tlcywgc3Ryb2tlUG9zICsgSU5UKDApLCB1U3Ryb2tlSW1hZ2VTaXplKTtcbiAgICAgIHZlYzQgc3Ryb2tlMSA9IGdldFRleGVsKHVTYW1wbGVyU3Ryb2tlcywgc3Ryb2tlUG9zICsgSU5UKDEpLCB1U3Ryb2tlSW1hZ2VTaXplKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb3ZlcmFnZVxuICAgICAgY292ZXJhZ2VYKHN0cm9rZTAueHksIHN0cm9rZTAuencsIHN0cm9rZTEueHkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGludGVyc2VjdCBjdXJ2ZXMgaW4gdGhpcyBjb2x1bW5cbiAge1xuICAgIGludCBjb2xJbmRleCA9IGdyaWRDb29yZC54ICsgdUdyaWRPZmZzZXQueDtcbiAgICB2ZWM0IGNvbEluZm8gPSBnZXRUZXhlbCh1U2FtcGxlckNvbHMsIGNvbEluZGV4LCB1R3JpZEltYWdlU2l6ZSk7XG4gICAgaW50IGNvbFN0cm9rZUluZGV4ID0gZ2V0SW50MTYoY29sSW5mby54eSk7XG4gICAgaW50IGNvbFN0cm9rZUNvdW50ID0gZ2V0SW50MTYoY29sSW5mby56dyk7XG4gICAgXG4gICAgZm9yIChpbnQgaUNvbFN0cm9rZSA9IElOVCgwKTsgaUNvbFN0cm9rZSA8IE47IGlDb2xTdHJva2UrKykge1xuICAgICAgaWYgKGlDb2xTdHJva2UgPj0gY29sU3Ryb2tlQ291bnQpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICB2ZWM0IHN0cm9rZUluZGljZXMgPSBnZXRUZXhlbCh1U2FtcGxlckNvbFN0cm9rZXMsIGNvbFN0cm9rZUluZGV4KyssIHVDZWxsc0ltYWdlU2l6ZSk7XG5cbiAgICAgIGludCBzdHJva2VQb3MgPSBnZXRJbnQxNihzdHJva2VJbmRpY2VzLnh5KTtcbiAgICAgIHZlYzQgc3Ryb2tlMCA9IGdldFRleGVsKHVTYW1wbGVyU3Ryb2tlcywgc3Ryb2tlUG9zICsgSU5UKDApLCB1U3Ryb2tlSW1hZ2VTaXplKTtcbiAgICAgIHZlYzQgc3Ryb2tlMSA9IGdldFRleGVsKHVTYW1wbGVyU3Ryb2tlcywgc3Ryb2tlUG9zICsgSU5UKDEpLCB1U3Ryb2tlSW1hZ2VTaXplKTtcbiAgICAgIGNvdmVyYWdlWShzdHJva2UwLnh5LCBzdHJva2UwLnp3LCBzdHJva2UxLnh5KTtcbiAgICB9XG4gIH1cblxuICB3ZWlnaHQgPSBzYXR1cmF0ZSgxLjAgLSB3ZWlnaHQgKiAyLjApO1xuICBmbG9hdCBkaXN0YW5jZSA9IG1heCh3ZWlnaHQueCArIHdlaWdodC55LCBtaW5EaXN0YW5jZSk7IC8vIG1hbmhhdHRhbiBhcHByb3guXG4gIGZsb2F0IGFudGlhbGlhcyA9IGFicyhkb3QoY292ZXJhZ2UsIHdlaWdodCkgLyBkaXN0YW5jZSk7XG4gIGZsb2F0IGNvdmVyID0gbWluKGFicyhjb3ZlcmFnZS54KSwgYWJzKGNvdmVyYWdlLnkpKTtcbiAgT1VUX0NPTE9SID0gdmVjNCh1TWF0ZXJpYWxDb2xvci5yZ2IsIDEuKSAqIHVNYXRlcmlhbENvbG9yLmE7XG4gIE9VVF9DT0xPUiAqPSBzYXR1cmF0ZShtYXgoYW50aWFsaWFzLCBjb3ZlcikpO1xufVxuYCwgbGluZVZlcnQ6IFAgKyBgLypcbiAgUGFydCBvZiB0aGUgUHJvY2Vzc2luZyBwcm9qZWN0IC0gaHR0cDovL3Byb2Nlc3Npbmcub3JnXG4gIENvcHlyaWdodCAoYykgMjAxMi0xNSBUaGUgUHJvY2Vzc2luZyBGb3VuZGF0aW9uXG4gIENvcHlyaWdodCAoYykgMjAwNC0xMiBCZW4gRnJ5IGFuZCBDYXNleSBSZWFzXG4gIENvcHlyaWdodCAoYykgMjAwMS0wNCBNYXNzYWNodXNldHRzIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5XG4gIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDIuMS5cbiAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbFxuICBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGVcbiAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UsIFN1aXRlIDMzMCxcbiAgQm9zdG9uLCBNQSAgMDIxMTEtMTMwNyAgVVNBXG4qL1xuXG4jZGVmaW5lIFBST0NFU1NJTkdfTElORV9TSEFERVJcblxucHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG51bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gZmxvYXQgdVN0cm9rZVdlaWdodDtcblxudW5pZm9ybSBib29sIHVVc2VMaW5lQ29sb3I7XG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG5cbnVuaWZvcm0gdmVjNCB1Vmlld3BvcnQ7XG51bmlmb3JtIGludCB1UGVyc3BlY3RpdmU7XG51bmlmb3JtIGludCB1U3Ryb2tlSm9pbjtcblxuSU4gdmVjNCBhUG9zaXRpb247XG5JTiB2ZWMzIGFUYW5nZW50SW47XG5JTiB2ZWMzIGFUYW5nZW50T3V0O1xuSU4gZmxvYXQgYVNpZGU7XG5JTiB2ZWM0IGFWZXJ0ZXhDb2xvcjtcblxuT1VUIHZlYzQgdkNvbG9yO1xuT1VUIHZlYzIgdlRhbmdlbnQ7XG5PVVQgdmVjMiB2Q2VudGVyO1xuT1VUIHZlYzIgdlBvc2l0aW9uO1xuT1VUIGZsb2F0IHZNYXhEaXN0O1xuT1VUIGZsb2F0IHZDYXA7XG5PVVQgZmxvYXQgdkpvaW47XG5cbnZlYzIgbGluZUludGVyc2VjdGlvbih2ZWMyIGFQb2ludCwgdmVjMiBhRGlyLCB2ZWMyIGJQb2ludCwgdmVjMiBiRGlyKSB7XG4gIC8vIFJvdGF0ZSBhbmQgdHJhbnNsYXRlIHNvIGEgc3RhcnRzIGF0IHRoZSBvcmlnaW4gYW5kIGdvZXMgb3V0IHRvIHRoZSByaWdodFxuICBiUG9pbnQgLT0gYVBvaW50O1xuICB2ZWMyIHJvdGF0ZWRCRnJvbSA9IHZlYzIoXG4gICAgYlBvaW50LngqYURpci54ICsgYlBvaW50LnkqYURpci55LFxuICAgIGJQb2ludC55KmFEaXIueCAtIGJQb2ludC54KmFEaXIueVxuICApO1xuICB2ZWMyIGJUbyA9IGJQb2ludCArIGJEaXI7XG4gIHZlYzIgcm90YXRlZEJUbyA9IHZlYzIoXG4gICAgYlRvLngqYURpci54ICsgYlRvLnkqYURpci55LFxuICAgIGJUby55KmFEaXIueCAtIGJUby54KmFEaXIueVxuICApO1xuICBmbG9hdCBpbnRlcnNlY3Rpb25EaXN0YW5jZSA9XG4gICAgcm90YXRlZEJUby54ICsgKHJvdGF0ZWRCRnJvbS54IC0gcm90YXRlZEJUby54KSAqIHJvdGF0ZWRCVG8ueSAvXG4gICAgKHJvdGF0ZWRCVG8ueSAtIHJvdGF0ZWRCRnJvbS55KTtcbiAgcmV0dXJuIGFQb2ludCArIGFEaXIgKiBpbnRlcnNlY3Rpb25EaXN0YW5jZTtcbn1cblxudm9pZCBtYWluKCkge1xuICAvLyBDYXBzIGhhdmUgb25lIG9mIGVpdGhlciB0aGUgaW4gb3Igb3V0IHRhbmdlbnQgc2V0IHRvIDBcbiAgdkNhcCA9IChhVGFuZ2VudEluID09IHZlYzMoMC4pKSAhPSAoYVRhbmdlbnRPdXQgPT0gKHZlYzMoMC4pKSlcbiAgICA/IDEuIDogMC47XG5cbiAgLy8gSm9pbnMgaGF2ZSB0d28gdW5pcXVlLCBkZWZpbmVkIHRhbmdlbnRzXG4gIHZKb2luID0gKFxuICAgIGFUYW5nZW50SW4gIT0gdmVjMygwLikgJiZcbiAgICBhVGFuZ2VudE91dCAhPSB2ZWMzKDAuKSAmJlxuICAgIGFUYW5nZW50SW4gIT0gYVRhbmdlbnRPdXRcbiAgKSA/IDEuIDogMC47XG5cbiAgdmVjNCBwb3NwID0gdU1vZGVsVmlld01hdHJpeCAqIGFQb3NpdGlvbjtcbiAgdmVjNCBwb3NxSW4gPSB1TW9kZWxWaWV3TWF0cml4ICogKGFQb3NpdGlvbiArIHZlYzQoYVRhbmdlbnRJbiwgMCkpO1xuICB2ZWM0IHBvc3FPdXQgPSB1TW9kZWxWaWV3TWF0cml4ICogKGFQb3NpdGlvbiArIHZlYzQoYVRhbmdlbnRPdXQsIDApKTtcblxuICBmbG9hdCBmYWNpbmdDYW1lcmEgPSBwb3coXG4gICAgLy8gVGhlIHdvcmQgc3BhY2UgdGFuZ2VudCdzIHogdmFsdWUgaXMgMCBpZiBpdCdzIGZhY2luZyB0aGUgY2FtZXJhXG4gICAgYWJzKG5vcm1hbGl6ZShwb3NxSW4tcG9zcCkueiksXG5cbiAgICAvLyBVc2luZyBwb3coKSBoZXJlIHRvIHJhbXAgXFxgZmFjaW5nQ2FtZXJhXFxgIHVwIGZyb20gMCB0byAxIHJlYWxseSBxdWlja2x5XG4gICAgLy8gc28gbW9zdCBsaW5lcyBnZXQgc2NhbGVkIGFuZCBkb24ndCBnZXQgY2xpcHBlZFxuICAgIDAuMjVcbiAgKTtcblxuICAvLyB1c2luZyBhIHNjYWxlIDwxIG1vdmVzIHRoZSBsaW5lcyB0b3dhcmRzIHRoZSBjYW1lcmFcbiAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBwb3BwaW5nIGVmZmVjdHMgZHVlIHRvIGhhbGYgb2ZcbiAgLy8gdGhlIGxpbmUgZGlzYXBwZWFyaW5nIGJlaGluZCB0aGUgZ2VvbWV0cnkgZmFjZXMuXG4gIGZsb2F0IHNjYWxlID0gbWl4KDEuLCAwLjk5NSwgZmFjaW5nQ2FtZXJhKTtcblxuICAvLyBNb3ZpbmcgdmVydGljZXMgc2xpZ2h0bHkgdG93YXJkIHRoZSBjYW1lcmFcbiAgLy8gdG8gYXZvaWQgZGVwdGgtZmlnaHRpbmcgd2l0aCB0aGUgZmlsbCB0cmlhbmdsZXMuXG4gIC8vIERpc2N1c3NlZCBoZXJlOlxuICAvLyBodHRwOi8vd3d3Lm9wZW5nbC5vcmcvZGlzY3Vzc2lvbl9ib2FyZHMvdWJidGhyZWFkcy5waHA/dWJiPXNob3dmbGF0Jk51bWJlcj0yNTI4NDggIFxuICBwb3NwLnh5eiA9IHBvc3AueHl6ICogc2NhbGU7XG4gIHBvc3FJbi54eXogPSBwb3NxSW4ueHl6ICogc2NhbGU7XG4gIHBvc3FPdXQueHl6ID0gcG9zcU91dC54eXogKiBzY2FsZTtcblxuICB2ZWM0IHAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHBvc3A7XG4gIHZlYzQgcUluID0gdVByb2plY3Rpb25NYXRyaXggKiBwb3NxSW47XG4gIHZlYzQgcU91dCA9IHVQcm9qZWN0aW9uTWF0cml4ICogcG9zcU91dDtcbiAgdkNlbnRlciA9IHAueHk7XG5cbiAgLy8gZm9ybXVsYSB0byBjb252ZXJ0IGZyb20gY2xpcCBzcGFjZSAocmFuZ2UgLTEuLjEpIHRvIHNjcmVlbiBzcGFjZSAocmFuZ2UgMC4uW3dpZHRoIG9yIGhlaWdodF0pXG4gIC8vIHNjcmVlbl9wID0gKHAueHkvcC53ICsgPDEsMT4pICogMC41ICogdVZpZXdwb3J0Lnp3XG5cbiAgLy8gcHJldmVudCBkaXZpc2lvbiBieSBXIGJ5IHRyYW5zZm9ybWluZyB0aGUgdGFuZ2VudCBmb3JtdWxhIChkaXYgYnkgMCBjYXVzZXNcbiAgLy8gdGhlIGxpbmUgdG8gZGlzYXBwZWFyLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb2Nlc3NpbmcvcHJvY2Vzc2luZy9pc3N1ZXMvNTE4MylcbiAgLy8gdCA9IHNjcmVlbl9xIC0gc2NyZWVuX3BcbiAgLy9cbiAgLy8gdGFuZ2VudCBpcyBub3JtYWxpemVkIGFuZCB3ZSBkb24ndCBjYXJlIHdoaWNoIGFEaXJlY3Rpb24gaXQgcG9pbnRzIHRvICgrLSlcbiAgLy8gdCA9ICstIG5vcm1hbGl6ZSggc2NyZWVuX3EgLSBzY3JlZW5fcCApXG4gIC8vIHQgPSArLSBub3JtYWxpemUoIChxLnh5L3Eudys8MSwxPikqMC41KnVWaWV3cG9ydC56dyAtIChwLnh5L3Audys8MSwxPikqMC41KnVWaWV3cG9ydC56dyApXG4gIC8vXG4gIC8vIGV4dHJhY3QgY29tbW9uIGZhY3RvciwgPDEsMT4gLSA8MSwxPiBjYW5jZWxzIG91dFxuICAvLyB0ID0gKy0gbm9ybWFsaXplKCAocS54eS9xLncgLSBwLnh5L3AudykgKiAwLjUgKiB1Vmlld3BvcnQuencgKVxuICAvL1xuICAvLyBjb252ZXJ0IHRvIGNvbW1vbiBkaXZpc29yXG4gIC8vIHQgPSArLSBub3JtYWxpemUoICgocS54eSpwLncgLSBwLnh5KnEudykgLyAocC53KnEudykpICogMC41ICogdVZpZXdwb3J0Lnp3IClcbiAgLy9cbiAgLy8gcmVtb3ZlIHRoZSBjb21tb24gc2NhbGFyIGRpdmlzb3IvZmFjdG9yLCBub3QgbmVlZGVkIGR1ZSB0byBub3JtYWxpemUgYW5kICstXG4gIC8vIChrZWVwIHVWaWV3cG9ydCAtIGNhbid0IHJlbW92ZSBiZWNhdXNlIGl0IGhhcyBkaWZmZXJlbnQgY29tcG9uZW50cyBmb3IgeCBhbmQgeVxuICAvLyAgYW5kIGNvcnJlY3RzIGZvciBhc3BlY3QgcmF0aW8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvY2Vzc2luZy9wcm9jZXNzaW5nL2lzc3Vlcy81MTgxKVxuICAvLyB0ID0gKy0gbm9ybWFsaXplKCAocS54eSpwLncgLSBwLnh5KnEudykgKiB1Vmlld3BvcnQuencgKVxuXG4gIHZlYzIgdGFuZ2VudEluID0gbm9ybWFsaXplKChxSW4ueHkqcC53IC0gcC54eSpxSW4udykgKiB1Vmlld3BvcnQuencpO1xuICB2ZWMyIHRhbmdlbnRPdXQgPSBub3JtYWxpemUoKHFPdXQueHkqcC53IC0gcC54eSpxT3V0LncpICogdVZpZXdwb3J0Lnp3KTtcblxuICB2ZWMyIGN1clBlcnNwU2NhbGU7XG4gIGlmKHVQZXJzcGVjdGl2ZSA9PSAxKSB7XG4gICAgLy8gUGVyc3BlY3RpdmUgLS0tXG4gICAgLy8gY29udmVydCBmcm9tIHdvcmxkIHRvIGNsaXAgYnkgbXVsdGlwbHlpbmcgd2l0aCBwcm9qZWN0aW9uIHNjYWxpbmcgZmFjdG9yXG4gICAgLy8gdG8gZ2V0IHRoZSByaWdodCB0aGlja25lc3MgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvY2Vzc2luZy9wcm9jZXNzaW5nL2lzc3Vlcy81MTgyKVxuXG4gICAgLy8gVGhlIHkgdmFsdWUgb2YgdGhlIHByb2plY3Rpb24gbWF0cml4IG1heSBiZSBmbGlwcGVkIGlmIHJlbmRlcmluZyB0byBhIEZyYW1lYnVmZmVyLlxuICAgIC8vIE11bHRpcGx5aW5nIGFnYWluIGJ5IGl0cyBzaWduIGhlcmUgbmVnYXRlcyB0aGUgZmxpcCB0byBnZXQganVzdCB0aGUgc2NhbGUuXG4gICAgY3VyUGVyc3BTY2FsZSA9ICh1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoMSwgc2lnbih1UHJvamVjdGlvbk1hdHJpeFsxXVsxXSksIDAsIDApKS54eTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBQZXJzcGVjdGl2ZSAtLS1cbiAgICAvLyBtdWx0aXBseSBieSBXICh0byBjYW5jZWwgb3V0IGRpdmlzaW9uIGJ5IFcgbGF0ZXIgaW4gdGhlIHBpcGVsaW5lKSBhbmRcbiAgICAvLyBjb252ZXJ0IGZyb20gc2NyZWVuIHRvIGNsaXAgKGRlcml2ZWQgZnJvbSBjbGlwIHRvIHNjcmVlbiBhYm92ZSlcbiAgICBjdXJQZXJzcFNjYWxlID0gcC53IC8gKDAuNSAqIHVWaWV3cG9ydC56dyk7XG4gIH1cblxuICB2ZWMyIG9mZnNldDtcbiAgaWYgKHZKb2luID09IDEuKSB7XG4gICAgdlRhbmdlbnQgPSBub3JtYWxpemUodGFuZ2VudEluICsgdGFuZ2VudE91dCk7XG4gICAgdmVjMiBub3JtYWxJbiA9IHZlYzIoLXRhbmdlbnRJbi55LCB0YW5nZW50SW4ueCk7XG4gICAgdmVjMiBub3JtYWxPdXQgPSB2ZWMyKC10YW5nZW50T3V0LnksIHRhbmdlbnRPdXQueCk7XG4gICAgZmxvYXQgc2lkZSA9IHNpZ24oYVNpZGUpO1xuICAgIGZsb2F0IHNpZGVFbnVtID0gYWJzKGFTaWRlKTtcblxuICAgIC8vIFdlIGdlbmVyYXRlIHZlcnRpY2VzIGZvciBqb2lucyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgY2VudGVybGluZSwgYnV0XG4gICAgLy8gdGhlIFwiZWxib3dcIiBzaWRlIGlzIHRoZSBvbmx5IG9uZSBuZWVkaW5nIGEgam9pbi4gQnkgbm90IHNldHRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IGZvciB0aGUgb3RoZXIgc2lkZSwgYWxsIGl0cyB2ZXJ0aWNlcyB3aWxsIGVuZCB1cCBpbiB0aGUgc2FtZVxuICAgIC8vIHNwb3QgYW5kIG5vdCByZW5kZXIsIGVmZmVjdGl2ZWx5IGRpc2NhcmRpbmcgaXQuXG4gICAgaWYgKHNpZ24oZG90KHRhbmdlbnRPdXQsIHZlYzIoLXRhbmdlbnRJbi55LCB0YW5nZW50SW4ueCkpKSAhPSBzaWRlKSB7XG4gICAgICAvLyBTaWRlIGVudW1zOlxuICAgICAgLy8gICAxOiB0aGUgc2lkZSBnb2luZyBpbnRvIHRoZSBqb2luXG4gICAgICAvLyAgIDI6IHRoZSBtaWRkbGUgb2YgdGhlIGpvaW5cbiAgICAgIC8vICAgMzogdGhlIHNpZGUgZ29pbmcgb3V0IG9mIHRoZSBqb2luXG4gICAgICBpZiAoc2lkZUVudW0gPT0gMi4pIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiArIHRhbmdlbnQgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGpvaW4sIGFuZFxuICAgICAgICAvLyBmaW5kIHdoZXJlIHRoZSBsaW5lcyBpbnRlcnNlY3QgdG8gZmluZCB0aGUgZWxib3cgb2YgdGhlIGpvaW5cbiAgICAgICAgdmVjMiBjID0gKHBvc3AueHkvcG9zcC53ICsgdmVjMigxLiwxLikpICogMC41ICogdVZpZXdwb3J0Lnp3O1xuICAgICAgICB2ZWMyIGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3Rpb24oXG4gICAgICAgICAgYyArIChzaWRlICogbm9ybWFsSW4gKiB1U3Ryb2tlV2VpZ2h0IC8gMi4pLFxuICAgICAgICAgIHRhbmdlbnRJbixcbiAgICAgICAgICBjICsgKHNpZGUgKiBub3JtYWxPdXQgKiB1U3Ryb2tlV2VpZ2h0IC8gMi4pLFxuICAgICAgICAgIHRhbmdlbnRPdXRcbiAgICAgICAgKTtcbiAgICAgICAgb2Zmc2V0ID0gKGludGVyc2VjdGlvbiAtIGMpO1xuXG4gICAgICAgIC8vIFdoZW4gbGluZXMgYXJlIHRoaWNrIGFuZCB0aGUgYW5nbGUgb2YgdGhlIGpvaW4gYXBwcm9hY2hlcyAxODAsIHRoZVxuICAgICAgICAvLyBlbGJvdyBtaWdodCBiZSByZWFsbHkgZmFyIGZyb20gdGhlIGNlbnRlci4gV2UnbGwgYXBwbHkgYSBsaW1pdCB0b1xuICAgICAgICAvLyB0aGUgbWFnbml0dWRlIHRvIGF2b2lkIGxpbmVzIGdvaW5nIGFjcm9zcyB0aGUgd2hvbGUgc2NyZWVuIHdoZW4gdGhpc1xuICAgICAgICAvLyBoYXBwZW5zLlxuICAgICAgICBmbG9hdCBtYWcgPSBsZW5ndGgob2Zmc2V0KTtcbiAgICAgICAgZmxvYXQgbWF4TWFnID0gMy4gKiB1U3Ryb2tlV2VpZ2h0O1xuICAgICAgICBpZiAobWFnID4gbWF4TWFnKSB7XG4gICAgICAgICAgb2Zmc2V0ICo9IG1heE1hZyAvIG1hZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaWRlRW51bSA9PSAxLikge1xuICAgICAgICBvZmZzZXQgPSBzaWRlICogbm9ybWFsSW4gKiB1U3Ryb2tlV2VpZ2h0IC8gMi47XG4gICAgICB9IGVsc2UgaWYgKHNpZGVFbnVtID09IDMuKSB7XG4gICAgICAgIG9mZnNldCA9IHNpZGUgKiBub3JtYWxPdXQgKiB1U3Ryb2tlV2VpZ2h0IC8gMi47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1U3Ryb2tlSm9pbiA9PSBTVFJPS0VfSk9JTl9CRVZFTCkge1xuICAgICAgdmVjMiBhdmdOb3JtYWwgPSB2ZWMyKC12VGFuZ2VudC55LCB2VGFuZ2VudC54KTtcbiAgICAgIHZNYXhEaXN0ID0gYWJzKGRvdChhdmdOb3JtYWwsIG5vcm1hbEluICogdVN0cm9rZVdlaWdodCAvIDIuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZNYXhEaXN0ID0gdVN0cm9rZVdlaWdodCAvIDIuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ZWMyIHRhbmdlbnQgPSBhVGFuZ2VudEluID09IHZlYzMoMC4pID8gdGFuZ2VudE91dCA6IHRhbmdlbnRJbjtcbiAgICB2VGFuZ2VudCA9IHRhbmdlbnQ7XG4gICAgdmVjMiBub3JtYWwgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XG5cbiAgICBmbG9hdCBub3JtYWxPZmZzZXQgPSBzaWduKGFTaWRlKTtcbiAgICAvLyBDYXBzIHdpbGwgaGF2ZSBzaWRlIHZhbHVlcyBvZiAtMiBvciAyIG9uIHRoZSBlZGdlIG9mIHRoZSBjYXAgdGhhdFxuICAgIC8vIGV4dGVuZHMgb3V0IGZyb20gdGhlIGxpbmVcbiAgICBmbG9hdCB0YW5nZW50T2Zmc2V0ID0gYWJzKGFTaWRlKSAtIDEuO1xuICAgIG9mZnNldCA9IChub3JtYWwgKiBub3JtYWxPZmZzZXQgKyB0YW5nZW50ICogdGFuZ2VudE9mZnNldCkgKlxuICAgICAgdVN0cm9rZVdlaWdodCAqIDAuNTtcbiAgICB2TWF4RGlzdCA9IHVTdHJva2VXZWlnaHQgLyAyLjtcbiAgfVxuICB2UG9zaXRpb24gPSB2Q2VudGVyICsgb2Zmc2V0O1xuXG4gIGdsX1Bvc2l0aW9uLnh5ID0gcC54eSArIG9mZnNldC54eSAqIGN1clBlcnNwU2NhbGU7XG4gIGdsX1Bvc2l0aW9uLnp3ID0gcC56dztcbiAgXG4gIHZDb2xvciA9ICh1VXNlTGluZUNvbG9yID8gYVZlcnRleENvbG9yIDogdU1hdGVyaWFsQ29sb3IpO1xufVxuYCwgbGluZUZyYWc6IFAgKyBgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG51bmlmb3JtIGludCB1U3Ryb2tlQ2FwO1xudW5pZm9ybSBpbnQgdVN0cm9rZUpvaW47XG51bmlmb3JtIGZsb2F0IHVTdHJva2VXZWlnaHQ7XG5cbklOIHZlYzQgdkNvbG9yO1xuSU4gdmVjMiB2VGFuZ2VudDtcbklOIHZlYzIgdkNlbnRlcjtcbklOIHZlYzIgdlBvc2l0aW9uO1xuSU4gZmxvYXQgdk1heERpc3Q7XG5JTiBmbG9hdCB2Q2FwO1xuSU4gZmxvYXQgdkpvaW47XG5cbmZsb2F0IGRpc3RTcXVhcmVkKHZlYzIgYSwgdmVjMiBiKSB7XG4gIHZlYzIgYVRvQiA9IGIgLSBhO1xuICByZXR1cm4gZG90KGFUb0IsIGFUb0IpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIGlmICh2Q2FwID4gMC4pIHtcbiAgICBpZiAoXG4gICAgICB1U3Ryb2tlQ2FwID09IFNUUk9LRV9DQVBfUk9VTkQgJiZcbiAgICAgIGRpc3RTcXVhcmVkKHZQb3NpdGlvbiwgdkNlbnRlcikgPiB1U3Ryb2tlV2VpZ2h0ICogdVN0cm9rZVdlaWdodCAqIDAuMjVcbiAgICApIHtcbiAgICAgIGRpc2NhcmQ7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHVTdHJva2VDYXAgPT0gU1RST0tFX0NBUF9TUVVBUkUgJiZcbiAgICAgIGRvdCh2UG9zaXRpb24gLSB2Q2VudGVyLCB2VGFuZ2VudCkgPiAwLlxuICAgICkge1xuICAgICAgZGlzY2FyZDtcbiAgICB9XG4gICAgLy8gVXNlIGZ1bGwgYXJlYSBmb3IgUFJPSkVDVFxuICB9IGVsc2UgaWYgKHZKb2luID4gMC4pIHtcbiAgICBpZiAoXG4gICAgICB1U3Ryb2tlSm9pbiA9PSBTVFJPS0VfSk9JTl9ST1VORCAmJlxuICAgICAgZGlzdFNxdWFyZWQodlBvc2l0aW9uLCB2Q2VudGVyKSA+IHVTdHJva2VXZWlnaHQgKiB1U3Ryb2tlV2VpZ2h0ICogMC4yNVxuICAgICkge1xuICAgICAgZGlzY2FyZDtcbiAgICB9IGVsc2UgaWYgKHVTdHJva2VKb2luID09IFNUUk9LRV9KT0lOX0JFVkVMKSB7XG4gICAgICB2ZWMyIG5vcm1hbCA9IHZlYzIoLXZUYW5nZW50LnksIHZUYW5nZW50LngpO1xuICAgICAgaWYgKGFicyhkb3QodlBvc2l0aW9uIC0gdkNlbnRlciwgbm9ybWFsKSkgPiB2TWF4RGlzdCkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgZnVsbCBhcmVhIGZvciBNSVRFUlxuICB9XG4gIE9VVF9DT0xPUiA9IHZlYzQodkNvbG9yLnJnYiwgMS4pICogdkNvbG9yLmE7XG59XG5gLCBwb2ludFZlcnQ6IGBJTiB2ZWMzIGFQb3NpdGlvbjtcbnVuaWZvcm0gZmxvYXQgdVBvaW50U2l6ZTtcbk9VVCBmbG9hdCB2U3Ryb2tlV2VpZ2h0O1xudW5pZm9ybSBtYXQ0IHVNb2RlbFZpZXdNYXRyaXg7XG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG52b2lkIG1haW4oKSB7XG5cdHZlYzQgcG9zaXRpb25WZWM0ID0gIHZlYzQoYVBvc2l0aW9uLCAxLjApO1xuXHRnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdU1vZGVsVmlld01hdHJpeCAqIHBvc2l0aW9uVmVjNDtcblx0Z2xfUG9pbnRTaXplID0gdVBvaW50U2l6ZTtcblx0dlN0cm9rZVdlaWdodCA9IHVQb2ludFNpemU7XG59XG5gLCBwb2ludEZyYWc6IGBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG51bmlmb3JtIHZlYzQgdU1hdGVyaWFsQ29sb3I7XG5JTiBmbG9hdCB2U3Ryb2tlV2VpZ2h0O1xuXG52b2lkIG1haW4oKXtcbiAgZmxvYXQgbWFzayA9IDAuMDtcblxuICAvLyBtYWtlIGEgY2lyY3VsYXIgbWFzayB1c2luZyB0aGUgZ2xfUG9pbnRDb29yZCAoZ29lcyBmcm9tIDAgLSAxIG9uIGEgcG9pbnQpXG4gIC8vIG1pZ2h0IGJlIGFibGUgdG8gZ2V0IGEgbmljZXIgZWRnZSBvbiBiaWcgc3Ryb2tld2VpZ2h0cyB3aXRoIHNtb290aHN0ZXAgYnV0IHNsaWdodGx5IGxlc3MgcGVyZm9ybWFudFxuXG4gIG1hc2sgPSBzdGVwKDAuOTgsIGxlbmd0aChnbF9Qb2ludENvb3JkICogMi4wIC0gMS4wKSk7XG5cbiAgLy8gaWYgc3Ryb2tlV2VpZ2h0IGlzIDEgb3IgbGVzcyBsZXRzIGp1c3QgZHJhdyBhIHNxdWFyZVxuICAvLyB0aGlzIHByZXZlbnRzIHdlaXJkIGFydGlmYWN0aW5nIGZyb20gY2FydmluZyBjaXJjbGVzIHdoZW4gb3VyIHBvaW50cyBhcmUgcmVhbGx5IHNtYWxsXG4gIC8vIGlmIHN0cm9rZVdlaWdodCBpcyBsYXJnZXIgdGhhbiAxLCB3ZSBqdXN0IHVzZSBpdCBhcyBpc1xuXG4gIG1hc2sgPSBtaXgoMC4wLCBtYXNrLCBjbGFtcChmbG9vcih2U3Ryb2tlV2VpZ2h0IC0gMC41KSwwLjAsMS4wKSk7XG5cbiAgLy8gdGhyb3cgYXdheSB0aGUgYm9yZGVycyBvZiB0aGUgbWFza1xuICAvLyBvdGhlcndpc2Ugd2UgZ2V0IHdlaXJkIGFscGhhIGJsZW5kaW5nIGlzc3Vlc1xuXG4gIGlmKG1hc2sgPiAwLjk4KXtcbiAgICBkaXNjYXJkO1xuICB9XG5cbiAgT1VUX0NPTE9SID0gdmVjNCh1TWF0ZXJpYWxDb2xvci5yZ2IsIDEuKSAqIHVNYXRlcmlhbENvbG9yLmE7XG59XG5gLCBpbWFnZUxpZ2h0VmVydDogYHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbmF0dHJpYnV0ZSB2ZWMzIGFQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XG5hdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XG5cbnZhcnlpbmcgdmVjMyBsb2NhbFBvcztcbnZhcnlpbmcgdmVjMyB2V29ybGROb3JtYWw7XG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG51bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB1Tm9ybWFsTWF0cml4O1xuXG52b2lkIG1haW4oKSB7XG4gIC8vIE11bHRpcGx5IHRoZSBwb3NpdGlvbiBieSB0aGUgbWF0cml4LlxuICB2ZWM0IHZpZXdNb2RlbFBvc2l0aW9uID0gdU1vZGVsVmlld01hdHJpeCAqIHZlYzQoYVBvc2l0aW9uLCAxLjApO1xuICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdmlld01vZGVsUG9zaXRpb247ICBcbiAgXG4gIC8vIG9yaWVudCB0aGUgbm9ybWFscyBhbmQgcGFzcyB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXG4gIHZXb3JsZE5vcm1hbCA9IHVOb3JtYWxNYXRyaXggKiBhTm9ybWFsO1xuICBcbiAgLy8gc2VuZCB0aGUgdmlldyBwb3NpdGlvbiB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXG4gIHZXb3JsZFBvc2l0aW9uID0gKHVNb2RlbFZpZXdNYXRyaXggKiB2ZWM0KGFQb3NpdGlvbiwgMS4wKSkueHl6O1xuICBcbiAgbG9jYWxQb3MgPSB2V29ybGRQb3NpdGlvbjtcbiAgdlRleENvb3JkID0gYVRleENvb3JkO1xufVxuXG5cbi8qXG5pbiB0aGUgdmVydGV4IHNoYWRlciB3ZSdsbCBjb21wdXRlIHRoZSB3b3JsZCBwb3NpdGlvbiBhbmQgd29ybGQgb3JpZW50ZWQgbm9ybWFsIG9mIHRoZSB2ZXJ0aWNlcyBhbmQgcGFzcyB0aG9zZSB0byB0aGUgZnJhZ21lbnQgc2hhZGVyIGFzIHZhcnlpbmdzLlxuKi9cbmAsIGltYWdlTGlnaHREaWZmdXNlZEZyYWc6IGBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG52YXJ5aW5nIHZlYzMgbG9jYWxQb3M7XG5cbi8vIHRoZSBIRFIgY3ViZW1hcCBjb252ZXJ0ZWQgKGNhbiBiZSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciBlbnZpcm9ubWVudCBtYXAuKVxudW5pZm9ybSBzYW1wbGVyMkQgZW52aXJvbm1lbnRNYXA7XG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTk7XG5cbnZlYzIgblRPRSggdmVjMyB2ICl7XG4gIC8vIHggPSByIHNpbihwaGkpIGNvcyh0aGV0YSkgICBcbiAgLy8geSA9IHIgY29zKHBoaSkgIFxuICAvLyB6ID0gciBzaW4ocGhpKSBzaW4odGhldGEpXG4gIGZsb2F0IHBoaSA9IGFjb3MoIHYueSApO1xuICAvLyBpZiBwaGkgaXMgMCwgdGhlbiB0aGVyZSBhcmUgbm8geCwgeiBjb21wb25lbnRzXG4gIGZsb2F0IHRoZXRhID0gMC4wO1xuICAvLyBlbHNlIFxuICB0aGV0YSA9IGFjb3Modi54IC8gc2luKHBoaSkpO1xuICBmbG9hdCBzaW5UaGV0YSA9IHYueiAvIHNpbihwaGkpO1xuICBpZiAoc2luVGhldGEgPCAwLjApIHtcbiAgICAvLyBUdXJuIGl0IGludG8gLXRoZXRhLCBidXQgaW4gdGhlIDAtMlBJIHJhbmdlXG4gICAgdGhldGEgPSAyLjAgKiBQSSAtIHRoZXRhO1xuICB9XG4gIHRoZXRhID0gdGhldGEgLyAoMi4wICogMy4xNDE1OSk7XG4gIHBoaSA9IHBoaSAvIDMuMTQxNTkgO1xuICBcbiAgdmVjMiBhbmdsZXMgPSB2ZWMyKCBwaGksIHRoZXRhICk7XG4gIHJldHVybiBhbmdsZXM7XG59XG5cbmZsb2F0IHJhbmRvbSh2ZWMyIHApIHtcbiAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIC4xMDMxKTtcbiAgcDMgKz0gZG90KHAzLCBwMy55enggKyAzMy4zMyk7XG4gIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XG59XG5cbnZvaWQgbWFpbigpXG57ICAgXHQgXG5cdC8vIHRoZSBzYW1wbGUgZGlyZWN0aW9uIGVxdWFscyB0aGUgaGVtaXNwaGVyZSdzIG9yaWVudGF0aW9uXG4gIGZsb2F0IHBoaSA9IHZUZXhDb29yZC54ICogMi4wICogUEk7XG4gIGZsb2F0IHRoZXRhID0gdlRleENvb3JkLnkgKiBQSTtcbiAgZmxvYXQgeCA9IHNpbih0aGV0YSkgKiBjb3MocGhpKTtcbiAgZmxvYXQgeSA9IHNpbih0aGV0YSkgKiBzaW4ocGhpKTtcbiAgZmxvYXQgeiA9IGNvcyh0aGV0YSk7XG4gIHZlYzMgbm9ybWFsID0gdmVjMyggeCwgeSwgeik7XG5cblx0Ly8gRGlzY3JldGVseSBzYW1wbGluZyB0aGUgaGVtaXNwaGVyZSBnaXZlbiB0aGUgaW50ZWdyYWwnc1xuICAvLyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgdHJhbnNsYXRlcyB0byB0aGUgZm9sbG93aW5nIGZyYWdtZW50IGNvZGU6XG5cdHZlYzMgaXJyYWRpYW5jZSA9IHZlYzMoMC4wKTsgIFxuXHR2ZWMzIHVwXHQ9IHZlYzMoMC4wLCAxLjAsIDAuMCk7XG5cdHZlYzMgcmlnaHQgPSBub3JtYWxpemUoY3Jvc3ModXAsIG5vcm1hbCkpO1xuXHR1cCA9IG5vcm1hbGl6ZShjcm9zcyhub3JtYWwsIHJpZ2h0KSk7XG5cblx0Ly8gIFdlIHNwZWNpZnkgYSBmaXhlZCBzYW1wbGVEZWx0YSBkZWx0YSB2YWx1ZSB0byB0cmF2ZXJzZVxuICAvLyB0aGUgaGVtaXNwaGVyZTsgZGVjcmVhc2luZyBvciBpbmNyZWFzaW5nIHRoZSBzYW1wbGUgZGVsdGFcbiAgLy8gd2lsbCBpbmNyZWFzZSBvciBkZWNyZWFzZSB0aGUgYWNjdXJhY3kgcmVzcGVjdGl2ZWx5LlxuXHRjb25zdCBmbG9hdCBzYW1wbGVEZWx0YSA9IDAuMTAwO1xuXHRmbG9hdCBuclNhbXBsZXMgPSAwLjA7XG4gIGZsb2F0IHJhbmRvbU9mZnNldCA9IHJhbmRvbShnbF9GcmFnQ29vcmQueHkpICogc2FtcGxlRGVsdGE7XG5cdGZvcihmbG9hdCByYXdQaGkgPSAwLjA7IHJhd1BoaSA8IDIuMCAqIFBJOyByYXdQaGkgKz0gc2FtcGxlRGVsdGEpXG5cdHtcbiAgICBmbG9hdCBwaGkgPSByYXdQaGkgKyByYW5kb21PZmZzZXQ7XG4gICAgZm9yKGZsb2F0IHJhd1RoZXRhID0gMC4wOyByYXdUaGV0YSA8ICggMC41ICkgKiBQSTsgcmF3VGhldGEgKz0gc2FtcGxlRGVsdGEpXG4gICAge1xuICAgICAgZmxvYXQgdGhldGEgPSByYXdUaGV0YSArIHJhbmRvbU9mZnNldDtcbiAgICAgIC8vIHNwaGVyaWNhbCB0byBjYXJ0ZXNpYW4gKGluIHRhbmdlbnQgc3BhY2UpIC8vIHRhbmdlbnQgc3BhY2UgdG8gd29ybGQgLy8gYWRkIGVhY2ggc2FtcGxlIHJlc3VsdCB0byBpcnJhZGlhbmNlXG4gICAgICBmbG9hdCB4ID0gc2luKHRoZXRhKSAqIGNvcyhwaGkpO1xuICAgICAgZmxvYXQgeSA9IHNpbih0aGV0YSkgKiBzaW4ocGhpKTtcbiAgICAgIGZsb2F0IHogPSBjb3ModGhldGEpO1xuICAgICAgdmVjMyB0YW5nZW50U2FtcGxlID0gdmVjMyggeCwgeSwgeik7XG4gICAgICBcbiAgICAgIHZlYzMgc2FtcGxlVmVjID0gdGFuZ2VudFNhbXBsZS54ICogcmlnaHQgKyB0YW5nZW50U2FtcGxlLnkgKiB1cCArIHRhbmdlbnRTYW1wbGUueiAqIG5vcm1hbDtcbiAgICAgICAgaXJyYWRpYW5jZSArPSAodGV4dHVyZTJEKGVudmlyb25tZW50TWFwLCBuVE9FKHNhbXBsZVZlYykpLnh5eikgKiBjb3ModGhldGEpICogc2luKHRoZXRhKTtcbiAgICAgIG5yU2FtcGxlcysrO1xuICAgIH1cblx0fVxuXHQvLyBkaXZpZGUgYnkgdGhlIHRvdGFsIG51bWJlciBvZiBzYW1wbGVzIHRha2VuLCBnaXZpbmcgdXMgdGhlIGF2ZXJhZ2Ugc2FtcGxlZCBpcnJhZGlhbmNlLlxuXHRpcnJhZGlhbmNlID0gUEkgKiBpcnJhZGlhbmNlICogKDEuMCAvIGZsb2F0KG5yU2FtcGxlcyApKSA7XG4gIFxuIFxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGlycmFkaWFuY2UsIDEuMCk7XG59YCwgaW1hZ2VMaWdodFNwZWN1bGFyRnJhZzogYHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXHJcbnZhcnlpbmcgdmVjMyBsb2NhbFBvcztcXHJcbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxyXG5cXHJcbi8vIG91ciB0ZXh0dXJlXFxyXG51bmlmb3JtIHNhbXBsZXIyRCBlbnZpcm9ubWVudE1hcDtcXHJcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcclxuXFxyXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTk7XFxyXG5cXHJcbmZsb2F0IFZhbkRlckNvcnB1dChpbnQgYml0cyk7XFxyXG52ZWMyIEhhbW1lcnNsZXlOb0JpdE9wcyhpbnQgaSwgaW50IE4pO1xcclxudmVjMyBJbXBvcnRhbmNlU2FtcGxlR0dYKHZlYzIgWGksIHZlYzMgTiwgZmxvYXQgcm91Z2huZXNzKTtcXHJcblxcclxuXFxyXG52ZWMyIG5UT0UoIHZlYzMgdiApe1xcclxuICAvLyB4ID0gciBzaW4ocGhpKSBjb3ModGhldGEpICAgXFxyXG4gIC8vIHkgPSByIGNvcyhwaGkpICBcXHJcbiAgLy8geiA9IHIgc2luKHBoaSkgc2luKHRoZXRhKVxcclxuICBmbG9hdCBwaGkgPSBhY29zKCB2LnkgKTtcXHJcbiAgLy8gaWYgcGhpIGlzIDAsIHRoZW4gdGhlcmUgYXJlIG5vIHgsIHogY29tcG9uZW50c1xcclxuICBmbG9hdCB0aGV0YSA9IDAuMDtcXHJcbiAgLy8gZWxzZSBcXHJcbiAgdGhldGEgPSBhY29zKHYueCAvIHNpbihwaGkpKTtcXHJcbiAgZmxvYXQgc2luVGhldGEgPSB2LnogLyBzaW4ocGhpKTtcXHJcbiAgaWYgKHNpblRoZXRhIDwgMC4wKSB7XFxyXG4gICAgLy8gVHVybiBpdCBpbnRvIC10aGV0YSwgYnV0IGluIHRoZSAwLTJQSSByYW5nZVxcclxuICAgIHRoZXRhID0gMi4wICogUEkgLSB0aGV0YTtcXHJcbiAgfVxcclxuICB0aGV0YSA9IHRoZXRhIC8gKDIuMCAqIDMuMTQxNTkpO1xcclxuICBwaGkgPSBwaGkgLyAzLjE0MTU5IDtcXHJcbiAgXFxyXG4gIHZlYzIgYW5nbGVzID0gdmVjMiggcGhpLCB0aGV0YSApO1xcclxuICByZXR1cm4gYW5nbGVzO1xcclxufVxcclxuXFxyXG5cXHJcbnZvaWQgbWFpbigpe1xcclxuICBjb25zdCBpbnQgU0FNUExFX0NPVU5UID0gNDAwOyAvLyA0MDk2XFxyXG4gIGludCBsb3dSb3VnaG5lc3NMaW1pdCA9IGludChwb3coMi4wLChyb3VnaG5lc3MrMC4xKSoyMC4wKSk7XFxyXG4gIGZsb2F0IHRvdGFsV2VpZ2h0ID0gMC4wO1xcclxuICB2ZWMzIHByZWZpbHRlcmVkQ29sb3IgPSB2ZWMzKDAuMCk7XFxyXG4gIGZsb2F0IHBoaSA9IHZUZXhDb29yZC54ICogMi4wICogUEk7XFxyXG4gIGZsb2F0IHRoZXRhID0gdlRleENvb3JkLnkgKiBQSTtcXHJcbiAgZmxvYXQgeCA9IHNpbih0aGV0YSkgKiBjb3MocGhpKTtcXHJcbiAgZmxvYXQgeSA9IHNpbih0aGV0YSkgKiBzaW4ocGhpKTtcXHJcbiAgZmxvYXQgeiA9IGNvcyh0aGV0YSk7XFxyXG4gIHZlYzMgTiA9IHZlYzMoeCx5LHopO1xcclxuICB2ZWMzIFYgPSBOO1xcclxuICBmb3IgKGludCBpID0gMDsgaSA8IFNBTVBMRV9DT1VOVDsgKytpKVxcclxuICB7XFxyXG4gICAgLy8gYnJlYWsgYXQgc21hbGxlciBzYW1wbGUgbnVtYmVycyBmb3IgbG93IHJvdWdobmVzcyBsZXZlbHNcXHJcbiAgICBpZihpID09IGxvd1JvdWdobmVzc0xpbWl0KVxcclxuICAgIHtcXHJcbiAgICAgIGJyZWFrO1xcclxuICAgIH1cXHJcbiAgICB2ZWMyIFhpID0gSGFtbWVyc2xleU5vQml0T3BzKGksIFNBTVBMRV9DT1VOVCk7XFxyXG4gICAgdmVjMyBIID0gSW1wb3J0YW5jZVNhbXBsZUdHWChYaSwgTiwgcm91Z2huZXNzKTtcXHJcbiAgICB2ZWMzIEwgPSBub3JtYWxpemUoMi4wICogZG90KFYsIEgpICogSCAtIFYpO1xcclxuXFxyXG4gICAgZmxvYXQgTmRvdEwgPSBtYXgoZG90KE4sIEwpLCAwLjApO1xcclxuICAgIGlmIChOZG90TCA+IDAuMClcXHJcbiAgICB7XFxyXG4gICAgICBwcmVmaWx0ZXJlZENvbG9yICs9IHRleHR1cmUyRChlbnZpcm9ubWVudE1hcCwgblRPRShMKSkueHl6ICogTmRvdEw7XFxyXG4gICAgICB0b3RhbFdlaWdodCArPSBOZG90TDtcXHJcbiAgICB9XFxyXG4gIH1cXHJcbiAgcHJlZmlsdGVyZWRDb2xvciA9IHByZWZpbHRlcmVkQ29sb3IgLyB0b3RhbFdlaWdodDtcXHJcblxcclxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHByZWZpbHRlcmVkQ29sb3IsIDEuMCk7XFxyXG59XFxyXG5cXHJcbnZlYzMgSW1wb3J0YW5jZVNhbXBsZUdHWCh2ZWMyIFhpLCB2ZWMzIE4sIGZsb2F0IHJvdWdobmVzcyl7XFxyXG4gIGZsb2F0IGEgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxyXG5cXHJcbiAgZmxvYXQgcGhpID0gMi4wICogUEkgKiBYaS54O1xcclxuICBmbG9hdCBjb3NUaGV0YSA9IHNxcnQoKDEuMCAtIFhpLnkpIC8gKDEuMCArIChhICogYSAtIDEuMCkgKiBYaS55KSk7XFxyXG4gIGZsb2F0IHNpblRoZXRhID0gc3FydCgxLjAgLSBjb3NUaGV0YSAqIGNvc1RoZXRhKTtcXHJcbiAgLy8gZnJvbSBzcGhlcmljYWwgY29vcmRpbmF0ZXMgdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzXFxyXG4gIHZlYzMgSDtcXHJcbiAgSC54ID0gY29zKHBoaSkgKiBzaW5UaGV0YTtcXHJcbiAgSC55ID0gc2luKHBoaSkgKiBzaW5UaGV0YTtcXHJcbiAgSC56ID0gY29zVGhldGE7XFxyXG5cXHJcbiAgLy8gZnJvbSB0YW5nZW50LXNwYWNlIHZlY3RvciB0byB3b3JsZC1zcGFjZSBzYW1wbGUgdmVjdG9yXFxyXG4gIHZlYzMgdXAgPSBhYnMoTi56KSA8IDAuOTk5ID8gdmVjMygwLjAsIDAuMCwgMS4wKSA6IHZlYzMoMS4wLCAwLjAsIDAuMCk7XFxyXG4gIHZlYzMgdGFuZ2VudCA9IG5vcm1hbGl6ZShjcm9zcyh1cCwgTikpO1xcclxuICB2ZWMzIGJpdGFuZ2VudCA9IGNyb3NzKE4sIHRhbmdlbnQpO1xcclxuXFxyXG4gIHZlYzMgc2FtcGxlVmVjID0gdGFuZ2VudCAqIEgueCArIGJpdGFuZ2VudCAqIEgueSArIE4gKiBILno7XFxyXG4gIHJldHVybiBub3JtYWxpemUoc2FtcGxlVmVjKTtcXHJcbn1cXHJcblxcclxuXFxyXG5mbG9hdCBWYW5EZXJDb3JwdXQoaW50IG4sIGludCBiYXNlKVxcclxue1xcclxuI2lmZGVmIFdFQkdMMlxcclxuXFxyXG4gICAgdWludCBiaXRzID0gdWludChuKTtcXHJcbiAgICBiaXRzID0gKGJpdHMgPDwgMTZ1KSB8IChiaXRzID4+IDE2dSk7XFxyXG4gICAgYml0cyA9ICgoYml0cyAmIDB4NTU1NTU1NTV1KSA8PCAxdSkgfCAoKGJpdHMgJiAweEFBQUFBQUFBdSkgPj4gMXUpO1xcclxuICAgIGJpdHMgPSAoKGJpdHMgJiAweDMzMzMzMzMzdSkgPDwgMnUpIHwgKChiaXRzICYgMHhDQ0NDQ0NDQ3UpID4+IDJ1KTtcXHJcbiAgICBiaXRzID0gKChiaXRzICYgMHgwRjBGMEYwRnUpIDw8IDR1KSB8ICgoYml0cyAmIDB4RjBGMEYwRjB1KSA+PiA0dSk7XFxyXG4gICAgYml0cyA9ICgoYml0cyAmIDB4MDBGRjAwRkZ1KSA8PCA4dSkgfCAoKGJpdHMgJiAweEZGMDBGRjAwdSkgPj4gOHUpO1xcclxuICAgIHJldHVybiBmbG9hdChiaXRzKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIC8gMHgxMDAwMDAwMDBcXHJcblxcclxuI2Vsc2VcXHJcblxcclxuICBmbG9hdCBpbnZCYXNlID0gMS4wIC8gZmxvYXQoYmFzZSk7XFxyXG4gIGZsb2F0IGRlbm9tID0gMS4wO1xcclxuICBmbG9hdCByZXN1bHQgPSAwLjA7XFxyXG5cXHJcblxcclxuICBmb3IgKGludCBpID0gMDsgaSA8IDMyOyArK2kpXFxyXG4gIHtcXHJcbiAgICAgICAgaWYgKG4gPiAwKVxcclxuICAgICAgICB7XFxyXG4gICAgICAgIGRlbm9tID0gbW9kKGZsb2F0KG4pLCAyLjApO1xcclxuICAgICAgICByZXN1bHQgKz0gZGVub20gKiBpbnZCYXNlO1xcclxuICAgICAgICBpbnZCYXNlID0gaW52QmFzZSAvIDIuMDtcXHJcbiAgICAgICAgbiA9IGludChmbG9hdChuKSAvIDIuMCk7XFxyXG4gICAgICAgIH1cXHJcbiAgfVxcclxuXFxyXG5cXHJcbiAgcmV0dXJuIHJlc3VsdDtcXHJcblxcclxuI2VuZGlmXFxyXG59XFxyXG5cXHJcbnZlYzIgSGFtbWVyc2xleU5vQml0T3BzKGludCBpLCBpbnQgTilcXHJcbntcXHJcbiAgcmV0dXJuIHZlYzIoZmxvYXQoaSkgLyBmbG9hdChOKSwgVmFuRGVyQ29ycHV0KGksIDIpKTtcXHJcbn1cXHJcbmAgfSwgTCA9IFIuc3BoZXJlTWFwcGluZ0ZyYWc7XG4gICAgICBmb3IgKEUgaW4gUilcbiAgICAgICAgUltFXSA9IGAjaWZkZWYgV0VCR0wyXG5cbiNkZWZpbmUgSU4gaW5cbiNkZWZpbmUgT1VUIG91dFxuXG4jaWZkZWYgRlJBR01FTlRfU0hBREVSXG5vdXQgdmVjNCBvdXRDb2xvcjtcbiNkZWZpbmUgT1VUX0NPTE9SIG91dENvbG9yXG4jZW5kaWZcbiNkZWZpbmUgVEVYVFVSRSB0ZXh0dXJlXG5cbiNlbHNlXG5cbiNpZmRlZiBGUkFHTUVOVF9TSEFERVJcbiNkZWZpbmUgSU4gdmFyeWluZ1xuI2Vsc2VcbiNkZWZpbmUgSU4gYXR0cmlidXRlXG4jZW5kaWZcbiNkZWZpbmUgT1VUIHZhcnlpbmdcbiNkZWZpbmUgVEVYVFVSRSB0ZXh0dXJlMkRcblxuI2lmZGVmIEZSQUdNRU5UX1NIQURFUlxuI2RlZmluZSBPVVRfQ09MT1IgZ2xfRnJhZ0NvbG9yXG4jZW5kaWZcblxuI2VuZGlmXG5gICsgUltFXTtcbiAgICAgIFQoTSA9IHt9LCBoLkdSQVksIGBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG5cbmZsb2F0IGx1bWEodmVjMyBjb2xvcikge1xuICAvLyB3ZWlnaHRlZCBncmF5c2NhbGUgd2l0aCBsdW1pbmFuY2UgdmFsdWVzXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgdGV4ID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCk7XG4gIGZsb2F0IGdyYXkgPSBsdW1hKHRleC5yZ2IpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGdyYXksIGdyYXksIGdyYXksIHRleC5hKTtcbn1cbmApLCBUKE0sIGguRVJPREUsIGAvLyBSZWR1Y2VzIHRoZSBicmlnaHQgYXJlYXMgaW4gYW4gaW1hZ2VcblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuZmxvYXQgbHVtYSh2ZWMzIGNvbG9yKSB7XG4gIC8vIHdlaWdodGVkIGdyYXlzY2FsZSB3aXRoIGx1bWluYW5jZSB2YWx1ZXNcbiAgLy8gd2VpZ2h0cyA3NywgMTUxLCAyOCB0YWtlbiBmcm9tIHNyYy9pbWFnZS9maWx0ZXJzLmpzXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMC4zMDA3ODEsIDAuNTg5ODQ0LCAwLjEwOTM3NSkpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdlRleENvb3JkKTtcbiAgZmxvYXQgbHVtID0gbHVtYShjb2xvci5yZ2IpO1xuXG4gIC8vIHNldCBjdXJyZW50IGNvbG9yIGFzIHRoZSBkYXJrZXN0IG5laWdoYm9yIGNvbG9yXG5cbiAgdmVjNCBuZWlnaGJvcnNbNF07XG4gIG5laWdoYm9yc1swXSA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQgKyB2ZWMyKCB0ZXhlbFNpemUueCwgMC4wKSk7XG4gIG5laWdoYm9yc1sxXSA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQgKyB2ZWMyKC10ZXhlbFNpemUueCwgMC4wKSk7XG4gIG5laWdoYm9yc1syXSA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQgKyB2ZWMyKDAuMCwgIHRleGVsU2l6ZS55KSk7XG4gIG5laWdoYm9yc1szXSA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQgKyB2ZWMyKDAuMCwgLXRleGVsU2l6ZS55KSk7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2ZWM0IG5laWdoYm9yQ29sb3IgPSBuZWlnaGJvcnNbaV07XG4gICAgZmxvYXQgbmVpZ2hib3JMdW0gPSBsdW1hKG5laWdoYm9yQ29sb3IucmdiKTtcblxuICAgIGlmIChuZWlnaGJvckx1bSA8IGx1bSkge1xuICAgICAgY29sb3IgPSBuZWlnaGJvckNvbG9yO1xuICAgICAgbHVtID0gbmVpZ2hib3JMdW07XG4gICAgfVxuICB9XG5cbiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG59XG5gKSwgVChNLCBoLkRJTEFURSwgYC8vIEluY3JlYXNlIHRoZSBicmlnaHQgYXJlYXMgaW4gYW4gaW1hZ2VcblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuZmxvYXQgbHVtYSh2ZWMzIGNvbG9yKSB7XG4gIC8vIHdlaWdodGVkIGdyYXlzY2FsZSB3aXRoIGx1bWluYW5jZSB2YWx1ZXNcbiAgLy8gd2VpZ2h0cyA3NywgMTUxLCAyOCB0YWtlbiBmcm9tIHNyYy9pbWFnZS9maWx0ZXJzLmpzXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMC4zMDA3ODEsIDAuNTg5ODQ0LCAwLjEwOTM3NSkpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdlRleENvb3JkKTtcbiAgZmxvYXQgbHVtID0gbHVtYShjb2xvci5yZ2IpO1xuXG4gIC8vIHNldCBjdXJyZW50IGNvbG9yIGFzIHRoZSBicmlnaHRlc3QgbmVpZ2hib3IgY29sb3JcblxuICB2ZWM0IG5laWdoYm9yc1s0XTtcbiAgbmVpZ2hib3JzWzBdID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCArIHZlYzIoIHRleGVsU2l6ZS54LCAwLjApKTtcbiAgbmVpZ2hib3JzWzFdID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCArIHZlYzIoLXRleGVsU2l6ZS54LCAwLjApKTtcbiAgbmVpZ2hib3JzWzJdID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCArIHZlYzIoMC4wLCAgdGV4ZWxTaXplLnkpKTtcbiAgbmVpZ2hib3JzWzNdID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCArIHZlYzIoMC4wLCAtdGV4ZWxTaXplLnkpKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZlYzQgbmVpZ2hib3JDb2xvciA9IG5laWdoYm9yc1tpXTtcbiAgICBmbG9hdCBuZWlnaGJvckx1bSA9IGx1bWEobmVpZ2hib3JDb2xvci5yZ2IpO1xuXG4gICAgaWYgKG5laWdoYm9yTHVtID4gbHVtKSB7XG4gICAgICBjb2xvciA9IG5laWdoYm9yQ29sb3I7XG4gICAgICBsdW0gPSBuZWlnaGJvckx1bTtcbiAgICB9XG4gIH1cblxuICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbn1cbmApLCBUKE0sIGguQkxVUiwgYHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuLy8gVHdvLXBhc3MgYmx1ciBmaWx0ZXIsIHVud2VpZ2h0ZWQga2VybmVsLlxuLy8gU2VlIGFsc28gYSBzaW1pbGFyIGJsdXIgYXQgQWRhbSBGZXJyaXNzJyByZXBvIG9mIHNoYWRlciBleGFtcGxlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZmVycmlzcy9wNWpzU2hhZGVyRXhhbXBsZXMvYmxvYi9naC1wYWdlcy80X2ltYWdlLWVmZmVjdHMvNC05X3NpbmdsZS1wYXNzLWJsdXIvZWZmZWN0LmZyYWdcblxuXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbnVuaWZvcm0gdmVjMiBkaXJlY3Rpb247XG51bmlmb3JtIHZlYzIgY2FudmFzU2l6ZTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuXG5mbG9hdCByYW5kb20odmVjMiBwKSB7XG4gIHZlYzMgcDMgID0gZnJhY3QodmVjMyhwLnh5eCkgKiAuMTAzMSk7XG4gIHAzICs9IGRvdChwMywgcDMueXp4ICsgMzMuMzMpO1xuICByZXR1cm4gZnJhY3QoKHAzLnggKyBwMy55KSAqIHAzLnopO1xufVxuXG4vLyBUaGlzIGlzbid0IGEgcmVhbCBHYXVzc2lhbiB3ZWlnaHQsIGl0J3MgYSBxdWFkcmF0aWMgd2VpZ2h0LiBJdCdzIHdoYXQgdGhlXG4vLyBDUFUgbW9kZSdzIGJsdXIgdXNlcyB0aG91Z2gsIHNvIHdlIGFsc28gdXNlIGl0IGhlcmUgdG8gbWF0Y2guXG5mbG9hdCBxdWFkV2VpZ2h0KGZsb2F0IHgsIGZsb2F0IGUpIHtcbiAgcmV0dXJuIHBvdyhlLWFicyh4KSwgMi4pO1xufVxuXG52b2lkIG1haW4oKXtcbiAgdmVjMiB1diA9IHZUZXhDb29yZDtcblxuICAvLyBBIHJlYXNvbmFibGUgbWF4aW11bSBudW1iZXIgb2Ygc2FtcGxlc1xuICBjb25zdCBmbG9hdCBtYXhTYW1wbGVzID0gNjQuMDtcblxuICBmbG9hdCBudW1TYW1wbGVzID0gZmxvb3IoNy4gKiByYWRpdXMpO1xuICBpZiAoZnJhY3QobnVtU2FtcGxlcyAvIDIuKSA9PSAwLikge1xuICAgIG51bVNhbXBsZXMrKztcbiAgfVxuICB2ZWM0IGF2ZyA9IHZlYzQoMC4wKTtcbiAgZmxvYXQgdG90YWwgPSAwLjA7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBzcGFjaW5nIHRvIGF2b2lkIHNrZXdpbmcgaWYgbnVtU2FtcGxlcyA+IG1heFNhbXBsZXNcbiAgZmxvYXQgc3BhY2luZyA9IDEuMDtcbiAgaWYgKG51bVNhbXBsZXMgPiBtYXhTYW1wbGVzKSB7XG4gICAgc3BhY2luZyA9IG51bVNhbXBsZXMgLyBtYXhTYW1wbGVzO1xuICAgIG51bVNhbXBsZXMgPSBtYXhTYW1wbGVzO1xuICB9XG5cbiAgZmxvYXQgcmFuZG9tT2Zmc2V0ID0gKHNwYWNpbmcgLSAxLjApICogbWl4KC0wLjUsIDAuNSwgcmFuZG9tKGdsX0ZyYWdDb29yZC54eSkpO1xuICBmb3IgKGZsb2F0IGkgPSAwLjA7IGkgPCBtYXhTYW1wbGVzOyBpKyspIHtcbiAgICBpZiAoaSA+PSBudW1TYW1wbGVzKSBicmVhaztcblxuICAgIGZsb2F0IHNhbXBsZSA9IGkgKiBzcGFjaW5nIC0gKG51bVNhbXBsZXMgLSAxLjApICogMC41ICogc3BhY2luZyArIHJhbmRvbU9mZnNldDtcbiAgICB2ZWMyIHNhbXBsZUNvb3JkID0gdXYgKyB2ZWMyKHNhbXBsZSwgc2FtcGxlKSAvIGNhbnZhc1NpemUgKiBkaXJlY3Rpb247XG4gICAgZmxvYXQgd2VpZ2h0ID0gcXVhZFdlaWdodChzYW1wbGUsIChudW1TYW1wbGVzIC0gMS4wKSAqIDAuNSAqIHNwYWNpbmcpO1xuXG4gICAgYXZnICs9IHdlaWdodCAqIHRleHR1cmUyRCh0ZXgwLCBzYW1wbGVDb29yZCk7XG4gICAgdG90YWwgKz0gd2VpZ2h0O1xuICB9XG5cbiAgYXZnIC89IHRvdGFsO1xuICBnbF9GcmFnQ29sb3IgPSBhdmc7XG59XG5gKSwgVChNLCBoLlBPU1RFUklaRSwgYC8vIExpbWl0IGNvbG9yIHNwYWNlIGZvciBhIHN0eWxpemVkIGNhcnRvb24gLyBwb3N0ZXIgZWZmZWN0XG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcbnVuaWZvcm0gZmxvYXQgZmlsdGVyUGFyYW1ldGVyO1xuXG52ZWMzIHF1YW50aXplKHZlYzMgY29sb3IsIGZsb2F0IG4pIHtcbiAgLy8gcmVzdHJpY3QgdmFsdWVzIHRvIE4gb3B0aW9ucy9iaW5zXG4gIC8vIGFuZCBmbG9vciBlYWNoIGNoYW5uZWwgdG8gbmVhcmVzdCB2YWx1ZVxuICAvL1xuICAvLyBlZy4gd2hlbiBOID0gNSwgdmFsdWVzID0gMC4wLCAwLjI1LCAwLjUwLCAwLjc1LCAxLjBcbiAgLy8gdGhlbiBxdWFudGl6ZSAoMC4xLCAwLjcsIDAuOSkgLT4gKDAuMCwgMC41LCAxLjApXG5cbiAgY29sb3IgPSBjb2xvciAqIG47XG4gIGNvbG9yID0gZmxvb3IoY29sb3IpO1xuICBjb2xvciA9IGNvbG9yIC8gKG4gLSAxLjApO1xuICByZXR1cm4gY29sb3I7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQpO1xuXG4gIHZlYzMgcmVzdHJpY3RlZENvbG9yID0gcXVhbnRpemUoY29sb3IucmdiIC8gY29sb3IuYSwgZmlsdGVyUGFyYW1ldGVyKTtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJlc3RyaWN0ZWRDb2xvci5yZ2IgKiBjb2xvci5hLCBjb2xvci5hKTtcbn1cbmApLCBUKE0sIGguT1BBUVVFLCBgLy8gU2V0IGFscGhhIGNoYW5uZWwgdG8gZW50aXJlbHkgb3BhcXVlXG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcblxudm9pZCBtYWluKCkge1xuICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHRleDAsIHZUZXhDb29yZCk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiIC8gY29sb3IuYSwgMS4wKTtcbn1cbmApLCBUKE0sIGguSU5WRVJULCBgLy8gU2V0IGVhY2ggcGl4ZWwgdG8gaW52ZXJzZSB2YWx1ZVxuLy8gTm90ZSB0aGF0IG9yaWdpbmFsIElOVkVSVCBkb2VzIG5vdCBjaGFuZ2UgdGhlIG9wYWNpdHksIHNvIHRoaXMgZm9sbG93cyBzdWl0XG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcblxudm9pZCBtYWluKCkge1xudmVjNCBjb2xvciA9IHRleHR1cmUyRCh0ZXgwLCB2VGV4Q29vcmQpO1xudmVjMyBvcmlnQ29sb3IgPSBjb2xvci5yZ2IgLyBjb2xvci5hO1xudmVjMyBpbnZlcnRlZENvbG9yID0gdmVjMygxLjApIC0gb3JpZ0NvbG9yO1xuZ2xfRnJhZ0NvbG9yID0gdmVjNChpbnZlcnRlZENvbG9yICogY29sb3IuYSwgY29sb3IuYSk7XG59XG5gKSwgVChNLCBoLlRIUkVTSE9MRCwgYC8vIENvbnZlcnQgcGl4ZWxzIHRvIGVpdGhlciB3aGl0ZSBvciBibGFjaywgXG4vLyBkZXBlbmRpbmcgb24gaWYgdGhlaXIgbHVtYSBpcyBhYm92ZSBvciBiZWxvdyBmaWx0ZXJQYXJhbWV0ZXJcblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xudW5pZm9ybSBmbG9hdCBmaWx0ZXJQYXJhbWV0ZXI7XG5cbmZsb2F0IGx1bWEodmVjMyBjb2xvcikge1xuICAvLyB3ZWlnaHRlZCBncmF5c2NhbGUgd2l0aCBsdW1pbmFuY2UgdmFsdWVzXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdlRleENvb3JkKTtcbiAgZmxvYXQgZ3JheSA9IGx1bWEoY29sb3IucmdiIC8gY29sb3IuYSk7XG4gIC8vIGZsb29yKCkgdXNlZCB0byBtYXRjaCBzcmMvaW1hZ2UvZmlsdGVycy5qc1xuICBmbG9hdCB0aHJlc2hvbGQgPSBmbG9vcihmaWx0ZXJQYXJhbWV0ZXIgKiAyNTUuMCkgLyAyNTUuMDtcbiAgZmxvYXQgYmxhY2tPcldoaXRlID0gc3RlcCh0aHJlc2hvbGQsIGdyYXkpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoYmxhY2tPcldoaXRlKSAqIGNvbG9yLmEsIGNvbG9yLmEpO1xufVxuYCk7XG4gICAgICB2YXIgRiA9IE07XG4gICAgICBmdW5jdGlvbiBWKFUsIFcsIGNlLCBuZSwgYiwgTywgRCwgQiwgWSwgSikge1xuICAgICAgICB2YXIgdGUgPSBXLmdldFBhcmFtZXRlcihXLkZSQU1FQlVGRkVSX0JJTkRJTkcpLCBjZSA9IChXLmJpbmRGcmFtZWJ1ZmZlcihXLkZSQU1FQlVGRkVSLCBjZSksIEIgPT09IFcuUkdCQSA/IDQgOiAzKSwgcmUgPSBPICogRCAqIGNlLCB1ZSA9IFkgPT09IFcuVU5TSUdORURfQllURSA/IFVpbnQ4QXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4gICAgICAgIGlmIChVIGluc3RhbmNlb2YgdWUgJiYgVS5sZW5ndGggPT09IHJlIHx8IChVID0gbmV3IHVlKHJlKSksIFcucmVhZFBpeGVscyhuZSwgSiA/IEogLSBiIC0gRCA6IGIsIE8sIEQsIEIsIFksIFUpLCBXLmJpbmRGcmFtZWJ1ZmZlcihXLkZSQU1FQlVGRkVSLCB0ZSksIEopXG4gICAgICAgICAgZm9yICh2YXIgbGUgPSBNYXRoLmZsb29yKEQgLyAyKSwgSyA9IG5ldyB1ZShPICogY2UpLCBhZSA9IDA7IGFlIDwgbGU7IGFlKyspIHtcbiAgICAgICAgICAgIHZhciBoZSA9IGFlICogTyAqIDQsIF9lID0gKEQgLSBhZSAtIDEpICogTyAqIDQ7XG4gICAgICAgICAgICBLLnNldChVLnN1YmFycmF5KGhlLCBoZSArIDQgKiBPKSksIFUuY29weVdpdGhpbihoZSwgX2UsIF9lICsgNCAqIE8pLCBVLnNldChLLCBfZSk7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gVTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEcoVSwgWSwgWCwgbmUsIGIsIE8sIEQpIHtcbiAgICAgICAgdmFyIEIgPSBVLmdldFBhcmFtZXRlcihVLkZSQU1FQlVGRkVSX0JJTkRJTkcpLCBZID0gKFUuYmluZEZyYW1lYnVmZmVyKFUuRlJBTUVCVUZGRVIsIFkpLCBiID09PSBVLlJHQkEgPyA0IDogMyksIFkgPSBuZXcgKE8gPT09IFUuVU5TSUdORURfQllURSA/IFVpbnQ4QXJyYXkgOiBGbG9hdDMyQXJyYXkpKFkpO1xuICAgICAgICByZXR1cm4gVS5yZWFkUGl4ZWxzKFgsIEQgPyBEIC0gbmUgLSAxIDogbmUsIDEsIDEsIGIsIE8sIFkpLCBVLmJpbmRGcmFtZWJ1ZmZlcihVLkZSQU1FQlVGRkVSLCBCKSwgQXJyYXkuZnJvbShZKTtcbiAgICAgIH1cbiAgICAgIHUuZGVmYXVsdC5wcm90b3R5cGUuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKFUsIFcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dsQXR0cmlidXRlcyA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIHNldEF0dHJpYnV0ZXMgb24gYSBwNS5HcmFwaGljcyBvYmplY3QgdGhhdCBkb2VzIG5vdCB1c2UgYSBXRUJHTCByZW5kZXJlci5cIik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBYID0gITA7XG4gICAgICAgICAgaWYgKFcgIT09IHZvaWQgMCA/ICh0aGlzLl9nbEF0dHJpYnV0ZXMgPT09IG51bGwgJiYgKHRoaXMuX2dsQXR0cmlidXRlcyA9IHt9KSwgdGhpcy5fZ2xBdHRyaWJ1dGVzW1VdICE9PSBXICYmICh0aGlzLl9nbEF0dHJpYnV0ZXNbVV0gPSBXLCBYID0gITEpKSA6IFUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdGhpcy5fZ2xBdHRyaWJ1dGVzICE9PSBVICYmICh0aGlzLl9nbEF0dHJpYnV0ZXMgPSBVLCBYID0gITEpLCB0aGlzLl9yZW5kZXJlci5pc1AzRCAmJiAhWCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXR1cERvbmUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmUgaW4gdGhpcy5fcmVuZGVyZXIucmV0YWluZWRNb2RlLmdlb21ldHJ5KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlci5yZXRhaW5lZE1vZGUuZ2VvbWV0cnkuaGFzT3duUHJvcGVydHkobmUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgdS5kZWZhdWx0Ll9mcmllbmRseUVycm9yKFwiU29ycnksIENvdWxkIG5vdCBzZXQgdGhlIGF0dHJpYnV0ZXMsIHlvdSBuZWVkIHRvIGNhbGwgc2V0QXR0cmlidXRlcygpIGJlZm9yZSBjYWxsaW5nIHRoZSBvdGhlciBkcmF3aW5nIG1ldGhvZHMgaW4gc2V0dXAoKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaCgpLCB0aGlzLl9yZW5kZXJlci5fcmVzZXRDb250ZXh0KCksIHRoaXMucG9wKCksIHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEgJiYgKHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEuX3JlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdS5kZWZhdWx0LlJlbmRlcmVyR0wgPSBmdW5jdGlvbihVKSB7XG4gICAgICAgIHZhciBXID0gbmU7XG4gICAgICAgIGlmICh0eXBlb2YgVSAhPSBcImZ1bmN0aW9uXCIgJiYgVSAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIFcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVICYmIFUucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgVSAmJiBhKFcsIFUpO1xuICAgICAgICB2YXIgWCA9IGMobmUpO1xuICAgICAgICBmdW5jdGlvbiBuZShiLCBPLCBELCBCKSB7XG4gICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBuZSlcbiAgICAgICAgICAgIHJldHVybiAoYiA9IFguY2FsbCh0aGlzLCBiLCBPLCBEKSkuX3NldEF0dHJpYnV0ZURlZmF1bHRzKE8pLCBiLl9pbml0Q29udGV4dCgpLCBiLmlzUDNEID0gITAsIGIuZ2VvbWV0cnlCdWlsZGVyID0gdm9pZCAwLCBiLkdMID0gYi5kcmF3aW5nQ29udGV4dCwgYi5fcEluc3QuX3NldFByb3BlcnR5KFwiZHJhd2luZ0NvbnRleHRcIiwgYi5kcmF3aW5nQ29udGV4dCksIGIuX2lzRXJhc2luZyA9ICExLCBiLl9jbGlwRGVwdGhzID0gW10sIGIuX2lzQ2xpcEFwcGxpZWQgPSAhMSwgYi5fc3RlbmNpbFRlc3RPbiA9ICExLCBiLl9lbmFibGVMaWdodGluZyA9ICExLCBiLmFtYmllbnRMaWdodENvbG9ycyA9IFtdLCBiLm1peGVkQW1iaWVudExpZ2h0ID0gW10sIGIubWl4ZWRTcGVjdWxhckNvbG9yID0gW10sIGIuc3BlY3VsYXJDb2xvcnMgPSBbMSwgMSwgMV0sIGIuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbnMgPSBbXSwgYi5kaXJlY3Rpb25hbExpZ2h0RGlmZnVzZUNvbG9ycyA9IFtdLCBiLmRpcmVjdGlvbmFsTGlnaHRTcGVjdWxhckNvbG9ycyA9IFtdLCBiLnBvaW50TGlnaHRQb3NpdGlvbnMgPSBbXSwgYi5wb2ludExpZ2h0RGlmZnVzZUNvbG9ycyA9IFtdLCBiLnBvaW50TGlnaHRTcGVjdWxhckNvbG9ycyA9IFtdLCBiLnNwb3RMaWdodFBvc2l0aW9ucyA9IFtdLCBiLnNwb3RMaWdodERpcmVjdGlvbnMgPSBbXSwgYi5zcG90TGlnaHREaWZmdXNlQ29sb3JzID0gW10sIGIuc3BvdExpZ2h0U3BlY3VsYXJDb2xvcnMgPSBbXSwgYi5zcG90TGlnaHRBbmdsZSA9IFtdLCBiLnNwb3RMaWdodENvbmMgPSBbXSwgYi5hY3RpdmVJbWFnZUxpZ2h0ID0gbnVsbCwgYi5kaWZmdXNlZFRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgYi5zcGVjdWxhclRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgYi5kcmF3TW9kZSA9IGguRklMTCwgYi5jdXJGaWxsQ29sb3IgPSBiLl9jYWNoZWRGaWxsU3R5bGUgPSBbMSwgMSwgMSwgMV0sIGIuY3VyQW1iaWVudENvbG9yID0gYi5fY2FjaGVkRmlsbFN0eWxlID0gWzEsIDEsIDEsIDFdLCBiLmN1clNwZWN1bGFyQ29sb3IgPSBiLl9jYWNoZWRGaWxsU3R5bGUgPSBbMCwgMCwgMCwgMF0sIGIuY3VyRW1pc3NpdmVDb2xvciA9IGIuX2NhY2hlZEZpbGxTdHlsZSA9IFswLCAwLCAwLCAwXSwgYi5jdXJTdHJva2VDb2xvciA9IGIuX2NhY2hlZFN0cm9rZVN0eWxlID0gWzAsIDAsIDAsIDFdLCBiLmN1ckJsZW5kTW9kZSA9IGguQkxFTkQsIGIucHJlRXJhc2VCbGVuZCA9IHZvaWQgMCwgYi5fY2FjaGVkQmxlbmRNb2RlID0gdm9pZCAwLCBiLndlYmdsVmVyc2lvbiA9PT0gaC5XRUJHTDIgPyBiLmJsZW5kRXh0ID0gYi5HTCA6IGIuYmxlbmRFeHQgPSBiLkdMLmdldEV4dGVuc2lvbihcIkVYVF9ibGVuZF9taW5tYXhcIiksIGIuX2lzQmxlbmRpbmcgPSAhMSwgYi5faGFzU2V0QW1iaWVudCA9ICExLCBiLl91c2VTcGVjdWxhck1hdGVyaWFsID0gITEsIGIuX3VzZUVtaXNzaXZlTWF0ZXJpYWwgPSAhMSwgYi5fdXNlTm9ybWFsTWF0ZXJpYWwgPSAhMSwgYi5fdXNlU2hpbmluZXNzID0gMSwgYi5fdXNlTWV0YWxuZXNzID0gMCwgYi5fdXNlTGluZUNvbG9yID0gITEsIGIuX3VzZVZlcnRleENvbG9yID0gITEsIGIucmVnaXN0ZXJFbmFibGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgYi5fdGludCA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdLCBiLmNvbnN0YW50QXR0ZW51YXRpb24gPSAxLCBiLmxpbmVhckF0dGVudWF0aW9uID0gMCwgYi5xdWFkcmF0aWNBdHRlbnVhdGlvbiA9IDAsIGIudU1WTWF0cml4ID0gbmV3IHUuZGVmYXVsdC5NYXRyaXgoKSwgYi51UE1hdHJpeCA9IG5ldyB1LmRlZmF1bHQuTWF0cml4KCksIGIudU5NYXRyaXggPSBuZXcgdS5kZWZhdWx0Lk1hdHJpeChcIm1hdDNcIiksIGIuY3VyTWF0cml4ID0gbmV3IHUuZGVmYXVsdC5NYXRyaXgoXCJtYXQzXCIpLCBiLl9jdXJyZW50Tm9ybWFsID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMCwgMSksIGIuX2N1ckNhbWVyYSA9IG5ldyB1LmRlZmF1bHQuQ2FtZXJhKHAoYikpLCBiLl9jdXJDYW1lcmEuX2NvbXB1dGVDYW1lcmFEZWZhdWx0U2V0dGluZ3MoKSwgYi5fY3VyQ2FtZXJhLl9zZXREZWZhdWx0Q2FtZXJhKCksIGIuZmlsdGVyQ2FtZXJhID0gbmV3IHUuZGVmYXVsdC5DYW1lcmEocChiKSksIGIuZmlsdGVyQ2FtZXJhLl9jb21wdXRlQ2FtZXJhRGVmYXVsdFNldHRpbmdzKCksIGIuZmlsdGVyQ2FtZXJhLl9zZXREZWZhdWx0Q2FtZXJhKCksIGIucHJldlRvdWNoZXMgPSBbXSwgYi56b29tVmVsb2NpdHkgPSAwLCBiLnJvdGF0ZVZlbG9jaXR5ID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMCksIGIubW92ZVZlbG9jaXR5ID0gbmV3IHUuZGVmYXVsdC5WZWN0b3IoMCwgMCksIGIuZXhlY3V0ZVpvb20gPSAhMSwgYi5leGVjdXRlUm90YXRlQW5kTW92ZSA9ICExLCBiLnNwZWN1bGFyU2hhZGVyID0gdm9pZCAwLCBiLnNwaGVyZU1hcHBpbmcgPSB2b2lkIDAsIGIuZGlmZnVzZWRTaGFkZXIgPSB2b2lkIDAsIGIuX2RlZmF1bHRMaWdodFNoYWRlciA9IHZvaWQgMCwgYi5fZGVmYXVsdEltbWVkaWF0ZU1vZGVTaGFkZXIgPSB2b2lkIDAsIGIuX2RlZmF1bHROb3JtYWxTaGFkZXIgPSB2b2lkIDAsIGIuX2RlZmF1bHRDb2xvclNoYWRlciA9IHZvaWQgMCwgYi5fZGVmYXVsdFBvaW50U2hhZGVyID0gdm9pZCAwLCBiLnVzZXJGaWxsU2hhZGVyID0gdm9pZCAwLCBiLnVzZXJTdHJva2VTaGFkZXIgPSB2b2lkIDAsIGIudXNlclBvaW50U2hhZGVyID0gdm9pZCAwLCBiLnJldGFpbmVkTW9kZSA9IHsgZ2VvbWV0cnk6IHt9LCBidWZmZXJzOiB7IHN0cm9rZTogW25ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDQsIFwibGluZVZlcnRleENvbG9yc1wiLCBcImxpbmVDb2xvckJ1ZmZlclwiLCBcImFWZXJ0ZXhDb2xvclwiLCBwKGIpKSwgbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMywgXCJsaW5lVmVydGljZXNcIiwgXCJsaW5lVmVydGljZXNCdWZmZXJcIiwgXCJhUG9zaXRpb25cIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwibGluZVRhbmdlbnRzSW5cIiwgXCJsaW5lVGFuZ2VudHNJbkJ1ZmZlclwiLCBcImFUYW5nZW50SW5cIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwibGluZVRhbmdlbnRzT3V0XCIsIFwibGluZVRhbmdlbnRzT3V0QnVmZmVyXCIsIFwiYVRhbmdlbnRPdXRcIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDEsIFwibGluZVNpZGVzXCIsIFwibGluZVNpZGVzQnVmZmVyXCIsIFwiYVNpZGVcIiwgcChiKSldLCBmaWxsOiBbbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMywgXCJ2ZXJ0aWNlc1wiLCBcInZlcnRleEJ1ZmZlclwiLCBcImFQb3NpdGlvblwiLCBwKGIpLCBiLl92VG9OQXJyYXkpLCBuZXcgdS5kZWZhdWx0LlJlbmRlckJ1ZmZlcigzLCBcInZlcnRleE5vcm1hbHNcIiwgXCJub3JtYWxCdWZmZXJcIiwgXCJhTm9ybWFsXCIsIHAoYiksIGIuX3ZUb05BcnJheSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDQsIFwidmVydGV4Q29sb3JzXCIsIFwiY29sb3JCdWZmZXJcIiwgXCJhVmVydGV4Q29sb3JcIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwidmVydGV4QW1iaWVudHNcIiwgXCJhbWJpZW50QnVmZmVyXCIsIFwiYUFtYmllbnRDb2xvclwiLCBwKGIpKSwgbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMiwgXCJ1dnNcIiwgXCJ1dkJ1ZmZlclwiLCBcImFUZXhDb29yZFwiLCBwKGIpLCBiLl9mbGF0dGVuKV0sIHRleHQ6IFtuZXcgdS5kZWZhdWx0LlJlbmRlckJ1ZmZlcigzLCBcInZlcnRpY2VzXCIsIFwidmVydGV4QnVmZmVyXCIsIFwiYVBvc2l0aW9uXCIsIHAoYiksIGIuX3ZUb05BcnJheSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDIsIFwidXZzXCIsIFwidXZCdWZmZXJcIiwgXCJhVGV4Q29vcmRcIiwgcChiKSwgYi5fZmxhdHRlbildIH0gfSwgYi5pbW1lZGlhdGVNb2RlID0geyBnZW9tZXRyeTogbmV3IHUuZGVmYXVsdC5HZW9tZXRyeSgpLCBzaGFwZU1vZGU6IGguVFJJQU5HTEVfRkFOLCBjb250b3VySW5kaWNlczogW10sIF9iZXppZXJWZXJ0ZXg6IFtdLCBfcXVhZHJhdGljVmVydGV4OiBbXSwgX2N1cnZlVmVydGV4OiBbXSwgYnVmZmVyczogeyBmaWxsOiBbbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMywgXCJ2ZXJ0aWNlc1wiLCBcInZlcnRleEJ1ZmZlclwiLCBcImFQb3NpdGlvblwiLCBwKGIpLCBiLl92VG9OQXJyYXkpLCBuZXcgdS5kZWZhdWx0LlJlbmRlckJ1ZmZlcigzLCBcInZlcnRleE5vcm1hbHNcIiwgXCJub3JtYWxCdWZmZXJcIiwgXCJhTm9ybWFsXCIsIHAoYiksIGIuX3ZUb05BcnJheSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDQsIFwidmVydGV4Q29sb3JzXCIsIFwiY29sb3JCdWZmZXJcIiwgXCJhVmVydGV4Q29sb3JcIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwidmVydGV4QW1iaWVudHNcIiwgXCJhbWJpZW50QnVmZmVyXCIsIFwiYUFtYmllbnRDb2xvclwiLCBwKGIpKSwgbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMiwgXCJ1dnNcIiwgXCJ1dkJ1ZmZlclwiLCBcImFUZXhDb29yZFwiLCBwKGIpLCBiLl9mbGF0dGVuKV0sIHN0cm9rZTogW25ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDQsIFwibGluZVZlcnRleENvbG9yc1wiLCBcImxpbmVDb2xvckJ1ZmZlclwiLCBcImFWZXJ0ZXhDb2xvclwiLCBwKGIpKSwgbmV3IHUuZGVmYXVsdC5SZW5kZXJCdWZmZXIoMywgXCJsaW5lVmVydGljZXNcIiwgXCJsaW5lVmVydGljZXNCdWZmZXJcIiwgXCJhUG9zaXRpb25cIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwibGluZVRhbmdlbnRzSW5cIiwgXCJsaW5lVGFuZ2VudHNJbkJ1ZmZlclwiLCBcImFUYW5nZW50SW5cIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDMsIFwibGluZVRhbmdlbnRzT3V0XCIsIFwibGluZVRhbmdlbnRzT3V0QnVmZmVyXCIsIFwiYVRhbmdlbnRPdXRcIiwgcChiKSksIG5ldyB1LmRlZmF1bHQuUmVuZGVyQnVmZmVyKDEsIFwibGluZVNpZGVzXCIsIFwibGluZVNpZGVzQnVmZmVyXCIsIFwiYVNpZGVcIiwgcChiKSldLCBwb2ludDogYi5HTC5jcmVhdGVCdWZmZXIoKSB9IH0sIGIucG9pbnRTaXplID0gNSwgYi5jdXJTdHJva2VXZWlnaHQgPSAxLCBiLmN1clN0cm9rZUNhcCA9IGguUk9VTkQsIGIuY3VyU3Ryb2tlSm9pbiA9IGguUk9VTkQsIGIudGV4dHVyZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBiLmZyYW1lYnVmZmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGIuYWN0aXZlRnJhbWVidWZmZXJzID0gW10sIGIuZmlsdGVyU2hhZGVyID0gdm9pZCAwLCBiLmZpbHRlckxheWVyID0gdm9pZCAwLCBiLmZpbHRlckxheWVyVGVtcCA9IHZvaWQgMCwgYi5kZWZhdWx0RmlsdGVyU2hhZGVycyA9IHt9LCBiLnRleHR1cmVNb2RlID0gaC5JTUFHRSwgYi50ZXh0dXJlV3JhcFggPSBoLkNMQU1QLCBiLnRleHR1cmVXcmFwWSA9IGguQ0xBTVAsIGIuX3RleCA9IG51bGwsIGIuX2N1cnZlVGlnaHRuZXNzID0gNiwgYi5fbG9va1VwVGFibGVCZXppZXIgPSBbXSwgYi5fbG9va1VwVGFibGVRdWFkcmF0aWMgPSBbXSwgYi5fbHV0QmV6aWVyRGV0YWlsID0gMCwgYi5fbHV0UXVhZHJhdGljRGV0YWlsID0gMCwgYi5pc1Byb2Nlc3NpbmdWZXJ0aWNlcyA9ICExLCBiLl90ZXNzeSA9IGIuX2luaXRUZXNzeSgpLCBiLmZvbnRJbmZvcyA9IHt9LCBiLl9jdXJTaGFkZXIgPSB2b2lkIDAsIGI7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVyA9IG5lLCAoVSA9IFt7IGtleTogXCJiZWdpbkdlb21ldHJ5XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZW9tZXRyeUJ1aWxkZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIGBiZWdpbkdlb21ldHJ5KClgIGlzIGJlaW5nIGNhbGxlZCB3aGlsZSBhbm90aGVyIHA1Lkdlb21ldHJ5IGlzIGFscmVhZHkgYmVpbmcgYnVpbGQuXCIpO1xuICAgICAgICAgIHRoaXMuZ2VvbWV0cnlCdWlsZGVyID0gbmV3IGcuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlbmRHZW9tZXRyeVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGI7XG4gICAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnlCdWlsZGVyKVxuICAgICAgICAgICAgcmV0dXJuIGIgPSB0aGlzLmdlb21ldHJ5QnVpbGRlci5maW5pc2goKSwgdGhpcy5nZW9tZXRyeUJ1aWxkZXIgPSB2b2lkIDAsIGI7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFrZSBzdXJlIHlvdSBjYWxsIGJlZ2luR2VvbWV0cnkoKSBiZWZvcmUgZW5kR2VvbWV0cnkoKSFcIik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYnVpbGRHZW9tZXRyeVwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJlZ2luR2VvbWV0cnkoKSwgYigpLCB0aGlzLmVuZEdlb21ldHJ5KCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NldEF0dHJpYnV0ZURlZmF1bHRzXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgdmFyIE8gPSB7IGFscGhhOiAhMCwgZGVwdGg6ICEwLCBzdGVuY2lsOiAhMCwgYW50aWFsaWFzOiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzYWZhcmlcIiksIHByZW11bHRpcGxpZWRBbHBoYTogITAsIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogITAsIHBlclBpeGVsTGlnaHRpbmc6ICEwLCB2ZXJzaW9uOiAyIH07XG4gICAgICAgICAgYi5fZ2xBdHRyaWJ1dGVzID09PSBudWxsID8gYi5fZ2xBdHRyaWJ1dGVzID0gTyA6IGIuX2dsQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oTywgYi5fZ2xBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfaW5pdENvbnRleHRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLnZlcnNpb24gIT09IDEgJiYgKHRoaXMuZHJhd2luZ0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHRoaXMuX3BJbnN0Ll9nbEF0dHJpYnV0ZXMpKSwgdGhpcy53ZWJnbFZlcnNpb24gPSB0aGlzLmRyYXdpbmdDb250ZXh0ID8gaC5XRUJHTDIgOiBoLldFQkdMLCB0aGlzLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJ3ZWJnbFZlcnNpb25cIiwgdGhpcy53ZWJnbFZlcnNpb24pLCB0aGlzLmRyYXdpbmdDb250ZXh0IHx8ICh0aGlzLmRyYXdpbmdDb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHRoaXMuX3BJbnN0Ll9nbEF0dHJpYnV0ZXMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgdGhpcy5fcEluc3QuX2dsQXR0cmlidXRlcykpLCB0aGlzLmRyYXdpbmdDb250ZXh0ID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgd2ViZ2wgY29udGV4dFwiKTtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMuZHJhd2luZ0NvbnRleHQ7XG4gICAgICAgICAgYi5lbmFibGUoYi5ERVBUSF9URVNUKSwgYi5kZXB0aEZ1bmMoYi5MRVFVQUwpLCBiLnZpZXdwb3J0KDAsIDAsIGIuZHJhd2luZ0J1ZmZlcldpZHRoLCBiLmRyYXdpbmdCdWZmZXJIZWlnaHQpLCBiLnBpeGVsU3RvcmVpKGIuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCAhMCksIHRoaXMuX3ZpZXdwb3J0ID0gdGhpcy5kcmF3aW5nQ29udGV4dC5nZXRQYXJhbWV0ZXIodGhpcy5kcmF3aW5nQ29udGV4dC5WSUVXUE9SVCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldFBhcmFtXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMuZHJhd2luZ0NvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGIuZ2V0UGFyYW1ldGVyKGIuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2FkanVzdERpbWVuc2lvbnNcIiwgdmFsdWU6IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICB0aGlzLl9tYXhUZXh0dXJlU2l6ZSB8fCAodGhpcy5fbWF4VGV4dHVyZVNpemUgPSB0aGlzLl9nZXRQYXJhbSgpKTtcbiAgICAgICAgICB2YXIgQiA9IHRoaXMuX21heFRleHR1cmVTaXplLCBCID0gKHUuZGVmYXVsdC5wcm90b3R5cGUuX21heEFsbG93ZWRQaXhlbERpbWVuc2lvbnMsIE1hdGguZmxvb3IoQiAvIHRoaXMucGl4ZWxEZW5zaXR5KCkpKSwgRCA9IE1hdGgubWluKGIsIEIpLCBCID0gTWF0aC5taW4oTywgQik7XG4gICAgICAgICAgcmV0dXJuIEQgPT09IGIgJiYgQiA9PT0gTyB8fCBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgcmVxdWVzdGVkIHdpZHRoL2hlaWdodCBleGNlZWRzIGhhcmR3YXJlIGxpbWl0cy4gXCIgKyBcIkFkanVzdGluZyBkaW1lbnNpb25zIHRvIHdpZHRoOiBcIi5jb25jYXQoRCwgXCIsIGhlaWdodDogXCIpLmNvbmNhdChCLCBcIi5cIikpLCB7IGFkanVzdGVkV2lkdGg6IEQsIGFkanVzdGVkSGVpZ2h0OiBCIH07XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3Jlc2V0Q29udGV4dFwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHZhciBELCBCID0gdGhpcy53aWR0aCwgWSA9IHRoaXMuaGVpZ2h0LCB0ZSA9IHRoaXMuY2FudmFzLmlkLCBKID0gdGhpcy5fcEluc3QgaW5zdGFuY2VvZiB1LmRlZmF1bHQuR3JhcGhpY3MsIHRlID0gKEogPyAoKEQgPSB0aGlzLl9wSW5zdCkuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoRC5jYW52YXMpLCBELmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIChELl9wSW5zdC5fdXNlck5vZGUgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoRC5jYW52YXMpLCB1LmRlZmF1bHQuRWxlbWVudC5jYWxsKEQsIEQuY2FudmFzLCBELl9wSW5zdCksIEQud2lkdGggPSBCLCBELmhlaWdodCA9IFkpIDogKChEID0gdGhpcy5jYW52YXMpICYmIEQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChEKSwgKEQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKS5pZCA9IHRlLCAodGhpcy5fcEluc3QuX3VzZXJOb2RlIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKEQpLCB0aGlzLl9wSW5zdC5jYW52YXMgPSBELCB0aGlzLmNhbnZhcyA9IEQpLCBuZXcgdS5kZWZhdWx0LlJlbmRlcmVyR0wodGhpcy5fcEluc3QuY2FudmFzLCB0aGlzLl9wSW5zdCwgIUopKTtcbiAgICAgICAgICB0aGlzLl9wSW5zdC5fc2V0UHJvcGVydHkoXCJfcmVuZGVyZXJcIiwgdGUpLCB0ZS5yZXNpemUoQiwgWSksIHRlLl9hcHBseURlZmF1bHRzKCksIEogfHwgdGhpcy5fcEluc3QuX2VsZW1lbnRzLnB1c2godGUpLCB0eXBlb2YgTyA9PSBcImZ1bmN0aW9uXCIgJiYgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE8uYXBwbHkod2luZG93Ll9yZW5kZXJlciwgYik7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3VwZGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51TVZNYXRyaXguc2V0KHRoaXMuX2N1ckNhbWVyYS5jYW1lcmFNYXRyaXgpLCB0aGlzLmFtYmllbnRMaWdodENvbG9ycy5sZW5ndGggPSAwLCB0aGlzLnNwZWN1bGFyQ29sb3JzID0gWzEsIDEsIDFdLCB0aGlzLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25zLmxlbmd0aCA9IDAsIHRoaXMuZGlyZWN0aW9uYWxMaWdodERpZmZ1c2VDb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5kaXJlY3Rpb25hbExpZ2h0U3BlY3VsYXJDb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5wb2ludExpZ2h0UG9zaXRpb25zLmxlbmd0aCA9IDAsIHRoaXMucG9pbnRMaWdodERpZmZ1c2VDb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5wb2ludExpZ2h0U3BlY3VsYXJDb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5zcG90TGlnaHRQb3NpdGlvbnMubGVuZ3RoID0gMCwgdGhpcy5zcG90TGlnaHREaXJlY3Rpb25zLmxlbmd0aCA9IDAsIHRoaXMuc3BvdExpZ2h0RGlmZnVzZUNvbG9ycy5sZW5ndGggPSAwLCB0aGlzLnNwb3RMaWdodFNwZWN1bGFyQ29sb3JzLmxlbmd0aCA9IDAsIHRoaXMuc3BvdExpZ2h0QW5nbGUubGVuZ3RoID0gMCwgdGhpcy5zcG90TGlnaHRDb25jLmxlbmd0aCA9IDAsIHRoaXMuX2VuYWJsZUxpZ2h0aW5nID0gITEsIHRoaXMuX3RpbnQgPSBbMjU1LCAyNTUsIDI1NSwgMjU1XSwgdGhpcy5HTC5jbGVhclN0ZW5jaWwoMCksIHRoaXMuR0wuY2xlYXIodGhpcy5HTC5ERVBUSF9CVUZGRVJfQklUIHwgdGhpcy5HTC5TVEVOQ0lMX0JVRkZFUl9CSVQpLCB0aGlzLkdMLmRpc2FibGUodGhpcy5HTC5TVEVOQ0lMX1RFU1QpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImJhY2tncm91bmRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBCID0gKEIgPSB0aGlzLl9wSW5zdCkuY29sb3IuYXBwbHkoQiwgYXJndW1lbnRzKSwgYiA9IEIubGV2ZWxzWzBdIC8gMjU1LCBPID0gQi5sZXZlbHNbMV0gLyAyNTUsIEQgPSBCLmxldmVsc1syXSAvIDI1NSwgQiA9IEIubGV2ZWxzWzNdIC8gMjU1O1xuICAgICAgICAgIHRoaXMuY2xlYXIoYiwgTywgRCwgQik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZmlsbFwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTywgRCwgQikge1xuICAgICAgICAgIHZhciBZID0gdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvci5hcHBseSh0aGlzLl9wSW5zdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLmN1ckZpbGxDb2xvciA9IFkuX2FycmF5LCB0aGlzLmRyYXdNb2RlID0gaC5GSUxMLCB0aGlzLl91c2VOb3JtYWxNYXRlcmlhbCA9ICExLCB0aGlzLl90ZXggPSBudWxsO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0cm9rZVwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTywgRCwgQikge1xuICAgICAgICAgIHZhciBZID0gdS5kZWZhdWx0LnByb3RvdHlwZS5jb2xvci5hcHBseSh0aGlzLl9wSW5zdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLmN1clN0cm9rZUNvbG9yID0gWS5fYXJyYXk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic3Ryb2tlQ2FwXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgdGhpcy5jdXJTdHJva2VDYXAgPSBiO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0cm9rZUpvaW5cIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICB0aGlzLmN1clN0cm9rZUpvaW4gPSBiO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldEZpbHRlckxheWVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJMYXllciB8fCAodGhpcy5maWx0ZXJMYXllciA9IHRoaXMuX3BJbnN0LmNyZWF0ZUZyYW1lYnVmZmVyKCkpLCB0aGlzLmZpbHRlckxheWVyO1xuICAgICAgICB9IH0sIHsga2V5OiBcImdldEZpbHRlckxheWVyVGVtcFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyTGF5ZXJUZW1wIHx8ICh0aGlzLmZpbHRlckxheWVyVGVtcCA9IHRoaXMuX3BJbnN0LmNyZWF0ZUZyYW1lYnVmZmVyKCkpLCB0aGlzLmZpbHRlckxheWVyVGVtcDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJtYXRjaFNpemVcIiwgdmFsdWU6IGZ1bmN0aW9uKGIsIE8pIHtcbiAgICAgICAgICBiLndpZHRoID09PSBPLndpZHRoICYmIGIuaGVpZ2h0ID09PSBPLmhlaWdodCB8fCBiLnJlc2l6ZShPLndpZHRoLCBPLmhlaWdodCksIGIucGl4ZWxEZW5zaXR5KCkgIT09IE8ucGl4ZWxEZW5zaXR5KCkgJiYgYi5waXhlbERlbnNpdHkoTy5waXhlbERlbnNpdHkoKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZmlsdGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiwgTywgRCA9IHRoaXMsIEIgPSB0aGlzLmdldEZpbHRlckxheWVyKCksIFkgPSB2b2lkIDAsIEogPSB2b2lkIDAsIHRlID0gKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSA9PSBcInN0cmluZ1wiID8gKEogPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIFQoYiA9IHt9LCBoLkJMVVIsIDMpLCBUKGIsIGguUE9TVEVSSVpFLCA0KSwgVChiLCBoLlRIUkVTSE9MRCwgMC41KSwgWSA9IEogaW4gKGIgPSBiKSAmJiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdm9pZCAwIDogYXJndW1lbnRzWzFdKSA9PT0gdm9pZCAwID8gYltKXSA6IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHZvaWQgMCA6IGFyZ3VtZW50c1sxXSwgSiBpbiB0aGlzLmRlZmF1bHRGaWx0ZXJTaGFkZXJzIHx8ICh0aGlzLmRlZmF1bHRGaWx0ZXJTaGFkZXJzW0pdID0gbmV3IHUuZGVmYXVsdC5TaGFkZXIoQi5fcmVuZGVyZXIsIGB1bmlmb3JtIG1hdDQgdU1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcblxuYXR0cmlidXRlIHZlYzMgYVBvc2l0aW9uO1xuLy8gdGV4Y29vcmRzIG9ubHkgY29tZSBmcm9tIHA1IHRvIHZlcnRleCBzaGFkZXJcbi8vIHNvIHBhc3MgdGV4Y29vcmRzIG9uIHRvIHRoZSBmcmFnbWVudCBzaGFkZXIgaW4gYSB2YXJ5aW5nIHZhcmlhYmxlXG5hdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xuXG52b2lkIG1haW4oKSB7XG4gIC8vIHRyYW5zZmVycmluZyB0ZXhjb29yZHMgZm9yIHRoZSBmcmFnIHNoYWRlclxuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG5cbiAgLy8gY29weSBwb3NpdGlvbiB3aXRoIGEgZm91cnRoIGNvb3JkaW5hdGUgZm9yIHByb2plY3Rpb24gKDEuMCBpcyBub3JtYWwpXG4gIHZlYzQgcG9zaXRpb25WZWM0ID0gdmVjNChhUG9zaXRpb24sIDEuMCk7XG5cbiAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVNb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvblZlYzQ7XG59XG5gLCBGW0pdKSksIHRoaXMuZmlsdGVyU2hhZGVyID0gdGhpcy5kZWZhdWx0RmlsdGVyU2hhZGVyc1tKXSkgOiB0aGlzLmZpbHRlclNoYWRlciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSwgdGhpcy5hY3RpdmVGcmFtZWJ1ZmZlcigpIHx8IHRoaXMpLCBjZSA9ICh0aGlzLm1hdGNoU2l6ZShCLCB0ZSksIEIuZHJhdyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBELl9wSW5zdC5jbGVhcigpO1xuICAgICAgICAgIH0pLCBbMSAvICh0ZS53aWR0aCAqIHRlLnBpeGVsRGVuc2l0eSgpKSwgMSAvICh0ZS5oZWlnaHQgKiB0ZS5waXhlbERlbnNpdHkoKSldKTtcbiAgICAgICAgICBKID09PSBoLkJMVVIgPyAoTyA9IHRoaXMuZ2V0RmlsdGVyTGF5ZXJUZW1wKCksIHRoaXMubWF0Y2hTaXplKE8sIHRlKSwgdGhpcy5fcEluc3QucHVzaCgpLCB0aGlzLl9wSW5zdC5ub1N0cm9rZSgpLCB0aGlzLl9wSW5zdC5ibGVuZE1vZGUoaC5CTEVORCksIHRoaXMuX3BJbnN0LnNoYWRlcih0aGlzLmZpbHRlclNoYWRlciksIHRoaXMuZmlsdGVyU2hhZGVyLnNldFVuaWZvcm0oXCJ0ZXhlbFNpemVcIiwgY2UpLCB0aGlzLmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwiY2FudmFzU2l6ZVwiLCBbdGUud2lkdGgsIHRlLmhlaWdodF0pLCB0aGlzLmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwicmFkaXVzXCIsIE1hdGgubWF4KDEsIFkpKSwgTy5kcmF3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgRC5maWx0ZXJTaGFkZXIuc2V0VW5pZm9ybShcImRpcmVjdGlvblwiLCBbMSwgMF0pLCBELmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwidGV4MFwiLCB0ZSksIEQuX3BJbnN0LmNsZWFyKCksIEQuX3BJbnN0LnNoYWRlcihELmZpbHRlclNoYWRlciksIEQuX3BJbnN0Lm5vTGlnaHRzKCksIEQuX3BJbnN0LnBsYW5lKHRlLndpZHRoLCB0ZS5oZWlnaHQpO1xuICAgICAgICAgIH0pLCBCLmRyYXcoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBELmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwiZGlyZWN0aW9uXCIsIFswLCAxXSksIEQuZmlsdGVyU2hhZGVyLnNldFVuaWZvcm0oXCJ0ZXgwXCIsIE8pLCBELl9wSW5zdC5jbGVhcigpLCBELl9wSW5zdC5zaGFkZXIoRC5maWx0ZXJTaGFkZXIpLCBELl9wSW5zdC5ub0xpZ2h0cygpLCBELl9wSW5zdC5wbGFuZSh0ZS53aWR0aCwgdGUuaGVpZ2h0KTtcbiAgICAgICAgICB9KSwgdGhpcy5fcEluc3QucG9wKCkpIDogQi5kcmF3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgRC5fcEluc3Qubm9TdHJva2UoKSwgRC5fcEluc3QuYmxlbmRNb2RlKGguQkxFTkQpLCBELl9wSW5zdC5zaGFkZXIoRC5maWx0ZXJTaGFkZXIpLCBELmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwidGV4MFwiLCB0ZSksIEQuZmlsdGVyU2hhZGVyLnNldFVuaWZvcm0oXCJ0ZXhlbFNpemVcIiwgY2UpLCBELmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwiY2FudmFzU2l6ZVwiLCBbdGUud2lkdGgsIHRlLmhlaWdodF0pLCBELmZpbHRlclNoYWRlci5zZXRVbmlmb3JtKFwiZmlsdGVyUGFyYW1ldGVyXCIsIFkpLCBELl9wSW5zdC5ub0xpZ2h0cygpLCBELl9wSW5zdC5wbGFuZSh0ZS53aWR0aCwgdGUuaGVpZ2h0KTtcbiAgICAgICAgICB9KSwgdGhpcy5fcEluc3QucHVzaCgpLCB0aGlzLl9wSW5zdC5ub1N0cm9rZSgpLCB0aGlzLmNsZWFyKCksIHRoaXMuX3BJbnN0LnB1c2goKSwgdGhpcy5fcEluc3QuaW1hZ2VNb2RlKGguQ09STkVSKSwgdGhpcy5fcEluc3QuYmxlbmRNb2RlKGguQkxFTkQpLCB0ZS5maWx0ZXJDYW1lcmEuX3Jlc2l6ZSgpLCB0aGlzLl9wSW5zdC5zZXRDYW1lcmEodGUuZmlsdGVyQ2FtZXJhKSwgdGhpcy5fcEluc3QucmVzZXRNYXRyaXgoKSwgdGhpcy5fcEluc3QuaW1hZ2UoQiwgLXRlLndpZHRoIC8gMiwgLXRlLmhlaWdodCAvIDIsIHRlLndpZHRoLCB0ZS5oZWlnaHQpLCB0aGlzLl9wSW5zdC5jbGVhckRlcHRoKCksIHRoaXMuX3BJbnN0LnBvcCgpLCB0aGlzLl9wSW5zdC5wb3AoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwaXhlbERlbnNpdHlcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gYiA/IHRoaXMuX3BJbnN0LnBpeGVsRGVuc2l0eShiKSA6IHRoaXMuX3BJbnN0LnBpeGVsRGVuc2l0eSgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImJsZW5kTW9kZVwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIGIgPT09IGguREFSS0VTVCB8fCBiID09PSBoLkxJR0hURVNUIHx8IGIgPT09IGguQUREIHx8IGIgPT09IGguQkxFTkQgfHwgYiA9PT0gaC5TVUJUUkFDVCB8fCBiID09PSBoLlNDUkVFTiB8fCBiID09PSBoLkVYQ0xVU0lPTiB8fCBiID09PSBoLlJFUExBQ0UgfHwgYiA9PT0gaC5NVUxUSVBMWSB8fCBiID09PSBoLlJFTU9WRSA/IHRoaXMuY3VyQmxlbmRNb2RlID0gYiA6IGIgIT09IGguQlVSTiAmJiBiICE9PSBoLk9WRVJMQVkgJiYgYiAhPT0gaC5IQVJEX0xJR0hUICYmIGIgIT09IGguU09GVF9MSUdIVCAmJiBiICE9PSBoLkRPREdFIHx8IGNvbnNvbGUud2FybihcIkJVUk4sIE9WRVJMQVksIEhBUkRfTElHSFQsIFNPRlRfTElHSFQsIGFuZCBET0RHRSBvbmx5IHdvcmsgZm9yIGJsZW5kTW9kZSBpbiAyRCBtb2RlLlwiKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlcmFzZVwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHRoaXMuX2lzRXJhc2luZyB8fCAodGhpcy5wcmVFcmFzZUJsZW5kID0gdGhpcy5jdXJCbGVuZE1vZGUsIHRoaXMuX2lzRXJhc2luZyA9ICEwLCB0aGlzLmJsZW5kTW9kZShoLlJFTU9WRSksIHRoaXMuX2NhY2hlZEZpbGxTdHlsZSA9IHRoaXMuY3VyRmlsbENvbG9yLnNsaWNlKCksIHRoaXMuY3VyRmlsbENvbG9yID0gWzEsIDEsIDEsIGIgLyAyNTVdLCB0aGlzLl9jYWNoZWRTdHJva2VTdHlsZSA9IHRoaXMuY3VyU3Ryb2tlQ29sb3Iuc2xpY2UoKSwgdGhpcy5jdXJTdHJva2VDb2xvciA9IFsxLCAxLCAxLCBPIC8gMjU1XSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibm9FcmFzZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5faXNFcmFzaW5nICYmICh0aGlzLmN1ckZpbGxDb2xvciA9IHRoaXMuX2NhY2hlZEZpbGxTdHlsZS5zbGljZSgpLCB0aGlzLmN1clN0cm9rZUNvbG9yID0gdGhpcy5fY2FjaGVkU3Ryb2tlU3R5bGUuc2xpY2UoKSwgdGhpcy5jdXJCbGVuZE1vZGUgPSB0aGlzLnByZUVyYXNlQmxlbmQsIHRoaXMuYmxlbmRNb2RlKHRoaXMucHJlRXJhc2VCbGVuZCksIHRoaXMuX2lzRXJhc2luZyA9ICExLCB0aGlzLl9hcHBseUJsZW5kTW9kZSgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkcmF3VGFyZ2V0XCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVGcmFtZWJ1ZmZlcnNbdGhpcy5hY3RpdmVGcmFtZWJ1ZmZlcnMubGVuZ3RoIC0gMV0gfHwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJiZWdpbkNsaXBcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSwgYiA9IChuKGoobmUucHJvdG90eXBlKSwgXCJiZWdpbkNsaXBcIiwgdGhpcykuY2FsbCh0aGlzLCBiKSwgdGhpcy5kcmF3VGFyZ2V0KCkuX2lzQ2xpcEFwcGxpZWQgPSAhMCwgdGhpcy5HTCk7XG4gICAgICAgICAgYi5jbGVhclN0ZW5jaWwoMCksIGIuY2xlYXIoYi5TVEVOQ0lMX0JVRkZFUl9CSVQpLCBiLmVuYWJsZShiLlNURU5DSUxfVEVTVCksIHRoaXMuX3N0ZW5jaWxUZXN0T24gPSAhMCwgYi5zdGVuY2lsRnVuYyhiLkFMV0FZUywgMSwgMjU1KSwgYi5zdGVuY2lsT3AoYi5LRUVQLCBiLktFRVAsIGIuUkVQTEFDRSksIGIuZGlzYWJsZShiLkRFUFRIX1RFU1QpLCB0aGlzLl9wSW5zdC5wdXNoKCksIHRoaXMuX3BJbnN0LnJlc2V0U2hhZGVyKCksIHRoaXMuX2RvRmlsbCAmJiB0aGlzLl9wSW5zdC5maWxsKDAsIDApLCB0aGlzLl9kb1N0cm9rZSAmJiB0aGlzLl9wSW5zdC5zdHJva2UoMCwgMCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZW5kQ2xpcFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fcEluc3QucG9wKCk7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLkdMO1xuICAgICAgICAgIGIuc3RlbmNpbE9wKGIuS0VFUCwgYi5LRUVQLCBiLktFRVApLCBiLnN0ZW5jaWxGdW5jKHRoaXMuX2NsaXBJbnZlcnQgPyBiLkVRVUFMIDogYi5OT1RFUVVBTCwgMCwgMjU1KSwgYi5lbmFibGUoYi5ERVBUSF9URVNUKSwgdGhpcy5fY2xpcERlcHRocy5wdXNoKHRoaXMuX3B1c2hQb3BEZXB0aCksIG4oaihuZS5wcm90b3R5cGUpLCBcImVuZENsaXBcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfY2xlYXJDbGlwXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLkdMLmNsZWFyU3RlbmNpbCgxKSwgdGhpcy5HTC5jbGVhcih0aGlzLkdMLlNURU5DSUxfQlVGRkVSX0JJVCksIDAgPCB0aGlzLl9jbGlwRGVwdGhzLmxlbmd0aCAmJiB0aGlzLl9jbGlwRGVwdGhzLnBvcCgpLCB0aGlzLmRyYXdUYXJnZXQoKS5faXNDbGlwQXBwbGllZCA9ICExO1xuICAgICAgICB9IH0sIHsga2V5OiBcInN0cm9rZVdlaWdodFwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHRoaXMuY3VyU3Ryb2tlV2VpZ2h0ICE9PSBiICYmICh0aGlzLnBvaW50U2l6ZSA9IGIsIHRoaXMuY3VyU3Ryb2tlV2VpZ2h0ID0gYik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldFBpeGVsXCIsIHZhbHVlOiBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgdmFyIEQgPSB0aGlzLkdMO1xuICAgICAgICAgIHJldHVybiBHKEQsIG51bGwsIGIsIE8sIEQuUkdCQSwgRC5VTlNJR05FRF9CWVRFLCB0aGlzLl9wSW5zdC5oZWlnaHQgKiB0aGlzLl9wSW5zdC5waXhlbERlbnNpdHkoKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibG9hZFBpeGVsc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGIsIE8sIEQgPSB0aGlzLl9waXhlbHNTdGF0ZTtcbiAgICAgICAgICB0aGlzLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gITAgPyBjb25zb2xlLmxvZyhcImxvYWRQaXhlbHMgb25seSB3b3JrcyBpbiBXZWJHTCB3aGVuIHByZXNlcnZlRHJhd2luZ0J1ZmZlciBpcyB0cnVlLlwiKSA6IChiID0gdGhpcy5fcEluc3QuX3BpeGVsRGVuc2l0eSwgTyA9IHRoaXMuR0wsIEQuX3NldFByb3BlcnR5KFwicGl4ZWxzXCIsIFYoRC5waXhlbHMsIE8sIG51bGwsIDAsIDAsIHRoaXMud2lkdGggKiBiLCB0aGlzLmhlaWdodCAqIGIsIE8uUkdCQSwgTy5VTlNJR05FRF9CWVRFLCB0aGlzLmhlaWdodCAqIGIpKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXBkYXRlUGl4ZWxzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMuX2dldFRlbXBGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgIGIucGl4ZWxzID0gdGhpcy5fcGl4ZWxzU3RhdGUucGl4ZWxzLCBiLnVwZGF0ZVBpeGVscygpLCB0aGlzLl9wSW5zdC5wdXNoKCksIHRoaXMuX3BJbnN0LnJlc2V0TWF0cml4KCksIHRoaXMuX3BJbnN0LmNsZWFyKCksIHRoaXMuX3BJbnN0LmltYWdlTW9kZShoLkNFTlRFUiksIHRoaXMuX3BJbnN0LmltYWdlKGIsIDAsIDApLCB0aGlzLl9wSW5zdC5wb3AoKSwgdGhpcy5HTC5jbGVhckRlcHRoKDEpLCB0aGlzLkdMLmNsZWFyKHRoaXMuR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldFRlbXBGcmFtZWJ1ZmZlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBGcmFtZWJ1ZmZlciB8fCAodGhpcy5fdGVtcEZyYW1lYnVmZmVyID0gdGhpcy5fcEluc3QuY3JlYXRlRnJhbWVidWZmZXIoeyBmb3JtYXQ6IGguVU5TSUdORURfQllURSwgdXNlRGVwdGg6IHRoaXMuX3BJbnN0Ll9nbEF0dHJpYnV0ZXMuZGVwdGgsIGRlcHRoRm9ybWF0OiBoLlVOU0lHTkVEX0lOVCwgYW50aWFsaWFzOiB0aGlzLl9wSW5zdC5fZ2xBdHRyaWJ1dGVzLmFudGlhbGlhcyB9KSksIHRoaXMuX3RlbXBGcmFtZWJ1ZmZlcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZW9tZXRyeUluSGFzaFwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJldGFpbmVkTW9kZS5nZW9tZXRyeVtiXSAhPT0gdm9pZCAwO1xuICAgICAgICB9IH0sIHsga2V5OiBcInZpZXdwb3J0XCIsIHZhbHVlOiBmdW5jdGlvbihiLCBPKSB7XG4gICAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBbMCwgMCwgYiwgT10sIHRoaXMuR0wudmlld3BvcnQoMCwgMCwgYiwgTyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVzaXplXCIsIHZhbHVlOiBmdW5jdGlvbihZLCBCKSB7XG4gICAgICAgICAgdS5kZWZhdWx0LlJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUuY2FsbCh0aGlzLCBZLCBCKSwgdGhpcy5fb3JpZ1ZpZXdwb3J0ID0geyB3aWR0aDogdGhpcy5HTC5kcmF3aW5nQnVmZmVyV2lkdGgsIGhlaWdodDogdGhpcy5HTC5kcmF3aW5nQnVmZmVySGVpZ2h0IH0sIHRoaXMudmlld3BvcnQodGhpcy5fb3JpZ1ZpZXdwb3J0LndpZHRoLCB0aGlzLl9vcmlnVmlld3BvcnQuaGVpZ2h0KSwgdGhpcy5fY3VyQ2FtZXJhLl9yZXNpemUoKTtcbiAgICAgICAgICB2YXIgWSA9IHRoaXMuX3BpeGVsc1N0YXRlLCBEID0gKFkucGl4ZWxzICE9PSB2b2lkIDAgJiYgWS5fc2V0UHJvcGVydHkoXCJwaXhlbHNcIiwgbmV3IFVpbnQ4QXJyYXkodGhpcy5HTC5kcmF3aW5nQnVmZmVyV2lkdGggKiB0aGlzLkdMLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiA0KSksICEwKSwgQiA9ICExLCBZID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBKLCB0ZSA9IHRoaXMuZnJhbWVidWZmZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShEID0gKEogPSB0ZS5uZXh0KCkpLmRvbmUpOyBEID0gITApXG4gICAgICAgICAgICAgIEoudmFsdWUuX2NhbnZhc1NpemVDaGFuZ2VkKCk7XG4gICAgICAgICAgfSBjYXRjaCAoY2UpIHtcbiAgICAgICAgICAgIEIgPSAhMCwgWSA9IGNlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBEIHx8IHRlLnJldHVybiA9PSBudWxsIHx8IHRlLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKEIpXG4gICAgICAgICAgICAgICAgdGhyb3cgWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiID0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgfHwgMCwgTyA9IChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB2b2lkIDAgOiBhcmd1bWVudHNbMV0pIHx8IDAsIEQgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdm9pZCAwIDogYXJndW1lbnRzWzJdKSB8fCAwLCBCID0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHZvaWQgMCA6IGFyZ3VtZW50c1szXSkgfHwgMCwgWSA9IHRoaXMuYWN0aXZlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICBZICYmIFkuZm9ybWF0ID09PSBoLlVOU0lHTkVEX0JZVEUgJiYgIVkuYW50aWFsaWFzICYmIEIgPT09IDAgJiYgKEIgPSAxZS0xMCksIHRoaXMuR0wuY2xlYXJDb2xvcihiICogQiwgTyAqIEIsIEQgKiBCLCBCKSwgdGhpcy5HTC5jbGVhckRlcHRoKDEpLCB0aGlzLkdMLmNsZWFyKHRoaXMuR0wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY2xlYXJEZXB0aFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5HTC5jbGVhckRlcHRoKDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogMSksIHRoaXMuR0wuY2xlYXIodGhpcy5HTC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJhcHBseU1hdHJpeFwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTywgRCwgQiwgWSwgSikge1xuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDE2ID8gdS5kZWZhdWx0Lk1hdHJpeC5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGhpcy51TVZNYXRyaXgsIGFyZ3VtZW50cykgOiB0aGlzLnVNVk1hdHJpeC5hcHBseShbYiwgTywgMCwgMCwgRCwgQiwgMCwgMCwgMCwgMCwgMSwgMCwgWSwgSiwgMCwgMV0pO1xuICAgICAgICB9IH0sIHsga2V5OiBcInRyYW5zbGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTywgRCkge1xuICAgICAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgdS5kZWZhdWx0LlZlY3RvciAmJiAoRCA9IGIueiwgTyA9IGIueSwgYiA9IGIueCksIHRoaXMudU1WTWF0cml4LnRyYW5zbGF0ZShbYiwgTywgRF0pLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNjYWxlXCIsIHZhbHVlOiBmdW5jdGlvbihiLCBPLCBEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudU1WTWF0cml4LnNjYWxlKGIsIE8sIEQpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJvdGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBPID09PSB2b2lkIDAgPyB0aGlzLnJvdGF0ZVooYikgOiAodS5kZWZhdWx0Lk1hdHJpeC5wcm90b3R5cGUucm90YXRlLmFwcGx5KHRoaXMudU1WTWF0cml4LCBhcmd1bWVudHMpLCB0aGlzKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyb3RhdGVYXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlKGIsIDEsIDAsIDApLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJvdGF0ZVlcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGUoYiwgMCwgMSwgMCksIHRoaXM7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicm90YXRlWlwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZShiLCAwLCAwLCAxKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJwdXNoXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHUuZGVmYXVsdC5SZW5kZXJlci5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzKSwgTyA9IGIucHJvcGVydGllcztcbiAgICAgICAgICByZXR1cm4gTy51TVZNYXRyaXggPSB0aGlzLnVNVk1hdHJpeC5jb3B5KCksIE8udVBNYXRyaXggPSB0aGlzLnVQTWF0cml4LmNvcHkoKSwgTy5fY3VyQ2FtZXJhID0gdGhpcy5fY3VyQ2FtZXJhLCB0aGlzLl9jdXJDYW1lcmEgPSB0aGlzLl9jdXJDYW1lcmEuY29weSgpLCBPLmFtYmllbnRMaWdodENvbG9ycyA9IHRoaXMuYW1iaWVudExpZ2h0Q29sb3JzLnNsaWNlKCksIE8uc3BlY3VsYXJDb2xvcnMgPSB0aGlzLnNwZWN1bGFyQ29sb3JzLnNsaWNlKCksIE8uZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbnMgPSB0aGlzLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25zLnNsaWNlKCksIE8uZGlyZWN0aW9uYWxMaWdodERpZmZ1c2VDb2xvcnMgPSB0aGlzLmRpcmVjdGlvbmFsTGlnaHREaWZmdXNlQ29sb3JzLnNsaWNlKCksIE8uZGlyZWN0aW9uYWxMaWdodFNwZWN1bGFyQ29sb3JzID0gdGhpcy5kaXJlY3Rpb25hbExpZ2h0U3BlY3VsYXJDb2xvcnMuc2xpY2UoKSwgTy5wb2ludExpZ2h0UG9zaXRpb25zID0gdGhpcy5wb2ludExpZ2h0UG9zaXRpb25zLnNsaWNlKCksIE8ucG9pbnRMaWdodERpZmZ1c2VDb2xvcnMgPSB0aGlzLnBvaW50TGlnaHREaWZmdXNlQ29sb3JzLnNsaWNlKCksIE8ucG9pbnRMaWdodFNwZWN1bGFyQ29sb3JzID0gdGhpcy5wb2ludExpZ2h0U3BlY3VsYXJDb2xvcnMuc2xpY2UoKSwgTy5zcG90TGlnaHRQb3NpdGlvbnMgPSB0aGlzLnNwb3RMaWdodFBvc2l0aW9ucy5zbGljZSgpLCBPLnNwb3RMaWdodERpcmVjdGlvbnMgPSB0aGlzLnNwb3RMaWdodERpcmVjdGlvbnMuc2xpY2UoKSwgTy5zcG90TGlnaHREaWZmdXNlQ29sb3JzID0gdGhpcy5zcG90TGlnaHREaWZmdXNlQ29sb3JzLnNsaWNlKCksIE8uc3BvdExpZ2h0U3BlY3VsYXJDb2xvcnMgPSB0aGlzLnNwb3RMaWdodFNwZWN1bGFyQ29sb3JzLnNsaWNlKCksIE8uc3BvdExpZ2h0QW5nbGUgPSB0aGlzLnNwb3RMaWdodEFuZ2xlLnNsaWNlKCksIE8uc3BvdExpZ2h0Q29uYyA9IHRoaXMuc3BvdExpZ2h0Q29uYy5zbGljZSgpLCBPLnVzZXJGaWxsU2hhZGVyID0gdGhpcy51c2VyRmlsbFNoYWRlciwgTy51c2VyU3Ryb2tlU2hhZGVyID0gdGhpcy51c2VyU3Ryb2tlU2hhZGVyLCBPLnVzZXJQb2ludFNoYWRlciA9IHRoaXMudXNlclBvaW50U2hhZGVyLCBPLnBvaW50U2l6ZSA9IHRoaXMucG9pbnRTaXplLCBPLmN1clN0cm9rZVdlaWdodCA9IHRoaXMuY3VyU3Ryb2tlV2VpZ2h0LCBPLmN1clN0cm9rZUNvbG9yID0gdGhpcy5jdXJTdHJva2VDb2xvciwgTy5jdXJGaWxsQ29sb3IgPSB0aGlzLmN1ckZpbGxDb2xvciwgTy5jdXJBbWJpZW50Q29sb3IgPSB0aGlzLmN1ckFtYmllbnRDb2xvciwgTy5jdXJTcGVjdWxhckNvbG9yID0gdGhpcy5jdXJTcGVjdWxhckNvbG9yLCBPLmN1ckVtaXNzaXZlQ29sb3IgPSB0aGlzLmN1ckVtaXNzaXZlQ29sb3IsIE8uX2hhc1NldEFtYmllbnQgPSB0aGlzLl9oYXNTZXRBbWJpZW50LCBPLl91c2VTcGVjdWxhck1hdGVyaWFsID0gdGhpcy5fdXNlU3BlY3VsYXJNYXRlcmlhbCwgTy5fdXNlRW1pc3NpdmVNYXRlcmlhbCA9IHRoaXMuX3VzZUVtaXNzaXZlTWF0ZXJpYWwsIE8uX3VzZVNoaW5pbmVzcyA9IHRoaXMuX3VzZVNoaW5pbmVzcywgTy5fdXNlTWV0YWxuZXNzID0gdGhpcy5fdXNlTWV0YWxuZXNzLCBPLmNvbnN0YW50QXR0ZW51YXRpb24gPSB0aGlzLmNvbnN0YW50QXR0ZW51YXRpb24sIE8ubGluZWFyQXR0ZW51YXRpb24gPSB0aGlzLmxpbmVhckF0dGVudWF0aW9uLCBPLnF1YWRyYXRpY0F0dGVudWF0aW9uID0gdGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbiwgTy5fZW5hYmxlTGlnaHRpbmcgPSB0aGlzLl9lbmFibGVMaWdodGluZywgTy5fdXNlTm9ybWFsTWF0ZXJpYWwgPSB0aGlzLl91c2VOb3JtYWxNYXRlcmlhbCwgTy5fdGV4ID0gdGhpcy5fdGV4LCBPLmRyYXdNb2RlID0gdGhpcy5kcmF3TW9kZSwgTy5fY3VycmVudE5vcm1hbCA9IHRoaXMuX2N1cnJlbnROb3JtYWwsIE8uY3VyQmxlbmRNb2RlID0gdGhpcy5jdXJCbGVuZE1vZGUsIE8uYWN0aXZlSW1hZ2VMaWdodCA9IHRoaXMuYWN0aXZlSW1hZ2VMaWdodCwgYjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwb3BcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiO1xuICAgICAgICAgIDAgPCB0aGlzLl9jbGlwRGVwdGhzLmxlbmd0aCAmJiB0aGlzLl9wdXNoUG9wRGVwdGggPT09IHRoaXMuX2NsaXBEZXB0aHNbdGhpcy5fY2xpcERlcHRocy5sZW5ndGggLSAxXSAmJiB0aGlzLl9jbGVhckNsaXAoKTtcbiAgICAgICAgICBmb3IgKHZhciBPID0gYXJndW1lbnRzLmxlbmd0aCwgRCA9IG5ldyBBcnJheShPKSwgQiA9IDA7IEIgPCBPOyBCKyspXG4gICAgICAgICAgICBEW0JdID0gYXJndW1lbnRzW0JdO1xuICAgICAgICAgIChiID0gbihqKG5lLnByb3RvdHlwZSksIFwicG9wXCIsIHRoaXMpKS5jYWxsLmFwcGx5KGIsIFt0aGlzXS5jb25jYXQoRCkpLCB0aGlzLl9hcHBseVN0ZW5jaWxUZXN0SWZDbGlwcGluZygpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hcHBseVN0ZW5jaWxUZXN0SWZDbGlwcGluZ1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLmRyYXdUYXJnZXQoKTtcbiAgICAgICAgICBiLl9pc0NsaXBBcHBsaWVkICE9PSB0aGlzLl9zdGVuY2lsVGVzdE9uICYmIChiLl9pc0NsaXBBcHBsaWVkID8gKHRoaXMuR0wuZW5hYmxlKHRoaXMuR0wuU1RFTkNJTF9URVNUKSwgdGhpcy5fc3RlbmNpbFRlc3RPbiA9ICEwKSA6ICh0aGlzLkdMLmRpc2FibGUodGhpcy5HTC5TVEVOQ0lMX1RFU1QpLCB0aGlzLl9zdGVuY2lsVGVzdE9uID0gITEpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZXNldE1hdHJpeFwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudU1WTWF0cml4LnNldCh0aGlzLl9jdXJDYW1lcmEuY2FtZXJhTWF0cml4KSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0SW1tZWRpYXRlU3Ryb2tlU2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMudXNlclN0cm9rZVNoYWRlcjtcbiAgICAgICAgICByZXR1cm4gYiAmJiBiLmlzU3Ryb2tlU2hhZGVyKCkgPyBiIDogdGhpcy5fZ2V0TGluZVNoYWRlcigpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRSZXRhaW5lZFN0cm9rZVNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEltbWVkaWF0ZVN0cm9rZVNoYWRlcigpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRTcGhlcmVNYXBwaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlTWFwcGluZyB8fCAodGhpcy5zcGhlcmVNYXBwaW5nID0gdGhpcy5fcEluc3QuY3JlYXRlRmlsdGVyU2hhZGVyKEwpKSwgdGhpcy51Tk1hdHJpeC5pbnZlcnNlVHJhbnNwb3NlKHRoaXMudU1WTWF0cml4KSwgdGhpcy51Tk1hdHJpeC5pbnZlcnQzeDModGhpcy51Tk1hdHJpeCksIHRoaXMuc3BoZXJlTWFwcGluZy5zZXRVbmlmb3JtKFwidUZvdllcIiwgdGhpcy5fY3VyQ2FtZXJhLmNhbWVyYUZPViksIHRoaXMuc3BoZXJlTWFwcGluZy5zZXRVbmlmb3JtKFwidUFzcGVjdFwiLCB0aGlzLl9jdXJDYW1lcmEuYXNwZWN0UmF0aW8pLCB0aGlzLnNwaGVyZU1hcHBpbmcuc2V0VW5pZm9ybShcInVOZXdOb3JtYWxNYXRyaXhcIiwgdGhpcy51Tk1hdHJpeC5tYXQzKSwgdGhpcy5zcGhlcmVNYXBwaW5nLnNldFVuaWZvcm0oXCJ1U2FtcGxlclwiLCBiKSwgdGhpcy5zcGhlcmVNYXBwaW5nO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRJbW1lZGlhdGVGaWxsU2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMudXNlckZpbGxTaGFkZXI7XG4gICAgICAgICAgaWYgKHRoaXMuX3VzZU5vcm1hbE1hdGVyaWFsICYmICghYiB8fCAhYi5pc05vcm1hbFNoYWRlcigpKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXROb3JtYWxTaGFkZXIoKTtcbiAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlTGlnaHRpbmcpIHtcbiAgICAgICAgICAgIGlmICghYiB8fCAhYi5pc0xpZ2h0U2hhZGVyKCkpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMaWdodFNoYWRlcigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGV4KSB7XG4gICAgICAgICAgICBpZiAoIWIgfHwgIWIuaXNUZXh0dXJlU2hhZGVyKCkpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMaWdodFNoYWRlcigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW1tZWRpYXRlTW9kZVNoYWRlcigpO1xuICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRSZXRhaW5lZEZpbGxTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl91c2VOb3JtYWxNYXRlcmlhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXROb3JtYWxTaGFkZXIoKTtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMudXNlckZpbGxTaGFkZXI7XG4gICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZUxpZ2h0aW5nKSB7XG4gICAgICAgICAgICBpZiAoIWIgfHwgIWIuaXNMaWdodFNoYWRlcigpKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGlnaHRTaGFkZXIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3RleCkge1xuICAgICAgICAgICAgaWYgKCFiIHx8ICFiLmlzVGV4dHVyZVNoYWRlcigpKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGlnaHRTaGFkZXIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbG9yU2hhZGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEltbWVkaWF0ZVBvaW50U2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMudXNlclBvaW50U2hhZGVyO1xuICAgICAgICAgIHJldHVybiBiICYmIGIuaXNQb2ludFNoYWRlcigpID8gYiA6IHRoaXMuX2dldFBvaW50U2hhZGVyKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldFJldGFpbmVkTGluZVNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEltbWVkaWF0ZUxpbmVTaGFkZXIoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0TGlnaHRTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0TGlnaHRTaGFkZXIgfHwgKHRoaXMuX3BJbnN0Ll9nbEF0dHJpYnV0ZXMucGVyUGl4ZWxMaWdodGluZyA/IHRoaXMuX2RlZmF1bHRMaWdodFNoYWRlciA9IG5ldyB1LmRlZmF1bHQuU2hhZGVyKHRoaXMsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJ2ZXJ0XCIsIFwiaGlnaHBcIikgKyBSLnBob25nVmVydCwgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcImZyYWdcIiwgXCJoaWdocFwiKSArIFIucGhvbmdGcmFnKSA6IHRoaXMuX2RlZmF1bHRMaWdodFNoYWRlciA9IG5ldyB1LmRlZmF1bHQuU2hhZGVyKHRoaXMsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJ2ZXJ0XCIsIFwiaGlnaHBcIikgKyBSLmxpZ2h0VmVydCwgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcImZyYWdcIiwgXCJoaWdocFwiKSArIFIubGlnaHRUZXh0dXJlRnJhZykpLCB0aGlzLl9kZWZhdWx0TGlnaHRTaGFkZXI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEltbWVkaWF0ZU1vZGVTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0SW1tZWRpYXRlTW9kZVNoYWRlciB8fCAodGhpcy5fZGVmYXVsdEltbWVkaWF0ZU1vZGVTaGFkZXIgPSBuZXcgdS5kZWZhdWx0LlNoYWRlcih0aGlzLCB0aGlzLl93ZWJHTDJDb21wYXRpYmlsaXR5UHJlZml4KFwidmVydFwiLCBcIm1lZGl1bXBcIikgKyBSLmltbWVkaWF0ZVZlcnQsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJmcmFnXCIsIFwibWVkaXVtcFwiKSArIFIudmVydGV4Q29sb3JGcmFnKSksIHRoaXMuX2RlZmF1bHRJbW1lZGlhdGVNb2RlU2hhZGVyO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXROb3JtYWxTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0Tm9ybWFsU2hhZGVyIHx8ICh0aGlzLl9kZWZhdWx0Tm9ybWFsU2hhZGVyID0gbmV3IHUuZGVmYXVsdC5TaGFkZXIodGhpcywgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcInZlcnRcIiwgXCJtZWRpdW1wXCIpICsgUi5ub3JtYWxWZXJ0LCB0aGlzLl93ZWJHTDJDb21wYXRpYmlsaXR5UHJlZml4KFwiZnJhZ1wiLCBcIm1lZGl1bXBcIikgKyBSLm5vcm1hbEZyYWcpKSwgdGhpcy5fZGVmYXVsdE5vcm1hbFNoYWRlcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0Q29sb3JTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0Q29sb3JTaGFkZXIgfHwgKHRoaXMuX2RlZmF1bHRDb2xvclNoYWRlciA9IG5ldyB1LmRlZmF1bHQuU2hhZGVyKHRoaXMsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJ2ZXJ0XCIsIFwibWVkaXVtcFwiKSArIFIubm9ybWFsVmVydCwgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcImZyYWdcIiwgXCJtZWRpdW1wXCIpICsgUi5iYXNpY0ZyYWcpKSwgdGhpcy5fZGVmYXVsdENvbG9yU2hhZGVyO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRQb2ludFNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQb2ludFNoYWRlciB8fCAodGhpcy5fZGVmYXVsdFBvaW50U2hhZGVyID0gbmV3IHUuZGVmYXVsdC5TaGFkZXIodGhpcywgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcInZlcnRcIiwgXCJtZWRpdW1wXCIpICsgUi5wb2ludFZlcnQsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJmcmFnXCIsIFwibWVkaXVtcFwiKSArIFIucG9pbnRGcmFnKSksIHRoaXMuX2RlZmF1bHRQb2ludFNoYWRlcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZ2V0TGluZVNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRMaW5lU2hhZGVyIHx8ICh0aGlzLl9kZWZhdWx0TGluZVNoYWRlciA9IG5ldyB1LmRlZmF1bHQuU2hhZGVyKHRoaXMsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJ2ZXJ0XCIsIFwibWVkaXVtcFwiKSArIFIubGluZVZlcnQsIHRoaXMuX3dlYkdMMkNvbXBhdGliaWxpdHlQcmVmaXgoXCJmcmFnXCIsIFwibWVkaXVtcFwiKSArIFIubGluZUZyYWcpKSwgdGhpcy5fZGVmYXVsdExpbmVTaGFkZXI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2dldEZvbnRTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0Rm9udFNoYWRlciB8fCAodGhpcy53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wgJiYgdGhpcy5HTC5nZXRFeHRlbnNpb24oXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIiksIHRoaXMuX2RlZmF1bHRGb250U2hhZGVyID0gbmV3IHUuZGVmYXVsdC5TaGFkZXIodGhpcywgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcInZlcnRcIiwgXCJtZWRpdW1wXCIpICsgUi5mb250VmVydCwgdGhpcy5fd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeChcImZyYWdcIiwgXCJtZWRpdW1wXCIpICsgUi5mb250RnJhZykpLCB0aGlzLl9kZWZhdWx0Rm9udFNoYWRlcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfd2ViR0wyQ29tcGF0aWJpbGl0eVByZWZpeFwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHZhciBEID0gXCJcIjtcbiAgICAgICAgICByZXR1cm4gdGhpcy53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wyICYmIChEICs9IGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgV0VCR0wyXG5gKSwgYiA9PT0gXCJ2ZXJ0XCIgPyBEICs9IGAjZGVmaW5lIFZFUlRFWF9TSEFERVJcbmAgOiBiID09PSBcImZyYWdcIiAmJiAoRCArPSBgI2RlZmluZSBGUkFHTUVOVF9TSEFERVJcbmApLCBPICYmIChEICs9IFwicHJlY2lzaW9uIFwiLmNvbmNhdChPLCBgIGZsb2F0O1xuYCkpLCBEO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRFbXB0eVRleHR1cmVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbXB0eVRleHR1cmUgfHwgKChiID0gbmV3IHUuZGVmYXVsdC5JbWFnZSgxLCAxKSkuc2V0KDAsIDAsIDI1NSksIHRoaXMuX2VtcHR5VGV4dHVyZSA9IG5ldyB1LmRlZmF1bHQuVGV4dHVyZSh0aGlzLCBiKSksIHRoaXMuX2VtcHR5VGV4dHVyZTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRUZXh0dXJlXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgYiBpbnN0YW5jZW9mIHUuZGVmYXVsdC5GcmFtZWJ1ZmZlciAmJiAoYiA9IGIuY29sb3IpO1xuICAgICAgICAgIHZhciBPID0gdGhpcy50ZXh0dXJlcy5nZXQoYik7XG4gICAgICAgICAgcmV0dXJuIE8gfHwgKE8gPSBuZXcgdS5kZWZhdWx0LlRleHR1cmUodGhpcywgYiksIHRoaXMudGV4dHVyZXMuc2V0KGIsIE8pLCBPKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXREaWZmdXNlZFRleHR1cmVcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICB2YXIgTywgRCwgQiA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZnVzZWRUZXh0dXJlcy5nZXQoYikgIT0gbnVsbCA/IHRoaXMuZGlmZnVzZWRUZXh0dXJlcy5nZXQoYikgOiAoTyA9IE1hdGguZmxvb3IoYi5oZWlnaHQgLyBiLndpZHRoICogMjAwKSwgRCA9IHRoaXMuX3BJbnN0LmNyZWF0ZUZyYW1lYnVmZmVyKHsgd2lkdGg6IDIwMCwgaGVpZ2h0OiBPLCBkZW5zaXR5OiAxIH0pLCB0aGlzLmRpZmZ1c2VkU2hhZGVyIHx8ICh0aGlzLmRpZmZ1c2VkU2hhZGVyID0gdGhpcy5fcEluc3QuY3JlYXRlU2hhZGVyKFIuaW1hZ2VMaWdodFZlcnQsIFIuaW1hZ2VMaWdodERpZmZ1c2VkRnJhZykpLCBELmRyYXcoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBCLl9wSW5zdC5zaGFkZXIoQi5kaWZmdXNlZFNoYWRlciksIEIuZGlmZnVzZWRTaGFkZXIuc2V0VW5pZm9ybShcImVudmlyb25tZW50TWFwXCIsIGIpLCBCLl9wSW5zdC5ub1N0cm9rZSgpLCBCLl9wSW5zdC5yZWN0TW9kZShoLkNFTlRFUiksIEIuX3BJbnN0Lm5vTGlnaHRzKCksIEIuX3BJbnN0LnJlY3QoMCwgMCwgMjAwLCBPKTtcbiAgICAgICAgICB9KSwgdGhpcy5kaWZmdXNlZFRleHR1cmVzLnNldChiLCBEKSwgRCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZ2V0U3BlY3VsYXJUZXh0dXJlXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgdmFyIE8gPSB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLnNwZWN1bGFyVGV4dHVyZXMuZ2V0KGIpICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjdWxhclRleHR1cmVzLmdldChiKTtcbiAgICAgICAgICBmb3IgKHZhciBELCBCID0gW10sIFkgPSB0aGlzLl9wSW5zdC5jcmVhdGVGcmFtZWJ1ZmZlcih7IHdpZHRoOiA1MTIsIGhlaWdodDogNTEyLCBkZW5zaXR5OiAxIH0pLCBKID0gTWF0aC5sb2coNTEyKSAvIE1hdGgubG9nKDIpLCB0ZSA9ICh0aGlzLnNwZWN1bGFyU2hhZGVyIHx8ICh0aGlzLnNwZWN1bGFyU2hhZGVyID0gdGhpcy5fcEluc3QuY3JlYXRlU2hhZGVyKFIuaW1hZ2VMaWdodFZlcnQsIFIuaW1hZ2VMaWdodFNwZWN1bGFyRnJhZykpLCA1MTIpOyAxIDw9IHRlOyB0ZSAvPSAyKVxuICAgICAgICAgICAgKGZ1bmN0aW9uKGNlKSB7XG4gICAgICAgICAgICAgIFkucmVzaXplKGNlLCBjZSk7XG4gICAgICAgICAgICAgIHZhciByZSA9IDEgLSBNYXRoLmxvZyhjZSkgLyBNYXRoLmxvZygyKSAvIEo7XG4gICAgICAgICAgICAgIFkuZHJhdyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBPLl9wSW5zdC5zaGFkZXIoTy5zcGVjdWxhclNoYWRlciksIE8uX3BJbnN0LmNsZWFyKCksIE8uc3BlY3VsYXJTaGFkZXIuc2V0VW5pZm9ybShcImVudmlyb25tZW50TWFwXCIsIGIpLCBPLnNwZWN1bGFyU2hhZGVyLnNldFVuaWZvcm0oXCJyb3VnaG5lc3NcIiwgcmUpLCBPLl9wSW5zdC5ub1N0cm9rZSgpLCBPLl9wSW5zdC5ub0xpZ2h0cygpLCBPLl9wSW5zdC5wbGFuZShjZSwgY2UpO1xuICAgICAgICAgICAgICB9KSwgQi5wdXNoKFkuZ2V0KCkuZHJhd2luZ0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNlLCBjZSkpO1xuICAgICAgICAgICAgfSkodGUpO1xuICAgICAgICAgIHJldHVybiBZLnJlbW92ZSgpLCBEID0gbmV3IHIuTWlwbWFwVGV4dHVyZSh0aGlzLCBCLCB7fSksIHRoaXMuc3BlY3VsYXJUZXh0dXJlcy5zZXQoYiwgRCksIEQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYWN0aXZlRnJhbWVidWZmZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUZyYW1lYnVmZmVyc1t0aGlzLmFjdGl2ZUZyYW1lYnVmZmVycy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNyZWF0ZUZyYW1lYnVmZmVyXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1LmRlZmF1bHQuRnJhbWVidWZmZXIodGhpcywgYik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NldFN0cm9rZVVuaWZvcm1zXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgYi5iaW5kU2hhZGVyKCksIGIuc2V0VW5pZm9ybShcInVVc2VMaW5lQ29sb3JcIiwgdGhpcy5fdXNlTGluZUNvbG9yKSwgYi5zZXRVbmlmb3JtKFwidU1hdGVyaWFsQ29sb3JcIiwgdGhpcy5jdXJTdHJva2VDb2xvciksIGIuc2V0VW5pZm9ybShcInVTdHJva2VXZWlnaHRcIiwgdGhpcy5jdXJTdHJva2VXZWlnaHQpLCBiLnNldFVuaWZvcm0oXCJ1U3Ryb2tlQ2FwXCIsIEFbdGhpcy5jdXJTdHJva2VDYXBdKSwgYi5zZXRVbmlmb3JtKFwidVN0cm9rZUpvaW5cIiwgeFt0aGlzLmN1clN0cm9rZUpvaW5dKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfc2V0RmlsbFVuaWZvcm1zXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgdmFyIE8gPSB0aGlzLCBEID0gKGIuYmluZFNoYWRlcigpLCB0aGlzLm1peGVkU3BlY3VsYXJDb2xvciA9IGkodGhpcy5jdXJTcGVjdWxhckNvbG9yKSwgMCA8IHRoaXMuX3VzZU1ldGFsbmVzcyAmJiAodGhpcy5taXhlZFNwZWN1bGFyQ29sb3IgPSB0aGlzLm1peGVkU3BlY3VsYXJDb2xvci5tYXAoZnVuY3Rpb24oQiwgWSkge1xuICAgICAgICAgICAgcmV0dXJuIE8uY3VyRmlsbENvbG9yW1ldICogTy5fdXNlTWV0YWxuZXNzICsgQiAqICgxIC0gTy5fdXNlTWV0YWxuZXNzKTtcbiAgICAgICAgICB9KSksIGIuc2V0VW5pZm9ybShcInVVc2VWZXJ0ZXhDb2xvclwiLCB0aGlzLl91c2VWZXJ0ZXhDb2xvciksIGIuc2V0VW5pZm9ybShcInVNYXRlcmlhbENvbG9yXCIsIHRoaXMuY3VyRmlsbENvbG9yKSwgYi5zZXRVbmlmb3JtKFwiaXNUZXh0dXJlXCIsICEhdGhpcy5fdGV4KSwgdGhpcy5fdGV4ICYmIGIuc2V0VW5pZm9ybShcInVTYW1wbGVyXCIsIHRoaXMuX3RleCksIGIuc2V0VW5pZm9ybShcInVUaW50XCIsIHRoaXMuX3RpbnQpLCBiLnNldFVuaWZvcm0oXCJ1SGFzU2V0QW1iaWVudFwiLCB0aGlzLl9oYXNTZXRBbWJpZW50KSwgYi5zZXRVbmlmb3JtKFwidUFtYmllbnRNYXRDb2xvclwiLCB0aGlzLmN1ckFtYmllbnRDb2xvciksIGIuc2V0VW5pZm9ybShcInVTcGVjdWxhck1hdENvbG9yXCIsIHRoaXMubWl4ZWRTcGVjdWxhckNvbG9yKSwgYi5zZXRVbmlmb3JtKFwidUVtaXNzaXZlTWF0Q29sb3JcIiwgdGhpcy5jdXJFbWlzc2l2ZUNvbG9yKSwgYi5zZXRVbmlmb3JtKFwidVNwZWN1bGFyXCIsIHRoaXMuX3VzZVNwZWN1bGFyTWF0ZXJpYWwpLCBiLnNldFVuaWZvcm0oXCJ1RW1pc3NpdmVcIiwgdGhpcy5fdXNlRW1pc3NpdmVNYXRlcmlhbCksIGIuc2V0VW5pZm9ybShcInVTaGluaW5lc3NcIiwgdGhpcy5fdXNlU2hpbmluZXNzKSwgYi5zZXRVbmlmb3JtKFwibWV0YWxsaWNcIiwgdGhpcy5fdXNlTWV0YWxuZXNzKSwgdGhpcy5fc2V0SW1hZ2VMaWdodFVuaWZvcm1zKGIpLCBiLnNldFVuaWZvcm0oXCJ1VXNlTGlnaHRpbmdcIiwgdGhpcy5fZW5hYmxlTGlnaHRpbmcpLCB0aGlzLnBvaW50TGlnaHREaWZmdXNlQ29sb3JzLmxlbmd0aCAvIDMpLCBEID0gKGIuc2V0VW5pZm9ybShcInVQb2ludExpZ2h0Q291bnRcIiwgRCksIGIuc2V0VW5pZm9ybShcInVQb2ludExpZ2h0TG9jYXRpb25cIiwgdGhpcy5wb2ludExpZ2h0UG9zaXRpb25zKSwgYi5zZXRVbmlmb3JtKFwidVBvaW50TGlnaHREaWZmdXNlQ29sb3JzXCIsIHRoaXMucG9pbnRMaWdodERpZmZ1c2VDb2xvcnMpLCBiLnNldFVuaWZvcm0oXCJ1UG9pbnRMaWdodFNwZWN1bGFyQ29sb3JzXCIsIHRoaXMucG9pbnRMaWdodFNwZWN1bGFyQ29sb3JzKSwgdGhpcy5kaXJlY3Rpb25hbExpZ2h0RGlmZnVzZUNvbG9ycy5sZW5ndGggLyAzKSwgRCA9IChiLnNldFVuaWZvcm0oXCJ1RGlyZWN0aW9uYWxMaWdodENvdW50XCIsIEQpLCBiLnNldFVuaWZvcm0oXCJ1TGlnaHRpbmdEaXJlY3Rpb25cIiwgdGhpcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9ucyksIGIuc2V0VW5pZm9ybShcInVEaXJlY3Rpb25hbERpZmZ1c2VDb2xvcnNcIiwgdGhpcy5kaXJlY3Rpb25hbExpZ2h0RGlmZnVzZUNvbG9ycyksIGIuc2V0VW5pZm9ybShcInVEaXJlY3Rpb25hbFNwZWN1bGFyQ29sb3JzXCIsIHRoaXMuZGlyZWN0aW9uYWxMaWdodFNwZWN1bGFyQ29sb3JzKSwgdGhpcy5hbWJpZW50TGlnaHRDb2xvcnMubGVuZ3RoIC8gMyksIEQgPSAodGhpcy5taXhlZEFtYmllbnRMaWdodCA9IGkodGhpcy5hbWJpZW50TGlnaHRDb2xvcnMpLCAwIDwgdGhpcy5fdXNlTWV0YWxuZXNzICYmICh0aGlzLm1peGVkQW1iaWVudExpZ2h0ID0gdGhpcy5taXhlZEFtYmllbnRMaWdodC5tYXAoZnVuY3Rpb24oQikge1xuICAgICAgICAgICAgcmV0dXJuIEIgLT0gTy5fdXNlTWV0YWxuZXNzLCBNYXRoLm1heCgwLCBCKTtcbiAgICAgICAgICB9KSksIGIuc2V0VW5pZm9ybShcInVBbWJpZW50TGlnaHRDb3VudFwiLCBEKSwgYi5zZXRVbmlmb3JtKFwidUFtYmllbnRDb2xvclwiLCB0aGlzLm1peGVkQW1iaWVudExpZ2h0KSwgdGhpcy5zcG90TGlnaHREaWZmdXNlQ29sb3JzLmxlbmd0aCAvIDMpO1xuICAgICAgICAgIGIuc2V0VW5pZm9ybShcInVTcG90TGlnaHRDb3VudFwiLCBEKSwgYi5zZXRVbmlmb3JtKFwidVNwb3RMaWdodEFuZ2xlXCIsIHRoaXMuc3BvdExpZ2h0QW5nbGUpLCBiLnNldFVuaWZvcm0oXCJ1U3BvdExpZ2h0Q29uY1wiLCB0aGlzLnNwb3RMaWdodENvbmMpLCBiLnNldFVuaWZvcm0oXCJ1U3BvdExpZ2h0RGlmZnVzZUNvbG9yc1wiLCB0aGlzLnNwb3RMaWdodERpZmZ1c2VDb2xvcnMpLCBiLnNldFVuaWZvcm0oXCJ1U3BvdExpZ2h0U3BlY3VsYXJDb2xvcnNcIiwgdGhpcy5zcG90TGlnaHRTcGVjdWxhckNvbG9ycyksIGIuc2V0VW5pZm9ybShcInVTcG90TGlnaHRMb2NhdGlvblwiLCB0aGlzLnNwb3RMaWdodFBvc2l0aW9ucyksIGIuc2V0VW5pZm9ybShcInVTcG90TGlnaHREaXJlY3Rpb25cIiwgdGhpcy5zcG90TGlnaHREaXJlY3Rpb25zKSwgYi5zZXRVbmlmb3JtKFwidUNvbnN0YW50QXR0ZW51YXRpb25cIiwgdGhpcy5jb25zdGFudEF0dGVudWF0aW9uKSwgYi5zZXRVbmlmb3JtKFwidUxpbmVhckF0dGVudWF0aW9uXCIsIHRoaXMubGluZWFyQXR0ZW51YXRpb24pLCBiLnNldFVuaWZvcm0oXCJ1UXVhZHJhdGljQXR0ZW51YXRpb25cIiwgdGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbiksIGIuYmluZFRleHR1cmVzKCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX3NldEltYWdlTGlnaHRVbmlmb3Jtc1wiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHZhciBPLCBEO1xuICAgICAgICAgIGIuc2V0VW5pZm9ybShcInVVc2VJbWFnZUxpZ2h0XCIsIHRoaXMuYWN0aXZlSW1hZ2VMaWdodCAhPSBudWxsKSwgdGhpcy5hY3RpdmVJbWFnZUxpZ2h0ICYmIChPID0gdGhpcy5nZXREaWZmdXNlZFRleHR1cmUodGhpcy5hY3RpdmVJbWFnZUxpZ2h0KSwgYi5zZXRVbmlmb3JtKFwiZW52aXJvbm1lbnRNYXBEaWZmdXNlZFwiLCBPKSwgTyA9IHRoaXMuZ2V0U3BlY3VsYXJUZXh0dXJlKHRoaXMuYWN0aXZlSW1hZ2VMaWdodCksIEQgPSAyMCAvIHRoaXMuX3VzZVNoaW5pbmVzcywgYi5zZXRVbmlmb3JtKFwibGV2ZWxPZkRldGFpbFwiLCA4ICogRCksIGIuc2V0VW5pZm9ybShcImVudmlyb25tZW50TWFwU3BlY3VsYXJcIiwgTykpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9zZXRQb2ludFVuaWZvcm1zXCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgYi5iaW5kU2hhZGVyKCksIGIuc2V0VW5pZm9ybShcInVNYXRlcmlhbENvbG9yXCIsIHRoaXMuY3VyU3Ryb2tlQ29sb3IpLCBiLnNldFVuaWZvcm0oXCJ1UG9pbnRTaXplXCIsIHRoaXMucG9pbnRTaXplICogdGhpcy5fcEluc3QuX3BpeGVsRGVuc2l0eSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiX2JpbmRCdWZmZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKGIsIE8sIEQsIEIsIFkpIHtcbiAgICAgICAgICBPID0gTyB8fCB0aGlzLkdMLkFSUkFZX0JVRkZFUiwgdGhpcy5HTC5iaW5kQnVmZmVyKE8sIGIpLCBEICE9PSB2b2lkIDAgJiYgKChiID0gRCkgaW5zdGFuY2VvZiB1LmRlZmF1bHQuRGF0YUFycmF5ID8gYiA9IEQuZGF0YUFycmF5KCkgOiBiIGluc3RhbmNlb2YgKEIgfHwgRmxvYXQzMkFycmF5KSB8fCAoYiA9IG5ldyAoQiB8fCBGbG9hdDMyQXJyYXkpKGIpKSwgdGhpcy5HTC5idWZmZXJEYXRhKE8sIGIsIFkgfHwgdGhpcy5HTC5TVEFUSUNfRFJBVykpO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9hcnJheXNFcXVhbFwiLCB2YWx1ZTogZnVuY3Rpb24oYiwgTykge1xuICAgICAgICAgIHJldHVybiBiLmxlbmd0aCA9PT0gTy5sZW5ndGggJiYgYi5ldmVyeShmdW5jdGlvbihELCBCKSB7XG4gICAgICAgICAgICByZXR1cm4gRCA9PT0gT1tCXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfaXNUeXBlZEFycmF5XCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIFtGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIFVpbnQzMkFycmF5XS5zb21lKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgTztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfZmxhdHRlblwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiBiLmZsYXQoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfdlRvTkFycmF5XCIsIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuZmxhdE1hcChmdW5jdGlvbihPKSB7XG4gICAgICAgICAgICByZXR1cm4gW08ueCwgTy55LCBPLnpdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9iZXppZXJDb2VmZmljaWVudHNcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICB2YXIgTyA9IGIgKiBiLCBEID0gMSAtIGIsIEIgPSBEICogRDtcbiAgICAgICAgICByZXR1cm4gW0IgKiBELCAzICogQiAqIGIsIDMgKiBEICogTywgTyAqIGJdO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9xdWFkcmF0aWNDb2VmZmljaWVudHNcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICB2YXIgTyA9IDEgLSBiO1xuICAgICAgICAgIHJldHVybiBbTyAqIE8sIDIgKiBPICogYiwgYiAqIGJdO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9iZXppZXJUb0NhdG11bGxcIiwgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gW2JbMV0sIGJbMV0gKyAoYlsyXSAtIGJbMF0pIC8gdGhpcy5fY3VydmVUaWdodG5lc3MsIGJbMl0gLSAoYlszXSAtIGJbMV0pIC8gdGhpcy5fY3VydmVUaWdodG5lc3MsIGJbMl1dO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9pbml0VGVzc3lcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiID0gbmV3IGYuZGVmYXVsdC5HbHVUZXNzZWxhdG9yKCk7XG4gICAgICAgICAgcmV0dXJuIGIuZ2x1VGVzc0NhbGxiYWNrKGYuZGVmYXVsdC5nbHVFbnVtLkdMVV9URVNTX1ZFUlRFWF9EQVRBLCBmdW5jdGlvbihPLCBEKSB7XG4gICAgICAgICAgICB2YXIgQiA9ICEwLCBZID0gITEsIEogPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciB0ZSwgY2UgPSBPW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShCID0gKHRlID0gY2UubmV4dCgpKS5kb25lKTsgQiA9ICEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlID0gdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgRC5wdXNoKHJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAodWUpIHtcbiAgICAgICAgICAgICAgWSA9ICEwLCBKID0gdWU7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEIgfHwgY2UucmV0dXJuID09IG51bGwgfHwgY2UucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKFkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBKO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGIuZ2x1VGVzc0NhbGxiYWNrKGYuZGVmYXVsdC5nbHVFbnVtLkdMVV9URVNTX0JFR0lOLCBmdW5jdGlvbihPKSB7XG4gICAgICAgICAgICBPICE9PSBmLmRlZmF1bHQucHJpbWl0aXZlVHlwZS5HTF9UUklBTkdMRVMgJiYgY29uc29sZS5sb2coXCJleHBlY3RlZCBUUklBTkdMRVMgYnV0IGdvdCB0eXBlOiBcIi5jb25jYXQoTykpO1xuICAgICAgICAgIH0pLCBiLmdsdVRlc3NDYWxsYmFjayhmLmRlZmF1bHQuZ2x1RW51bS5HTFVfVEVTU19FUlJPUiwgZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciBjYWxsYmFja1wiKSwgY29uc29sZS5sb2coXCJlcnJvciBudW1iZXI6IFwiLmNvbmNhdChPKSk7XG4gICAgICAgICAgfSksIGIuZ2x1VGVzc0NhbGxiYWNrKGYuZGVmYXVsdC5nbHVFbnVtLkdMVV9URVNTX0NPTUJJTkUsIGZ1bmN0aW9uKE8sIEQsIEIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFkgPSBuZXcgQXJyYXkodS5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLnRlc3N5VmVydGV4U2l6ZSkuZmlsbCgwKSwgSiA9IDA7IEogPCBCLmxlbmd0aDsgSisrKVxuICAgICAgICAgICAgICBmb3IgKHZhciB0ZSA9IDA7IHRlIDwgWS5sZW5ndGg7IHRlKyspXG4gICAgICAgICAgICAgICAgQltKXSAhPT0gMCAmJiBEW0pdICYmIChZW3RlXSArPSBEW0pdW3RlXSAqIEJbSl0pO1xuICAgICAgICAgICAgcmV0dXJuIFk7XG4gICAgICAgICAgfSksIGIuZ2x1VGVzc0NhbGxiYWNrKGYuZGVmYXVsdC5nbHVFbnVtLkdMVV9URVNTX0VER0VfRkxBRywgZnVuY3Rpb24oTykge1xuICAgICAgICAgIH0pLCBiLmdsdVRlc3NQcm9wZXJ0eShmLmRlZmF1bHQuZ2x1RW51bS5HTFVfVEVTU19XSU5ESU5HX1JVTEUsIGYuZGVmYXVsdC53aW5kaW5nUnVsZS5HTFVfVEVTU19XSU5ESU5HX05PTlpFUk8pLCBiO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl90cmlhbmd1bGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHZhciBPID0gYlswXSA/IGJbMF1bMl0gOiB2b2lkIDAsIEQgPSAhMCwgQiA9ICEwLCByZSA9ICExLCBsZSA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgWSwgSiA9IGJbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKEIgPSAoWSA9IEoubmV4dCgpKS5kb25lKTsgQiA9ICEwKVxuICAgICAgICAgICAgICBmb3IgKHZhciB0ZSA9IFkudmFsdWUsIGNlID0gMDsgY2UgPCB0ZS5sZW5ndGg7IGNlICs9IHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS50ZXNzeVZlcnRleFNpemUpXG4gICAgICAgICAgICAgICAgaWYgKHRlW2NlICsgMl0gIT09IE8pIHtcbiAgICAgICAgICAgICAgICAgIEQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoICh4ZSkge1xuICAgICAgICAgICAgcmUgPSAhMCwgbGUgPSB4ZTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgQiB8fCBKLnJldHVybiA9PSBudWxsIHx8IEoucmV0dXJuKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAocmUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIEQgPyB0aGlzLl90ZXNzeS5nbHVUZXNzTm9ybWFsKDAsIDAsIDEpIDogdGhpcy5fdGVzc3kuZ2x1VGVzc05vcm1hbCgwLCAwLCAwKTtcbiAgICAgICAgICB2YXIgcmUgPSBbXSwgdWUgPSAodGhpcy5fdGVzc3kuZ2x1VGVzc0JlZ2luUG9seWdvbihyZSksICEwKSwgbGUgPSAhMSwgSyA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYWUsIGhlID0gYltTeW1ib2wuaXRlcmF0b3JdKCk7ICEodWUgPSAoYWUgPSBoZS5uZXh0KCkpLmRvbmUpOyB1ZSA9ICEwKSB7XG4gICAgICAgICAgICAgIHZhciBfZSA9IGFlLnZhbHVlO1xuICAgICAgICAgICAgICB0aGlzLl90ZXNzeS5nbHVUZXNzQmVnaW5Db250b3VyKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGZlID0gMDsgZmUgPCBfZS5sZW5ndGg7IGZlICs9IHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS50ZXNzeVZlcnRleFNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2UgPSBfZS5zbGljZShmZSwgZmUgKyB1LmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUudGVzc3lWZXJ0ZXhTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXNzeS5nbHVUZXNzVmVydGV4KGdlLCBnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fdGVzc3kuZ2x1VGVzc0VuZENvbnRvdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoICh4ZSkge1xuICAgICAgICAgICAgbGUgPSAhMCwgSyA9IHhlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB1ZSB8fCBoZS5yZXR1cm4gPT0gbnVsbCB8fCBoZS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChsZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGVzc3kuZ2x1VGVzc0VuZFBvbHlnb24oKSwgcmU7XG4gICAgICAgIH0gfV0pICYmIGwoVy5wcm90b3R5cGUsIFUpLCBuZTtcbiAgICAgIH0odS5kZWZhdWx0LlJlbmRlcmVyKSwgdS5kZWZhdWx0LnByb3RvdHlwZS5fYXNzZXJ0M2QgPSBmdW5jdGlvbihVKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuaXNQM0QpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFUsIFwiKCkgaXMgb25seSBzdXBwb3J0ZWQgaW4gV0VCR0wgbW9kZS4gSWYgeW91J2QgbGlrZSB0byB1c2UgM0QgZ3JhcGhpY3MgYW5kIFdlYkdMLCBzZWUgIGh0dHBzOi8vcDVqcy5vcmcvZXhhbXBsZXMvZm9ybS0zZC1wcmltaXRpdmVzLmh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpKTtcbiAgICAgIH0sIHUuZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS50ZXNzeVZlcnRleFNpemUgPSAxMiwgTSA9IHUuZGVmYXVsdC5SZW5kZXJlckdMLCBDLmRlZmF1bHQgPSBNO1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCIuLi9jb3JlL3A1LlJlbmRlcmVyXCI6IDI4MywgXCIuL0dlb21ldHJ5QnVpbGRlclwiOiAzMjQsIFwiLi9wNS5DYW1lcmFcIjogMzI5LCBcIi4vcDUuRnJhbWVidWZmZXJcIjogMzMxLCBcIi4vcDUuTWF0cml4XCI6IDMzMywgXCIuL3A1LlNoYWRlclwiOiAzMzgsIFwiLi9wNS5UZXh0dXJlXCI6IDMzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0XCI6IDE1MiwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29weS13aXRoaW5cIjogMTUzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5ldmVyeVwiOiAxNTQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGxcIjogMTU1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0XCI6IDE1OSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmxhdC1tYXBcIjogMTU4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tXCI6IDE2MSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXNcIjogMTYyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcFwiOiAxNjcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlXCI6IDE2OCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiOiAxNjksIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXRcIjogMTcyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS51bnNjb3BhYmxlcy5mbGF0LW1hcFwiOiAxNzEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcFwiOiAxNzQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ25cIjogMTgxLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjogMTg1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIjogMTg5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldFwiOiAxOTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmdcIjogMTkzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zZXRcIjogMTk0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXNcIjogMTk2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2xcIjogMjA5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIjogMjA3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIjogMjA4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiOiAyMTAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5XCI6IDIxMSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiOiAyMTIsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiOiAyMTMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmRcIjogMjE1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCI6IDIxNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheVwiOiAyMTYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0NjQtYXJyYXlcIjogMjE3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaFwiOiAyMTgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCI6IDIxOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIjogMjIwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbnQxNi1hcnJheVwiOiAyMjEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCI6IDIyMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiOiAyMjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIjogMjI1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIjogMjI2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIjogMjI4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIjogMjI3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCI6IDIyOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCI6IDIzMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIjogMjMxLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCI6IDIzMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiOiAyMzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCI6IDIzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiOiAyMzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiOiAyMzYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQxNi1hcnJheVwiOiAyMzcsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQzMi1hcnJheVwiOiAyMzgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCI6IDIzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MywgbGlidGVzczogMjUyLCBwYXRoOiAyNTUgfV0sIDMzODogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIHZhciBtID0gKHQgPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiB0Ll9fZXNNb2R1bGUgPyB0IDogeyBkZWZhdWx0OiB0IH07XG4gICAgICBmdW5jdGlvbiB5KHUsIGgpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBoLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgdmFyIGYgPSBoW2ddO1xuICAgICAgICAgIGYuZW51bWVyYWJsZSA9IGYuZW51bWVyYWJsZSB8fCAhMSwgZi5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGYgJiYgKGYud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBmLmtleSwgZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0uZGVmYXVsdC5TaGFkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gdShmLCByLCBzKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IGYsIHRoaXMuX3ZlcnRTcmMgPSByLCB0aGlzLl9mcmFnU3JjID0gcywgdGhpcy5fdmVydFNoYWRlciA9IC0xLCB0aGlzLl9mcmFnU2hhZGVyID0gLTEsIHRoaXMuX2dsUHJvZ3JhbSA9IDAsIHRoaXMuX2xvYWRlZEF0dHJpYnV0ZXMgPSAhMSwgdGhpcy5hdHRyaWJ1dGVzID0ge30sIHRoaXMuX2xvYWRlZFVuaWZvcm1zID0gITEsIHRoaXMudW5pZm9ybXMgPSB7fSwgdGhpcy5fYm91bmQgPSAhMSwgdGhpcy5zYW1wbGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoLCBnO1xuICAgICAgICByZXR1cm4gaCA9IHUsIChnID0gW3sga2V5OiBcImluaXRcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9nbFByb2dyYW0gPT09IDApIHtcbiAgICAgICAgICAgIHZhciBmID0gdGhpcy5fcmVuZGVyZXIuR0w7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmVydFNoYWRlciA9IGYuY3JlYXRlU2hhZGVyKGYuVkVSVEVYX1NIQURFUiksIGYuc2hhZGVyU291cmNlKHRoaXMuX3ZlcnRTaGFkZXIsIHRoaXMuX3ZlcnRTcmMpLCBmLmNvbXBpbGVTaGFkZXIodGhpcy5fdmVydFNoYWRlciksICFmLmdldFNoYWRlclBhcmFtZXRlcih0aGlzLl92ZXJ0U2hhZGVyLCBmLkNPTVBJTEVfU1RBVFVTKSlcbiAgICAgICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIllpa2VzISBBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHZlcnRleCBzaGFkZXI6XCIuY29uY2F0KGYuZ2V0U2hhZGVySW5mb0xvZyh0aGlzLl92ZXJ0U2hhZGVyKSkpLCBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZyYWdTaGFkZXIgPSBmLmNyZWF0ZVNoYWRlcihmLkZSQUdNRU5UX1NIQURFUiksIGYuc2hhZGVyU291cmNlKHRoaXMuX2ZyYWdTaGFkZXIsIHRoaXMuX2ZyYWdTcmMpLCBmLmNvbXBpbGVTaGFkZXIodGhpcy5fZnJhZ1NoYWRlciksICFmLmdldFNoYWRlclBhcmFtZXRlcih0aGlzLl9mcmFnU2hhZGVyLCBmLkNPTVBJTEVfU1RBVFVTKSlcbiAgICAgICAgICAgICAgcmV0dXJuIG0uZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIkRhcm4hIEFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgZnJhZ21lbnQgc2hhZGVyOlwiLmNvbmNhdChmLmdldFNoYWRlckluZm9Mb2codGhpcy5fZnJhZ1NoYWRlcikpKSwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2dsUHJvZ3JhbSA9IGYuY3JlYXRlUHJvZ3JhbSgpLCBmLmF0dGFjaFNoYWRlcih0aGlzLl9nbFByb2dyYW0sIHRoaXMuX3ZlcnRTaGFkZXIpLCBmLmF0dGFjaFNoYWRlcih0aGlzLl9nbFByb2dyYW0sIHRoaXMuX2ZyYWdTaGFkZXIpLCBmLmxpbmtQcm9ncmFtKHRoaXMuX2dsUHJvZ3JhbSksIGYuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLl9nbFByb2dyYW0sIGYuTElOS19TVEFUVVMpIHx8IG0uZGVmYXVsdC5fZnJpZW5kbHlFcnJvcihcIlNuYXAhIEVycm9yIGxpbmtpbmcgc2hhZGVyIHByb2dyYW06IFwiLmNvbmNhdChmLmdldFByb2dyYW1JbmZvTG9nKHRoaXMuX2dsUHJvZ3JhbSkpKSwgdGhpcy5fbG9hZEF0dHJpYnV0ZXMoKSwgdGhpcy5fbG9hZFVuaWZvcm1zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImNvcHlUb0NvbnRleHRcIiwgdmFsdWU6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB2YXIgciA9IG5ldyBtLmRlZmF1bHQuU2hhZGVyKGYuX3JlbmRlcmVyLCB0aGlzLl92ZXJ0U3JjLCB0aGlzLl9mcmFnU3JjKTtcbiAgICAgICAgICByZXR1cm4gci5lbnN1cmVDb21waWxlZE9uQ29udGV4dChmKSwgcjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJlbnN1cmVDb21waWxlZE9uQ29udGV4dFwiLCB2YWx1ZTogZnVuY3Rpb24oZikge1xuICAgICAgICAgIGlmICh0aGlzLl9nbFByb2dyYW0gIT09IDAgJiYgdGhpcy5fcmVuZGVyZXIgIT09IGYuX3JlbmRlcmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNoYWRlciBiZWluZyBydW4gaXMgYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgY29udGV4dC4gRG8geW91IG5lZWQgdG8gY29weSBpdCB0byB0aGlzIGNvbnRleHQgZmlyc3Qgd2l0aCAuY29weVRvQ29udGV4dCgpP1wiKTtcbiAgICAgICAgICB0aGlzLl9nbFByb2dyYW0gPT09IDAgJiYgKHRoaXMuX3JlbmRlcmVyID0gZi5fcmVuZGVyZXIsIHRoaXMuaW5pdCgpKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJfbG9hZEF0dHJpYnV0ZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVkQXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5fcmVuZGVyZXIuR0wsIHIgPSBmLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fZ2xQcm9ncmFtLCBmLkFDVElWRV9BVFRSSUJVVEVTKSwgcyA9IDA7IHMgPCByOyArK3MpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSBmLmdldEFjdGl2ZUF0dHJpYih0aGlzLl9nbFByb2dyYW0sIHMpLCBpID0gby5uYW1lLCBsID0gZi5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9nbFByb2dyYW0sIGkpLCBuID0ge307XG4gICAgICAgICAgICAgIG4ubmFtZSA9IGksIG4ubG9jYXRpb24gPSBsLCBuLmluZGV4ID0gcywgbi50eXBlID0gby50eXBlLCBuLnNpemUgPSBvLnNpemUsIHRoaXMuYXR0cmlidXRlc1tpXSA9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRBdHRyaWJ1dGVzID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcIl9sb2FkVW5pZm9ybXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVkVW5pZm9ybXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSB0aGlzLl9yZW5kZXJlci5HTCwgciA9IGYuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLl9nbFByb2dyYW0sIGYuQUNUSVZFX1VOSUZPUk1TKSwgcyA9IDAsIG8gPSAwOyBvIDwgcjsgKytvKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gZi5nZXRBY3RpdmVVbmlmb3JtKHRoaXMuX2dsUHJvZ3JhbSwgbyksIGwgPSB7fSwgbiA9IChsLmxvY2F0aW9uID0gZi5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fZ2xQcm9ncmFtLCBpLm5hbWUpLCBsLnNpemUgPSBpLnNpemUsIGkubmFtZSk7XG4gICAgICAgICAgICAgIDEgPCBpLnNpemUgJiYgKG4gPSBuLnN1YnN0cmluZygwLCBuLmluZGV4T2YoXCJbMF1cIikpKSwgbC5uYW1lID0gbiwgbC50eXBlID0gaS50eXBlLCBsLl9jYWNoZWREYXRhID0gdm9pZCAwLCBsLnR5cGUgPT09IGYuU0FNUExFUl8yRCAmJiAobC5zYW1wbGVySW5kZXggPSBzLCBzKyssIHRoaXMuc2FtcGxlcnMucHVzaChsKSksIGwuaXNBcnJheSA9IDEgPCBpLnNpemUgfHwgbC50eXBlID09PSBmLkZMT0FUX01BVDMgfHwgbC50eXBlID09PSBmLkZMT0FUX01BVDQgfHwgbC50eXBlID09PSBmLkZMT0FUX1ZFQzIgfHwgbC50eXBlID09PSBmLkZMT0FUX1ZFQzMgfHwgbC50eXBlID09PSBmLkZMT0FUX1ZFQzQgfHwgbC50eXBlID09PSBmLklOVF9WRUMyIHx8IGwudHlwZSA9PT0gZi5JTlRfVkVDNCB8fCBsLnR5cGUgPT09IGYuSU5UX1ZFQzMsIHRoaXMudW5pZm9ybXNbbl0gPSBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkVW5pZm9ybXMgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiY29tcGlsZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiYmluZFNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5pbml0KCksIHRoaXMuX2JvdW5kIHx8ICh0aGlzLnVzZVByb2dyYW0oKSwgdGhpcy5fYm91bmQgPSAhMCwgdGhpcy5fc2V0TWF0cml4VW5pZm9ybXMoKSwgdGhpcy5zZXRVbmlmb3JtKFwidVZpZXdwb3J0XCIsIHRoaXMuX3JlbmRlcmVyLl92aWV3cG9ydCkpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInVuYmluZFNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kICYmICh0aGlzLnVuYmluZFRleHR1cmVzKCksIHRoaXMuX2JvdW5kID0gITEpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImJpbmRUZXh0dXJlc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLl9yZW5kZXJlci5HTCwgciA9ICEwLCBzID0gITEsIG8gPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGksIGwgPSB0aGlzLnNhbXBsZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShyID0gKGkgPSBsLm5leHQoKSkuZG9uZSk7IHIgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgbiA9IGkudmFsdWUsIGEgPSBuLnRleHR1cmU7XG4gICAgICAgICAgICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9IHRoaXMuX3JlbmRlcmVyLl9nZXRFbXB0eVRleHR1cmUoKSksIGYuYWN0aXZlVGV4dHVyZShmLlRFWFRVUkUwICsgbi5zYW1wbGVySW5kZXgpLCBhLmJpbmRUZXh0dXJlKCksIGEudXBkYXRlKCksIGYudW5pZm9ybTFpKG4ubG9jYXRpb24sIG4uc2FtcGxlckluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgICAgICBzID0gITAsIG8gPSBjO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByIHx8IGwucmV0dXJuID09IG51bGwgfHwgbC5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChzKVxuICAgICAgICAgICAgICAgIHRocm93IG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcInVwZGF0ZVRleHR1cmVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZiA9ICEwLCByID0gITEsIHMgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG8sIGkgPSB0aGlzLnNhbXBsZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShmID0gKG8gPSBpLm5leHQoKSkuZG9uZSk7IGYgPSAhMCkge1xuICAgICAgICAgICAgICB2YXIgbCA9IG8udmFsdWUudGV4dHVyZTtcbiAgICAgICAgICAgICAgbCAmJiBsLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICAgIHIgPSAhMCwgcyA9IG47XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGYgfHwgaS5yZXR1cm4gPT0gbnVsbCB8fCBpLnJldHVybigpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgICAgdGhyb3cgcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidW5iaW5kVGV4dHVyZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmID0gITAsIHIgPSAhMSwgcyA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbywgaSA9IHRoaXMuc2FtcGxlcnNbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKGYgPSAobyA9IGkubmV4dCgpKS5kb25lKTsgZiA9ICEwKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gby52YWx1ZTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKGwubmFtZSwgdGhpcy5fcmVuZGVyZXIuX2dldEVtcHR5VGV4dHVyZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgICAgICByID0gITAsIHMgPSBuO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmIHx8IGkucmV0dXJuID09IG51bGwgfHwgaS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICAgIHRocm93IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sIHsga2V5OiBcIl9zZXRNYXRyaXhVbmlmb3Jtc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLl9yZW5kZXJlci5fY3VyQ2FtZXJhLmNhbWVyYU1hdHJpeCwgciA9IHRoaXMuX3JlbmRlcmVyLnVQTWF0cml4LCBzID0gdGhpcy5fcmVuZGVyZXIudU1WTWF0cml4LCBvID0gcy5jb3B5KCk7XG4gICAgICAgICAgby5tdWx0KHIpLCB0aGlzLmlzU3Ryb2tlU2hhZGVyKCkgJiYgdGhpcy5zZXRVbmlmb3JtKFwidVBlcnNwZWN0aXZlXCIsIHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEudXNlTGluZVBlcnNwZWN0aXZlID8gMSA6IDApLCB0aGlzLnNldFVuaWZvcm0oXCJ1Vmlld01hdHJpeFwiLCBmLm1hdDQpLCB0aGlzLnNldFVuaWZvcm0oXCJ1UHJvamVjdGlvbk1hdHJpeFwiLCByLm1hdDQpLCB0aGlzLnNldFVuaWZvcm0oXCJ1TW9kZWxWaWV3TWF0cml4XCIsIHMubWF0NCksIHRoaXMuc2V0VW5pZm9ybShcInVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCIsIG8ubWF0NCksIHRoaXMudW5pZm9ybXMudU5vcm1hbE1hdHJpeCAmJiAodGhpcy5fcmVuZGVyZXIudU5NYXRyaXguaW52ZXJzZVRyYW5zcG9zZSh0aGlzLl9yZW5kZXJlci51TVZNYXRyaXgpLCB0aGlzLnNldFVuaWZvcm0oXCJ1Tm9ybWFsTWF0cml4XCIsIHRoaXMuX3JlbmRlcmVyLnVOTWF0cml4Lm1hdDMpKSwgdGhpcy51bmlmb3Jtcy51Q2FtZXJhUm90YXRpb24gJiYgKHRoaXMuX3JlbmRlcmVyLmN1ck1hdHJpeC5pbnZlcnNlVHJhbnNwb3NlKHRoaXMuX3JlbmRlcmVyLl9jdXJDYW1lcmEuY2FtZXJhTWF0cml4KSwgdGhpcy5zZXRVbmlmb3JtKFwidUNhbWVyYVJvdGF0aW9uXCIsIHRoaXMuX3JlbmRlcmVyLmN1ck1hdHJpeC5tYXQzKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXNlUHJvZ3JhbVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLl9yZW5kZXJlci5HTDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX2N1clNoYWRlciAhPT0gdGhpcyAmJiAoZi51c2VQcm9ncmFtKHRoaXMuX2dsUHJvZ3JhbSksIHRoaXMuX3JlbmRlcmVyLl9jdXJTaGFkZXIgPSB0aGlzKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZXRVbmlmb3JtXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByKSB7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLnVuaWZvcm1zW2ZdO1xuICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuX3JlbmRlcmVyLkdMO1xuICAgICAgICAgICAgaWYgKHMuaXNBcnJheSkge1xuICAgICAgICAgICAgICBpZiAocy5fY2FjaGVkRGF0YSAmJiB0aGlzLl9yZW5kZXJlci5fYXJyYXlzRXF1YWwocy5fY2FjaGVkRGF0YSwgcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBzLl9jYWNoZWREYXRhID0gci5zbGljZSgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzLl9jYWNoZWREYXRhICYmIHMuX2NhY2hlZERhdGEgPT09IHIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHIpID8gcy5fY2FjaGVkRGF0YSA9IHIuc2xpY2UoMCkgOiBzLl9jYWNoZWREYXRhID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gcy5sb2NhdGlvbjtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy51c2VQcm9ncmFtKCksIHMudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIG8uQk9PTDpcbiAgICAgICAgICAgICAgICByID09PSAhMCA/IG8udW5pZm9ybTFpKGksIDEpIDogby51bmlmb3JtMWkoaSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2Ugby5JTlQ6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTFpdihpLCByKSA6IG8udW5pZm9ybTFpKGksIHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uRkxPQVQ6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTFmdihpLCByKSA6IG8udW5pZm9ybTFmKGksIHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uRkxPQVRfTUFUMzpcbiAgICAgICAgICAgICAgICBvLnVuaWZvcm1NYXRyaXgzZnYoaSwgITEsIHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uRkxPQVRfTUFUNDpcbiAgICAgICAgICAgICAgICBvLnVuaWZvcm1NYXRyaXg0ZnYoaSwgITEsIHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uRkxPQVRfVkVDMjpcbiAgICAgICAgICAgICAgICAxIDwgcy5zaXplID8gci5sZW5ndGggJiYgby51bmlmb3JtMmZ2KGksIHIpIDogby51bmlmb3JtMmYoaSwgclswXSwgclsxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2Ugby5GTE9BVF9WRUMzOlxuICAgICAgICAgICAgICAgIDEgPCBzLnNpemUgPyByLmxlbmd0aCAmJiBvLnVuaWZvcm0zZnYoaSwgcikgOiBvLnVuaWZvcm0zZihpLCByWzBdLCByWzFdLCByWzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBvLkZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTRmdihpLCByKSA6IG8udW5pZm9ybTRmKGksIHJbMF0sIHJbMV0sIHJbMl0sIHJbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uSU5UX1ZFQzI6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTJpdihpLCByKSA6IG8udW5pZm9ybTJpKGksIHJbMF0sIHJbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uSU5UX1ZFQzM6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTNpdihpLCByKSA6IG8udW5pZm9ybTNpKGksIHJbMF0sIHJbMV0sIHJbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uSU5UX1ZFQzQ6XG4gICAgICAgICAgICAgICAgMSA8IHMuc2l6ZSA/IHIubGVuZ3RoICYmIG8udW5pZm9ybTRpdihpLCByKSA6IG8udW5pZm9ybTRpKGksIHJbMF0sIHJbMV0sIHJbMl0sIHJbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIG8uU0FNUExFUl8yRDpcbiAgICAgICAgICAgICAgICBvLmFjdGl2ZVRleHR1cmUoby5URVhUVVJFMCArIHMuc2FtcGxlckluZGV4KSwgcy50ZXh0dXJlID0gciBpbnN0YW5jZW9mIG0uZGVmYXVsdC5UZXh0dXJlID8gciA6IHRoaXMuX3JlbmRlcmVyLmdldFRleHR1cmUociksIG8udW5pZm9ybTFpKGksIHMuc2FtcGxlckluZGV4KSwgcy50ZXh0dXJlLnNyYy5naWZQcm9wZXJ0aWVzICYmIHMudGV4dHVyZS5zcmMuX2FuaW1hdGVHaWYodGhpcy5fcmVuZGVyZXIuX3BJbnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB7IGtleTogXCJpc0xpZ2h0U2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW3RoaXMuYXR0cmlidXRlcy5hTm9ybWFsLCB0aGlzLnVuaWZvcm1zLnVVc2VMaWdodGluZywgdGhpcy51bmlmb3Jtcy51QW1iaWVudExpZ2h0Q291bnQsIHRoaXMudW5pZm9ybXMudURpcmVjdGlvbmFsTGlnaHRDb3VudCwgdGhpcy51bmlmb3Jtcy51UG9pbnRMaWdodENvdW50LCB0aGlzLnVuaWZvcm1zLnVBbWJpZW50Q29sb3IsIHRoaXMudW5pZm9ybXMudURpcmVjdGlvbmFsRGlmZnVzZUNvbG9ycywgdGhpcy51bmlmb3Jtcy51RGlyZWN0aW9uYWxTcGVjdWxhckNvbG9ycywgdGhpcy51bmlmb3Jtcy51UG9pbnRMaWdodExvY2F0aW9uLCB0aGlzLnVuaWZvcm1zLnVQb2ludExpZ2h0RGlmZnVzZUNvbG9ycywgdGhpcy51bmlmb3Jtcy51UG9pbnRMaWdodFNwZWN1bGFyQ29sb3JzLCB0aGlzLnVuaWZvcm1zLnVMaWdodGluZ0RpcmVjdGlvbiwgdGhpcy51bmlmb3Jtcy51U3BlY3VsYXJdLnNvbWUoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYgIT09IHZvaWQgMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpc05vcm1hbFNoYWRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5hTm9ybWFsICE9PSB2b2lkIDA7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaXNUZXh0dXJlU2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMCA8IHRoaXMuc2FtcGxlcnMubGVuZ3RoO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzQ29sb3JTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuYVZlcnRleENvbG9yICE9PSB2b2lkIDAgfHwgdGhpcy51bmlmb3Jtcy51TWF0ZXJpYWxDb2xvciAhPT0gdm9pZCAwO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzVGV4TGlnaHRTaGFkZXJcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzTGlnaHRTaGFkZXIoKSAmJiB0aGlzLmlzVGV4dHVyZVNoYWRlcigpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzU3Ryb2tlU2hhZGVyXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U3Ryb2tlV2VpZ2h0ICE9PSB2b2lkIDA7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZW5hYmxlQXR0cmliXCIsIHZhbHVlOiBmdW5jdGlvbihmLCByLCBzLCBvLCBpLCBsKSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgcmV0dXJuIGYgJiYgKGYgPSBmLmxvY2F0aW9uKSAhPT0gLTEgJiYgKG4gPSB0aGlzLl9yZW5kZXJlci5HTCwgdGhpcy5fcmVuZGVyZXIucmVnaXN0ZXJFbmFibGVkLmhhcyhmKSB8fCAobi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShmKSwgdGhpcy5fcmVuZGVyZXIucmVnaXN0ZXJFbmFibGVkLmFkZChmKSksIHRoaXMuX3JlbmRlcmVyLkdMLnZlcnRleEF0dHJpYlBvaW50ZXIoZiwgciwgcyB8fCBuLkZMT0FULCBvIHx8ICExLCBpIHx8IDAsIGwgfHwgMCkpLCB0aGlzO1xuICAgICAgICB9IH0sIHsga2V5OiBcImRpc2FibGVSZW1haW5pbmdBdHRyaWJ1dGVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMsIHIgPSAhMCwgcyA9ICExLCBvID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpLCBsID0gdGhpcy5fcmVuZGVyZXIucmVnaXN0ZXJFbmFibGVkLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTsgIShyID0gKGkgPSBsLm5leHQoKSkuZG9uZSk7IHIgPSAhMClcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gaS52YWx1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmLmF0dHJpYnV0ZXMpLnNvbWUoZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGYuYXR0cmlidXRlc1thXS5sb2NhdGlvbiA9PT0gbjtcbiAgICAgICAgICAgICAgICB9KSB8fCAoZi5fcmVuZGVyZXIuR0wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KG4pLCBmLl9yZW5kZXJlci5yZWdpc3RlckVuYWJsZWQuZGVsZXRlKG4pKTtcbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgICAgICBzID0gITAsIG8gPSBuO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByIHx8IGwucmV0dXJuID09IG51bGwgfHwgbC5yZXR1cm4oKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChzKVxuICAgICAgICAgICAgICAgIHRocm93IG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dKSAmJiB5KGgucHJvdG90eXBlLCBnKSwgdTtcbiAgICAgIH0oKSwgdCA9IG0uZGVmYXVsdC5TaGFkZXIsIEMuZGVmYXVsdCA9IHQ7XG4gICAgfSwgeyBcIi4uL2NvcmUvbWFpblwiOiAyODAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mXCI6IDE2MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZVwiOiAxNjgsIFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWVcIjogMTY5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lXCI6IDE3MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXNcIjogMTg2LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvclwiOiAyNDMgfV0sIDMzOTogW2Z1bmN0aW9uKHQsIEgsIEMpIHtcbiAgICAgIGZ1bmN0aW9uIG0oYykge1xuICAgICAgICByZXR1cm4gKG0gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBwO1xuICAgICAgICB9IDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHAuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBwICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBwO1xuICAgICAgICB9KShjKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHkoYykge1xuICAgICAgICByZXR1cm4gKHkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBtKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIG0ocCk7XG4gICAgICAgIH0gOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHAgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogbShwKTtcbiAgICAgICAgfSkoYyk7XG4gICAgICB9XG4gICAgICB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50OC1hcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXhcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2hcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2ZcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2VcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWVcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4XCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW5cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZVwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXlcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmdcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEMuY2hlY2tXZWJHTENhcGFiaWxpdGllcyA9IGEsIEMuZGVmYXVsdCA9IEMuTWlwbWFwVGV4dHVyZSA9IHZvaWQgMDtcbiAgICAgIHZhciB1ID0gKG4gPSB0KFwiLi4vY29yZS9tYWluXCIpKSAmJiBuLl9fZXNNb2R1bGUgPyBuIDogeyBkZWZhdWx0OiBuIH0sIGggPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmIChjICYmIGMuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgaWYgKGMgPT09IG51bGwgfHwgeShjKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogYyB9O1xuICAgICAgICB2YXIgcCA9IGcoKTtcbiAgICAgICAgaWYgKHAgJiYgcC5oYXMoYykpXG4gICAgICAgICAgcmV0dXJuIHAuZ2V0KGMpO1xuICAgICAgICB2YXIgaiwgVCA9IHt9LCBfID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgIGZvciAoaiBpbiBjKSB7XG4gICAgICAgICAgdmFyIFM7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsIGopICYmICgoUyA9IF8gPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMsIGopIDogbnVsbCkgJiYgKFMuZ2V0IHx8IFMuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShULCBqLCBTKSA6IFRbal0gPSBjW2pdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVC5kZWZhdWx0ID0gYywgcCAmJiBwLnNldChjLCBUKSwgVDtcbiAgICAgIH0odChcIi4uL2NvcmUvY29uc3RhbnRzXCIpKTtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICByZXR1cm4gdHlwZW9mIFdlYWtNYXAgIT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IChjID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSwgYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmKGMsIHApIHtcbiAgICAgICAgcmV0dXJuIChmID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKGosIFQpIHtcbiAgICAgICAgICByZXR1cm4gai5fX3Byb3RvX18gPSBULCBqO1xuICAgICAgICB9KShjLCBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIoYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAsIGogPSBzKGMpLCBqID0gKHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3QuY29uc3RydWN0ICYmICFSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KSksIDE7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSgpID8gKHAgPSBzKHRoaXMpLmNvbnN0cnVjdG9yLCBSZWZsZWN0LmNvbnN0cnVjdChqLCBhcmd1bWVudHMsIHApKSA6IGouYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFwIHx8IHkocCkgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHAgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaiAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICByZXR1cm4gajtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKGMpIHtcbiAgICAgICAgcmV0dXJuIChzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCk7XG4gICAgICAgIH0pKGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbyhjLCBwKSB7XG4gICAgICAgIGlmICghKGMgaW5zdGFuY2VvZiBwKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShjLCBwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBUID0gcFtqXTtcbiAgICAgICAgICBULmVudW1lcmFibGUgPSBULmVudW1lcmFibGUgfHwgITEsIFQuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBUICYmIChULndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgVC5rZXksIFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKGMsIHAsIGopIHtcbiAgICAgICAgcCAmJiBpKGMucHJvdG90eXBlLCBwKTtcbiAgICAgIH1cbiAgICAgIHUuZGVmYXVsdC5UZXh0dXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGMoRSwgaiwgUykge1xuICAgICAgICAgIG8odGhpcywgYyksIHRoaXMuX3JlbmRlcmVyID0gRTtcbiAgICAgICAgICB2YXIgXyA9IHRoaXMuX3JlbmRlcmVyLkdMLCBTID0gKFMgPSBTIHx8IHt9LCB0aGlzLnNyYyA9IGosIHRoaXMuZ2xUZXggPSB2b2lkIDAsIHRoaXMuZ2xUYXJnZXQgPSBfLlRFWFRVUkVfMkQsIHRoaXMuZ2xGb3JtYXQgPSBTLmZvcm1hdCB8fCBfLlJHQkEsIHRoaXMubWlwbWFwcyA9ICExLCB0aGlzLmdsTWluRmlsdGVyID0gUy5taW5GaWx0ZXIgfHwgXy5MSU5FQVIsIHRoaXMuZ2xNYWdGaWx0ZXIgPSBTLm1hZ0ZpbHRlciB8fCBfLkxJTkVBUiwgdGhpcy5nbFdyYXBTID0gUy53cmFwUyB8fCBfLkNMQU1QX1RPX0VER0UsIHRoaXMuZ2xXcmFwVCA9IFMud3JhcFQgfHwgXy5DTEFNUF9UT19FREdFLCB0aGlzLmdsRGF0YVR5cGUgPSBTLmRhdGFUeXBlIHx8IF8uVU5TSUdORURfQllURSwgYShFKSksIEUgPSAodGhpcy5nbEZvcm1hdCAhPT0gXy5IQUxGX0ZMT0FUIHx8IFMuaGFsZkZsb2F0IHx8IChjb25zb2xlLmxvZyhcIlRoaXMgZGV2aWNlIGRvZXMgbm90IHN1cHBvcnQgZGF0YVR5cGUgSEFMRl9GTE9BVC4gRmFsbGluZyBiYWNrIHRvIEZMT0FULlwiKSwgdGhpcy5nbERhdGFUeXBlID0gXy5GTE9BVCksIHRoaXMuZ2xGb3JtYXQgIT09IF8uSEFMRl9GTE9BVCB8fCB0aGlzLmdsTWluRmlsdGVyICE9PSBfLkxJTkVBUiAmJiB0aGlzLmdsTWFnRmlsdGVyICE9PSBfLkxJTkVBUiB8fCBTLmhhbGZGbG9hdExpbmVhciB8fCAoY29uc29sZS5sb2coXCJUaGlzIGRldmljZSBkb2VzIG5vdCBzdXBwb3J0IGxpbmVhciBmaWx0ZXJpbmcgZm9yIGRhdGFUeXBlIEZMT0FULiBGYWxsaW5nIGJhY2sgdG8gTkVBUkVTVC5cIiksIHRoaXMuZ2xNaW5GaWx0ZXIgPT09IF8uTElORUFSICYmICh0aGlzLmdsTWluRmlsdGVyID0gXy5ORUFSRVNUKSwgdGhpcy5nbE1hZ0ZpbHRlciA9PT0gXy5MSU5FQVIgJiYgKHRoaXMuZ2xNYWdGaWx0ZXIgPSBfLk5FQVJFU1QpKSwgdGhpcy5nbEZvcm1hdCAhPT0gXy5GTE9BVCB8fCBTLmZsb2F0IHx8IChjb25zb2xlLmxvZyhcIlRoaXMgZGV2aWNlIGRvZXMgbm90IHN1cHBvcnQgZGF0YVR5cGUgRkxPQVQuIEZhbGxpbmcgYmFjayB0byBVTlNJR05FRF9CWVRFLlwiKSwgdGhpcy5nbERhdGFUeXBlID0gXy5VTlNJR05FRF9CWVRFKSwgdGhpcy5nbEZvcm1hdCAhPT0gXy5GTE9BVCB8fCB0aGlzLmdsTWluRmlsdGVyICE9PSBfLkxJTkVBUiAmJiB0aGlzLmdsTWFnRmlsdGVyICE9PSBfLkxJTkVBUiB8fCBTLmZsb2F0TGluZWFyIHx8IChjb25zb2xlLmxvZyhcIlRoaXMgZGV2aWNlIGRvZXMgbm90IHN1cHBvcnQgbGluZWFyIGZpbHRlcmluZyBmb3IgZGF0YVR5cGUgRkxPQVQuIEZhbGxpbmcgYmFjayB0byBORUFSRVNULlwiKSwgdGhpcy5nbE1pbkZpbHRlciA9PT0gXy5MSU5FQVIgJiYgKHRoaXMuZ2xNaW5GaWx0ZXIgPSBfLk5FQVJFU1QpLCB0aGlzLmdsTWFnRmlsdGVyID09PSBfLkxJTkVBUiAmJiAodGhpcy5nbE1hZ0ZpbHRlciA9IF8uTkVBUkVTVCkpLCB0aGlzLmlzU3JjTWVkaWFFbGVtZW50ID0gdS5kZWZhdWx0Lk1lZGlhRWxlbWVudCAhPT0gdm9pZCAwICYmIGogaW5zdGFuY2VvZiB1LmRlZmF1bHQuTWVkaWFFbGVtZW50LCB0aGlzLl92aWRlb1ByZXZVcGRhdGVUaW1lID0gMCwgdGhpcy5pc1NyY0hUTUxFbGVtZW50ID0gdS5kZWZhdWx0LkVsZW1lbnQgIT09IHZvaWQgMCAmJiBqIGluc3RhbmNlb2YgdS5kZWZhdWx0LkVsZW1lbnQgJiYgIShqIGluc3RhbmNlb2YgdS5kZWZhdWx0LkdyYXBoaWNzKSAmJiAhKGogaW5zdGFuY2VvZiB1LmRlZmF1bHQuUmVuZGVyZXIpLCB0aGlzLmlzU3JjUDVJbWFnZSA9IGogaW5zdGFuY2VvZiB1LmRlZmF1bHQuSW1hZ2UsIHRoaXMuaXNTcmNQNUdyYXBoaWNzID0gaiBpbnN0YW5jZW9mIHUuZGVmYXVsdC5HcmFwaGljcywgdGhpcy5pc1NyY1A1UmVuZGVyZXIgPSBqIGluc3RhbmNlb2YgdS5kZWZhdWx0LlJlbmRlcmVyLCB0aGlzLmlzSW1hZ2VEYXRhID0gdHlwZW9mIEltYWdlRGF0YSA8IFwidVwiICYmIGogaW5zdGFuY2VvZiBJbWFnZURhdGEsIHRoaXMuaXNGcmFtZWJ1ZmZlclRleHR1cmUgPSBqIGluc3RhbmNlb2YgdS5kZWZhdWx0LkZyYW1lYnVmZmVyVGV4dHVyZSwgdGhpcy5fZ2V0VGV4dHVyZURhdGFGcm9tU291cmNlKCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoID0gRS53aWR0aCwgdGhpcy5oZWlnaHQgPSBFLmhlaWdodCwgdGhpcy5pbml0KEUpLCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsKGMsIFt7IGtleTogXCJfZ2V0VGV4dHVyZURhdGFGcm9tU291cmNlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSA/IHAgPSB0aGlzLnNyYy5yYXdUZXh0dXJlKCkgOiB0aGlzLmlzU3JjUDVJbWFnZSA/IHAgPSB0aGlzLnNyYy5jYW52YXMgOiB0aGlzLmlzU3JjTWVkaWFFbGVtZW50IHx8IHRoaXMuaXNTcmNQNUdyYXBoaWNzIHx8IHRoaXMuaXNTcmNQNVJlbmRlcmVyIHx8IHRoaXMuaXNTcmNIVE1MRWxlbWVudCA/IHAgPSB0aGlzLnNyYy5lbHQgOiB0aGlzLmlzSW1hZ2VEYXRhICYmIChwID0gdGhpcy5zcmMpLCBwO1xuICAgICAgICB9IH0sIHsga2V5OiBcImluaXRcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICB2YXIgaiwgVCA9IHRoaXMuX3JlbmRlcmVyLkdMO1xuICAgICAgICAgIHRoaXMuaXNGcmFtZWJ1ZmZlclRleHR1cmUgfHwgKHRoaXMuZ2xUZXggPSBULmNyZWF0ZVRleHR1cmUoKSksIHRoaXMuZ2xXcmFwUyA9IHRoaXMuX3JlbmRlcmVyLnRleHR1cmVXcmFwWCwgdGhpcy5nbFdyYXBUID0gdGhpcy5fcmVuZGVyZXIudGV4dHVyZVdyYXBZLCB0aGlzLnNldFdyYXBNb2RlKHRoaXMuZ2xXcmFwUywgdGhpcy5nbFdyYXBUKSwgdGhpcy5iaW5kVGV4dHVyZSgpLCBULnRleFBhcmFtZXRlcmkoVC5URVhUVVJFXzJELCBULlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbE1hZ0ZpbHRlciksIFQudGV4UGFyYW1ldGVyaShULlRFWFRVUkVfMkQsIFQuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsTWluRmlsdGVyKSwgdGhpcy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSB8fCAodGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMCB8fCB0aGlzLmlzU3JjTWVkaWFFbGVtZW50ICYmICF0aGlzLnNyYy5sb2FkZWRtZXRhZGF0YSA/IChqID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDEsIDEsIDFdKSwgVC50ZXhJbWFnZTJEKHRoaXMuZ2xUYXJnZXQsIDAsIFQuUkdCQSwgMSwgMSwgMCwgdGhpcy5nbEZvcm1hdCwgdGhpcy5nbERhdGFUeXBlLCBqKSkgOiBULnRleEltYWdlMkQodGhpcy5nbFRhcmdldCwgMCwgdGhpcy5nbEZvcm1hdCwgdGhpcy5nbEZvcm1hdCwgdGhpcy5nbERhdGFUeXBlLCBwKSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwidXBkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcCwgaiwgVCwgXyA9IHRoaXMuc3JjO1xuICAgICAgICAgIHJldHVybiBfLndpZHRoICE9PSAwICYmIF8uaGVpZ2h0ICE9PSAwICYmICF0aGlzLmlzRnJhbWVidWZmZXJUZXh0dXJlICYmIChwID0gdGhpcy5fZ2V0VGV4dHVyZURhdGFGcm9tU291cmNlKCksIGogPSAhMSwgVCA9IHRoaXMuX3JlbmRlcmVyLkdMLCBwLndpZHRoICE9PSB0aGlzLndpZHRoIHx8IHAuaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCA/IChqID0gITAsIHRoaXMud2lkdGggPSBwLndpZHRoIHx8IF8ud2lkdGgsIHRoaXMuaGVpZ2h0ID0gcC5oZWlnaHQgfHwgXy5oZWlnaHQsIHRoaXMuaXNTcmNQNUltYWdlID8gXy5zZXRNb2RpZmllZCghMSkgOiAodGhpcy5pc1NyY01lZGlhRWxlbWVudCB8fCB0aGlzLmlzU3JjSFRNTEVsZW1lbnQpICYmIF8uc2V0TW9kaWZpZWQoITApKSA6IHRoaXMuaXNTcmNQNUltYWdlID8gXy5pc01vZGlmaWVkKCkgJiYgXy5zZXRNb2RpZmllZCghKGogPSAhMCkpIDogdGhpcy5pc1NyY01lZGlhRWxlbWVudCA/IF8uaXNNb2RpZmllZCgpID8gXy5zZXRNb2RpZmllZCghKGogPSAhMCkpIDogXy5sb2FkZWRtZXRhZGF0YSAmJiB0aGlzLl92aWRlb1ByZXZVcGRhdGVUaW1lICE9PSBfLnRpbWUoKSAmJiAodGhpcy5fdmlkZW9QcmV2VXBkYXRlVGltZSA9IF8udGltZSgpLCBqID0gITApIDogdGhpcy5pc0ltYWdlRGF0YSA/IF8uX2RpcnR5ICYmIChqID0gIShfLl9kaXJ0eSA9ICExKSkgOiBqID0gITAsIGogJiYgKHRoaXMuYmluZFRleHR1cmUoKSwgVC50ZXhJbWFnZTJEKHRoaXMuZ2xUYXJnZXQsIDAsIHRoaXMuZ2xGb3JtYXQsIHRoaXMuZ2xGb3JtYXQsIHRoaXMuZ2xEYXRhVHlwZSwgcCkpLCBqKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJiaW5kVGV4dHVyZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLkdMLmJpbmRUZXh0dXJlKHRoaXMuZ2xUYXJnZXQsIHRoaXMuZ2V0VGV4dHVyZSgpKSwgdGhpcztcbiAgICAgICAgfSB9LCB7IGtleTogXCJ1bmJpbmRUZXh0dXJlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5HTC5iaW5kVGV4dHVyZSh0aGlzLmdsVGFyZ2V0LCBudWxsKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnZXRUZXh0dXJlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSA/IHRoaXMuc3JjLnJhd1RleHR1cmUoKSA6IHRoaXMuZ2xUZXg7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2V0SW50ZXJwb2xhdGlvblwiLCB2YWx1ZTogZnVuY3Rpb24ocCwgaikge1xuICAgICAgICAgIHZhciBUID0gdGhpcy5fcmVuZGVyZXIuR0w7XG4gICAgICAgICAgdGhpcy5nbE1pbkZpbHRlciA9IHRoaXMuZ2xGaWx0ZXIocCksIHRoaXMuZ2xNYWdGaWx0ZXIgPSB0aGlzLmdsRmlsdGVyKGopLCB0aGlzLmJpbmRUZXh0dXJlKCksIFQudGV4UGFyYW1ldGVyaShULlRFWFRVUkVfMkQsIFQuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsTWluRmlsdGVyKSwgVC50ZXhQYXJhbWV0ZXJpKFQuVEVYVFVSRV8yRCwgVC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2xNYWdGaWx0ZXIpLCB0aGlzLnVuYmluZFRleHR1cmUoKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJnbEZpbHRlclwiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHZhciBqID0gdGhpcy5fcmVuZGVyZXIuR0w7XG4gICAgICAgICAgcmV0dXJuIHAgPT09IGguTkVBUkVTVCA/IGouTkVBUkVTVCA6IGouTElORUFSO1xuICAgICAgICB9IH0sIHsga2V5OiBcInNldFdyYXBNb2RlXCIsIHZhbHVlOiBmdW5jdGlvbihwLCBqKSB7XG4gICAgICAgICAgZnVuY3Rpb24gVChBKSB7XG4gICAgICAgICAgICByZXR1cm4gKEEgJiBBIC0gMSkgPT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF8gPSB0aGlzLl9yZW5kZXJlci5HTCwgRSA9IHRoaXMuX2dldFRleHR1cmVEYXRhRnJvbVNvdXJjZSgpLCBFID0gRS5uYXR1cmFsV2lkdGggJiYgRS5uYXR1cmFsSGVpZ2h0ID8gKFMgPSBFLm5hdHVyYWxXaWR0aCwgRS5uYXR1cmFsSGVpZ2h0KSA6IChTID0gdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCBTID0gVChTKSwgRSA9IFQoRSk7XG4gICAgICAgICAgcCA9PT0gaC5SRVBFQVQgPyB0aGlzLl9yZW5kZXJlci53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wyIHx8IFMgJiYgRSA/IHRoaXMuZ2xXcmFwUyA9IF8uUkVQRUFUIDogKGNvbnNvbGUud2FybihcIllvdSB0cmllZCB0byBzZXQgdGhlIHdyYXAgbW9kZSB0byBSRVBFQVQgYnV0IHRoZSB0ZXh0dXJlIHNpemUgaXMgbm90IGEgcG93ZXIgb2YgdHdvLiBTZXR0aW5nIHRvIENMQU1QIGluc3RlYWRcIiksIHRoaXMuZ2xXcmFwUyA9IF8uQ0xBTVBfVE9fRURHRSkgOiBwID09PSBoLk1JUlJPUiA/IHRoaXMuX3JlbmRlcmVyLndlYmdsVmVyc2lvbiA9PT0gaC5XRUJHTDIgfHwgUyAmJiBFID8gdGhpcy5nbFdyYXBTID0gXy5NSVJST1JFRF9SRVBFQVQgOiAoY29uc29sZS53YXJuKFwiWW91IHRyaWVkIHRvIHNldCB0aGUgd3JhcCBtb2RlIHRvIE1JUlJPUiBidXQgdGhlIHRleHR1cmUgc2l6ZSBpcyBub3QgYSBwb3dlciBvZiB0d28uIFNldHRpbmcgdG8gQ0xBTVAgaW5zdGVhZFwiKSwgdGhpcy5nbFdyYXBTID0gXy5DTEFNUF9UT19FREdFKSA6IHRoaXMuZ2xXcmFwUyA9IF8uQ0xBTVBfVE9fRURHRSwgaiA9PT0gaC5SRVBFQVQgPyB0aGlzLl9yZW5kZXJlci53ZWJnbFZlcnNpb24gPT09IGguV0VCR0wyIHx8IFMgJiYgRSA/IHRoaXMuZ2xXcmFwVCA9IF8uUkVQRUFUIDogKGNvbnNvbGUud2FybihcIllvdSB0cmllZCB0byBzZXQgdGhlIHdyYXAgbW9kZSB0byBSRVBFQVQgYnV0IHRoZSB0ZXh0dXJlIHNpemUgaXMgbm90IGEgcG93ZXIgb2YgdHdvLiBTZXR0aW5nIHRvIENMQU1QIGluc3RlYWRcIiksIHRoaXMuZ2xXcmFwVCA9IF8uQ0xBTVBfVE9fRURHRSkgOiBqID09PSBoLk1JUlJPUiA/IHRoaXMuX3JlbmRlcmVyLndlYmdsVmVyc2lvbiA9PT0gaC5XRUJHTDIgfHwgUyAmJiBFID8gdGhpcy5nbFdyYXBUID0gXy5NSVJST1JFRF9SRVBFQVQgOiAoY29uc29sZS53YXJuKFwiWW91IHRyaWVkIHRvIHNldCB0aGUgd3JhcCBtb2RlIHRvIE1JUlJPUiBidXQgdGhlIHRleHR1cmUgc2l6ZSBpcyBub3QgYSBwb3dlciBvZiB0d28uIFNldHRpbmcgdG8gQ0xBTVAgaW5zdGVhZFwiKSwgdGhpcy5nbFdyYXBUID0gXy5DTEFNUF9UT19FREdFKSA6IHRoaXMuZ2xXcmFwVCA9IF8uQ0xBTVBfVE9fRURHRSwgdGhpcy5iaW5kVGV4dHVyZSgpLCBfLnRleFBhcmFtZXRlcmkoXy5URVhUVVJFXzJELCBfLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsV3JhcFMpLCBfLnRleFBhcmFtZXRlcmkoXy5URVhUVVJFXzJELCBfLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsV3JhcFQpLCB0aGlzLnVuYmluZFRleHR1cmUoKTtcbiAgICAgICAgfSB9XSksIGM7XG4gICAgICB9KCk7XG4gICAgICB2YXIgbiA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHAgPSBUO1xuICAgICAgICBpZiAodHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiICYmIGMgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyAmJiBjLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogcCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIGMgJiYgZihwLCBjKTtcbiAgICAgICAgdmFyIGogPSByKFQpO1xuICAgICAgICBmdW5jdGlvbiBUKF8sIFMsIEUpIHtcbiAgICAgICAgICByZXR1cm4gbyh0aGlzLCBUKSwgUyA9IChfID0gai5jYWxsKHRoaXMsIF8sIFMsIEUpKS5fcmVuZGVyZXIuR0wsIF8uZ2xNaW5GaWx0ZXIgPT09IFMuTElORUFSICYmIChfLmdsTWluRmlsdGVyID0gUy5MSU5FQVJfTUlQTUFQX0xJTkVBUiksIF87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGwoVCwgW3sga2V5OiBcImdsRmlsdGVyXCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLkdMLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuICAgICAgICB9IH0sIHsga2V5OiBcIl9nZXRUZXh0dXJlRGF0YUZyb21Tb3VyY2VcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNyYztcbiAgICAgICAgfSB9LCB7IGtleTogXCJpbml0XCIsIHZhbHVlOiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgdmFyIFMgPSB0aGlzLl9yZW5kZXJlci5HTDtcbiAgICAgICAgICB0aGlzLmdsVGV4ID0gUy5jcmVhdGVUZXh0dXJlKCksIHRoaXMuYmluZFRleHR1cmUoKTtcbiAgICAgICAgICBmb3IgKHZhciBFID0gMDsgRSA8IF8ubGVuZ3RoOyBFKyspXG4gICAgICAgICAgICBTLnRleEltYWdlMkQodGhpcy5nbFRhcmdldCwgRSwgdGhpcy5nbEZvcm1hdCwgdGhpcy5nbEZvcm1hdCwgdGhpcy5nbERhdGFUeXBlLCBfW0VdKTtcbiAgICAgICAgICB0aGlzLmdsTWluRmlsdGVyID0gUy5MSU5FQVJfTUlQTUFQX0xJTkVBUiwgUy50ZXhQYXJhbWV0ZXJpKFMuVEVYVFVSRV8yRCwgUy5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2xNYWdGaWx0ZXIpLCBTLnRleFBhcmFtZXRlcmkoUy5URVhUVVJFXzJELCBTLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbE1pbkZpbHRlciksIHRoaXMudW5iaW5kVGV4dHVyZSgpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInVwZGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0gfV0pLCBUO1xuICAgICAgfSh1LmRlZmF1bHQuVGV4dHVyZSk7XG4gICAgICBmdW5jdGlvbiBhKF8pIHtcbiAgICAgICAgdmFyIHAgPSBfLkdMLCBfID0gXy53ZWJnbFZlcnNpb24sIGogPSBfID09PSBoLldFQkdMMiA/IHAuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSAmJiBwLmdldEV4dGVuc2lvbihcIkVYVF9mbG9hdF9ibGVuZFwiKSA6IHAuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksIFQgPSBqICYmIHAuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpLCBfID0gXyA9PT0gaC5XRUJHTDIgPyBwLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikgOiBwLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7XG4gICAgICAgIHJldHVybiB7IGZsb2F0OiBqLCBmbG9hdExpbmVhcjogVCwgaGFsZkZsb2F0OiBfLCBoYWxmRmxvYXRMaW5lYXI6IF8gJiYgcC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiKSB9O1xuICAgICAgfVxuICAgICAgQy5NaXBtYXBUZXh0dXJlID0gbiwgdCA9IHUuZGVmYXVsdC5UZXh0dXJlLCBDLmRlZmF1bHQgPSB0O1xuICAgIH0sIHsgXCIuLi9jb3JlL2NvbnN0YW50c1wiOiAyNjksIFwiLi4vY29yZS9tYWluXCI6IDI4MCwgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIjogMTY0LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCI6IDE4MywgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjogMTg1LCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3RcIjogMTg5LCBcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nXCI6IDE5MywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCI6IDE5NywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW5cIjogMjEwLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeVwiOiAyMTEsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGxcIjogMjEyLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXJcIjogMjEzLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kXCI6IDIxNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleFwiOiAyMTQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoXCI6IDIxOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXNcIjogMjE5LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZlwiOiAyMjAsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yXCI6IDIyMywgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pblwiOiAyMjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2ZcIjogMjI1LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXBcIjogMjI2LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2VcIjogMjI4LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHRcIjogMjI3LCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlXCI6IDIyOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0XCI6IDIzMCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2VcIjogMjMxLCBcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lXCI6IDIzMiwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydFwiOiAyMzMsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5XCI6IDIzNCwgXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZ1wiOiAyMzUsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZ1wiOiAyMzYsIFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5XCI6IDIzOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSwgMzQwOiBbZnVuY3Rpb24odCwgSCwgQykge1xuICAgICAgZnVuY3Rpb24gbShjKSB7XG4gICAgICAgIHJldHVybiAobSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHA7XG4gICAgICAgIH0gOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgcC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHAgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHA7XG4gICAgICAgIH0pKGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geShjKSB7XG4gICAgICAgIHJldHVybiAoeSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG0oU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbShwKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBwLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgcCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBtKHApO1xuICAgICAgICB9KShjKTtcbiAgICAgIH1cbiAgICAgIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvblwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3JcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvclwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN1YlwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb25cIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmdcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIiksIHQoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdFwiKSwgdChcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCIpLCB0KFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3JcIik7XG4gICAgICB2YXIgdSwgaCA9ICh1ID0gdChcIi4uL2NvcmUvbWFpblwiKSkgJiYgdS5fX2VzTW9kdWxlID8gdSA6IHsgZGVmYXVsdDogdSB9LCBnID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYyAmJiBjLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIGlmIChjID09PSBudWxsIHx8IHkoYykgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IGMgfTtcbiAgICAgICAgdmFyIHAgPSBmKCk7XG4gICAgICAgIGlmIChwICYmIHAuaGFzKGMpKVxuICAgICAgICAgIHJldHVybiBwLmdldChjKTtcbiAgICAgICAgdmFyIGosIFQgPSB7fSwgXyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICBmb3IgKGogaW4gYykge1xuICAgICAgICAgIHZhciBTO1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLCBqKSAmJiAoKFMgPSBfID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjLCBqKSA6IG51bGwpICYmIChTLmdldCB8fCBTLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoVCwgaiwgUykgOiBUW2pdID0gY1tqXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFQuZGVmYXVsdCA9IGMsIHAgJiYgcC5zZXQoYywgVCksIFQ7XG4gICAgICB9KHQoXCIuLi9jb3JlL2NvbnN0YW50c1wiKSk7XG4gICAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBXZWFrTWFwICE9IFwiZnVuY3Rpb25cIiA/IG51bGwgOiAoYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0sIGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihjLCBwKSB7XG4gICAgICAgIGlmICghKGMgaW5zdGFuY2VvZiBwKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhjLCBwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBUID0gcFtqXTtcbiAgICAgICAgICBULmVudW1lcmFibGUgPSBULmVudW1lcmFibGUgfHwgITEsIFQuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBUICYmIChULndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgVC5rZXksIFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKGMsIHAsIGopIHtcbiAgICAgICAgcCAmJiBzKGMucHJvdG90eXBlLCBwKTtcbiAgICAgIH1cbiAgICAgIHQoXCIuL3A1LlNoYWRlclwiKSwgdChcIi4vcDUuUmVuZGVyZXJHTC5SZXRhaW5lZFwiKSwgaC5kZWZhdWx0LlJlbmRlcmVyR0wucHJvdG90eXBlLl9hcHBseVRleHRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB9LCBoLmRlZmF1bHQuUmVuZGVyZXJHTC5wcm90b3R5cGUudGV4dFdpZHRoID0gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuVHlwZSgpID8gdGhpcy5fdGV4dEZvbnQuX3RleHRXaWR0aChjLCB0aGlzLl90ZXh0U2l6ZSkgOiAwO1xuICAgICAgfTtcbiAgICAgIHZhciBpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGMocCwgaikge1xuICAgICAgICAgIHIodGhpcywgYyksIHRoaXMud2lkdGggPSBwLCB0aGlzLmhlaWdodCA9IGosIHRoaXMuaW5mb3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbyhjLCBbeyBrZXk6IFwiZmluZEltYWdlXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIGosIFQsIF8gPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgaWYgKF8gPCBwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9udCBpcyB0b28gY29tcGxleCB0byByZW5kZXIgaW4gM0RcIik7XG4gICAgICAgICAgZm9yICh2YXIgUyA9IHRoaXMuaW5mb3MubGVuZ3RoIC0gMTsgMCA8PSBTOyAtLVMpIHtcbiAgICAgICAgICAgIHZhciBFID0gdGhpcy5pbmZvc1tTXTtcbiAgICAgICAgICAgIGlmIChFLmluZGV4ICsgcCA8IF8pIHtcbiAgICAgICAgICAgICAgVCA9IChqID0gRSkuaW1hZ2VEYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFqKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBUID0gbmV3IEltYWdlRGF0YSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgdmFyIEEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNhbnZhc1wiKVswXSwgeCA9ICFBLCBQID0gKEEgfHwgKChBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKEEpKSwgQS5nZXRDb250ZXh0KFwiMmRcIikpO1xuICAgICAgICAgICAgICBQICYmIChUID0gUC5jcmVhdGVJbWFnZURhdGEodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpKSwgeCAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmZvcy5wdXNoKGogPSB7IGluZGV4OiAwLCBpbWFnZURhdGE6IFQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQID0gai5pbmRleCwgai5pbmRleCArPSBwLCBULl9kaXJ0eSA9ICEwLCB7IGltYWdlRGF0YTogVCwgaW5kZXg6IFAgfTtcbiAgICAgICAgfSB9XSksIGM7XG4gICAgICB9KCk7XG4gICAgICBmdW5jdGlvbiBsKEUsIHAsIGosIFQsIF8pIHtcbiAgICAgICAgdmFyIFMgPSBFLmltYWdlRGF0YS5kYXRhLCBFID0gNCAqIEUuaW5kZXgrKztcbiAgICAgICAgU1tFKytdID0gcCwgU1tFKytdID0gaiwgU1tFKytdID0gVCwgU1srRV0gPSBfO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBNYXRoLnNxcnQoMyksIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gYyhwKSB7XG4gICAgICAgICAgcih0aGlzLCBjKSwgdGhpcy5mb250ID0gcCwgdGhpcy5zdHJva2VJbWFnZUluZm9zID0gbmV3IGkoNjQsIDY0KSwgdGhpcy5jb2xEaW1JbWFnZUluZm9zID0gbmV3IGkoNjQsIDY0KSwgdGhpcy5yb3dEaW1JbWFnZUluZm9zID0gbmV3IGkoNjQsIDY0KSwgdGhpcy5jb2xDZWxsSW1hZ2VJbmZvcyA9IG5ldyBpKDY0LCA2NCksIHRoaXMucm93Q2VsbEltYWdlSW5mb3MgPSBuZXcgaSg2NCwgNjQpLCB0aGlzLmdseXBoSW5mb3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbyhjLCBbeyBrZXk6IFwiZ2V0R2x5cGhJbmZvXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIGogPSB0aGlzLmdseXBoSW5mb3NbcC5pbmRleF07XG4gICAgICAgICAgaWYgKCFqKSB7XG4gICAgICAgICAgICB2YXIgVCA9IHAuZ2V0Qm91bmRpbmdCb3goKSwgXyA9IFQueDEsIFMgPSBULnkxLCBFID0gVC54MiAtIF8sIEEgPSBULnkyIC0gUywgeCA9IHAucGF0aC5jb21tYW5kcztcbiAgICAgICAgICAgIGlmIChFID09IDAgfHwgQSA9PSAwIHx8ICF4Lmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhJbmZvc1twLmluZGV4XSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgUCA9IFtdLCBNID0gW10sIFIgPSBbXSwgTCA9IDg7IDAgPD0gTDsgLS1MKVxuICAgICAgICAgICAgICBSLnB1c2goW10pO1xuICAgICAgICAgICAgZm9yIChMID0gODsgMCA8PSBMOyAtLUwpXG4gICAgICAgICAgICAgIE0ucHVzaChbXSk7XG4gICAgICAgICAgICB2YXIgRiwgViwgRywgVSwgVyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiB6ZShWZSwgWGUsIEhlLCB2ZSkge1xuICAgICAgICAgICAgICAgIHIodGhpcywgemUpLCB0aGlzLnAwID0gVmUsIHRoaXMuYzAgPSBYZSwgdGhpcy5jMSA9IEhlLCB0aGlzLnAxID0gdmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG8oemUsIFt7IGtleTogXCJ0b1F1YWRyYXRpY1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5wMC54LCB5OiB0aGlzLnAwLnksIHgxOiB0aGlzLnAxLngsIHkxOiB0aGlzLnAxLnksIGN4OiAoMyAqICh0aGlzLmMwLnggKyB0aGlzLmMxLngpIC0gKHRoaXMucDAueCArIHRoaXMucDEueCkpIC8gNCwgY3k6ICgzICogKHRoaXMuYzAueSArIHRoaXMuYzEueSkgLSAodGhpcy5wMC55ICsgdGhpcy5wMS55KSkgLyA0IH07XG4gICAgICAgICAgICAgIH0gfSwgeyBrZXk6IFwicXVhZEVycm9yXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5kZWZhdWx0LlZlY3Rvci5zdWIoaC5kZWZhdWx0LlZlY3Rvci5zdWIodGhpcy5wMSwgdGhpcy5wMCksIGguZGVmYXVsdC5WZWN0b3IubXVsdChoLmRlZmF1bHQuVmVjdG9yLnN1Yih0aGlzLmMxLCB0aGlzLmMwKSwgMykpLm1hZygpIC8gMjtcbiAgICAgICAgICAgICAgfSB9LCB7IGtleTogXCJzcGxpdFwiLCB2YWx1ZTogZnVuY3Rpb24oUmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgWGUgPSBoLmRlZmF1bHQuVmVjdG9yLmxlcnAodGhpcy5wMCwgdGhpcy5jMCwgUmUpLCB2ZSA9IGguZGVmYXVsdC5WZWN0b3IubGVycCh0aGlzLmMwLCB0aGlzLmMxLCBSZSksIEhlID0gaC5kZWZhdWx0LlZlY3Rvci5sZXJwKFhlLCB2ZSwgUmUpLCB2ZSA9ICh0aGlzLmMxID0gaC5kZWZhdWx0LlZlY3Rvci5sZXJwKHRoaXMuYzEsIHRoaXMucDEsIFJlKSwgdGhpcy5jMCA9IGguZGVmYXVsdC5WZWN0b3IubGVycCh2ZSwgdGhpcy5jMSwgUmUpLCBoLmRlZmF1bHQuVmVjdG9yLmxlcnAoSGUsIHRoaXMuYzAsIFJlKSksIFJlID0gbmV3IHplKHRoaXMucDAsIFhlLCBIZSwgdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnAwID0gdmUsIFJlO1xuICAgICAgICAgICAgICB9IH0sIHsga2V5OiBcInNwbGl0SW5mbGVjdGlvbnNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBWZSA9IGguZGVmYXVsdC5WZWN0b3Iuc3ViKHRoaXMuYzAsIHRoaXMucDApLCBYZSA9IGguZGVmYXVsdC5WZWN0b3Iuc3ViKGguZGVmYXVsdC5WZWN0b3Iuc3ViKHRoaXMuYzEsIHRoaXMuYzApLCBWZSksIEhlID0gaC5kZWZhdWx0LlZlY3Rvci5zdWIoaC5kZWZhdWx0LlZlY3Rvci5zdWIoaC5kZWZhdWx0LlZlY3Rvci5zdWIodGhpcy5wMSwgdGhpcy5jMSksIFZlKSwgaC5kZWZhdWx0LlZlY3Rvci5tdWx0KFhlLCAyKSksIHZlID0gW10sIFJlID0gWGUueCAqIEhlLnkgLSBYZS55ICogSGUueDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmUgIT09IDAgJiYgMCA8PSAoVmUgPSAoSGUgPSBWZS54ICogSGUueSAtIFZlLnkgKiBIZS54KSAqIEhlIC0gNCAqIFJlICogKFZlLnggKiBYZS55IC0gVmUueSAqIFhlLngpKSAmJiAoUmUgPCAwICYmIChSZSA9IC1SZSwgSGUgPSAtSGUpLCBWZSA9ICgtSGUgKyAoWGUgPSBNYXRoLnNxcnQoVmUpKSkgLyAoMiAqIFJlKSwgMCA8IChIZSA9ICgtSGUgLSBYZSkgLyAoMiAqIFJlKSkgJiYgSGUgPCAxICYmICh2ZS5wdXNoKHRoaXMuc3BsaXQoSGUpKSwgVmUgPSAxIC0gKDEgLSBWZSkgLyAoMSAtIEhlKSksIDAgPCBWZSAmJiBWZSA8IDEgJiYgdmUucHVzaCh0aGlzLnNwbGl0KFZlKSkpLCB2ZS5wdXNoKHRoaXMpLCB2ZTtcbiAgICAgICAgICAgICAgfSB9XSksIHplO1xuICAgICAgICAgICAgfSgpLCBYID0gITAsIG5lID0gITEsIGIgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBPLCBEID0geFtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoWCA9IChPID0gRC5uZXh0KCkpLmRvbmUpOyBYID0gITApIHtcbiAgICAgICAgICAgICAgICB2YXIgQiA9IE8udmFsdWUsIFkgPSAoQi54IC0gXykgLyBFLCBKID0gKEIueSAtIFMpIC8gQTtcbiAgICAgICAgICAgICAgICBpZiAoIU1lKEYsIFYsIFksIEopKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKEIudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgIEcgPSBZLCBVID0gSjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBEZShGLCBWLCBZLCBKKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGUgPSAoQi54MSAtIF8pIC8gRSwgY2UgPSAoQi55MSAtIFMpIC8gQTtcbiAgICAgICAgICAgICAgICAgICAgICBnZShbRiwgWSwgdGVdLCBbViwgSiwgY2VdLCB7IHg6IEYsIHk6IFYsIGN4OiB0ZSwgY3k6IGNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgIE1lKEYsIFYsIEcsIFUpID8gUC5wdXNoKHsgeDogRiwgeTogViB9KSA6IChEZShGLCBWLCBHLCBVKSwgUC5wdXNoKHsgeDogRywgeTogVSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmUgPSBmdW5jdGlvbigkLCBqZSwgQ2UsIEhlLCB2ZSwgUmUsIHdlLCBaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJCA9IG5ldyBXKG5ldyBoLmRlZmF1bHQuVmVjdG9yKCQsIGplKSwgbmV3IGguZGVmYXVsdC5WZWN0b3IoQ2UsIEhlKSwgbmV3IGguZGVmYXVsdC5WZWN0b3IodmUsIFJlKSwgbmV3IGguZGVmYXVsdC5WZWN0b3Iod2UsIFopKS5zcGxpdEluZmxlY3Rpb25zKCksIHEgPSBbXSwgZWUgPSAzMCAvIG4sIHBlID0gITAsIGplID0gITEsIENlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgRmUsIE5lID0gJFtTeW1ib2wuaXRlcmF0b3JdKCk7ICEocGUgPSAoRmUgPSBOZS5uZXh0KCkpLmRvbmUpOyBwZSA9ICEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgQmUgPSBGZS52YWx1ZSwgV2UgPSBbXSwgc3QgPSB2b2lkIDA7ICEoMC4xMjUgPD0gKHN0ID0gZWUgLyBCZS5xdWFkRXJyb3IoKSkpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudCA9IE1hdGgucG93KHN0LCAwLjMzMzMzMzMzMzMzMzMzMzMpLCBLZSA9IEJlLnNwbGl0KG50KSwgYXQgPSBCZS5zcGxpdCgxIC0gbnQgLyAoMSAtIG50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLnB1c2goS2UpLCBXZS5wdXNoKEJlKSwgQmUgPSBhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QgPCAxICYmIHEucHVzaChCZS5zcGxpdCgwLjUpKSwgcS5wdXNoKEJlKSwgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocSwgV2UucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgamUgPSAhMCwgQ2UgPSBvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGUgfHwgTmUucmV0dXJuID09IG51bGwgfHwgTmUucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGplKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBxO1xuICAgICAgICAgICAgICAgICAgICAgIH0oRiwgViwgKEIueDEgLSBfKSAvIEUsIChCLnkxIC0gUykgLyBBLCAoQi54MiAtIF8pIC8gRSwgKEIueTIgLSBTKSAvIEEsIFksIEopLCB1ZSA9IDA7IHVlIDwgcmUubGVuZ3RoOyB1ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSByZVt1ZV0udG9RdWFkcmF0aWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlKFtsZS54LCBsZS54MSwgbGUuY3hdLCBbbGUueSwgbGUueTEsIGxlLmN5XSwgbGUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbW1hbmQgdHlwZTogXCIuY29uY2F0KEIudHlwZSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgRiA9IFksIFYgPSBKO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoemUpIHtcbiAgICAgICAgICAgICAgbmUgPSAhMCwgYiA9IHplO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBYIHx8IEQucmV0dXJuID09IG51bGwgfHwgRC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAobmUpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBLID0gUC5sZW5ndGgsIGFlID0gdGhpcy5zdHJva2VJbWFnZUluZm9zLmZpbmRJbWFnZShLKSwgaGUgPSBhZS5pbmRleCwgX2UgPSAwOyBfZSA8IEs7ICsrX2UpIHtcbiAgICAgICAgICAgICAgdmFyIGZlID0gUFtfZV07XG4gICAgICAgICAgICAgIGwoYWUsIHhlKGZlLngpLCB4ZShmZS55KSwgeGUoZmUuY3gpLCB4ZShmZS5jeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKGogPSB0aGlzLmdseXBoSW5mb3NbcC5pbmRleF0gPSB7IGdseXBoOiBwLCB1R2x5cGhSZWN0OiBbVC54MSwgLVQueTEsIFQueDIsIC1ULnkyXSwgc3Ryb2tlSW1hZ2VJbmZvOiBhZSwgc3Ryb2tlczogUCwgY29sSW5mbzogUWUoUiwgdGhpcy5jb2xEaW1JbWFnZUluZm9zLCB0aGlzLmNvbENlbGxJbWFnZUluZm9zKSwgcm93SW5mbzogUWUoTSwgdGhpcy5yb3dEaW1JbWFnZUluZm9zLCB0aGlzLnJvd0NlbGxJbWFnZUluZm9zKSB9KS51R3JpZE9mZnNldCA9IFtqLmNvbEluZm8uZGltT2Zmc2V0LCBqLnJvd0luZm8uZGltT2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgICAgZnVuY3Rpb24gZ2UoemUsIFZlLCBYZSkge1xuICAgICAgICAgICAgdmFyIEhlID0gUC5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiB2ZShxLCBlZSwgcGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgamUgPSBxLmxlbmd0aDsgMCA8IGplLS07ICkge1xuICAgICAgICAgICAgICAgIHZhciBDZSA9IHFbamVdO1xuICAgICAgICAgICAgICAgIENlIDwgZWUgJiYgKGVlID0gQ2UpLCBwZSA8IENlICYmIChwZSA9IENlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4geyBtaW46IGVlLCBtYXg6IHBlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQLnB1c2goWGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgWGUgPSB2ZSh6ZSwgMSwgMCksIHplID0gTWF0aC5tYXgoTWF0aC5mbG9vcig5ICogWGUubWluIC0gMC41KSwgMCksIFJlID0gTWF0aC5taW4oTWF0aC5jZWlsKDkgKiBYZS5tYXggKyAwLjUpLCA5KSwgd2UgPSB6ZTsgd2UgPCBSZTsgKyt3ZSlcbiAgICAgICAgICAgICAgUlt3ZV0ucHVzaChIZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBYZSA9IHZlKFZlLCAxLCAwKSwgemUgPSBNYXRoLm1heChNYXRoLmZsb29yKDkgKiBYZS5taW4gLSAwLjUpLCAwKSwgWiA9IE1hdGgubWluKE1hdGguY2VpbCg5ICogWGUubWF4ICsgMC41KSwgOSksICQgPSB6ZTsgJCA8IFo7ICsrJClcbiAgICAgICAgICAgICAgTVskXS5wdXNoKEhlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24geGUoemUpIHtcbiAgICAgICAgICAgIHJldHVybiAoemUgPSAoWGUgPSAyNTUpICogemUpIDwgKFZlID0gMCkgPyBWZSA6IFhlIDwgemUgPyBYZSA6IHplO1xuICAgICAgICAgICAgdmFyIFZlLCBYZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRGUoemUsIFZlLCBYZSwgSGUpIHtcbiAgICAgICAgICAgIGdlKFt6ZSwgWGVdLCBbVmUsIEhlXSwgeyB4OiB6ZSwgeTogVmUsIGN4OiAoemUgKyBYZSkgLyAyLCBjeTogKFZlICsgSGUpIC8gMiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gTWUoemUsIFZlLCBYZSwgSGUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhYZSAtIHplKSA8IDFlLTUgJiYgTWF0aC5hYnMoSGUgLSBWZSkgPCAxZS01O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBRZSh6ZSwgVmUsIFhlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBIZSA9IHplLmxlbmd0aCwgdmUgPSBWZS5maW5kSW1hZ2UoSGUpLCBWZSA9IHZlLmluZGV4LCBSZSA9IDAsIHdlID0gMDsgd2UgPCBIZTsgKyt3ZSlcbiAgICAgICAgICAgICAgUmUgKz0gemVbd2VdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIFogPSBYZS5maW5kSW1hZ2UoUmUpLCAkID0gMDsgJCA8IEhlOyArKyQpIHtcbiAgICAgICAgICAgICAgdmFyIHEgPSB6ZVskXSwgZWUgPSBxLmxlbmd0aCwgcGUgPSBaLmluZGV4O1xuICAgICAgICAgICAgICBsKHZlLCBwZSA+PiA3LCAxMjcgJiBwZSwgZWUgPj4gNywgMTI3ICYgZWUpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqZSA9IDA7IGplIDwgZWU7ICsramUpIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2UgPSBxW2plXSArIGhlO1xuICAgICAgICAgICAgICAgIGwoWiwgQ2UgPj4gNywgMTI3ICYgQ2UsIDAsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjZWxsSW1hZ2VJbmZvOiBaLCBkaW1PZmZzZXQ6IFZlLCBkaW1JbWFnZUluZm86IHZlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dKSwgYztcbiAgICAgIH0oKTtcbiAgICAgIGguZGVmYXVsdC5SZW5kZXJlckdMLnByb3RvdHlwZS5fcmVuZGVyVGV4dCA9IGZ1bmN0aW9uKGMsIHAsIGosIFQsIF8pIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRGb250ICYmIHR5cGVvZiB0aGlzLl90ZXh0Rm9udCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKCEoXyA8PSBUKSAmJiB0aGlzLl9kb0ZpbGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc09wZW5UeXBlKCkpIHtcbiAgICAgICAgICAgICAgYy5wdXNoKCk7XG4gICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fZG9TdHJva2UsIFMgPSB0aGlzLmRyYXdNb2RlLCBFID0gKHRoaXMuX2RvU3Ryb2tlID0gITEsIHRoaXMuZHJhd01vZGUgPSBnLlRFWFRVUkUsIHRoaXMuX3RleHRGb250LmZvbnQpLCBBID0gKEEgPSB0aGlzLl90ZXh0Rm9udC5fZm9udEluZm8pIHx8ICh0aGlzLl90ZXh0Rm9udC5fZm9udEluZm8gPSBuZXcgYShFKSksIGogPSB0aGlzLl90ZXh0Rm9udC5faGFuZGxlQWxpZ25tZW50KHRoaXMsIHAsIGosIFQpLCBUID0gdGhpcy5fdGV4dFNpemUgLyBFLnVuaXRzUGVyRW0sIHggPSAodGhpcy50cmFuc2xhdGUoai54LCBqLnksIDApLCB0aGlzLnNjYWxlKFQsIFQsIDEpLCB0aGlzLkdMKSwgaiA9ICF0aGlzLl9kZWZhdWx0Rm9udFNoYWRlciwgUCA9IHRoaXMuX2dldEZvbnRTaGFkZXIoKSwgTSA9IChQLmluaXQoKSwgUC5iaW5kU2hhZGVyKCksIGogJiYgKFAuc2V0VW5pZm9ybShcInVHcmlkSW1hZ2VTaXplXCIsIFs2NCwgNjRdKSwgUC5zZXRVbmlmb3JtKFwidUNlbGxzSW1hZ2VTaXplXCIsIFs2NCwgNjRdKSwgUC5zZXRVbmlmb3JtKFwidVN0cm9rZUltYWdlU2l6ZVwiLCBbNjQsIDY0XSksIFAuc2V0VW5pZm9ybShcInVHcmlkU2l6ZVwiLCBbOSwgOV0pKSwgdGhpcy5fYXBwbHlDb2xvckJsZW5kKHRoaXMuY3VyRmlsbENvbG9yKSwgdGhpcy5yZXRhaW5lZE1vZGUuZ2VvbWV0cnkuZ2x5cGgpLCBSID0gKE0gfHwgKChUID0gdGhpcy5fdGV4dEdlb20gPSBuZXcgaC5kZWZhdWx0Lkdlb21ldHJ5KDEsIDEsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHVlID0gMDsgdWUgPD0gMTsgdWUrKylcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxlID0gMDsgbGUgPD0gMTsgbGUrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBoLmRlZmF1bHQuVmVjdG9yKGxlLCB1ZSwgMCkpLCB0aGlzLnV2cy5wdXNoKGxlLCB1ZSk7XG4gICAgICAgICAgICAgIH0pKS5jb21wdXRlRmFjZXMoKS5jb21wdXRlTm9ybWFscygpLCBNID0gdGhpcy5jcmVhdGVCdWZmZXJzKFwiZ2x5cGhcIiwgVCkpLCAhMCksIGogPSAhMSwgVCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBMLCBGID0gdGhpcy5yZXRhaW5lZE1vZGUuYnVmZmVycy50ZXh0W1N5bWJvbC5pdGVyYXRvcl0oKTsgIShSID0gKEwgPSBGLm5leHQoKSkuZG9uZSk7IFIgPSAhMClcbiAgICAgICAgICAgICAgICAgIEwudmFsdWUuX3ByZXBhcmVCdWZmZXIoTSwgUCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHVlKSB7XG4gICAgICAgICAgICAgICAgaiA9ICEwLCBUID0gdWU7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIFIgfHwgRi5yZXR1cm4gPT0gbnVsbCB8fCBGLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoailcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYmluZEJ1ZmZlcihNLmluZGV4QnVmZmVyLCB4LkVMRU1FTlRfQVJSQVlfQlVGRkVSKSwgUC5zZXRVbmlmb3JtKFwidU1hdGVyaWFsQ29sb3JcIiwgdGhpcy5jdXJGaWxsQ29sb3IpLCB4LnBpeGVsU3RvcmVpKHguVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCAhMSk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIFYgPSAwLCBHID0gbnVsbCwgVSA9IEUuc3RyaW5nVG9HbHlwaHMocCksIFcgPSAhMCwgWCA9ICExLCBuZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiwgTyA9IFVbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKFcgPSAoYiA9IE8ubmV4dCgpKS5kb25lKTsgVyA9ICEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBELCBCLCBZID0gYi52YWx1ZSwgSiA9IChHICYmIChWICs9IEUuZ2V0S2VybmluZ1ZhbHVlKEcsIFkpKSwgQS5nZXRHbHlwaEluZm8oWSkpO1xuICAgICAgICAgICAgICAgICAgICBKLnVHbHlwaFJlY3QgJiYgKEQgPSBKLnJvd0luZm8sIEIgPSBKLmNvbEluZm8sIFAuc2V0VW5pZm9ybShcInVTYW1wbGVyU3Ryb2tlc1wiLCBKLnN0cm9rZUltYWdlSW5mby5pbWFnZURhdGEpLCBQLnNldFVuaWZvcm0oXCJ1U2FtcGxlclJvd1N0cm9rZXNcIiwgRC5jZWxsSW1hZ2VJbmZvLmltYWdlRGF0YSksIFAuc2V0VW5pZm9ybShcInVTYW1wbGVyUm93c1wiLCBELmRpbUltYWdlSW5mby5pbWFnZURhdGEpLCBQLnNldFVuaWZvcm0oXCJ1U2FtcGxlckNvbFN0cm9rZXNcIiwgQi5jZWxsSW1hZ2VJbmZvLmltYWdlRGF0YSksIFAuc2V0VW5pZm9ybShcInVTYW1wbGVyQ29sc1wiLCBCLmRpbUltYWdlSW5mby5pbWFnZURhdGEpLCBQLnNldFVuaWZvcm0oXCJ1R3JpZE9mZnNldFwiLCBKLnVHcmlkT2Zmc2V0KSwgUC5zZXRVbmlmb3JtKFwidUdseXBoUmVjdFwiLCBKLnVHbHlwaFJlY3QpLCBQLnNldFVuaWZvcm0oXCJ1R2x5cGhPZmZzZXRcIiwgViksIFAuYmluZFRleHR1cmVzKCksIHguZHJhd0VsZW1lbnRzKHguVFJJQU5HTEVTLCA2LCB0aGlzLkdMLlVOU0lHTkVEX1NIT1JULCAwKSksIFYgKz0gWS5hZHZhbmNlV2lkdGgsIEcgPSBZO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHVlKSB7XG4gICAgICAgICAgICAgICAgICBYID0gITAsIG5lID0gdWU7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFcgfHwgTy5yZXR1cm4gPT0gbnVsbCB8fCBPLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFgpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIFAudW5iaW5kU2hhZGVyKCksIHRoaXMuX2RvU3Ryb2tlID0gXywgdGhpcy5kcmF3TW9kZSA9IFMsIHgucGl4ZWxTdG9yZWkoeC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsICEwKSwgYy5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0VCR0w6IG9ubHkgT3BlbnR5cGUgKC5vdGYpIGFuZCBUcnVldHlwZSAoLnR0ZikgZm9udHMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS5sb2coXCJXRUJHTDogeW91IG11c3QgbG9hZCBhbmQgc2V0IGEgZm9udCBiZWZvcmUgZHJhd2luZyB0ZXh0LiBTZWUgYGxvYWRGb250YCBhbmQgYHRleHRGb250YCBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4uL2NvcmUvY29uc3RhbnRzXCI6IDI2OSwgXCIuLi9jb3JlL21haW5cIjogMjgwLCBcIi4vcDUuUmVuZGVyZXJHTC5SZXRhaW5lZFwiOiAzMzYsIFwiLi9wNS5TaGFkZXJcIjogMzM4LCBcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvclwiOiAxNjQsIFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjogMTgzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nXCI6IDE4NywgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWNcIjogMTkyLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3JcIjogMTk3LCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXRcIjogMjAzLCBcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3ViXCI6IDIwNSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sXCI6IDIwOSwgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uXCI6IDIwNywgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yXCI6IDIwOCwgXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXBcIjogMjQxLCBcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yXCI6IDI0MyB9XSB9LCB7fSwgWzI2NF0pKDI2NCk7XG4gIH0pO1xufSkod24pO1xudmFyIFFuID0gd24uZXhwb3J0cztcbmNvbnN0IEtuID0gLyogQF9fUFVSRV9fICovIHFuKFFuKTtcbmZ1bmN0aW9uIEpuKHl0LCBFdCkge1xuICByZXR1cm4gbmV3IEtuKHl0LCBFdCk7XG59XG5mdW5jdGlvbiBqbih5dCkge1xuICB2YXIgRXQ7XG4gIChFdCA9IHl0LmN1cnJlbnQpID09IG51bGwgfHwgRXQucmVtb3ZlKCksIHl0LmN1cnJlbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gJG4oeXQpIHtcbiAgY29uc3QgeyBza2V0Y2g6IEV0LCBjaGlsZHJlbjogVnQsIC4uLnQgfSA9IHl0LCBIID0gZ24obnVsbCksIEMgPSBnbihudWxsKTtcbiAgcmV0dXJuIEFyKCgpID0+IHtcbiAgICBILmN1cnJlbnQgIT09IG51bGwgJiYgKGpuKEMpLCBDLmN1cnJlbnQgPSBKbihcbiAgICAgIEV0LFxuICAgICAgSC5jdXJyZW50XG4gICAgKSk7XG4gIH0sIFtFdF0pLCBBcigoKSA9PiB7XG4gICAgdmFyIG0sIHk7XG4gICAgKHkgPSAobSA9IEMuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IG0udXBkYXRlV2l0aFByb3BzKSA9PSBudWxsIHx8IHkuY2FsbChtLCB0KTtcbiAgfSwgW3QsIEhdKSwgQXIoKCkgPT4gKCkgPT4gam4oQyksIFtdKSwgLyogQF9fUFVSRV9fICovIHdyLmpzeChcImRpdlwiLCB7IHJlZjogSCwgY2xhc3NOYW1lOiBabiwgY2hpbGRyZW46IFZ0IH0pO1xufVxuZnVuY3Rpb24gZW8oeXQpIHtcbiAgY29uc3QgeyBza2V0Y2g6IEV0LCBmYWxsYmFjazogVnQgfSA9IHl0O1xuICByZXR1cm4gRXQgPT09IHZvaWQgMCA/IChjb25zb2xlLmVycm9yKFwiW1JlYWN0UDVXcmFwcGVyXSBUaGUgYHNrZXRjaGAgcHJvcCBpcyByZXF1aXJlZC5cIiksIFZ0ICE9PSB2b2lkIDAgPyAvKiBAX19QVVJFX18gKi8gd3IuanN4KHdyLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBWdCB9KSA6IG51bGwpIDogLyogQF9fUFVSRV9fICovIHdyLmpzeChcbiAgICAkbixcbiAgICB7XG4gICAgICAuLi55dFxuICAgIH1cbiAgKTtcbn1cbmNvbnN0IHJvID0gem4oZW8sIFduKTtcbmV4cG9ydCB7XG4gIFpuIGFzIFA1V3JhcHBlckNsYXNzTmFtZSxcbiAgcm8gYXMgUmVhY3RQNVdyYXBwZXJcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@p5-wrapper/react/dist/component/react.js\n"));

/***/ })

}]);